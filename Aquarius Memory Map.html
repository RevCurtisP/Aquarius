<html>
<head>
<title>Mattel Aquarius Memory Layout</title>
<!-- Source Document - https://www.vdsteenoven.com/aquarius/mempointer.html -->
<style>
 table { border-collapse:collapse } 
 th {
	border-width: thin;
	padding: 2px;
	border-style: solid;
	border-color: #2e9595;
        color: #FFFFFF; 
        background: #31c6c6;
 }
 tr { border: 1px solid #31c6c6 }
 td { border: 1px solid #31c6c6 }
 body { 
   font-family: Arial, Helvetica, sans-serif;
   height: 100%;
   margin: 0;
   padding: 0;
   background: #bdecec url('../graphics/body-bg.png') 0 0 repeat-x; 
 }
 h1 { 
   font-family: Helvetica, Arial, sans-serif;
   font-weight: bold;
   font-size: 2.7em;
   margin: 0;
 }

</style>
<body>
<h1>Memory Layout</h1>
</p>
<p>
Memory on the Mattel Aquarius computer is divided in the following main parts:
</p>
<p>
<table style="border-collapse: collapse">
<tr>
<td colspan=2>ROM Part</td><td rowspan=2>Not addressable with PEEK and POKE</td>
</tr>
<tr>
<td>00 00<br>2F FF</td><td align=right>0<br>12287</td>
</tr>
<tr>
<td colspan=2>RAM Part</td><td rowspan=2>VIDEO AND COLOR MATRIX</td>
</tr>
<tr>
<td>30 00<br>37 FF</td><td align=right>12288<br>14335</td>
</tr>
<tr>
<td colspan=2>RAM Part</td><td rowspan=2>SYSTEM INFORMATION</td>
</tr>
<tr>
<td>38 00<br>38 FF</td><td align=right>14336<br>14591</td>
</tr>
<tr>
<td colspan=2>RAM Part</td><td>START BASIC PROGRAMMCODE</td>
</tr>
<tr>
<td>39 01</td><td align=right>14593</td><td>This pointer can be found at 14414(LSB) and 14415(MSB)</td>
</tr>
<tr>
<td colspan=2>LENGTH DEPENDS ON BASICPROGRAM</td><Td>Ends with two zero's</td>
</tr>
<tr>
<td colspan=2>RAM Part</td><td>START SIMPLE VARIABLE LIST</td></tr>
<tr>
<td></td><td align=right></td><td>Following after BASIC programmcode. The pointer to this start address can be found at 14550(LSB) and 14451(MSB)</td>
</tr>
<tr>
<td colspan=2>RAM Part</td><td>START ARRAY-VARIABLE LIST</td></tr>
<tr>
<td></td><td align=right></td><td>Following after the simple variable list. The pointer to this start address can be found at 14552(LSB) and 14453(MSB)</td>
</tr>
<tr>
<td colspan=2>RAM Part</td><td>START REST MEMORY</td></tr>
<tr>
<td></td><td align=right></td><td>Following after the array-variable list. The pointer to this start address can be found at 14554(LSB) and 14455(MSB). This part of memory is used by the computer as "stack" and "overhead"</td>
</tr>
<tr>
<td colspan=2>RAM Part</td><td>START STRING-VARIABLE MEMORY</td></tr>
<tr>
<td></td><td align=right></td><td>The pointer to this start address can be found at 14411(LSB) and 14412(MSB). Default 50 bytes, can be enlarged with the CLEAR command (e.g. CLEAR 100)</td>
</tr>
<tr>
<td colspan=2>MAX MEMORY</td><td>Pointer at 14509(LSB) and 14510(MSB)</td></tr>
</table>
</p>
<hr>
<p>
After the memory reserved for the character and color matrix is a part of the memory reserved for the system and BASIC. This area is about 256 bytes and runs from memory address 14336 up to 14591 (0x3800 -> 0x3FF)
<table style="border-collapse: collapse">
<tr>
<th colspan=2 align=center>Address</th><th rowspan =2>Mnemonic</th><th rowspan=2>Start<br>value</th><th rowspan=2>Description</th>
</tr>
<tr>
<th>Hex</th><th>Dec</th>
</tr>
<tr>
<td>0x3800</td><td>14336</td><td>TTYPOS:</td><td>0x00</td><td>Row position of cursor on screen (0x00-0x27)</td>
</tr>
<tr>
<td>0x3801<br>0x3802</td><td>14337<br>14338</td><td>CHRPOS:</td><td></td><td>Address of the cursor within the cursor matrix</td>
</tr>
<tr>
<td>0x3803</td><td>14339</td><td>USRGO:</td><td>0xC3</td><td>The number 179, which is the JUMP (0xC3) instruction for the Z80, is used for the execution of the USR() function.</td>
</tr>
<tr>
<td>0x3804<br>0x3805</td><td>14340<br>14341</td><td>USRAL:<br>USRAH</td><td>0x97<br>0x06</td><td>The start address to the machinecoded programm used by the USR() function. On startup it uses LSB=151 (0x97) and MSB=6 (0x06), pointing to memory address 1687 (0x0697) --> JMP FCERR. Jump to an errormessage routine within ROM)</td>
</tr>
<tr>
<td>0x3806<br>0x3807</td><td>14342<br>14343</td><td>HOKDSP:</td><td>0x3B<br>0x00</td><td>Pointer to the "HOOK SERVICE ROUTINE" LSB=59 (0x3B) and MSB=0, address 59 (0x003B) in the standard ROM. If BASIC Extension-ROM is used the address will be changed.</td>
</tr>
<tr>
<td>0x3808</td><td>14344</td><td>LISTCT:</td><td>0x00</td><td>Counter for LIST-command. The listening will be stopped after every 24 rows.</td>
</tr>
<tr>
<td>0x3809</td><td>14345</td><td>PTOLD:</td><td>0xA3</td><td>Contains the code which will be send to the protection port</td>
</tr>
<tr>
<td>0x380A</td><td>14346</td><td>CHARQ:</td><td>0x00</td><td>ASCII-value of the latest key pressed on the keyboard, but not yet been transferred to the character-matrix. Hence the value which will be used by the key-scanning routine (). The value will eventually end op at address 14351 (0x380F)</td>
</tr>
<td>0x380B<br>0x380C</td><td>14347<br>14348</td><td>SKEY:</td><td>0x00<br>0x00</td><td>Pointer use in the single key command</td>
</tr>
<tr>
<td>0x380D</td><td>14349</td><td>BUFO:</td><td>0x20</td><td>Storage of the character behind the cursor</td>
</tr>
<tr><!-- 380E and 380F were incorrectly swapped in the original document -->
<td>0x380E</td><td>14350</td><td>CTRLFG:</td><td>0x00</td><td>Current key value after scanning</td>
</tr>
<tr>
<td>0x380F</td><td>14351</td><td>FLAG:</td><td>0x00</td><td>Debounce count for the key scanning routine</td>
</tr>
<tr>
<td>0x3810<br>0x381E</td><td>14352<br>14366</td><td>FDIV:</td><td></td><td>Subroutine for division</td>
</tr>
<tr>
<td>0x381F<br>0x3844</td><td>14367<br>14404</td><td>RANDOM:</td><td></td><td>For the use in generation random numbers</td>
</tr>
<tr>
<td>0x3845</td><td>14405</td><td>LPTLST:</td><td>0x00</td><td>Last printer operation status.</td>
</tr>
<tr>
<td>0x3846</td><td>14406</td><td>LPTPOS:</td><td>0x00</td><td>Position of the printerhead (0-131)</td>
</tr>
<tr>
<td>0x3847</td><td>14407</td><td>PRTFLG:</td><td>0x28</td><td>Flag to direct output to printer or CRT.</td>
</tr>
<tr>
<td>0x3848</td><td>14408</td><td>LINLEN:</td><td>0x28</td><td>Line length. Initially set to 40</td>
</tr>
<tr>
<td>0x3849</td><td>14409</td><td>CLMLST:</td><td>0x0E</td><td>Position of last comma column</td>
</tr>
<tr>
<td>0x384A</td><td>14410</td><td>RUBSW:</td><td>0x00</td><td>Rubout switch</td>
</tr>
<tr>
<td>0x384B<br>0x384C</td><td>14411<br>14412</td><td>STKTOP:</td><td></td><td>Top location to be used for stack. It is followed by the RAM-stack where the strings are stored. At default there are 50 bytes reserved for strings at the top of the memory. With the command 'CLEAR 100' the stringspace will be enlarged en the stack therefor has to start at a lower address. </td>
</tr>
<tr>
<td>0x384D<br>0x384E</td><td>14413<br>14414</td><td>CURLIN:</td><td>0xFE<br>0xFF</td><td>Current line number. Set to 0xFFFF for direct statement mode.</td>
</tr>
<tr>
<td>0x384F<br>0x3850</td><td>14415<br>14416</td><td>TXTTAB:</td><td>0x01<br>0x39</td><td>Pointer to the beginning of Text of Basic programm.</td>
</tr>
<tr>
<td>0x3851<br>0x3856</td><td>14417<br>14422</td><td>CASNAM:</td><td></td><td>6 bytes for cassette name.</td>
</tr>
<tr>
<td>0x3857<br>0x385C</td><td>14423<br>14428</td><td>CASNM2:</td><td></td><td>6 bytes for cassette name read from tape</td>
</tr>
<tr>
<td>0x385D<br>0x385E</td><td>14429<br>14430</td><td>CASFL2:<br>CASFL3:</td><td>0xBE<br>0x08</td><td>Flags for cassette input/output routines.</td>
</tr>
<tr>
<td>0x385F</td><td>14431</td><td>BUFMIN:</td><td>0x31</td><td>Used by INPUT statement</td>
</tr>
<tr>
<td>0x3860<br>0x38A8</td><td>14432<br>14504</td><td>BUF:</td><td></td><td>73 bytes used for the current line input buffer.</td>
</tr>
<tr>
<td>0x38A9</td><td>14505</td><td>BUFEND:</td><td></td><td>End of input buffer</td>
</tr>
<tr>
<td>0x38AA</td><td>14506</td><td>DIMFLG:</td><td></td><td>Flag to differentiate variable type.</td>
</tr>
<tr>
<td>0x38AB</td><td>14507</td><td>VALTYP:</td><td></td><td>To differentiate between string or nummeric value.</td>
</tr>
<tr>
<td>0x38AC</td><td>14508</td><td>DORES:</td><td></td><td>Flag for crunch.</td>
</tr>
<tr>
<td>0x38AD<br>0x38AE</td><td>14509<br>14510</td><td>MEMSIZ:</td><td></td><td>Contains the highest RAM location.</td>
</tr>
<tr>
<td>0x38AF<br>0x38C0</td><td>14511<br>14528</td><td></td><td></td><td>For string functions</td>
</tr>
<tr>
<td>0x38C1<br>0x38C2</td><td>14529<br>14530</td><td>FRETOP:</td><td></td><td>Top of string free space.</td>
</tr>
<tr>
<td>0x38C3<br>0x38C5</td><td>14531<br>14533</td><td>TEMP:</td><td></td><td>Pointer for addresses of string storage.</td>
</tr>
<tr>
<td>0x38C6<br>0x38CB</td><td>14534<br>14539</td><td></td><td></td><td>Use for FOR function.</td>
</tr>
<tr>
<td>0x38CC<br>0x38D3</td><td>14538<br>14547</td><td></td><td></td><td>Pointer and flags for programm execution</td>
</tr>
<tr>
<td>0x38D4<br>0x38D5</td><td>14548<br>14549</td><td></td><td></td><td>Points to the start of the BASIC line which was interrupted by the break.</td>
</tr>
<tr>
<td>0x38D6<br>0x38D7</td><td>14550<br>14551</td><td>VARTAB:</td><td></td><td>Points to start of simple variable table</td>
</tr>
<tr>
<td>0x38D8<br>0x38D9</td><td>14552<br>14553</td><td>ARYTAB:</td><td></td><td>Points to start of array table.</td>
</tr>
<tr>
<td>0x38DA<br>0x38DB</td><td>14554<br>14555</td><td></td><td></td><td>Contains the end address of the BASIC & simple & array list.</td>
</tr>
<tr>
<td>0x38DC<br>0x38DD</td><td>14556<br>14557</td><td></td><td></td><td>Points to where the DATA has been READ. At start of programm or after a RESTORE this points to the address before the start of the BASIC programm (14592) which always contains zero.</td>
</tr>
<tr>
<td>0x38DE<br>0x38E3</td><td>14558<br>14563</td><td></td><td></td><td>Pointer and flags for arrays</td>
</tr>
<tr>
<td>0x38E4<br>0x38F8</td><td>14556</td><td>FACLO:</td><td></td><td>Floating number (exponent & mantissa stored here.)</td>
</tr>
</table>
</body>
</html>