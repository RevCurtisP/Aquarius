Creating s2basic.asm, s2basic.bin from aquarius-rom.lst
1 ;;Mattel Aquarius Microsoft Basic ROM disassembly
2 
3 ;;
4 ;;Annotated by Curtis F Kaylor
5 ;;
6 ;;Originally disassembled with dasmx, but modified to match TASM syntax
7 
8 ;;Listing format:
9 ;;
10 ;;  Lines beginning with ; are metacomments, i.e. not part of the source code
11 ;;
12 ;;  Lines beginning with : are temporary lines to allow progressive testing of
13 ;;  conversion to a source file and subsequent assembly. They will be added
14 ;;  and removed as needed until the generated source code fully assembles.
15 
16 
17 
18 ;;Labels and comments are taken from the following:
19 ;;  Original Source Code (Canonical Labels and Comments)
20 ;;    [M80] Microsoft Basic-80 5.2 Source [198]
21 ;;          winworldpc.com/product/microsoft-basic/80
22 ;;    [M65] Microsoft BASIC for 6502 Original Source Code [1978]
23 ;;          www.pagetable.com/?p=774
24 ;;    [GWB] Microsoft GW-BASIC Interpreter Source Code [1983]
25 ;;          https://github.com/microsoft/GW-BASIC
26 ;;  Commented Disassemby Listings (Non-Canonical)
27 ;;    [A4K] Altair BASIC 3.2 (4K) - Annotated Disassembly [1975]
28 ;;          altairbasic.org/
29 ;;    [A8K] Altair BASIC 84K - Disassembly [1978]
30 ;;          www.autometer.de/unix4fun/z80pack/ftp/altair/basic8k78.orge
31 ;;    [TR1] TRS-80 Model I Level II Basic ROM Disassembly
32 ;;          http://www.trs-80.com/wordpress/zaps-patches-pokes-tips/rom-cpu-info-page/
33 ;;  Third Party Reference Materials (Non-Canonical)
34 ;;    [L2R] Level II ROM Reference Manual [1980]
35 ;;          https://www.classic-computers.org.nz/system-80/manuals_Level%20II%20ROM%20Reference%20Manual.pdf
36 ;;    [M64] COMPUTE!'s Mapping the C64
37 ;;
38 ;;Label sources are denoted to the left of the label and comment sources are denoted at the beginning of the comment.
39 ;;
40 ;;Comments taken from the above sources are preceded by a single semicolon, while unsourced comments
41 ;;are preceded by two semicolons, and annotations are preceded by three semicolons.
42 
43                         ;;BASIC Constants
44                         CLMWID  equ     14      ;[M80] MAKE COMMA COLUMNS FOURTEEN CHARACTERS
45                         LPTSIZ  equ     132     ;{M80} WIDTH OF PRINTER
46 
47                         ;;System Variables
48                         SCREEN  equ     $3000   ;;Screen Character Matrix
49                         COLOR   equ     $3400   ;;Screen Color Matrix
50                   [M80] TTYPOS  equ     $3800   ;[M80] STORE TERMINAL POSITION HERE
51                         CURRAM  equ     $3801   ;;Position in CHARACTER RAM of cursor
52                   [M65] USRPOK  equ     $3803   ;;JP instruction for USR() routine
53                         USRADD  equ     $3804   ;;Address of USR routine
54                         HOOK    equ     $3806   ;;Extended ROM Hook Vector
55                   [M80] CNTOFL  equ     $3808   ;;Line Counter. If not 0,
56                         LASTFF  equ     $3809   ;;Last value last output to port #FF
57                         CHARC   equ     $380A   ;[M80] ISCNTC STORES EATEN CHAR HERE WHEN NOT A ^C
58                         RESPTR  equ     $380B   ;;Pointer to Ctrl-Key Reserved Word
59                         CURCHR  equ     $380D   ;;Character under Cursor
60                   [M64] LSTX    equ     $380E   ;[M64] Matrix Coordinate of Last Key Pressed
61                         KCOUNT  equ     $380F   ;;Keyboard debounce counter
62                   [M80] FDIVC   equ     $3810   ;
63                   [M80] FDIVB   equ     $3814   ;
64                   [M80] FDIVA   equ     $3818   ;
65                   [M80] FDIVG   equ     $381B   ;
66                         ;               $381E   ;{M80} RND FUNCTION PERTUBATION COUNT
67                   [M80] RNDCNT  equ     $381F   ;
68                   [M80] ;       equ     $3820   ;
69                   [M80] RNDTAB  equ     $3821   ;;Unused Random Number TABLE
70                                                 ;;;The exact same table exists in CP/M Basic where it is unused
71                         RNDX    equ     $3841   ;[M80] LAST RANDOM NUMBER GENERATED, BETWEEN 0 AND 1
72                   [M80] LPTPOS  equ     $3846   ;[M80] POSITION OF LPT PRINT HEAD
73                   [M80] PRTFLG  equ     $3847   ;[M80] WHETHER OUTPUT GOES TO LPT
74                         LINLEN  equ     $3848   ;;Length of a Screen Line
75                         CLMLST  equ     $3849
76                   [M80] RUBSW   equ     $384A   ;[M80] RUBOUT SWITCH =1 INSIDE THE PROCESSING OF A RUBOUT (INLIN)
77                   [M80] TOPMEM  equ     $384B   ;[M80] TOP LOCATION TO USE FOR THE STACK INITIALLY SET UP BY INIT
78                                                 ;[M80] ACCORDING TO MEMORY SIZE TO ALLOW FOR 50 BYTES OF STRING SPACE.
79                                                 ;[M80] CHANGED BY A CLEAR COMMAND WITH AN ARGUMENT.
80                   [M80] CURLIN  equ     $384D   ;[M80] CURRENT LINE #
81                   [M80] TXTTAB  equ     $384F   ;[M80] POINTER TO BEGINNING OF TEXT
82                                                 ;[M80] DOESN'T CHANGE AFTER BEING SETUP BY INIT.
83                   [GWB] FILNAM  equ     $3851   ;;File Name for CSAVE and CLOAD
84                         FILNAF  equ     $3857   ;;File Name Read from Cassette
85                         INSYNC  equ     $385D   ;;Contains $FF between read of SYNC and data from tape
86                         CLFLAG  equ     $385E   ;;Flags whether doing CLOAD (0) or CLOAD? ($FF)
87                         BUFMIN  equ     $385F   ;{M80} START OF BUFFER
88                   [M80] BUF     equ     $3860   ;[M80] TYPE IN STORED HERE. DIRECT STATEMENTS EXECUTE OUT OF HERE.
89                                                 ;[M80] REMEMBER "INPUT" SMASHES BUF. MUST BE AT A LOWER ADDRESS THAN DSCTMP
90                                                 ;[M80] OR ASSIGNMENT OF STRING VALUES IN DIRECT STATEMENTS WON'T COPY INTO
91                                                 ;[M80] STRING SPACE -- WHICH IT MUST ALLOW FOR SINGLE QUOTE IN BIG LINE
92                   [M80] ENDBUF  equ     $38A9   ;[M80] PLACE TO STOP BIG LINES
93                   [M80] BUFLEN  = ENDBUF-BUF-1  ;;Buffer Length
Misaligned operand in line 93
>= ENDBUF
94                   [M80] DIMFLG  equ     $38AA   ;[M80] IN GETTING A POINTER TO A VARIABLE IT IS IMPORTANT TO REMEMBER
95                                                 ;[M80] WHETHER IT IS BEING DONE FOR "DIM" OR NOT
96                   [M80] VALTYP  equ     $38AB   ;[M80] THE TYPE INDICATOR 0=NUMERIC 1=STRING
97                   [M80] DORES   equ     $38AC   ;[M80] WHETHER CAN OR CAN'T CRUNCH RES'D WORDS TURNED ON WHEN "DATA"
98                                                 ;[M80] BEING SCANNED BY CRUNCH SO UNQUOTED STRINGS WON'T BE CRUNCHED.
99                   [M80] MEMSIZ  equ     $38AD   ;[M80] HIGHEST LOCATION IN MEMORY
100                   [M80] TEMPPT  equ     $38AF   ;[M80] POINTER AT FIRST FREE TEMP DESCRIPTOR. INITIALIZED TO POINT TO TEMPST
101                   [M80] TEMPST  equ     $38B1   ;[M80] STORAGE FOR NUMTMP TEMP DESCRIPTORS
102                   [M80] DSCTMP  equ     $38BD   ;[M80] STRING FUNCTIONS BUILD ANSWER DESCRIPTOR HERE
103                   [M80] FRETOP  equ     $38C1   ;[M80] TOP OF STRING FREE SPACE
104                   [M80] TENP3   equ     $38C3   ;[M80] USED MOMENTARILY BY FRMEVL. USED IN EXTENDED BY FOUT AND
105                                                 ;[M80] USER DEFINED FUNCTIONS ARRAY VARIABLE HANDLING TEMPORARY
106                   [M80] TEMP8   equ     $38C5   ;[M80] USED TO STORE THE ADDRESS OF THE END OF STRING ARRAYS IN GARBAGE COLLECTION
107                   [M80] ENDFOR  equ     $38C7   ;[M80] SAVED TEXT POINTER AT END OF "FOR" STATEMENT
108                   [M80] DATLIN  equ     $38C9   ;[M80] DATA LINE # -- REMEMBER FOR ERRORS
109                   [M80] SUBFLG  equ     $38CB   ;[M80] FLAG WHETHER SUBSCRIPTED VARIABLE ALLOWED "FOR" AND USER-DEFINED
110                                                 ;[M80] FUNCTION POINTER FETCHING TURN THIS ON BEFORE CALLING PTRGET SO
111                                                 ;[M80] ARRAYS WON'T BE DETECTED. STKINI AND PTRGET CLEAR IT.
112                   [M80] USFLG   equ     $38CC   ;;Direct Mode Flag
113                   [M80] FLGINP  equ     $38CD   ;[M80] FLAGS WHETHER WE ARE DOING "INPUT" OR A READ
114                   [M80] SAVTXT  equ     $38CE   ;[M80] PLACE WHERE NEWSTT SAVES TEXT POINTER
115                   [M80] TENP2   equ     $38D0   ;[M80] FORMULA EVALUATOR TEMP MUST BE PRESERVED BY OPERATORS
116                                                 ;[M80] USED IN EXTENDED BY FOUT AND USER-DEFINED FUNCTIONS
117                   [M80] OLDLIN  equ     $38D2   ;[M80] OLD LINE NUMBER (SETUP BY ^C,"STOP" OR "END" IN A PROGRAM)
118                   [M80] OLDTXT  equ     $38D4   ;[M80] OLD TEXT POINTER
119                   [M80] VARTAB  equ     $38D6   ;[M80] POINTER TO START OF SIMPLE VARIABLE SPACE. UPDATED WHENEVER
120                                                 ;[M80] THE SIZE OF THE PROGRAM CHANGES, SET TO [TXTTAB] BY SCRATCH ("NEW").
121                   [M80] ARYTAB  equ     $38D8   ;[M80] POINTER TO BEGINNING OF ARRAY TABLE. INCREMENTED BY 6 WHENEVER
122                                                 ;[M80] A NEW SIMPLE VARIABLE IS FOUND, AND SET TO [VARTAB] BY CLEARC.
123                   [M80] STREND  equ     $38DA   ;[M80] END OF STORAGE IN USE. INCREASED WHENEVER A NEW ARRAY
124                                                 ;[M80] OR SIMPLE VARIABLE IS ENCOUNTERED SET TO [VARTAB] BY CLEARC.
125                   [M80] DATPTR  equ     $38DC   ;[M80] POINTER TO DATA. INITIALIZED TO POINT AT THE ZERO IN FRONT OF [TXTTAB]
126                                                 ;[M80] BY "RESTORE" WHICH IS CALLED BY CLEARC. UPDATED BY EXECUTION OF A "READ"
127                   [M65] VARNAM  equ     $38DE   ;;Variable Name
128                   [M65] VARPNT  equ     $38E0   ;;Pointer to Variable
129 ;                                       $38E2   ;;Used by Extended BASIC
130 ;                                       $38E3   ;;Unused
131                   [M80] FACLO   equ     $38E4   ;[M80] LOW ORDER OF MANTISSA
132                   {M80} FACMO   equ     $38E5   ;[M80] MIDDLE ORDER OF MANTISSA
133                   [M80] FACHO   equ     $38E6   ;[M80] HIGH ORDER OF MANTISSA
134                   [M80] FAC     equ     $38E7   ;[M80] EXPONENT
135                   [M80] FBUFFR  equ     $38E8   ;[M80[ BUFFER FOR FOUT
136                   [M65] RESHO   equ     $38F6   ;[M65] RESULT OF MULTIPLIER AND DIVIDER
137                   [M65] RESMO   equ     $38F7   ;;RESMO and RESLO are loaded into and stored from HL
138                   {M65} RESLO   equ     $38F8   ;
139                   [M80] SAVSTK  equ     $38F9   ;[M80] NEWSTT SAVES STACK HERE BEFORE SO THAT ERROR REVERY CAN
140                                                 ;[M80] CAN RESTORE THE STACK WHEN AN ERROR OCCURS
141                         ;;              $3900   ;;This is always 0
142                         BASTXT  equ     $3901   ;;Start of Basic Program
143 
144                         ;;External Addresses
145                         EXTBAS  equ     $2000   ;;Start of Extended Basic
146                         XSTART  equ     $2010   ;;Extended BASIC Startup Routine
147                         XINIT   equ     $E010   ;;ROM Cartridge Initialization Entry Point
148 
149                                 .org    0       ;;Starting Address of ROM
150 
151 0000                  + ;;RST 0 - Startup
152 0000                  | ;;On power up or reset, the Z80 jumps to this RST
153 0000                  | ;;The instruction RST START is functionally equivalent to doing
154 0000                  | ;;a hardware reset.
155 0000 : C3 E1 1F   [M80] START:  jp      JMPINI          ;;Start Initialization
156 0003 : 82 06 22                 byte    $82,$06,$22     ;;Revision Date 1982-06-22
157 0006 : 0B                       byte    11              ;;Revision Number?
158 0007 : 00                       nop                     ;;Pad out the RST routine
159 0008
160 0008                  + ;;RST 1 - Syntax Check
161 0008                  | ;;Check for Matching Character
162 0008                  | ;[M65] "SYNCHK" LOOKS AT THE CURRENT CHARACTER TO MAKE SURE IT
163 0008                  | ;[M65] IS THE SPECIFIC THING IN THE BYTE IMMEDIATELY FOLLOWING
164 0008                  | ;[M65] "RST SYNCHK". IF NOT, IT CALLS THE "SYNTAX ERROR" ROUTINE.
165 0008                  | ;[M65] OTHERWISE IT GOBBLES THE NEXT CHAR AND RETURNS,
166 0008                  | ;
167 0008                  | ;[M65] [A]=NEW CHAR AND [H,L] IS ADVANCED BY "CHRGET".
168 0008                  | ;
169 0008                  | ;;;In Basic versions that don't use RST, this routine is named SYNCHR
170 0008 : 7E         [M80] SYNCHK: ld      a,(hl)
171 0009 : E3                       ex      (sp),hl
172 000A : BE                       cp      (hl)                    ;[M65] CHARACTERS EQUAL?
173 000B : 23                       inc     hl
174 000C : E3                       ex      (sp),hl
175 000D : C2 C4 03                 jp      nz,SNERR                ;[M65] "SYNTAX ERROR"
176 0010
177 0010                  + ;;RST 2 - Get Next Character
178 0010                  | ;[M80] CHRGET - THE NEXT CHARACTER SCAN ROUTINE
179 0010                  | ;[M65] "CHRGET" USES [H,L] AS THE CURRENT TEXT PNTR
180 0010                  | ;[M65] FETCHES A NEW CHARACTER INTO ACCA AFTER INCREMENTING [H,L]
181 0010                  | ;[M65] AND SETS CONDITION CODES ACCORDING TO WHAT'S IN ACCA.
182 0010                  | ;[M65]       NOT C=  NUMERIC   ("0" THRU "9")
183 0010                  | ;[M65]       Z=      ":" OR END-OF-LINE (A NULL)
184 0010                  | ;[M65]
185 0010                  | ;[M65] [ACCA] = NEW CHAR.
186 0010                  | ;[M65] [H,L]=[H,L]+1
187 0010                  |
188 0010                  | ;;Since the text pointer is kept in HL, the 8080 versions of Basic
189 0010                  | ;;use LD A,HL to get the current character, rather than CHRGOT
190 0010                  |
191 0010                  | ;;;Basic versions that don't use RST use CALL CHRGTR instead
192 0010 : 23         [M65] CHRGET: inc     hl              ;[M65] INCREMENT THE TEXT PNTR
193 0011 : 7E         {M65} CHRGOT: ld      a,(hl)          ;;Entry point to get current character
194 0012 : FE 3A      {M65} QNUM:   cp      ':'             ;[M65] IS IT A ":"?
195 0014 : D0                       ret     nc              ;[M65] IT IS .GE. ":"
196 0015 : C3 70 06                 jp      CHRCON          ;;Continue in CHRGETR
197 0018
198 0018                  + ;;RST 3 - Output Character
199 0018                  | ;{M80}  RST OUTCHR prints char in [A] no registers affected
200 0018                  | ;{M80}    to either terminal or printer depending on flag:
201 0018                  | ;{M80}    PRTFLG if non-zero print to printer
202 0018                  | ;
203 0018                  | ;;;Basic versions that don't use RST use CALL OUTDO instead
204 0018 : C3 8A 19   [GWB] OUTCHR: jp      OUTDO           ;; Execute print character routine
205 001B : 00 00 00 00              byte    0,0,0,0,0       ;; Pad out the RST routine
206 001F : 00                                               ;;; (The hook call code from OUTDO could be moved here)
207 0020
208 0020                  + ;;RST 4 - Integer Compare
209 0020                  | ;[TR1] Compares HL with DE. After execution,
210 0020                  | ;;If HL = DE, Z flag is set
211 0020                  | ;;If HL <> DE, Z flag is reset
212 0020                  | ;;If HL < DE, C flag is set
213 0020                  | ;;If HL >= DE, C flag is reset
214 0020                  | ;;;In versions that don't use RST, this routine is named DCOMPR
215 0020 : 7C         [M80] COMPAR: ld      a,h             ;;Compare [DE] to [HL]
216 0021 : 92                       sub     d               ;;Sets Z flag if equal
217 0022 : C0                       ret     nz              ;;Sets Carry if [DE] > [HL]
218 0023 : 7D                       ld      a,l             ;;Destroys [A]
219 0024 : 93                       sub     e               ;
220 0025 : C9                       ret                     ;
221 0026 : 00 00                    byte    0,0             ;; Pad out the RST routine
222 0028
223 0028                  + ;;RST 5 - Get sign of Floating Point Argument
224 0028                  | ;[M80] PUT SIGN OF FAC IN A.
225 0028                  | ;[M80] ALTERS A ONLY
226 0028                  | ;[M80] LEAVES FAC ALONE
227 0028                  | ;
228 0028                  | ;;;Basic versions that don't use RST use CALL SIGN insteaoard
229 0028 : 3A E7 38   [M80] FSIGN:  ld      a,(FAC)         ;
230 002B : B7                       or      a               ;[M65] IF NUMBER IS ZERO, SO IS RESULT
231 002C : C2 EB 14                 jp      nz,SIGNC        ;;Check sign of mantissa if not 0
232 002F : C9                       ret                     ;
233 0030
234 0030                  + ;;RST 6 - Extended BASIC Hook Dispatch
235 0030                  | ;;The additional functionality of Extended Basic are invoked via this RST.
236 0030                  | ;;Each RST HOOK instruction is followed by a byte that indicates which hook
237 0030                  | ;;routine to execute. On startup, this routine jumps to NOHOOK, which skips
238 0030                  | ;;the hook number byte the does a RET.
239 0030                  | ;;
240 0030                  | ;;Extended Basic overwrites the address in HOOK, enabling hook dispatch.
241 0030                  | ;;
242 0030                  } ;;
243 0030                  | ;;*** TODO: List the hook routines.
244 0030 : DD 2A 06 38      HOOKDO: ld      ix,(HOOK)       ;;Get hook routine address
245 0034 : DD E9                    jp      (ix)            ;;and jump to it
246 0036 : 00 00                    byte    0,0             ;;Pad out RST routine
247 0038
248 0038                  + ;;RST 7 - Execute USR Routine
249 0038                  | ;;The instruction RST USRFN executes user defined code at
250 0038                  | ;;the address in USR via the JP instruction in USRPOK.
251 0038                  | ;;
252 0038                  | ;;This is the same entry point used by the USR function.
253 0038                  | ;;***TODO: how to detect a USR() call
254 0038 : C3 03 38   [M80] USRFN:  jp      USRPOK          ;;Execute USR() routine
255 003B
256 003B                  + ;;Default Extended BASIC Hook Routine
257 003B                  | ;;The system variable HOOK is loaded with the address of this
258 003B                  | ;;routine on startup, so that all RST HOOK instructions
259 003B                  | ;;are routed here.
260 003B                  | ;;
261 003B                  | ;;This routine returns to the second byte after the RST
262 003B                  | ;;RST instruction, preserving all registers.
263 003B : D9               NOHOOK: exx                     ;;Save BC, DE, and HL
264 003C : E1                       pop     hl              ;;Get return address off stack
265 003D : 23                       inc     hl              ;;Increment to skip byte after RST
266 003E : E5                       push    hl              ;;Put new return address on stack
267 003F : D9                       exx                     ;;Restore BC, DE, and HL
268 0040 : C9                       ret                     ;;and Return
269 0041
270 0041 : 31 A0 38   [M80] INIT:   ld      sp,$38A0        ;[M80] SET UP TEMP STACK
271 0044 : 3E 0B                    ld      a,11            ;
272 0046 : CD 94 1D                 call    TTYOUT          ;;Print CLS to Clear Screen
273 0049 : 2A 01 38                 ld      hl,(CURRAM)     ;
274 004C : 36 20                    ld      (hl),' '        ;;Place Space on Screen
275 004E : 3E 07                    ld      a,7             ;
276 0050 : CD 94 1D                 call    TTYOUT          ;;Print BEL to Sound Beep
277 0053 : AF                       xor     a               ;
278 0054 : D3 FF                    out     ($FF),a         ;;Output 0 to I/O Port 255;
279 0056 : 21 FF 2F                 ld      hl,$2FFF        ;
280 0059 : 22 5D 38                 ld      (INSYNC),hl     ;
281 005C
282 005C                    ;;Check for Catridge ROM at $E010
283 005C : 11 11 E0         CRTCHK: ld      de,$E011        ;
284 005F : 21 81 00                 ld      hl,CRTSIG-1     ;
285 0062 : 1B         (~~~) CRTCH1: dec     de              ;
286 0063 : 1B                       dec     de              ;
287 0064 : 23                       inc     hl              ;
288 0065 : 1A                       ld      a,(de)          ;
289 0066 : 0F                       rrca                    ;
290 0067 : 0F                       rrca                    ;
291 0068 : 83                       add     a,e             ;
292 0069 : BE                       cp      (hl)            ;
293 006A : 28 F6                    jr      z,CRTCH1        ;
294 006C : 7E                       ld      a,(hl)          ;
295 006D : B7                       or      a               ;
296 006E : 20 19                    jr      nz,RESET        ;;ROM not found, start Basic
297 0070 : EB                       ex      de,hl           ;
298 0071 : 06 0C                    ld      b,00CH          ;
299 0073 : 86         (~~~) CRTCH2: add     a,(hl)          ;
300 0074 : 23                       inc     hl              ;
301 0075 : 80                       add     a,b             ;
302 0076 : 05                       dec     b               ;
303 0077 : 20 FA                    jr      nz,CRTCH2       ;
304 0079 : AE                       xor     (hl)            ;
305 007A : D3 FF                    out     ($FF),a         ;
306 007C : 32 09 38                 ld      (LASTFF),a      ;
307 007F : C3 10 E0                 jp      XINIT           ;;Execute Catridge Code
308 0082
309 0082 : 2B 37 24 24      CRTSIG: byte    "+7$$3,",0      ;;$A000 Cartridge Signature
310 0086 : 33 2C 00
311 0089
312 0089                  + ;;Display Startup Screen
313 0089                  | ;;Copies the bytes at BASICT and STARTT directly to
314 0089                  | ;;specific positions in screen memory.
315 0089 : 11 A1 31         RESET:  ld      de,SCREEN+417           ;;Display "BASIC"
316 008C : 21 B0 00                 ld      hl,BASICT               ;;at line 10, column 17
317 008F : 01 05 00                 ld      bc,STARTT-BASICT        ;
318 0092 : ED B0                    ldir                            ;
319 0094 : 11 10 32                 ld      de,SCREEN+528           ;;Display Start Message
320 0097 : 21 B5 00                 ld      hl,STARTT               ;at line 13, column 8
321 009A : 01 19 00                 ld      bc,STARTE-STARTT        ;
322 009D : ED B0                    ldir                            ;
323 009F
324 009F                  + ;;Cycle Screen Colors
325 009F                  | ;;Cycles through backround colors by sequentially
326 009F                  | ;;calling the COLORS routine in a loop.
327 009F : 06 03            CYCLE:  ld      b,3             ;; Black on Yellow
328 00A1 : CD CF 00                 call    COLORS          ;
329 00A4 : 06 02                    ld      b,2             ;; Black on Green
330 00A6 : CD CF 00                 call    COLORS          ;
331 00A9 : 06 06                    ld      b,6             ;; Black on Light Cyan
332 00AB : CD CF 00                 call    COLORS          ;
333 00AE : 18 EF                    jr      CYCLE           ;
334 0080
335 0080                  + ;;Start Screen Text
336 0080                  | ;;Copied directly into Screen RAM by the RESET routine
337 00B0 : 42 41 53 49      BASICT: byte    "BASIC"                         ;
338 00B4 : 43
339 00B5 : 50 72 65 73      STARTT: byte    "Press RETURN key to start"     ;
340 00B9 : 73 20 52 45
341 00BD : 54 55 52 4E
342 00C1 : 20 6B 65 79
343 00C5 : 20 74 6F 20
344 00C9 : 73 74 61 72
345 00CD : 74
346 00CE : 00               STARTE: byte    0               ;;End of String
347 00CF
348 00CF                  + ;;Set Screen Colors and Check for Keypress
349 00CF                  | ;;Fills color RAM with the foreground/backround colors
350 00CF                  | ;;pssed in the accumulator, then goes into a delay loop
351 00CF                  | ;;that checks for a keypress.
352 00CF                  | ;;
353 00CF                  | ;;If RETURN is pressed, execution passes to COLDST,
354 00CF                  | ;;initializing the Basic interpreter,
355 00CF                  | ;;
356 00CF                  | ;;If CTRL-C is pressed, execution passes to WARMST,
357 00CF                  | ;;preserving the Basic program and returning the user
358 00CF                  | ;;to the "Ok" prompt.
359 00CF : 21 00 34         COLORS: ld      hl,COLOR        ;;Store Accumulator in all bytes of Color
360 00D2 : 70         (~~~) COLOR1: ld      (hl),b          ;;memory, addresses $3400 through $3FFF
361 00D3 : 23                       inc     hl              ;;
362 00D4 : 7C                       ld      a,h             ;;NOTE: This wipes out $3B80 through $3FFF,
363 00D5 : FE 38                    cp      $38             ;;which are after the end of Color memory.
364 00D7 : 20 F9                    jr      nz,COLOR1       ;
365 00D9 : 21 00 40                 ld      hl,$4000        ;;Loop 12,288 times
366 00DC : CD 80 1E   (~~~) COLOR2: call    INCHRC          ;;Check for keypress
367 00DF : FE 0D                    cp      13              ;{M80} IS IT A CARRIAGE RETURN?
368 00E1 : 28 1A                    jr      z,COLDST        ;;Cold Start
369 00E3 : FE 03                    cp      3               ;;Is it CTRL-C?
370 00E5 : 28 06                    jr      z,WARMST        ;;Warm Start
371 00E7 : 2B                       dec     hl              ;;Decrement Counter
372 00E8 : 7C                       ld      a,h             ;
373 00E9 : B5                       or      l               ;
374 00EA : 20 F0                    jr      nz,COLOR2       ;;If not 0, loop
375 00EC : C9                       ret                     ;;Back to CYCLE
376 00ED
377 00ED                  + ;;Basic Interpreter Warm Start
378 00ED                  | ;;Clears the screen, resets I/O port $FF, initializes
379 00ED                  | ;;the hardware stack,
380 00ED                  | ;;***then does other stuff.
381 00ED : 3E 0B            WARMST: ld      a,11            ;
382 00EF : CD 72 1D                 call    TTYCHR          ;;Clear Scree,
383 00F2 : 3A 09 38                 ld      a,(LASTFF)      ;
384 00F5 : D3 FF                    out     ($FF),a         ;;Reset I/O Port 255
385 00F7 : CD E5 0B                 call    STKINI          ;;Initialize stack
386 00FA : CD 40 1A                 call    WRMCON          ;;Finish Up
387 00FD
388 00FD : 21 87 01         COLDST: ld      hl,DEFALT       ;Set System Variable Default Values
389 0100 : 01 51 00                 ld      bc,81           ;
390 0103 : 11 03 38                 ld      de,USRPOK       ;;Copy 80 bytes starting at DEFALT
391 0106 : ED B0                    ldir                    ;;to the first 80 bytes of System Variables
392 0108 : AF                       xor     a               ;
393 0109 : 32 A9 38                 ld      (ENDBUF),a      ;;Clear byte after end of BUF
394 010C : 32 00 39                 ld      (BASTXT-1),a    ;;Clear byte before start of basic program
395 010F                    ;;Test Memory to Find Top of RAM
396 010F : 21 64 39                 ld      hl,BASTXT+99    ;;Set RAM Test starting address
397 0112 : 23               MEMTST: inc     hl              ;;Bump pointer
398 0113 : 4E                       ld      c,(hl)          ;;Save contents of location
399 0114 : 7C                       ld      a,h             ;
400 0115 : B5                       or      l               ;;Wrapped around to $0000?
401 0116 : 28 0B                    jr      z,MEMCHK        ;;Yes, go on to check memory
402 0118 : A9                       xor     c               ;;Scramble bits into A
403 0119 : 77                       ld      (hl),a          ;;and write to location
404 011A : 46                       ld      b,(hl)          ;;Read back into B
405 011B : 2F                       cpl                     ;;Invert scrambled bits
406 011C : 77                       ld      (hl),a          ;;Write to location
407 011D : 7E                       ld      a,(hl)          ;;read it back
408 011E : 2F                       cpl                     ;;and revert back
409 011F : 71                       ld      (hl),c          ;;Write original byte to location
410 0120 : B8                       cp      b               ;;Did reads match writes?
411 0121 : 28 EF                    jr      z,MEMTST        ;;Yes, check next location
412 0123                    ;;Check Memory Size             ;
413 0123 : 2B         (~~~) MEMCHK: dec     hl              ;;Back up to last good address
414 0124 : 11 2C 3A                 ld      de,BASTXT+299   ;
415 0127 : E7                       rst     COMPAR          ;;Is there enough RAM?
416 0128 : DA B7 0B                 jp      c,OMERR         ;;No, Out of Memory error
417 012B                    ;;Set Top of memory
418 012B : 11 CE FF   {~~~} MEMSET: ld      de,$FFCE
419 012E : 22 AD 38                 ld      (MEMSIZ),hl     ;;Set MEMSIZ to last RAM location
420 0131 : 19                       add     hl,de
421 0132 : 22 4B 38                 ld      (TOPMEM),hl     ;;Set TOPMEM t0 MEMSIZ-50
422 0135 : CD BE 0B                 call    SCRTCH          ;;Perform NEW
423 0138 : CD F2 1F                 call    PRNTIT          ;;Print copyright message
424 013B : 31 65 38                 ld      sp,$03865       ;;Top of of stack used to be here
425 013E : CD E5 0B                 call    STKINI          ;;Set stack pointer to TOPMEM
426 0141                    ;;Check for Extended BASIC
427 0141 : 21 05 20                 ld      hl,EXTBAS+5     ;;End of signature in Extended BASIC
428 0144 : 11 82 00                 ld      de,CRTSIG       ;;Text to check signature against
429 0147 : 1A         (~~~) EXTCHK: ld      a,(de)          ;;Get byte from signature
430 0148 : B7                       or      a               ;;Did we reach a terminator?
431 0149 : CA E8 1F                 jp      z,XBASIC        ;;Yes, start Extended BASIC
432 014C : BE                       cp      (hl)            ;;Does it match byte in ROM?
433 014D : 20 04                    jr      nz,INITFF       ;;No, move on
434 014F : 2B                       dec     hl              ;;Move backward in Extended BASIC
435 0150 : 13                       inc     de              ;;and forward in test signature
436 0151 : 18 F4                    jr      EXTCHK          ;;Compare next character
437 0153
438 0153                    ;;Initialize I/O Port 255
439 0153 : ED 5F      (~~~) INITFF: ld      a,r             ;;Read random number from Refresh Register
440 0155 : 17                       rla                     ;;Rotate left
441 0156 : 81                       add     a,c             ;;Copy in bit that was rotated out
442 0157 : D3 FF                    out     ($FF),a         ;;Write it to I/O Port 255
443 0159 : 32 09 38                 ld      (LASTFF),a      ;;and save it for later
444 015C : C3 02 04                 jp      READY           ;;Enter direct mode
445 015F
446 015F : 0B         [GWB] HEDING: byte    11
447 0160 : 43 6F 70 79              byte    "Copyright ",5," "
448 0164 : 72 69 67 68
449 0168 : 74 20 05 20
450 016C : 31 39 38 32              byte    "1982 by Microsoft Inc. S2",10,0
451 0170 : 20 62 79 20
452 0174 : 4D 69 63 72
453 0178 : 6F 73 6F 66
454 017C : 74 20 49 6E
455 0180 : 63 2E 20 53
456 0184 : 32 0A 00
457 0187
458 0187                            ;;System Variable Default Values - 81 ($51) bytes
459 0187 : C3 97 06         DEFALT: jp      FCERR           ;;3803 USRPOK
460 018A : 3B 00                    word    NOHOOK          ;;3806 HOOK
461 018C : 00                       byte    0               ;;3808 CNTOFL
462 018D : A3                       byte    163             ;;3809 LASTFF
463 018E : 00                       byte    0               ;;380A CHARC
464 018F : 00 00                    word    0               ;;380B RESPTR
465 0191 : 20                       byte    ' '             ;;380D CURCHR
466 0192 : 00                       byte    0               ;;380E LSTX
467 0193 : 00                       byte    0               ;;380F KCOUNT
468 0194 : D6 00                    sub     $00             ;;3810 FDIVC
469 0196 : 6F                       ld      l,a             ;;3812
470 0197 : 7C                       ld      a,h             ;;3813
471 0198 : DE 00                    sbc     a,00            ;;3814 FDIVB
472 019A : 67                       ld      h,a             ;;3816
473 019B : 78                       ld      a,b             ;;3817
474 019C : DE 00                    sbc     a,00            ;;3818 FDIVA
475 019E : 47                       ld      b,a             ;;381A
476 019F : 3E 00                    ld      a,0             ;;381B FDIVG
477 01A1 : C9                       ret                     ;;381D
478 01A2 : 00                       byte    0               ;;381E
479 01A3 : 00                       byte    0               ;;381F RNDCNT
480 01A4 : 00                       byte    0               ;;3820
481 01A5 : 35 4A CA 99              byte    $35,$4A,$CA,$99 ;;3821 RNDTAB
482 01A9 : 39 1C 76 98              byte    $39,$1C,$76,$98 ;;3825
483 01AD : 22 95 B3 98              byte    $22,$95,$B3,$98 ;;3829
484 01B1 : 0A DD 47 98              byte    $0A,$DD,$47,$98 ;;383D
485 01B5 : 53 D1 99 99              byte    $53,$D1,$99,$99 ;;3831
486 01B9 : 0A 1A 9F 98              byte    $0A,$1A,$9F,$98 ;;3835
487 01BD : 65 BC CD 98              byte    $65,$BC,$CD,$98 ;;3839
488 01C1 : D6 77 3E 98              byte    $D6,$77,$3E,$98 ;;383D
489 01C5 : 52 C7 4F 80              byte    $52,$C7,$4F,$80 ;;3841 RNDX
490 01C9 : 00                       byte    $00             ;;3845
491 01CA : 00                       byte    $00             ;;3846 LPTPOS
492 01CB : 00                       byte    $00             ;;3847 PRTFLG
493 01CC : 28                       byte    $28             ;;3848 LINLEN
494 01CD : 0E                       byte    $0E             ;;3849 CLMLST
495 01CE : 00                       byte    $00             ;;384A RUBSW
496 01CF : 64 39                    byte    $64,$39         ;;384B TOPMEM
497 01D1 : FE FF                    byte    $FE,$FF         ;;384D CURLIN
498 01D3 : 01 39                    byte    $01,$39         ;;384F TXTTAB
499 01D5
500 01D5                  + ;[M65] STATEMENT DISPATCH ADDRESSES
501 01D5                  | ;[M65] WHEN A STATEMENT IS TO BE EXECUTED, THE FIRST
502 01D5                  | ;[M65] CHARACTER OF THE STATEMENT IS EXAMINED
503 01D5                  | ;[M65] TO SEE IF IT IS LESS THAN THE RESERVED
504 01D5                  | ;[M65] WORD TOKEN FOR THE LOWEST NUMBERED STATEMENT NAME.
505 01D5                  | ;[M65] IF SO, THE "LET" CODE IS CALLED TO
506 01D5                  | ;[M65] TREAT THE STATEMENT AS AN ASSIGNMENT STATEMENT.
507 01D5                  | ;[M65] OTHERWISE A CHECK IS MADE TO MAKE SURE THE
508 01D5                  | ;[M65] RESERVED WORD NUMBER IS NOT TOO LARGE TO BE A
509 01D5                  | ;[M65] STATEMENT TYPE NUMBER. IF NOT THE ADDRESS
510 01D5                  | ;[M65] TO DISPATCH TO IS FETCHED FROM "STMDSP" (THE STATEMENT
511 01D5                  | ;[M65] DISPATCH LIST) USING THE RESERVED WORD
512 01D5                  | ;[M65] NUMBER FOR THE STATEMENT TO CALCULATE AN INDEX INTO
513 01D5                  | ;[M65] THE LIST.
514 01D5                  | ;
515 01D5              [M65] STMDSP: ;MARKS START OF STATEMENT LIST
516 01D5 : 21 0C                    word    ENDS            ;;$0C21
517 01D7 : BC 05                    word    FOR             ;;$05BC
518 01D9 : 13 0D                    word    NEXT            ;;$0D13
519 01DB : 1C 07                    word    DATA            ;;$071C
520 01DD : 93 08                    word    INPUT           ;;$0893
521 01DF : CC 10                    word    DIM             ;;$10CC
522 01E1 : BE 08                    word    READ            ;;$08BE
523 01E3 : 31 07                    word    LET             ;;$0731
524 01E5 : DC 06                    word    GOTO            ;;$06DC
525 01E7 : BE 06                    word    RUN             ;;$06BE
526 01E9 : 9C 07                    word    IFS             ;;$079C
527 01EB : 05 0C                    word    RESTOR          ;;$0C05
528 01ED : CB 06                    word    GOSUB           ;;$06CB
529 01EF : F8 06                    word    RETURN          ;;$06F8
530 01F1 : 1E 07                    word    REM             ;;$071E
531 01F3 : 1F 0C                    word    STOP            ;;$0C1F
532 01F5 : 80 07                    word    ONGOTO          ;;$0780
533 01F7 : B5 07                    word    LPRINT          ;;$07B5
534 01F9 : 15 1B                    word    COPY            ;;$1B15
535 01FB : 3B 0B                    word    DEF             ;;$0B3B
536 01FD : 6D 0B                    word    POKE            ;;$0B6D
537 01FF : BC 07                    word    PRINT           ;;$07BC
538 0201 : 4B 0C                    word    CONT            ;;$0C4B
539 0203 : 6C 05                    word    LIST            ;;$056C
540 0205 : 67 05                    word    LLIST           ;;$0567
541 0207 : CD 0C                    word    CLEAR           ;;$0CCD
542 0209 : 2c 1C                    word    CLOAD           ;;$1C2C
543 020B : 08 1C                    word    CSAVE           ;;$1C08
544 020D : 4F 1A                    word    PSET            ;;$1A4F
545 020F : 4C 1A                    word    PRESET          ;;$1A4C
546 0211 : D6 1A                    word    SOUND           ;;$1AD6
547 0213 : BD 0B                    word    SCRATH          ;;$0BBD NEW
548 0215 : F5 14      [M80] FUNDSP: word    SGN             ;;$14F5
549 0217 : B1 15                    word    INT             ;;$15B1
550 0219 : 09 15                    word    ABS             ;;$1509
551 021B : 03 38                    word    USRPOK          ;;$3803 USR()
552 021D : A8 10                    word    FRE             ;;$10A8
553 022F : 2E 0B                    word    LPOS            ;;$0B2E
554 0221 : 33 0B                    word    POS             ;;$0B33
555 0223 : 75 17                    word    SQR             ;;$1775
556 0225 : 66 18                    word    RND             ;;$1866
557 0227 : 85 13                    word    LOG             ;;$1385
558 0229 : CD 17                    word    EXP             ;;$17CD
559 022B : D7 18                    word    COS             ;;$18D7
560 022D : DD 18                    word    SIN             ;;$18DD
561 022F : 70 19                    word    TAN             ;;$1970
562 0231 : 85 19                    word    ATN             ;;$1985
563 0233 : 63 0B                    word    PEEK            ;;$0B63
564 0235 : F3 0F                    word    LEN             ;;$0FF3
565 0237 : 29 0E                    word    STR             ;;$0E29
566 0239 : 84 10                    word    VAL             ;;$1084
567 023B : 02 10                    word    ASC             ;;$1002
568 023D : 13 10                    word    CHR             ;;$1013
569 023F : 21 10                    word    LEFT            ;;$1021
570 0241 : 50 10                    word    RIGHT           ;;$1050
571 0243 : 59 10                    word    MID             ;;$1059
572 0245
573 0245                  + ;; Statement Tokens
574 0245                  | ;[M65] TOKENS FOR RESERVED WORDS ALWAYS HAVE THE MOST
575 0245                  | ;[M65] SIGNIFICANT BIT ON.
576 0245                  | ;;;The first (or only) character of each keyword has bit 7 set.
577 0245                  | ;;;In Altair and 6502 Basic, bit 7 was set in the last character
578 0245 :            [M65] RESLST: ;[M65] THE LIST OF RESERVED WORDS:
579 0245 :                  TK      =       $80             ;;Tokens start at $80
580 0245 :            [M65] ENDTK   equ     TK              ;
581 0245 : C5 4E 44                 byte    'E'+$80,"ND"    ;;$80
582 0248 :                  TK      =       TK+1            ;
583 0248 :            [M65] FORTK   equ     TK              ;
584 0248 : C6 4F 52                 byte    'F'+$80,"OR"    ;;$81
585 024B :                  TK      =       TK+1            ;
586 024B : CE 45 58 54              byte    'N'+$80,"EXT"   ;;$82
587 024F :                  TK      =       TK+1            ;
588 024F :            [M65] DATATK  equ     TK              ;
589 024F : C4 41 54 41              byte    'D'+$80,"ATA"   ;;$83
590 0253 :                  TK      =       TK+1            ;
591 0253 :                  INPUTK  equ     TK              ;
592 0253 : C9 4E 50 55              byte    'I'+$80,"NPUT"  ;;$84
593 0257 : 54
594 0258 :                  TK      =       TK+1            ;
595 0258 : C4 49 4D                 byte    'D'+$80,"IM"    ;;$85
596 025B :                  TK      =       TK+1            ;
597 025B : D2 45 41 44              byte    'R'+$80,"EAD"   ;;$86
598 025F :                  TK      =       TK+1            ;
599 025F : CC 45 54                 byte    'L'+$80,"ET"    ;;$87
600 0262 :                  TK      =       TK+1            ;
601 0262 :            [M65] GOTOTK  equ     TK              ;
602 0262 : C7 4F 54 4F              byte    'G'+$80,"OTO"   ;;$88
603 0266 :                  TK      =       TK+1            ;
604 0266 : D2 55 4E                 byte    'R'+$80,"UN"    ;;$89
605 0269 :                  TK      =       TK+1            ;
606 0269 : C9 46                    byte    'I'+$80,"F"     ;;$8A
607 026B :                  TK      =       TK+1            ;
608 026B : D2 45 53 54              byte    'R'+$80,"ESTORE";;$8B
609 026F : 4F 52 45
610 0272 :                  TK      =       TK+1            ;
611 0272 :            [M65] GOSUTK  equ     TK              ;
612 0272 : C7 4F 53 55              byte    'G'+$80,"OSUB"  ;;$8C
613 0276 : 42
614 0277 :                  TK      =       TK+1            ;
615 0277 : D2 45 54 55              byte    'R'+$80,"ETURN" ;;$8D
616 027B : 52 4E                                            ;
617 027D :                  TK      =       TK+1            ;
618 027D :            [M65] REMTK   equ     TK              ;
619 027D : D2 45 4D                 byte    'R'+$80,"EM"    ;;$8E
620 0280 :                  TK      =       TK+1            ;
621 0280 : D3 54 4F 50              byte    'S'+$80,"TOP"   ;;$8F
622 0282 :                  TK      =       TK+1            ;
623 0284 : CF 4E                    byte    'O'+$80,"N"     ;;$90
624 0286 :                  TK      =       TK+1            ;
625 0286 : CC 50 52 49              byte    'L'+$80,"PRINT" ;;$91
626 028A : 4E 54                                            ;
627 028C :                  TK      =       TK+1            ;
628 028C : C3 4F 50 59              byte    'C'+$80,"OPY"   ;;$92
629 0290 :                  TK      =       TK+1            ;
630 0290 : C4 45 46                 byte    'D'+$80,"EF"    ;;$93
631 0293 :                  TK      =       TK+1            ;
632 0293 : D0 4F 4B 45              byte    'P'+$80,"OKE"   ;;$94
633 0297 :                  TK      =       TK+1            ;
634 0297 :            [M65] PRINTK  equ     TK              ;
635 0297 : D0 52 49 4E              byte    'P'+$80,"RINT"  ;;$95
636 029B : 54
637 029C :                  TK      =       TK+1            ;
638 029C : C3 4F 4E 54              byte    'C'+$80,"ONT"   ;;$96
639 02A0 :                  TK      =       TK+1            ;
640 02A0 : CC 49 53 54              byte    'L'+$80,"IST"   ;;$97
641 02A4 :                  TK      =       TK+1            ;
642 02A4 : CC 4C 49 53              byte    'L'+$80,"LIST"  ;;$98
643 02A8 : 54
644 02A9 :                  TK      =       TK+1            ;
645 02A9 : C3 4C 45 41              byte    'C'+$80,"LEAR"  ;;$99
646 02AD : 52
647 02AE :                  TK      =       TK+1            ;
648 02AE : C3 4C 4F 41              byte    'C'+$80,"LOAD"  ;;$9A
649 02B2 : 44
650 02B3 :                  TK      =       TK+1            ;
651 02B3 : C3 53 41 56              byte    'C'+$80,"SAVE"  ;;$9B
652 02B7 : 45
653 02B8 :                  TK      =       TK+1            ;
654 02B8 :                  PSETTK  equ     TK              ;;For Extended BASIC
655 02B8 : D0 53 45 54              byte    'P'+$80,"SET"   ;;$9C
656 02BC :                  TK      =       TK+1            ;
657 02B8 :                  PRESTK  equ     TK              ;;For Extended BASIC
658 02BC : D0 52 45 53              byte    'P'+$80,"RESET" ;;$9D
659 02C0 : 45 54                                            ;
660 02C2 :                  TK      =       TK+1            ;
661 02C2 : D3 4F 55 4E              byte    'S'+$80,"OUND"  ;;$9E
662 02C6 : 44
663 02C7 :                  TK      =       TK+1            ;
664 02C7 :            [M65] SCRATK  equ     TK              ;
665 02C7 : CE 45 57                 byte    'N'+$80,"EW"    ;;$9F
666 02CA :                  TK      =       TK+1            ;
667 02CA :                  ;[M65] END OF COMMAND LIST      ;
668 02CA :                  TABTK   equ     TK              ;
669 02CA : D4 41 42 28              byte    'T'+$80,"AB("   ;;$A0
670 02CE :                  TK      =       TK+1            ;
671 02CE :            [M80] TOTK    equ     TK              ;
672 02CE : D4 4F                    byte    'T'+$80,"O"     ;;$A1
673 02D0 :                  TK      =       TK+1            ;
674 02D0 :            [M80] FNTK    equ     TK              ;
675 02D0 : C6 4E                    byte    'F'+$80,"N"     ;;$A2
676 02D2 :                  TK      =       TK+1            ;
677 02D2 :                  SPCTK   equ     TK              ;
678 02D2 : D3 50 43 28              byte    'S'+$80,"PC("   ;;$A3
679 02D6 :                  TK      =       TK+1            ;
680 02D6 :                  INKETK  equ     TK              ;
681 02D6 : C9 4E 4B 45              byte    'I'+$80,"NKEY$" ;;$A4
682 02DA : 59 24
683 02DC :                  TK      =       TK+1            ;
684 02DC :            [M65] THENTK  equ     TK              ;
685 02DC : D4 48 45 4E              byte    'T'+$80,"HEN"   ;;$A5
686 02E0 :                  TK      =       TK+1            ;
687 02E0 :            [M80] NOTTK   equ     TK              ;
688 02E0 : CE 4F 54                 byte    'N'+$80,"OT"    ;;$A6
689 02E3 :                  TK      =       TK+1            ;
690 02E3 :            [M65] STEPTK  equ     TK              ;
691 02E3 : D3 54 45 50              byte    'S'+$80,"TEP"   ;;$A7
692 02E7 :                  TK      =       TK+1            ;
693 02E7
694 02E7 :                  ;;Operators
695 02E7 :            [M80] PLUSTK  equ     TK              ;
696 02E7 : AB                       byte    '+'+$80         ;;$A8 plus
697 02E8 :                  TK      =       TK+1            ;
698 02E8 :            [M80] MINUTK  equ     TK              ;
699 02E8 : AD                       byte    '-'+$80         ;;$A9 minus
700 02E9 :                  TK      =       TK+1            ;
701 02E9 :            [M80] MULTK   equ     TK              ;
702 02E9 : AA                       byte    '*'+$80         ;;$AA times
703 02EA :                  TK      =       TK+1            ;
704 02EA :            [M80] DIVTK   equ     TK              ;
705 02EA : AF                       byte    '/'+$80         ;;$AB divide
706 02EB :                  TK      =       TK+1            ;
707 02EB :            [M80] EXPTK   equ     TK              ;
708 02EB : DE                       byte    '^'+$80         ;;$AC
709 02EC :                  TK      =       TK+1            ;
710 02EC :                  ANDTK   equ     TK              ;;For Extended BASIC
711 02EC : C1 4E 44                 byte    'A'+$80,"ND"    ;;$AD
712 02EF :                  TK      =       TK+1            ;
713 02EF :                  ORTK    equ     TK              ;;For Extended BASIC
714 02EF : CF 52                    byte    'O'+$80,"R"     ;;$AE
715 02F1 :                  TK      =       TK+1            ;
716 02F1 :            [M80] GREATK  equ     TK              ;
717 02F1 : BE                       byte    '>'+$80         ;;$BE greater than
718 02F2 :                  TK      =       TK+1            ;
719 02F2 :            [M80] EQUATK  equ     TK              ;
720 02F2 : BD                       byte    '='+$80         ;;$BD equals
721 02F3 :                  TK      =       TK+1            ;
722 02F3 :            [M80] LESSTK  equ     TK              ;
723 02F3 : BC                       byte    '<'+$80         ;;$BC less than
724 02F3 :                  TK      =       TK+1            ;
725 02F4
726 02F4 :                + ;;Functions
727 02F4 :                | ;[M65] NOTE DANGER OF ONE RESERVED WORD BEING A PART
728 02F4 :                | ;[M65] OF ANOTHER:
729 02F4 :                | ;[M65] IE . . IF 2 GREATER THAN F OR T=5 THEN...
730 02F4 :                | ;[M65] WILL NOT WORK!!! SINCE "FOR" WILL BE CRUNCHED!!
731 02F4 :                | ;[M65] IN ANY CASE MAKE SURE THE SMALLER WORD APPEARS
732 02F4 :                | ;[M65] SECOND IN THE RESERVED WORD TABLE ("INP" AND "INPUT")
733 02F4 :                | ;[M65] ANOTHER EXAMPLE: IF T OR Q THEN ... "TO" IS CRUNCHED
734 02F4 :            [M65] ONEFUN  equ     TK              ;;*** This might go after SGN
735 02F4 : D3 47 4E                 byte    'S'+$80,"GN"    ;;$B2
736 02F7                    TK      =       TK+1            ;
737 02F7 : C9 4E 54                 byte    'I'+$80,"NT"    ;;$B3
738 02FA                    TK      =       TK+1            ;
739 02FA : C1 42 53                 byte    'A'+$80,"BS"    ;;$B4
740 02FD                    TK      =       TK+1            ;
741 02FD : D5 53 52                 byte    'U'+$80,"SR"    ;;$B5
742 0300                    TK      =       TK+1            ;
743 0300 : C6 52 45                 byte    'F'+$80,"RE"    ;;$B6
744 0303                    TK      =       TK+1            ;
745 0303 : CC 50 4F 53              byte    'L'+$80,"POS"   ;;$B7
746 0307                    TK      =       TK+1            ;
747 0307 : D0 4F 53                 byte    'P'+$80,"OS"    ;;$B8
748 030A                    TK      =       TK+1            ;
749 030A : D3 51 52                 byte    'S'+$80,"QR"    ;;$B9
750 030D                    TK      =       TK+1            ;
751 030D : D2 4E 44                 byte    'R'+$80,"ND"    ;;$BA
752 0310                    TK      =       TK+1            ;
753 0310 : CC 4F 47                 byte    'L'+$80,"OG"    ;;$BB
754 0313                    TK      =       TK+1            ;
755 0313 : C5 58 50                 byte    'E'+$80,"XP"    ;;$BC
756 0316                    TK      =       TK+1            ;
757 0316 : C3 4F 53                 byte    'C'+$80,"OS"    ;;$BD
758 0319                    TK      =       TK+1            ;
759 0319 : D3 49 4E                 byte    'S'+$80,"IN"    ;;$BE
760 031C                    TK      =       TK+1            ;
761 031C : D4 41 4E                 byte    'T'+$80,"AN"    ;;$BF
762 031F                    TK      =       TK+1            ;
763 031F : C1 54 4E                 byte    'A'+$80,"TN"    ;;$C0
764 0322                    TK      =       TK+1            ;
765 0322 : D0 45 45 4B              byte    'P'+$80,"EEK"   ;;$C1
766 0326                    TK      =       TK+1            ;
767 0326 : CC 45 4E                 byte    'L'+$80,"EN"    ;;$C2
768 0329                    TK      =       TK+1
769 0329 : D3 54 52 24              byte    'S'+$80,"TR$"   ;;$C3
770 032D                    TK      =       TK+1            ;
771 032D : D6 41 4C                 byte    'V'+$80,"AL"    ;;$C4
772 0330                    TK      =       TK+1            ;
773 0330 : C1 53 43                 byte    'A'+$80,"SC"    ;;$C5
774 0333                    TK      =       TK+1            ;
775 0333                    CHRTK   equ     TK
776 0333 : C3 48 52 24              byte    'C'+$80,"HR$"   ;;$C6
777 0337                    TK      =       TK+1            ;
778 0337 : CC 45 46 54              byte    'L'+$80,"EFT$"  ;;$C7
779 033B : 24
780 033C                    TK      =       TK+1            ;
781 033C : D2 49 47 48              byte    'R'+$80,"IGHT$" ;;$C8
782 0340 : 54 24
783 0342                    TK      =       TK+1            ;
784 0342 : CD 49 44 24              byte    'M'+$80,"ID$"   ;;$C9
785 0346                    TK      =       TK+1            ;
786 0346                    POINTK  equ     TK
787 0346 : D0 4F 49 4E              byte    'P'+$80,"OINT"  ;;$CA
788 034A : 54
789 034B
790 ;;The token crunching routine stops here, but the token expansion routine does not
791 ;;so any 'tokens' above $CA will produce strange results when LISTed
792 034B : 80                       byte    $80             ;;End of List Marker
793 034C
794 034C                    ;OPERATOR TABLE CONTAINS PRECEDENCE FOLLOWED BY THE ROUTINE ADDRESS
795 034C : 79         [M80] OPTAB:  byte    121             ;ADD
796 034D : 5C 16                    word    FADDT           ;
797 034F : 79                       byte    121             ;SUBTRACT
798 0350 : 5C 12                    word    FSUBT           ;
799 0352 : 7C                       byte    124             ;MULTIPLY
800 0353 : C9 13                    word    FMULTT          ;
801 0355 : 7C                       byte    124             ;DIVIDE
802 0356 : 2D 14                    word    FDIVT           ;
803 0358 : 7F                       byte    127             ;POWER
804 0359 : 7E 17                    word    FPWRT           ;
805 035B : 50                       byte    80              ;AND
806 035C : A9 0A                    word    ANDOP           ;
807 035E : 46                       byte    70              ;OR
808 035F : A8 0A                    word    OROP            ;
809 0361
810 0361                    ;{M80} NEEDED FOR MESSAGES
811 0361
812 0361 : 20 45 72 72[M65] ERR:    byte    " Error",7,0
813 0365 : 6F 72 07 00
814 0369
815 0369 : 20 69 6E 20[M65] INTXT:  byte    " in ",0
816 036C : 00
817 036E
818 036E : 4F 6B 0D 0A[M80] REDDY:  byte    "Ok",13,10,0    ;;FINZER relies on REDDY-1 being a 0!
819 0372 : 00
820 0373
821 0373 : 42 72 65 61[M80] BRKTXT: byte    "Break",0
822 0377 : 6B 00
823 0379
824 0379                  + ; [M65] ERROR MESSAGES
825 0379                  | ; [M65] WHEN AN ERROR CONDITION IS DETECTED,
826 0379                  | ; [M65] [ACCX] MUST BE SET UP TO INDICATE WHICH ERROR
827 0379                  | ; [M65] MESSAGE IS APPROPRIATE AND A BRANCH MUST BE MADE
828 0379                  | ; [M65] TO "ERROR". THE STACK WILL BE RESET AND ALL
829 0379                  | ; [M65] PROGRAM CONTEXT WILL BE LOST. VARIABLES
830 0379                  | ; [M65] VALUES AND THE ACTUAL PROGRAM REMAIN INTACT.
831 0379                  | ; [M65] ONLY THE VALUE OF [ACCX] IS IMPORTANT WHEN
832 0379                  | ; [M65] THE BRANCH IS MADE TO ERROR. [ACCX] IS USED AS AN
833 0379                  | ; [M65] INDEX INTO "ERRTAB" WHICH GIVES THE TWO
834 0379                  | ; [M65] CHARACTER ERROR MESSAGE THAT WILL BE PRINTED ON THE
835 0379                  | ; [M65] USER'S TERMINAL.
836 0379                  | ;
837 0379 :            [M80] ERRTAB: ;;List OF Error Messages
838 0379 :            [M80] ERRNF   equ     *-ERRTAB        ;;$00
839 0379 : 4E 46                    byte    "NF"            ;[M80] NEXT without FOR
840 037B :            [M80] ERRSN   equ     *-ERRTAB        ;;$02
841 037B : 53 4E                    byte    "SN"            ;[M80] Syntax error
842 037D :            [M80] ERRRG   equ     *-ERRTAB        ;;$04
843 037D : 52 47                    byte    "RG"            ;[M80] RETURN without GOSUB
844 037F :            [M80] ERROD   equ     *-ERRTAB        ;;$06
845 037F : 4F 44                    byte    "OD"            ;[M80] Out of DATA
846 0381 :            [M80] ERRFC   equ     *-ERRTAB        ;;$08
847 0381 : 46 43                    byte    "FC"            ;[M80] Illegal function call
848 0383 :            [M80] ERROV   equ     *-ERRTAB        ;;$0A
849 0383 : 4F 56                    byte    "OV"            ;[M80] Overflow
850 0385 :            [M80] ERROM   equ     *-ERRTAB        ;;$0C
851 0385 : 4F 4D                    byte    "OM"            ;[M80] Out of memory
852 0387 :            [M80] ERRUS   equ     *-ERRTAB        ;;$0E
853 0387 : 55 4C                    byte    "UL"            ;[M80] Undefined line number
854 0389              [M80] ERRBS   equ     *-ERRTAB        ;;$10
855 0389 : 42 53                    byte    "BS"            ;[M80] Subscript out of range
856 038B              [M80] ERRDDS  equ     *-ERRTAB        ;;$12
857 038B : 44 44                    byte    "DD"            ;[M80] Duplicate Definition
858 038D              [M80] ERRDV0  equ     *-ERRTAB        ;;$14
859 038D : 2F 30                    byte    "/0"            ;[M80] Division by zero
860 038F              [M80] ERRID   equ     *-ERRTAB        ;;$16
861 038F : 49 44                    byte    "ID"            ;[M80] Illegal direct
862 0391              [M80] ERRTM   equ     *-ERRTAB        ;;$18
863 0391 : 54 4D                    byte    "TM"            ;[M80] Type mismatch
864 0393              [M80] ERRSO   equ     *-ERRTAB        ;;$1A
865 0393 : 4F 53                    byte    "OS"            ;[M80] Out of string space
866 0395              [M80] ERRLS   equ     *-ERRTAB        ;;$1C
867 0395 : 4C 53                    byte    "LS"            ;[M80] String too long
868 0397              [M80] ERRST   equ     *-ERRTAB        ;;$1E
869 0397 : 53 54                    byte    "ST"            ;[M80] String formula too complex
870 0399              [M80] ERRCN   equ     *-ERRTAB        ;;$20
871 0399 : 43 4E                    byte    "CN"            ;[M80] Can't continue
872 039B              [M80] ERRUF   equ     *-ERRTAB        ;;$22
873 039B : 55 46                    byte    "UF"            ;[M80] Undefined user function
874 039D              [M80] ERRMO   equ     *-ERRTAB        ;;$24
875 039D : 4D 4F                    byte    "MO"            ;[M80] Missing operand
876 039F
877 039F                  + ;[M80] FIND A "FOR" ENTRY ON THE STACK WITH THE VARIABLE POINTER PASSED IN [D,E]
878 039F                  | ;[M65] MOST SMALL ROUTINES ARE FAIRLY SIMPLE
879 039F                  | ;[M65] AND ARE DOCUMENTED IN PLACE. "FNDFOR" IS
880 039F                  | ;[M65] USED FOR FINDING "FOR" ENTRIES ON
881 039F                  | ;[M65] THE STACK. WHENEVER A "FOR" IS EXECUTED, A
882 039F                  | ;[M65] 16-BYTE ENTRY IS PUSHED ONTO THE STACK.
883 039F                  | ;[M65] BEFORE THIS IS DONE, HOWEVER, A CHECK
884 039F                  | ;[M65] MUST BE MADE TO SEE IF THERE
885 039F                  | ;[M65] ARE ANY "FOR" ENTRIES ALREADY ON THE STACK
886 039F                  | ;[M65] FOR THE SAME LOOP VARIABLE. IF SO, THAT "FOR" ENTRY
887 039F                  | ;[M65] AND ALL OTHER "FOR" ENTRIES THAT WERE MADE AFTER IT
888 039F                  | ;[M65] ARE ELIMINATED FROM THE STACK. THIS IS SO A
889 039F                  | ;[M65] PROGRAM THAT JUMPS OUT OF THE MIDDLE
890 039F                  | ;[M65] OF A "FOR" LOOP AND THEN RESTARTS THE LOOP AGAIN
891 039F                  | ;[M65] AND AGAIN WON'T USE UP 18 BYTES OF STACK
892 039F                  | ;[M65] SPACE EVERY TIME. THE "NEXT" CODE ALSO
893 039F                  | ;[M65] CALLS "FNDFOR" TO SEARCH FOR A "FOR" ENTRY WITH
894 039F                  | ;[M65] THE LOOP VARIABLE IN
895 039F                  | ;[M65] THE "NEXT". AT WHATEVER POINT A MATCH IS FOUND
896 039F                  | ;[M65] THE STACK IS RESET. IF NO MATCH IS FOUND A
897 039F                  | ;[M65] "NEXT WITHOUT FOR"  ERROR OCCURS. GOSUB EXECUTION
898 039F                  | ;[M65] ALSO PUTS A 5-BYTE ENTRY ON STACK.
899 039F                  | ;[M65] WHEN A RETURN IS EXECUTED "FNDFOR" IS
900 039F                  | ;[M65] CALLED WITH A VARIABLE POINTER THAT CAN'T
901 039F                  | ;[M65] BE MATCHED. WHEN "FNDFOR" HAS RUN
902 039F                  | ;[M65] THROUGH ALL THE "FOR" ENTRIES ON THE STACK
903 039F                  | ;[M65] IT RETURNS AND THE RETURN CODE MAKES
904 039F                  | ;[M65] SURE THE ENTRY THAT WAS STOPPED
905 039F                  | ;[M65] ON IS A GOSUB ENTRY. THIS ASSURES THAT
906 039F                  | ;[M65] IF YOU GOSUB TO A SECTION OF CODE
907 039F                  | ;[M65] IN WHICH A FOR LOOP IS ENTERED BUT NEVER
908 039F                  | ;[M65] EXITED THE RETURN WILL STILL BE
909 039F                  | ;[M65] ABLE TO FIND THE MOST RECENT
910 039F                  | ;[M65] GOSUB ENTRY. THE "RETURN" CODE ELIMINATES THE
911 039F                  | ;[M65] "GOSUB" ENTRY AND ALL "FOR" ENTRIES MADE AFTER
912 039F                  | ;[M65] THE GOSUB ENTRY.
913 039F                  | ;
914 039F :            [M80] FORSIZ  equ     13              ;;Size of a FOR entry on the stack
915 039F
916 039F : 21 04 00   [M80] FNDFOR: ld      hl,4+0          ;[M80] IGNORING THE RETURN ADDRESS OF
917 03A2 : 39                       add     hl,sp           ;[M80] THIS SUBROUTINE, SET [H,L]=SP
918 03A3 : 7E         [M80] LOOPER: ld      a,(hl)          ;[M80] SEE WHAT TYPE OF THING IS ON THE STACK
919 03A4 : 23                       inc     hl              ;
920 03A5 : FE 81                    cp      FORTK           ;[M80] IS THIS STACK ENTRY A "FOR"?
921 03A7 : C0                       ret     nz              ;[M80] NO SO OK
922 03A8 : 4E                       ld      c,(hl)          ;[M80] DO EQUIVALENT OF PUSHM / XTHL
923 03A9 : 23                       inc     hl              ;
924 03AA : 46                       ld      b,(hl)          ;
925 03AB : 23                       inc     hl              ;
926 03AC : E5                       push    hl              ;[M80] PUT H  ON
927 03AD : 60                       ld      h,b             ;[M80] PUSH B / XTHL IS SLOWER
928 03AE : 69                       ld      l,c             ;
929 03AF : 7A                       ld      a,d             ;[M80] FOR THE "NEXT" STATMENT WITHOUT AN ARGUMENT
930 03B0 : B3                       or      e               ;[M80] WE MATCH ON ANYTHING
931 03B1 : EB                       ex      de,hl           ;[M80] MAKE SURE WE RETURN [D,E]
932 03B2 : 28 02                    jr      z,POPGOF        ;[M80] POINTING TO THE VARIABLE
933 03B4 : EB                       ex      de,hl           ;
934 03B5 : E7                       rst     COMPAR          ;
935 03B6 : 01 0D 00   [M80] POPGOF: ld      bc,FORSIZ       ;[M80] TO WIPE OUT A "FOR" ENTRY
936 03B9 : E1                       pop     hl              ;[M80] IF VARIABLE IN THIS ENTRY MATCHES RETURN
937 03BA : C8                       ret     z               ;[M80] WITH [H,L] POINTING THE BOTTOM ;OF THE ENTRY
938 03BB : 09                       add     hl,bc           ;[M80] NOW POINTING TO THE START OF THE NEXT ENTRY.
939 03BC : 18 E5                    jr      LOOPER          ;[M80] SEE IF ITS A "FOR" ENTRY AND IF THE VARIABLE MATCHES
940 03BE
941 03BE : 2A C9 38   [M80] DATSNE: ld      hl,(DATLIN)     ;[M80] GET DATA LINE
942 03C1 : 22 4D 38                 ld      (CURLIN),hl     ;[M80] MAKE IT CURRENT LINE
943 03C4 : 1E 02      [M80] SNERR:  ld      e,ERRSN         ;[M80] "SYNTAX ERROR"
944 03C6 : 01                       byte    $01             ;[M80] "LD BC," OVER THE NEXT 2
945 03C7 : 1E 14      [M80] DV0ERR: ld      e,ERRDV0        ;[M80] DIVISION BY ZERO
946 03C9 : 01                       byte    $01             ;[M80] "LD BC," OVER THE NEXT 2
947 03CA : 1E 00      [M80] NFERR:  ld      e,ERRNF         ;[M80] "NEXT WITHOUT FOR" ERROR
948 03CC : 01                       byte    $01             ;[M80] "LD BC," OVER THE NEXT 2
949 03CD : 1E 12      [M80] DDERR:  ld      e,ERRDDS        ;[M80] "REDIMENSIONED VARIABLE"
950 03CF : 01                       byte    $01             ;[M80] "LD BC," OVER THE NEXT 2
951 03D0 : 1E 22      [M80] UFERR:  ld      e,ERRUF         ;[M80] "UNDEFINED FUNCTION" ERROR
952 03D2 : 01                       byte    $01             ;[M80] "LD BC," OVER THE NEXT 2
953 03D3 : 1E 0A      [M80] OVERR:  ld      e,ERROV         ;;      Overflow Error
954 03D5 : 01                       byte    $01             ;[M80] "LD BC," OVER THE NEXT 2
955 03D6 : 1E 24      [M80] MOERR:  ld      e,ERRMO         ;;     Missing Operand
956 03D8 : 01                       byte    $01             ;[M80] "LD BC," OVER THE NEXT 2
957 03D9 : 1E 18      [M80] TMERR:  ld      e,ERRTM         ;[M80] TYPE MISMATCH ERROR
958 03DB
959 03DB : CD E5 0B   [M80] ERROR:  call    STKINI          ;
960 03DE : F7                       rst     HOOKDO          ;;call Hook Service Routine
961 03DF : 00         {~~~} HOOK0:  byte    0               ;
962 03E0 : CD DE 19   (M65) ERRCRD: call    CRDONZ          ;
963 03E3 : 21 79 03                 ld      hl,ERRTAB       ;
964 03E6 : F7                       rst     HOOKDO          ;;call Hook Service Routine
965 03E7 : 01         {~~~} HOOK1:  byte    1               ;
966 03E8 : 57                       ld      d,a             ;;Add Error Offset
967 03E9 : 19                       add     hl,de           ;
968 03EA : 3E 3F                    ld      a,'?'           ;[M65] PRINT A QUESTION MARK
969 03EC : DF                       rst     OUTCHR          ;
970 03ED : 7E         (M80) ERRFIN: ld      a,(hl)          ;[M65] GET FIRST CHR OF ERR MSG.
971 03EE : DF                       rst     OUTCHR          ;[M65] OUTPUT IT.
972 03EF : D7                       rst     CHRGET          ;[M65] GET SECOND CHR.
973 03F0 : DF                       rst     OUTCHR          ;[M65] OUTPUT IT.
974 03F1 : 21 61 03                 ld      hl,ERR          ;;" Error"
975 03F4 : CD 9D 0E   [M80] ERRFN1: call    STROUT          ;[M80] PRINT MESSAGE
976 03F7 : 2A 4D 38                 ld      hl,(CURLIN)     ;[M80] RESTORE LINE NUMBER
977 03FA : 7C                       ld      a,h             ;[M80] SEE IF IN DIRECT MODE
978 03FB : A5                       and     l               ;
979 03FC : 3C                       inc     a               ;[M80] ZERO SAYS DIRECT MODE
980 03FD : C4 6D 16                 call    nz,INPRT        ;[M80] PRINT LINE NUMBER IN [H,L]
981 0400 : 3E                       byte    $3E             ;[M80] SKIP THE NEXT BYTE WITH "MVI A,0"
982 0401
983 0401                  - ;[M80] FOR "LIST" COMMAND STOPPING
984 0401 : C1         [M80] STPRDY: pop     bc
985 0402
986 0402 : F7         [M80] READY:  rst     HOOKDO          ;;Call hook routine
987 0403 : 02         {~~~} HOOK2:  byte    2               ;
988 0404 : CD BE 19                 call    FINLPT          ;[M80] PRINT ANY LEFT OVERS
989 0407 : AF                       xor     a               ;
990 0408 : 32 08 38                 ld      (CNTOFL),a      ;[M80] FORCE OUTPUT
991 040B : CD DE 19                 call    CRDONZ          ;[M80] IF NOT ALREADY AT LEFT, SEND CRLF
992 040E : 21 6E 03                 ld      hl,REDDY        ;[M80] "OK" CRLF CRLF
993 0411 : CD 9D 0E                 call    STROUT          ;
994 0414                                                        ;
995 0414 : 21 FF FF   [M80] MAIN:   ld      hl,$FFFF        ;
996 0417 : 22 4D 38                 ld      (CURLIN),hl     ;[M80] SETUP CURLIN FOR DIRECT MODE
997 ;;;GW-BASIC and CP/M Basic have Automatic Line Numbering Logic here
998 041A : CD 85 0D   {M80} NTAUTO: call    INLIN           ;[M80] GET A LINE FROM TTY
999 041D : 38 F5                    jr      c,MAIN          ;[M80] IGNORE ^C S
1000 041F : D7                       rst     CHRGET          ;[M80] GET THE FIRST
1001 0420 : 3C                       inc     a               ;[M80] SEE IF 0 SAVING THE CARRY FLAG
1002 0421 : 3D                       dec     a               ;
1003 0422 : 28 F0                    jr      z,MAIN          ;[M80] IF SO, A BLANK LINE WAS INPUT
1004 0424 : F5                       push    af              ;[M80] SAVE STATUS INDICATOR FOR 1ST CHARACTER
1005 0425 : CD 9C 06   {M65} MAIN1:  call    SCNLIN          ;[M80] READ IN A LINE #
1006 ;;;GW-BASIC snd CP/M Basic have extra logic here         ;
1007 0428 : D5         [M80] EDENT:  push    de              ;[M80] SAVE LINE #
1008 0429 : CD BC 04                 call    CRUNCH          ;[M80] CRUNCH THE LINE DOWN
1009 042C : 47                       ld      b,a             ;[M65] RETAIN CHARACTER COUNT.
1010 042D : D1                       pop     de              ;[M80] RESTORE LINE #
1011 042E : F1                       pop     af              ;[M80] WAS THERE A LINE #?
1012 042F : F7                       rst     HOOKDO          ;;Call Hook Dispatch Routine
1013 0430 : 03         {~~~} HOOK3:  byte    3               ;
1014 0431 : D2 4B 06                 jp      nc,GONE         ;
1015 0434 : D5                       push    de              ;
1016 0435 : C5                       push    bc              ;[M80] SAVE LINE # AND CHARACTER COUNT
1017 0436 : AF                       xor     a               ;
1018 0437 : 32 CC 38                 ld      (USFLG),a       ;{M80} RESET THE FLAG
1019 043A : D7                       rst     CHRGET          ;[M80] REMEMBER IF THIS LINE IS
1020 043B : B7                       or      a               ;[M80] SET THE ZERO FLAG ON ZERO
1021 043C : F5                       push    af              ;[M80] BLANK SO WE DON'T INSERT IT
1022 043D : CD 9F 04                 call    FNDLIN          ;[M80] GET A POINTER TO THE LINE
1023 0440 : 38 06                    jr      c,LEXIST        ;[M80] LINE EXISTS, DELETE IT
1024 0442 : F1                       pop     af              ;[M80] GET FLAG SAYS WHETHER LINE BLANK
1025 0443 : F5                       push    af              ;[M80] SAVE BACK
1026 0444 : CA F3 06                 jp      z,USERR         ;[M80] SAVE BACK
1027 0447 : B7                       or      a               ;[M80] TRYING TO DELETE NON-EXISTANT LINE, ERROR
1028 0448 : C5         (M80) LEXIST: push    bc              ;[M80] SAVE THE POINTER
1029 0449 : 30 10                    jr      nc,NODEL        ;
1030 0FFB                    ;[M80] DELETE THE LINE
1031 044B : EB         {M80} DEL:    ex      de,hl           ;[M80] [D,E] NOW HAVE THE POINTER TO NEXT LINE
1032 044C : 2A D6 38                 ld      hl,(VARTAB)     ;[M80] COMPACTIFYING TO VARTAB
1033 044F : 1A         (M80) MLOOP:  ld      a,(de)          ;
1034 0450 : 02                       ld      (bc),a          ;[M80] SHOVING DOWN TO ELIMINATE A LINE
1035 0451 : 03                       inc     bc              ;
1036 0452 : 13                       inc     de              ;
1037 0453 : E7                       rst     COMPAR          ;
1038 0454 : 20 F9                    jr      nz,MLOOP        ;[M80] DONE COMPACTIFYING?
1039 0456 : 60                       ld      h,b             ;
1040 0457 : 69                       ld      l,c             ;;HL = new end of program
1041 0458 : 22 D6 38                 ld      (VARTAB),hl     ;[M65] SETUP [VARTAB]
1042 045B : D1         (M80) NODEL:  pop     de              ;[M80] POP POINTER AT PLACE TO INSERT
1043 045C : F1                       pop     af              ;[M80] SEE IF THIS LINE HAD ANYTHING ON IT
1044 045D : 28 21                    jr      z,FINI          ;[M80] IF NOT DON'T INSERT
1045 045F : 2A D6 38   (M80) LEVFRE: ld      hl,(VARTAB)     ;[M80] CURRENT END
1046 0462 : E3                       ex      (sp),hl         ;[M80] [H,L]=CHARACTER COUNT. VARTAB ONTO STACK
1047 0463 : C1                       pop     bc              ;[M80] [B,C]=OLD VARTAB
1048 0464 : 09                       add     hl,bc           ;
1049 0465 : E5                       push    hl              ;[M80] SAVE NEW VARTAB
1050 0466 : CD 92 0B                 call    BLTU            ;;Create space for new line
1051 0469 : E1                       pop     hl              ;[M80] POP OFF VARTAB
1052 046A : 22 D6 38                 ld      (VARTAB),hl     ;[M80] UPDATE VARTAB
1053 046D : EB                       ex      de,hl           ;
1054 046E : 74                       ld      (hl),h          ;[M80] FOOL CHEAD WITH NON-ZERO LINK
1055 046F : D1                       pop     de              ;[M80] GET LINE # OFF STACK
1056 0470 : 23                       inc     hl              ;[M80] SO IT DOESN'T THINK THIS LINK
1057 0471 : 23                       inc     hl              ;[M80] IS THE END OF THE PROGRAM
1058 0472 : 73                       ld      (hl),e          ;
1059 0473 : 23                       inc     hl              ;[M80] PUT DOWN LINE #
1060 0474 : 72                       ld      (hl),d          ;
1061 0475 : 23                       inc     hl              ;
1062 0476 : 11 60 38                 ld      de,BUF          ;[M80] MOVE LINE FRM BUF TO PROGRAM AREA
1063 0479 : 1A         (M80) MLOOPR: ld      a,(de)          ;[M80] NOW TRANSFERING LINE IN FROM BUF
1064 047A : 77                       ld      (hl),a          ;
1065 047B : 23                       inc     hl              ;
1066 047C : 13                       inc     de              ;
1067 047D : B7                       or      a               ;;If not line terminator, keep going
1068 047E : 20 F9                    jr      nz,MLOOPR       ;
1069 0480
1070 0480 : F7         [M80] FINI:   rst     HOOKDO          ;
1071 0481 : 04         {~~~} HOOK4:  byte    4               ;
1072 0482 : CD CB 0B                 call    RUNC            ;[M80] DO CLEAR & SET UP STACK
1073 0485 : F7                       rst     HOOKDO          ;
1074 0486 : 05         {~~~} HOOK5:  byte    5               ;
1075 0487 : 23                       inc     hl              ;;HL=TXTTAB
1076 0488 : EB         {M80} LINKER: ex      de,hl           ;;DE=TXTTAB
1077 0489
1078 0489                  + ;;Fix Basic Line Links
1079 0489                  | ;[M80] CHEAD GOES THROUGH PROGRAM STORAGE AND FIXES
1080 0489                  | ;[M80] UP ALL THE LINKS. THE END OF EACH
1081 0489                  | ;[M80] LINE IS FOUND BY SEARCHING FOR THE ZERO AT THE END.
1082 0489                  | ;[M80] THE DOUBLE ZERO LINK IS USED TO DETECT THE END OF THE PROGRAM
1083 0489                  | ;
1084 0489 : 62         [M80] CHEAD:  ld      h,d             ;[H,L]=[D,E]
1085 048A : 6B                       ld      l,e             ;
1086 048B : 7E                       ld      a,(hl)          ;[M80] SEE IF END OF CHAIN
1087 048C : 23                       inc     hl              ;[M80] BUMP POINTER
1088 048D : B6                       or      (hl)            ;[M80] 2ND BYTE
1089 048E : CA 14 04                 jp      z,MAIN          ;
1090 0491 : 23                       inc     hl              ;[M80] FIX HL TO START OF TEXT
1091 0492 : 23                       inc     hl              ;
1092 0493 : 23                       inc     hl              ;
1093 0494 : AF                       xor     a               ;SET CC'S
1094 0495 : BE         (M80) CZLOOP: cp      (hl)            ;;Skip to end of Basic line
1095 0496 : 23                       inc     hl              ;
1096 0497 : 20 FC                    jr      nz,CZLOOP       ;
1097 0499 : EB                       ex      de,hl           ;SWITCH TEMP
1098 049A : 73                       ld      (hl),e          ;DO FIRST BYTE OF FIXUP
1099 049B : 23                       inc     hl              ;ADVANCE POINTER
1100 049C : 72                       ld      (hl),d          ;2ND BYTE OF FIXUP
1101 049D : 18 EA                    jr      CHEAD           ;KEEP CHAINING TIL DONE
1102 049F
1103 049F                  + ;;Find Basic Line
1104 049F                  | ;[M80] FNDLIN SEARCHES THE PROGRAM TEXT FOR THE LINE
1105 049F                  | ;[M80] WHOSE LINE # IS PASSED IN [D,E]. [D,E] IS PRESERVED.
1106 049F                  | ;[M80] THERE ARE THREE POSSIBLE RETURNS:
1107 049F                  | ;[M80]
1108 049F                  | ;[M80]  1) ZERO FLAG SET. CARRY NOT SET.  LINE NOT FOUND.
1109 049F                  | ;[M80]     NO LINE IN PROGRAM GREATER THAN ONE SOUGHT.
1110 049F                  | ;[M80]     [B,C] POINTS TO TWO ZERO BYTES AT END OF PROGRAM.
1111 049F                  | ;[M80]     [H,L]=[B,C]
1112 049F                  | ;[M80]
1113 049F                  | ;[M80]  2) ZERO, CARRY SET.
1114 049F                  | ;[M80]     [B,C] POINTS TO THE LINK FIELD IN THE LINE
1115 049F                  | ;[M80]     WHICH IS THE LINE SEARCHED FOR.
1116 049F                  | ;[M80]     [H,L] POINTS TO THE LINK FIELD IN THE NEXT LINE.
1117 049F                  | ;[M80]
1118 049F                  | ;[M80]  3) NON-ZERO, CARRY NOT SET.
1119 049F                  | ;[M80]     LINE NOT FOUND, [B,C]  POINTS TO LINE IN PROGRAM
1120 049F                  | ;[M80]     GREATER THAN ONE SEARCHED FOR.
1121 049F                  | ;[M80]     [H,L] POINTS TO THE LINK FIELD IN THE NEXT LINE.
1122 049F : 2A 4F 38         FNDLIN: ld      hl,(TXTTAB)     ;[M80] GET POINTER TO START OF TEXT
1123 04A2 : 44               LOOP:   ld      b,h             ;[M80] IF EXITING BECAUSE OF END OF PROGRAM,
1124 04A3 : 4D                       ld      c,l             ;[M80] SET [B,C] TO POINT TO DOUBLE ZEROES.
1125 04A4 : 7E                       ld      a,(hl)          ;[M80] GET WORD POINTER TO
1126 04A5 : 23                       inc     hl              ;[M80] BUMP POINTER
1127 04A6 : B6                       or      (hl)            ;[M80] GET 2ND BYTE
1128 04A7 : 2B                       dec     hl              ;[M80] GO BACK
1129 04A8 : C8                       ret     z               ;[M80] IF ZERO THEN DONE
1130 04A9 : 23                       inc     hl              ;[M80] SKIP PAST AND GET THE LINE #
1131 04AA : 23                       inc     hl              ;
1132 04AB : 7E                       ld      a,(hl)          ;[M80] INTO [H,L] FOR COMPARISON WITH
1133 04AC : 23                       inc     hl              ;[M80] THE LINE # BEING SEARCHED FOR
1134 04AD : 66                       ld      h,(hl)          ;[M80] WHICH IS IN [D,E]
1135 04AE : 6F                       ld      l,a             ;
1136 04AF : E7                       rst     COMPAR          ;[M80] SEE IF IT MATCHES OR IF WE'VE GONE TOO FAR
1137 04B0 : 60                       ld      h,b             ;[M80] MAKE [H,L] POINT TO THE START OF THE
1138 04B1 : 69                       ld      l,c             ;[M80] LINE BEYOND THIS ONE, BY PICKING
1139 04B2 : 7E                       ld      a,(hl)          ;[M80] UP THE LINK THAT [B,C] POINTS AT
1140 04B3 : 23                       inc     hl              ;
1141 04B4 : 66                       ld      h,(hl)          ;
1142 04B5 : 6F                       ld      l,a             ;
1143 04B6 : 3F                       ccf                     ;[M80] TURN CARRY OFF
1144 04B7 : C8                       ret     z               ;[M80] EQUAL RETURN
1145 04B8 : 3F                       ccf                     ;[M80] MAKE CARRY ZERO
1146 04B9 : D0                       ret     nc              ;[M80] NO MATCH RETURN (GREATER)
1147 04BA : 18 E6                    jr      LOOP            ;[M80] KEEP LOOPING
1148 04BC
1149 04BC                  + ;;Convert Keyword to Token
1150 04BC                  | ;[M80] ALL "RESERVED" WORDS ARE TRANSLATED INTO SINGLE
1151 04BC                  | ;[M80] ONE OR TWO (IF TWO, FIRST IS ALWAYS 377 OCTAL)
1152 04BC                  | ;[M80] BYTES WITH THE MSB ON. THIS SAVES SPACE AND TIME
1153 04BC                  | ;[M80] BY ALLOWING FOR TABLE DISPATCH DURING EXECUTION.
1154 04BC                  | ;[M80] THEREFORE ALL STATEMENTS APPEAR TOGETHER IN THE
1155 04BC                  | ;[M80] RESERVED WORD LIST IN THE SAME
1156 04BC                  | ;[M80] ORDER THEY APPEAR IN IN STMDSP.
1157 04BC : AF         [M80] CRUNCH: xor     a               ;SAY EXPECTING FLOATING NUMBERS
1158 04BD : 32 AC 38                 ld      (DORES),a       ;ALLOW CRUNCHING
1159 04C0 : 0E 05                    ld      c,5             ;LENGTH OF KRUNCH BUFFER
1160 04C2 : 11 60 38                 ld      de,BUF          ;SETUP DESTINATION POINTER
1161 04C5 : 7E         [M80] KLOOP:  ld      a,(hl)          ;GET CHARACTER FROM BUF
1162 04C6 : FE 20                    cp      ' '             ;SPACE?
1163 04C8 : CA 3C 05                 jp      z,STUFFH        ;JUST STUFF AWAY
1164 04CB : 47                       ld      b,a             ;SETUP B WITH A QUOTE IF IT IS A STRING
1165 04CC : FE 22                    cp      '"'             ;QUOTE SIGN?
1166 04CE : CA 58 05                 jp      z,STRNG         ;YES, GO TO SPECIAL STRING HANDLING
1167 04D1 : B7                       or      a               ;END OF LINE?
1168 04D2 : CA 5E 05                 jp      z,CRDONE        ;YES, DONE CRUNCHING
1169 04D5 : 3A AC 38                 ld      a,(DORES)       ;IN DATA STATEMENT AND NO CRUNCH?
1170 04D8 : B7                       or      a
1171 04D9 : 7E                       ld      a,(hl)          ;GET THE CHARACTER AGAIN
1172 04DA : C2 3C 05                 jp      nz,STUFFH       ;IF NO CRUNCHING JUST STORE THE CHARACTER
1173 04DD : FE 3F                    cp      '?'             ;A QMARK?
1174 04DF : 3E 95                    ld      a,PRINTK        ;
1175 04E1 : CA 3C 05                 jp      z,STUFFH        ;THEN USE A "PRINT" TOKEN
1176 04E4 : 7E                       ld      a,(hl)          ;
1177 04E5 : FE 30                    cp      '0'             ;[M65] SKIP NUMERICS.
1178 04E7 : 38 05                    jr      c,MUSTCR        ;
1179 04E9 : FE 3C                    cp      '<'             ;[M65] ":" AND ";" ARE ENTERED STRAIGHTAWAY.
1180 04EB : DA 3C 05                 jp      c,STUFFH        ;
1181 04EE : D5         [M65] MUSTCR: push    de              ;[M65] SAVE BUFFER POINTER.
1182 04EF : 11 44 02                 ld      de,RESLST-1     ;[M65] LOAD RESLST POINTER.
1183 04F2 : C5                       push    bc              ;[M65] SAVE TEXT POINTER FOR LATER USE.
1184 04F3 : 01 36 05                 ld      bc,NOTGOS       ;[M80] PLACE TO RETURN IF NOT FUNNY GO
1185 04F6 : C5                       push    bc              ;
1186 04F7 : 06 7F                    ld      b,$7F           ;
1187 04F9 : 7E       *       CRUNCX: ld      a,(hl)          ;[M80] GET CHAR FROM MEMORY
Error parsing object code '7E*' in line 1187

1188 04FA : FE 61                    cp      'a'             ;[M80] IS IT LOWER CASE RANGE
1189 04FC : 38 07                    jr      c,RESCON        ;[M80] LESS
1190 04FE : FE 7B                    cp      '{'             ;[M80] GREATER
1191 0500 : 30 03                    jr      nc,RESCON       ;[M80] TEST
1192 0502 : E6 5F                    and     $5F             ;[M80] MAKE UPPER CASE
1193 0504 : 77                       ld      (hl),a          ;;and put it back
1194 0505 : 4E         [N65] RESCON: ld      c,(hl)          ;[M80 SAVE CHAR IN [C]
1195 0506                    ;;Find next Reserved Word that starts with this character
1196 0506 : EB                       ex      de,hl           ;;HL=RESLST Pointer, DE=Text Pointer
1197 0507 : 23         (M80) LOPPSI: inc     hl              ;[M80] BUMP RESLST POINTER
1198 0508 : B6                       or      (hl)            ;[M80] SET CC'S
1199 0509 : F2 07 05                 jp      p,LOPPSI        ;[M80] SEE IF REST OF CHARS MATCH
1200 050C : 04                       inc     b               ;
1201 050D : 7E                       ld      a,(hl)          ;[M80] GET BYTE FROM RESERVED WORD LIST
1202 050E : E6 7F                    and     $7F             ;[M80] GET RID OF HIGH BIT
1203 0510 : C8                       ret     z               ;[M80] IF=0 THEN END OF THIS CHARS RESLT
1204 0511 : B9                       cp      c               ;[M80] COMPARE TO CHAR FROM SOURCE LINE
1205 0512 : 20 F3                    jr      nz,LOPPSI       ;[M80] IF NO MATCH, SEARCH FOR NEXT RESWRD
1206 0514 : EB                       ex      de,hl           ;;DE=RESLST Pointer, HL=Text Pointer
1207 0515 : E5                       push    hl              ;;Save Text Pointer
1208 0516 : 13         (M80) LOPSKP: inc     de              ;[M80] POINT AFTER TOKEN
1209 0517 : 1A                       ld      a,(de)          ;[M80] GET A BYTE FROM RESWRD LIST
1210 0518 : B7                       or      a               ;[M80] BUMP RESLST POINTER
1211 0519 : FA 32 05                 jp      m,NOTFNT        ;[M80] SET CC'S
1212 051C : 4F                       ld      c,a             ;[M80] NOT END OF RESWRD, KEEP SKIPPING
1213 051D : 78                       ld      a,b             ;
1214 051E : FE 88                    cp      GOTOTK          ;
1215 0520 : 20 02                    jr      nz,MAKUPL       ;
1216 0522 : D7                       rst     CHRGET          ;
1217 0523 : 2B                       dec     hl              ;[M80] FIX TEXT POINTER
1218 0524 : 23         (M80) MAKUPL: inc     hl              ;
1219 0525 : 7E                       ld      a,(hl)          ;
1220 0526 : FE 61                    cp      'a'             ;[M80] IS IT LOWER CASE RANGE
1221 0528 : 38 02                    jr      c,MAKUPS        ;[M80] LESS
1222 052A : E6 5F                    and     $5F             ;[M80] MAKE UPPER CASE
1223 052C : B9         (M80) MAKUPS: cp      c               ;[M80] COMPARE TO CHAR FROM SOURCE LINE
1224 052D : 28 E7                    jr      z,LOPSKP        ;[M80] IF NO MATCH, SEARCH FOR NEXT RESWRD
1225 052F : E1                       pop     hl              ;
1226 0530 : 18 D3                    jr      RESCON          ;
1227 0532 : 48         (M80) NOTFNT: ld      c,b             ;
1228 0533 : F1                       pop     af              ;
1229 0534 : EB                       ex      de,hl           ;
1230 0535 : C9                       ret                     ;
1231 0536 : F7         [M80] NOTGOS: rst     HOOKDO          ;
1232 0537 : 0A         {~~~} HOOK10: byte    10              ;
1233 0538 : EB                       ex      de,hl           ;;HL=text pointer, DE=krunch pointer
1234 0539 : 79                       ld      a,c             ;;Get token
1235 053A : C1                       pop     bc              ;
1236 053B : D1                       pop     de              ;
1237 053C
1238 053C                    ;;Copy character to crunch buffer
1239 053C : 23         [M80] STUFFH: inc     hl              ;[M80] ENTRY TO BUMP [H,L]
1240 053D : 12         {M80} KRNSAV: ld      (de),a          ;[M80] SAVE BYTE IN KRUNCH BUFFER
1241 053E : 13                       inc     de              ;[M80] BUMP POINTER
1242 053F : 0C                       inc     c               ;;Increment buffer count
1243 0540 : D6 3A                    sub     ':'             ;[M65] IS IT A ":"?"
1244 0542 : 28 04                    jr      z,COLIS         ;[M65] YES, ALLOW CRUNCHING AGAIN.
1245 0544 : FE 49                    cp      DATATK-':'      ;[M65] IS IT A DATATK?
1246 0546 : 20 03                    jr      nz,NODATT       ;[M65] NO, SEE IF IT IS REM TOKEN.
1247 0548
1248 0548 : 32 AC 38   (M80) COLIS:  ld      (DORES),a       ;[M65] SETUP FLAG.
1249 054B : D6 54      (M80) NODATT: sub     REMTK-':'       ;[M65] REM ONLY STOPS ON NULL.
1250 054D : C2 C5 04                 jp      nz,KLOOP        ;[M65] NO, CONTINUE CRUNCHING.
1251 0550 : 47                       ld      b,a             ;{M80} SAVE TERMINATOR IN [B]
1252 0551 : 7E         (M80) STR1:   ld      a,(hl)          ;[M80] GET A CHAR
1253 0552 : B7                       or      a               ;[M80] SET CONDITION CODES
1254 0553 : 28 09                    jr      z,CRDONE        ;[M80] IF END OF LINE THEN DONE
1255 0555 : B8                       cp      b               ;[M80] COMPARE CHAR WITH THIS TERMINATOR
1256 0556 : 28 E4                    jr      z,STUFFH        ;[M80] IF YES, DONE WITH STRING
1257 0558
1258 0558 : 23         (M80) STRNG:  inc     hl              ;[M80] INCREMENT TEXT POINTER
1259 0559 : 12                       ld      (de),a          ;[M80] SAVE CHAR IN KRUNCH BUFFER
1260 055A : 0C                       inc     c               ;;Increment buffer count
1261 055B : 13                       inc     de              ;[M65] INCREMENT BUFFER POINTER.
1262 055C : 18 F3                    jr      STR1            ;[M80] KEEP LOOPING
1263 055E
1264 055E : 21 5F 38   (M80) CRDONE: ld      hl,BUF-1        ;[M80] GET POINTER TO CHAR BEFORE BUF AS "GONE" DOES A CHRGET
1265 0561 : 12                       ld      (de),a          ;[M80] NEED THREE 0'S ON THE END
1266 0562 : 13                       inc     de              ;[M80] ONE FOR END-OF-LINE
1267 0563 : 12                       ld      (de),a          ;[M80] AND 2 FOR A ZERO LINK
1268 0564 : 13                       inc     de              ;[M80] SINCE IF THIS IS A DIRECT STATEMENT
1269 0565 : 12                       ld      (de),a          ;[M80] ITS END MUST LOOK LIKE THE END OF A PROGRAM
1270 0566 : C9                       ret                     ;[M80] END OF CRUNCHING
1271 0567
1272 0567                    ;;The LLIST and LIST commands
1273 0567 : 3E 01      [M80] LLIST:  ld      a,1             ;[M80] PRTFLG=1 FOR REGULAR LIST
1274 0569 : 32 47 38                 ld      (PRTFLG),a      ;[M80] SAVE IN I/O FLAG (END OF LPT)
1275 056C : 3E 17      [M80] LIST:   ld      a,23            ;;Set line count to 23
1276 056E : 32 08 38                 ld      (CNTOFL),a      ;
1277 0571 : CD 9C 06                 call    SCNLIN          ;[M80] SCAN LINE RANGE
1278 0574 : C0                       ret     nz              ;
1279 0575 : C1                       pop     bc              ;[M80] GET RID OF NEWSTT RETURN ADDR
1280 0576 : CD 9F 04                 call    FNDLIN          ;[M80] DONT EVEN LIST LINE #
1281 0579 : C5                       push    bc              ;[M80] SAVE POINTER TO 1ST LINE
1282 057A : E1         (M80) LIST4:  pop     hl              ;[M80] GET POINTER TO LINE
1283 057B : 4E                       ld      c,(hl)          ;[M80] [B,C]=THE LINK POINTING TO THE NEXT
1284 057C : 23                       inc     hl              ;
1285 057D : 46                       ld      b,(hl)          ;
1286 057E : 23                       inc     hl              ;
1287 057F : 78                       ld      a,b             ;[M80] SEE IF END OF CHAIN
1288 0580 : B1                       or      c               ;
1289 0581 : CA 02 04                 jp      z,READY         ;[M80] LAST LINE, STOP.
1290 0584 : CD 25 1A                 call    ISCNTC          ;[M80] CHECK FOR CONTROL-C
1291 0587 : C5                       push    bc              ;[M80] SAVE LINK
1292 0588 : CD EA 19                 call    CRDO            ;
1293 058B : 5E                       ld      e,(hl)          ;[M80] [B,C]=THE LINK POINTING TO THE NEXT LINE
1294 058C : 23                       inc     hl              ;
1295 058D : 56                       ld      d,(hl)          ;
1296 058E : 23                       inc     hl              ;
1297 058F : E5                       push    hl              ;[M80] DON'T ALLOW ^C
1298 0590 : EB                       ex      de,hl           ;[M80] GET LINE # IN [H,L]
1299 0591 : CD 75 16                 call    LINPRT          ;[M80] PRINT AS INT WITHOUT LEADING SPACE
1300 0594 : 3E 20                    ld      a,' '           ;
1301 0596 : E1                       pop     hl              ;
1302 0597 : DF         (M65) PLOOP:  rst     OUTCHR          ;[M80] PRINT A SPACE AFTER THE LINE #
1303 0598 : 7E       * [M80] LISPRT: ld      a,(hl)          ;
Error parsing object code '7E*' in line 1303

1304 0599 : 23                       inc     hl              ;[M80] INCR POINTER
1305 059A : B7                       or      a               ;[M80] SET CC
1306 059B : 28 DD                    jr      z,LIST4         ;[M80] IF =0 THEN END OF LINE
1307 059D : F2 97 05                 jp      p,PLOOP         ;
1308 05A0 : F7                       rst     HOOKDO          ;;Handle Extended BASIC Tokens
1309 05A1 : 16         {~~~} HOOK22: byte    22              ;
1310 05A2 : D6 7F                    sub     $7F             ;
1311 05A4 : 4F                       ld      c,a             ;
1312 05A5 : 11 45 02                 ld      de,RESLST       ;[M80] GET PTR TO START OF RESERVED WORD LIST
1313 05A8 : 1A         (M80) RESSRC: ld      a,(de)          ;[M80] GET CHAR FROM RESLST
1314 05A9 : 13                       inc     de              ;[M80] BUMP SOURCE PTR
1315 05AA : B7                       or      a               ;[M80] SET CC'S
1316 05AB : F2 A8 05                 jp      p,RESSRC        ;[M80] IF NOT END OF THIS RESWRD, THEN KEEP LOOKING
1317 05AE : 0D                       dec     c               ;
1318 05AF : 20 F7                    jr      nz,RESSRC       ;
1319 05B1 : E6 7F      [m80] MORLNP: and     $7F             ;[M80] AND OFF HIGH ORDER BIT
1320 05B3 : DF                       rst     OUTCHR          ;[M80] STORE THIS CHAR
1321 05B4 : 1A         {M80} MORPUR: ld      a,(de)          ;[M80] GET BYTE FROM RESWRD
1322 05B5 : 13                       inc     de              ;[M80] BUMP POINTER
1323 05B6 : B7                       or      a               ;[M80] SET CC'S
1324 05B7 : F2 B1 05                 jp      p,MORLNP        ;[M80] END OF RESWRD?
1325 05BA : 18 DC                    jr      LISPRT          ;[M80] PRINT NEXT CHAR
1326 05BC
1327 05BC                  + ;[M80] "FOR" STATEMENT
1328 05BC                  | ;[M80] A "FOR" ENTRY ON THE STACK HAS THE FOLLOWING FORMAT:
1329 05BC                  | ;[M80]
1330 05BC                  | ;[M80] LOW ADDRESS
1331 05BC                  | ;[M80]  TOKEN ($FOR IN HIGH BYTE)  1 BYTE
1332 05BC                  | ;[M80]  A POINTER TO THE LOOP VARIABLE  2 BYTES
1333 05BC                  | ;[M80]  A BYTE REFLECTING THE SIGN OF THE INCREMENT 1 BYTE
1334 05BC                  | ;[M80]  THE STEP 4 BYTES
1335 05BC                  | ;[M80]  THE UPPER VALUE 4 BYTES
1336 05BC                  | ;[M80]  THE LINE # OF THE "FOR" STATEMENT 2 BYTES
1337 05BC                  | ;[M80]  A TEXT POINTER INTO THE "FOR" STATEMENT 2 BYTES
1338 05BC                  | ;[M80] HIGH ADDRESS
1339 05BC                  | ;[M80]
1340 05BC                  | ;[M80] TOTAL 16 BYTES
1341 05BC                  | ;;;*** On the Aquarius, the entry is only 13 bytes
1342 05BC : 3E 64      [M80] FOR:    ld      a,100
1343 05BE : 32 CB 38                 ld      (SUBFLG),a      ;[M80] DONT RECOGNIZE SUBSCRIPTED VARIABLES
1344 05C1 : CD 31 07                 call    LET             ;[M65] READ VARIABLE AND ASSIGN INITIAL VALUE
1345 05C4 : C1                       pop     bc              ;
1346 05C5 : E5                       push    hl              ;[M80] SAVE THE TEXT POINTER
1347 05C6 : CD 1C 07                 call    DATA            ;[M80] SET [H,L]=END OF STATEMENT
1348 05C9 : 22 C7 38                 ld      (ENDFOR),hl     ;[M80] SAVE FOR COMPARISON
1349 05CC : 21 02 00                 ld      hl,2            ;[M80] SET UP POINTER INTO STACK
1350 05CF : 39                       add     hl,sp           ;
1351 05D0 : CD A3 03   (M80) LPFORM: call    LOOPER          ;[M80] MUST HAVE VARIABLE POINTER IN [D,E]
1352 05D3 : 20 14                    jr      nz,NOTOL        ;[M80] NO MATCHING ENTRY, DON'T ELIMINATE ANYTHING
1353 05D5 : 09                       add     hl,bc           ;[M80] ELIMINATE THE MATCHING ENTRY
1354 05D6 : D5                       push    de              ;[M80] SAVE THE TEXT POINTER
1355 05D7 : 2B                       dec     hl              ;[M80] SEE IF END TEXT POINTER OF MATCHING ENTRY
1356 05D8 : 56                       ld      d,(hl)          ;[M80] MATCHES THE FOR WE ARE HANDLING
1357 05D9 : 2B                       dec     hl              ;[M80] PICK UP THE END OF THE "FOR" TEXT POINTER
1358 05DA : 5E                       ld      e,(hl)          ;[M80] FOR THE ENTRY ON THE STACK
1359 05DB : 23                       inc     hl              ;[M80] WITHOUT CHANGING [H,L]
1360 05DC : 23                       inc     hl              ;
1361 05DD : E5                       push    hl              ;[M80] SAVE THE STACK POINTER FOR THE COMPARISON
1362 05DE : 2A C7 38                 ld      hl,(ENDFOR)     ;[M80] GET ENDING TEXT POINTER FOR THIS "FOR"
1363 05E1 : E7                       rst     COMPAR          ;[M80] SEE IF THEY MATCH
1364 05E2 : E1                       pop     hl              ;[M80] GET BACK THE STACK POINTER
1365 05E3 : D1                       pop     de              ;
1366 05E4 : 20 EA                    jr      nz,LPFORM       ;;[M80] KEEP SEARCHING IF NO MATCH
1367 05E6 : D1                       pop     de              ;[M80] GET BACK THE TEXT POINTER
1368 05E7 : F9                       ld      sp,hl           ;[M80] DO THE ELIMINATION
1369 05E8 : 0C                       inc     c               ;
1370 05E9 : D1         (M80) NOTOL:  pop     de              ;
1371 05EA : EB                       ex      de,hl           ;[M80] [H,L]=TEXT POINTER
1372 05EB : 0E 08                    ld      c,8             ;[M80] MAKE SURE 16 BYTES ARE AVAILABLE
1373 05ED : CD A0 0B                 call    GETSTK          ;[M80] OFF OF THE STACK
1374 05F0 : E5                       push    hl              ;[M80] REALLY SAVE THE TEXT POINTER
1375 05F1 : 2A C7 38                 ld      hl,(ENDFOR)     ;[M80] PICK UP POINTER AT END OF "FOR"
1376 05F4 : E3                       ex      (sp),hl         ;[M80] PUT POINTER ON STACK AND RESTORE TEXT POINTER
1377 05F5 : E5                       push    hl              ;[M80] PUSH POINTER TO VARIABLE ONTO THE STACK
1378 05F6 : 2A 4D 38                 ld      hl,(CURLIN)     ;[M80] [H,L] GET THE CURRENT LINE #
1379 05F9 : E3                       ex      (sp),hl         ;[M80] LINE # ON THE STACK AND [H,L] IS THE TEXT POINTER
1380 05FA : CD 75 09                 call    CHKNUM          ;
1381 05FD : CF                       rst     SYNCHK          ;
1382 05FE : A1                       byte    TOTK            ;[M80] "TO" IS NECESSARY
1383 05FF : CD 72 09                 call    FRMNUM          ;[M65] VALUE MUST BE A NUMBER
1384 0602 : E5                       push    hl              ;
1385 0603 : CD 2E 15                 call    MOVRF           ;[M80] GET THE STUFF
1386 0606 : E1                       pop     hl              ;[M80] REGAIN TEXT POINTER
1387 0607 : C5                       push    bc              ;[M80] OPPOSITE OF PUSHR
1388 0608 : D5                       push    de              ;[M80] SAVE THE SIGN OF THE INCREMENT
1389 0609 : 01 00 81                 ld      bc,$8100        ;[M80] DEFAULT THE STEP TO BE 1
1390 060C : 51                       ld      d,c             ;
1391 060D : 5A                       ld      e,d             ;[M80] GET 1.0 IN THE REGISTERS
1392 060E : 7E                       ld      a,(hl)          ;[M80] GET TERMINATING CHARACTER
1393 060F : FE A7                    cp      STEPTK          ;[M80] DO WE HAVE "STEP" ?
1394 0611 : 3E 01                    ld      a,1             ;[M80] SETUP DEFAULT SIGN
1395 0613 : 20 0A                    jr      nz,ONEON        ;[M65] NO. ASSUME 1.0.
1396 0615 : D7                       rst     CHRGET          ;[M65] YES. ADVANCE POINTER
1397 0616 : CD 72 09                 call    FRMNUM          ;
1398 0619 : E5                       push    hl              ;
1399 061A : CD 2E 15                 call    MOVRF           ;[M80] SET UP THE REGISTERS
1400 061D : EF                       rst     FSIGN           ;[M80] GET THE SIGN OF THE INCREMENT
1401 061E : E1         {M80} STPSGN: pop     hl              ;[M80] POP OFF THE TEXT POINTER
1402 061F : C5         (M80) ONEON:  push    bc              ;[M80] PUT VALUE ON BACKWARDS
1403 0620 : D5                       push    de              ;[M80] OPPOSITE OF PUSHR
1404 0621 : F5                       push    af              ;
1405 0622 : 33                       inc     sp              ;
1406 0623 : E5                       push    hl              ;
1407 0624 : 2A CE 38                 ld      hl,(SAVTXT)     ;
1408 0627 : E3                       ex      (sp),hl         ;
1409 0628 : 06 81      [M80] NXTCON: ld      b,FORTK         ;[M80] PUT A 'FOR' TOKEN ONTO THE STACK
1410 062A : C5                       push    bc              ;
1411 062B : 33                       inc     sp              ;[M80] THE "TOKEN" ONLY TAKES ONE BYTE OF STACK SPACE
1412 062C
1413 062C                  + ;[M80] NEW STATEMENT FETCHER
1414 062C                  | ;[M80] BACK HERE FOR NEW STATEMENT. CHARACTER POINTED TO BY [H,L]
1415 062C                  | ;[M80] ":" OR END-OF-LINE. THE ADDRESS OF THIS LOCATION IS
1416 062C                  | ;[M80] LEFT ON THE STACK WHEN A STATEMENT IS EXECUTED SO
1417 062C                  | ;[M80] IT CAN MERELY DO A RETURN WHEN IT IS DONE.
1418 062C : 22 CE 38   [M80] NEWSTT: ld      (SAVTXT),hl     ;USED BY CONTINUE AND INPUT AND CLEAR AND PRINT USING
1419 062F : CD C2 1F                 call    INCNTC           ;;*** might be [M65] ISCNTC
1420 0632 : 7E                       ld      a,(hl)          ;;Get Terminator
1421 0633 : FE 3A                    cp      ':'             ;[M80] IS IT A COLON?
1422 0635 : 28 14                    jr      z,GONE          ;
1423 0637 : B7                       or      a               ;
1424 0638 : C2 C4 03                 jp      nz,SNERR        ;[M80] MUST BE A ZERO
1425 063B : 23                       inc     hl              ;
1426 063C : 7E         [M80] GONE4:  ld      a,(hl)          ;[M80] IF POINTER IS ZERO, END OF PROGRAM
1427 063D : 23                       inc     hl              ;
1428 063E : B6                       or      (hl)            ;[M80] OR IN HIGH PART
1429 063F : CA 29 0C                 jp      z,ENDCON        ;[M80] FIX SYNTAX ERROR IN UNENDED ERROR ROUTINE
1430 0642 : 23                       inc     hl              ;
1431 0643 : 5E                       ld      e,(hl)          ;
1432 0644 : 23                       inc     hl              ;
1433 0645 : 56                       ld      d,(hl)          ;[M80] GET LINE # IN [D,E]
1434 0646 : EB                       ex      de,hl           ;[M80] [H,L]=LINE #
1435 0647 : 22 4D 38                 ld      (CURLIN),hl     ;[M80] SETUP CURLIN WITH THE CURRENT LINE #
1436 064A : EB                       ex      de,hl           ;;DE=Line#, HL=Text Pointer
1437 064B
1438 064B : D7         [M80] GONE:   rst     CHRGET          ;[M80] GET THE STATEMENT TYPE
1439 064C : 11 2C 06                 ld      de,NEWSTT       ;[M80] PUSH ON A RETURN ADDRESS OF NEWSTT
1440 064F : D5                       push    de              ;[M80] STATEMENT
1441 0650 : C8         [M80] GONE3:  ret     z               ;[M80] IF A TERMINATOR TRY AGAIN
1442 0651                    ;[M80] "IF" COMES HERE
1443 0651 : D6 80      [M80] GONE2:  sub     $80             ;[M80] "ON ... GOTO" AND "ON ... GOSUB" COME HERE
1444 0653 : DA 31 07                 jp      c,LET           ;[M80] MUST BE A LET
1445 0656 : FE 20                    cp      TABTK-$80       ;;End of Statement Tokens
1446 0658 : F7                       rst     HOOKDO          ;;Handle Extended BASIC Statement Tokens
1447 0659 : 17         {~~~} HOOK23: byte    23              ;
1448 065A : D2 C4 03                 jp      nc,SNERR        ;;Not a Statement Token
1449 065D : 07                       rlca                    ;[M80] MULTIPLY BY 2
1450 065E : 4F                       ld      c,a             ;
1451 065F : 06 00                    ld      b,0             ;;Offset = (Token - 128) * 2
1452 0661 : EB                       ex      de,hl           ;
1453 0662 : 21 D5 01                 ld      hl,STMDSP       ;[M80] STATEMENT DISPATCH TABLE
1454 0665 : 09         [~~~] GONE5:  add     hl,bc           ;[M80] ADD ON OFFSET
1455 0666 : 4E                       ld      c,(hl)          ;[M80] PUSH THE ADDRESS TO GO TO ONTO
1456 0667 : 23                       inc     hl              ;[M80] THE STACK
1457 0668 : 46                       ld      b,(hl)          ;[M80] PUSHM SAVES BYTES BUT NOT SPEED
1458 0669 : C5                       push    bc              ;
1459 066A : EB                       ex      de,hl           ;[M80] RESTORE THE TEXT POINTER
1460 066B                  + ;;Execute Statement
1461 066B                  | ;[M80] NEWSTT FALLS INTO CHRGET. THIS FETCHES THE FIRST CHAR AFTER
1462 066B                  | ;[M80] THE STATEMENT TOKEN AND THE CHRGET'S "RET" DISPATCHES TO STATEMENT
1463 066B : 23         [M80] CHRGTR: inc     hl              ;[M80] DUPLICATION OF CHRGET RST FOR SPEED
1464 066C : 7E         {M80} CHRGT2: ld      a,(hl)          ;
1465 066D : FE 3A                    cp      ':'             ;[M80] SEE CHRGET RST FOR EXPLANATION
1466 066F : D0                       ret     nc              ;
1467 0670                    ;[M80] CHRCON IS THE CONTINUATION OF THE CHRGET RST
1468 0670 : FE 20      [M80] CHRCON: cp      ' '             ;MUST SKIP SPACES
1469 0672 : 28 F7                    jr      z,CHRGTR        ;GET ANOTHER CHARACTER
1470 0674 : FE 30                    cp      '0'             ;ALL CHARS .GT. "9" HAVE RET'D SO
1471 0676 : 3F                       ccf                     ;TURN CARRY ON IF NUMERIC.
1472 0677 : 3C                       inc     a               ;ALSO, SETZ IF NULL.
1473 0678 : 3D                       dec     a               ;
1474 0679 : C9         {M80} CHRRTS: ret                     ;RETURN TO CALLER.
1475 067A
1476 067A                  + ;[M80] INTIDX READS A FORMULA FROM THE CURRENT POSITION AND
1477 067A                  | ;[M80] TURNS IT INTO A POSITIVE INTEGER
1478 067A                  | ;[M80] LEAVING THE RESULT IN [D,E].  NEGATIVE ARGUMENTS
1479 067A                  | ;[M80] ARE NOT ALLOWED. [H,L] POINTS TO THE TERMINATING
1480 067A                  | ;[M80] CHARACTER OF THE FORMULA ON RETURN.
1481 067A                  | ;
1482 067A : D7               INTIDX: rst     CHRGET          ;
1483 067B : CD 72 09         INTID2: call    FRMNUM          ;{M80} READ FORMULA AND GET RESULT AS INTEGER IN [D,E]
1484 067E : EF               INTFR2: rst     FSIGN           ;[M80] DON'T ALLOW NEGATIVE NUMBERS
1485 067F : FA 97 06                 jp      m,FCERR         ;[M80] TOO BIG. FUNCTION CALL ERROR
1486 0682
1487 0682 : 3A E7 38   [M80] FRCINT: ld      a,(FAC)         ;
1488 0685 : FE 90                    cp      144             ;[M65] FAC .GT. 32767?
1489 0687 : DA 86 15                 jp      c,QINT          ;[M65] GO TO QINT AND SHOVE IT
1490 068A : 01 80 90                 ld      bc,$9080        ;
1491 068D : 11 00 00                 ld      de,$0000        ;[M65] -32768
1492 0690 : E5                       push    hl              ;
1493 0691 : CD 5B 15                 call    FCOMP           ;[M65] SEE IF FAC=[B,C,D,E]
1494 0694 : E1                       pop     hl              ;
1495 0695 : 51                       ld      d,c             ;
1496 0696 : C8                       ret     z               ;[M65] NO, FAC IS TOO BIG.
1497 0697
1498 0697 : 1E 08      [M80] FCERR:  ld      e,ERRFC         ;[M65] "FUNCTION CALL" ERROR
1499 0699 : C3 DB 03                 jp      ERROR           ;
1500 069C
1501 069C                    ;[M80]  LINGET READS A LINE # FROM THE CURRENT TEXT POSITION
1502 069C                    ;[M80]
1503 069C                    ;[M80]  LINE NUMBERS RANGE FROM 0 TO 65529
1504 069C                    ;[M80]
1505 069C                    ;[M80]  THE ANSWER IS RETURNED IN [D,E].
1506 069C                    ;[M80]  [H,L] IS UPDATED TO POINT TO THE TERMINATING CHARACTER
1507 069C                    ;[M80]  AND [A] CONTAINS THE TERMINATING CHARACTER WITH CONDITION
1508 069C                    ;[M80]  CODES SET UP TO REFLECT ITS VALUE.
1509 069C                    ;
1510 069C : 2B         [M80] SCNLIN: dec     hl
1511 069D : 11 00 00   [M80] LINGET: ld      de,0            ;[M80] ASSUME START LIST AT ZERO
1512 06A0 : D7         (M80) MORLIN: rst     CHRGET          ;;Get next character
1513 06A1 : D0                       ret     nc              ;[M80] WAS IT A DIGIT
1514 06A2 : E5                       push    hl              ;
1515 06A3 : F5                       push    af              ;
1516 06A4 : 21 98 19                 ld      hl,0+6552       ;[M80] SEE IF THE LINE # IS TOO BIG
1517 06A7 : E7                       rst     COMPAR          ;
1518 06A8 : 38 11                    jr      c,POPHSR        ;[M80] YES, DON'T SCAN ANY MORE DIGITS AND GIVE SYNTAX ERROR
1519 06AA : 62                       ld      h,d             ;[M80] SAVE [D,E]
1520 06AB : 6B                       ld      l,e             ;
1521 06AC : 19                       add     hl,de           ;
1522 06AD : 29                       add     hl,hl           ;
1523 06AE : 19                       add     hl,de           ;
1524 06AF : 29                       add     hl,hl           ;[M80] PUTTING [D,E]*10 INTO [H,L]
1525 06B0 : F1                       pop     af              ;
1526 06B1 : D6 30                    sub     '0'             ;
1527 06B3 : 5F                       ld      e,a             ;
1528 06B4 : 16 00                    ld      d,0             ;
1529 06B6 : 19                       add     hl,de           ;[M80] ADD THE NEW DIGIT
1530 06B7 : EB                       ex      de,hl           ;
1531 06B8 : E1                       pop     hl              ;[M80] GET BACK TEXT POINTER
1532 06B9 : 18 E5                    jr      MORLIN          ;
1533 06BB : F1         (M80) POPHSR: pop     af              ;[M80] GET OFF TERMINATING DIGIT
1534 06BC : E1                       pop     hl              ;[M80] GET BACK OLD TEXT POINTER
1535 06BD : C9                       ret                     ;
1536 06BE
1537 06BE : F7         [M80] RUN:    rst     HOOKDO          ;Call Hook Routine
1538 06BF : 18         {~~~} HOOK24: byte    24              ;
1539 06C0 : CA CB 0B                 jp      z,RUNC          ;[M80] NO LINE # ARGUMENT
1540 06C3 : CD CF 0B   {M80} CONRUN: call    CLEARC          ;RESET THE STACK,DATPTR,VARIABLES ...
1541 06C6 : 01 2C 06                 ld      bc,NEWSTT       ;
1542 06C9 : 18 10                    jr      RUNC2           ;[M80] PUT "NEWSTT" ON AND FALL INTO "GOTO"
1543 06CB
1544 06CB                  + ;[M80] GOSUB STATEMENT
1545 06CB                  | ;[M80] A "GOSUB" ENTRY ON THE STACK HAS THE FOLLOWING FORMAT
1546 06CB                  | ;[M80]
1547 06CB                  | ;[M80] LOW ADDRESS
1548 06CB                  | ;[M80]
1549 06CB                  | ;[M80]  A TOKEN EQUAL TO $GOSUB 1 BYTE
1550 06CB                  | ;[M80]  THE LINE # OF THE THE "GOSUB" STATEMENT 2 BYTES
1551 06CB                  | ;[M80]  A POINTER INTO THE TEXT OF THE "GOSUB" 2 BYTES
1552 06CB                  | ;[M80]
1553 06CB                  | ;[M80] HIGH ADDRESS
1554 06CB                  | ;[M80]
1555 06CB                  | ;[M80] TOTAL 5 BYTES
1556 06CB : 0E 03      [M80] GOSUB:  ld      c,3             ;[M80] "GOSUB" ENTRIES ARE 5 BYTES LONG
1557 06CD : CD A0 0B                 call    GETSTK          ;[M80] MAKE SURE THERE IS ROOM
1558 06D0 : C1                       pop     bc              ;[M80] POP OFF RETURN ADDRESS OF "NEWSTT"
1559 06D1 : E5                       push    hl              ;[M80] REALLY PUSH THE TEXT POINTER
1560 06D2 : E5                       push    hl              ;[M80] SAVE TEXT POINTER
1561 06D3 : 2A 4D 38                 ld      hl,(CURLIN)     ;[M80] GET THE CURRENT LINE #
1562 06D6 : E3                       ex      (sp),hl         ;[M80] PUT CURLIN ON THE STACK AND [H,L]=TEXT PTR
1563 06D7 : 3E 8C                    ld      a,GOSUTK        ;
1564 06D9 : F5                       push    af              ;[M80] PUT GOSUB TOKEN ON THE STACK
1565 06DA : 33                       inc     sp              ;[M80] THE GOSUB TOKEN TAKES ONLY ONE BYTE
1566 06DB
1567 06DB : C5         [M80] RUNC2:  push    bc              ;[M80] RESTORE RETURN ADDRESS OF "NEWSTT"
1568 06DC
1569 06DC : CD 9C 06   [M80] GOTO:   call    SCNLIN          ;[M80] PICK UP THE LINE # AND PUT IT IN [D,E]
1570 06DF : CD 1E 07                 call    REM             ;[M80] SKIP TO THE END OF THIS LINE
1571 06E2 : 23                       inc     hl              ;[M80] POINT AT THE LINK BEYOND IT
1572 06E3 : E5                       push    hl              ;[M80] SAVE THE POINTER
1573 06E4 : 2A 4D 38                 ld      hl,(CURLIN)     ;[M80] GET THE CURRENT LINE #
1574 06E7 : E7                       rst     COMPAR          ;;Is target line less than current line
1575 06E8 : E1                       pop     hl              ;[M80] [H,L]=CURRENT POINTER
1576 06E9 : DC A2 04                 call    c,LOOP          ;[M80] SEARCH FROM THIS POINT
1577 06EC : D4 9F 04                 call    nc,FNDLIN       ;[M80] SEARCH FROM THE BEGINNING -- ACTUALLY
1578 06EF : 60                       ld      h,b             ;[M80] [H,L]= POINTER TO THE START OF THE MATCHED LINE
1579 06F0 : 69                       ld      l,c             ;
1580 06F1 : 2B                       dec     hl              ;
1581 06F2 : D8                       ret     c               ;[M80] GO TO NEWSTT
1582 06F3 : 1E 0E      [M80] USERR:  ld      e,ERRUS         ;[M80] C=MATCH, SO IF NO MATCH WE
1583 06F5 : C3 DB 03                 jp      ERROR           ;[M80] GIVE A "US" ERROR
1584 06F8
1585 06F8                  + ;[M80] RETURN STATEMENT
1586 06F8                  | ;[M80] SEE "GOSUB" FOR THE FORMAT OF THE STACK ENTRY
1587 06F8                  | ;[M80] "RETURN" RESTORES THE LINE NUMBER AND TEXT POINTER ON THE STACK
1588 06F8                  | ;[M80] AFTER ELIMINATING ALL THE "FOR" ENTRIES IN FRONT OF THE "GOSUB"
1589 06F8                  | ;[M80] ENTRY
1590 06F8 : C0         [M80] RETURN: ret     nz              ;[M80] BLOW HIM UP IF THERE ISN'T A TERMINATOR
1591 06F9 : 16 FF                    ld      d,255           ;[M80] MAKE SURE VARIABLE POINTER IN [D,E] NEVER GETS MATCHED
1592 06FB : CD 9F 03                 call    FNDFOR          ;[M80] GO PAST ALL THE "FOR" ENTRIES
1593 06FE : F9                       ld      sp,hl           ;[M80] UPDATE THE STACK
1594 06FF : FE 8C                    cp      GOSUTK          ;
1595 0701 : 1E 04                    ld      e,ERRRG         ;[M80] ERROR ERRRG IS "RETURN WITHOUT GOSUB"
1596 0703 : C2 DB 03                 jp      nz,ERROR        ;
1597 0706 : E1                       pop     hl              ;GET LINE # "GOSUB" WAS FROM
1598 0707 : 22 4D 38                 ld      (CURLIN),hl     ;PUT IT INTO CURLIN
1599 070A : 23                       inc     hl              ;
1600 070B : 7C                       ld      a,h             ;
1601 070C : B5                       or      l               ;;Is line number $FFFF
1602 070D : 20 07                    jr      nz,RETU1        ;;No, carry on
1603 070F : 3A CC 38                 ld      a,(USFLG)       ;
1604 0712 : B7                       or      a               ;;Is flag set?
1605 0713 : C2 01 04                 jp      nz,STPRDY       ;;Yes, abort to direct mode
1606 0716 : 21 2C 06   (M65) RETU1:  ld      hl,NEWSTT       ;[M80] PUT RETURN ADDRESS OF "NEWSTT" BACK ON STACK
1607 0719 : E3                       ex      (sp),hl         ;[M80] GET TEXT POINTER FROM "GOSUB"
1608 071A : 3E                       byte    $3E             ;{M80} "LD A," AROUND POP HL
1609 071B : E1         [M80] DATAH:  pop     hl              ;[M80] GET TEXT POINTER OFF STACK
1610 071C : 01         [M80] DATA:   byte    $01             ;[M80] "LD BC," TO PICK UP ":" INTO C AND SKIP
1611 071D : 3A                       byte    ':'             ;{M80} ":" ONLY APPLIES IF QUOTES HAVE MATCHED UP
1612 071E : 0E         [M80] REM:    byte    $0E             ;[M80] "LD C,"   THE ONLY TERMINATOR IS ZERO
1613 071F : 00                       byte    0               ;[M80] NO-OPERATION "DATA" ACTUALLY EXECUTES THIS 0
1614 0720 : 06 00                    ld      b,0             ;[M80] INSIDE QUOTES THE ONLY TERMINATOR IS ZERO
1615 0722 : 79         (M80) EXCHQT: ld      a,c             ;[M80] WHEN A QUOTE IS SEEN THE SECOND
1616 0723 : 48                       ld      c,b             ;[M80] TERMINATOR IS TRADED, SO IN "DATA"
1617 0724 : 47                       ld      b,a             ;[M80] COLONS INSIDE QUOTATIONS WILL HAVE NO EFFECT
1618 0725 : 7E         (M80) REMER:  ld      a,(hl)          ;[M80] GET A CHAR
1619 0726 : B7                       or      a               ;[M80] ZERO IS ALWAYS A TERMINATOR
1620 0727 : C8                       ret     z               ;
1621 0728 : B8                       cp      b               ;[M80] TEST FOR THE OTHER TERMINATOR
1622 0729 : C8                       ret     z               ;
1623 072A : 23                       inc     hl              ;
1624 072B : FE 22                    cp      '"'             ;[M80] IS IT A QUOTE?
1625 072D : 28 F3                    jr      z,EXCHQT        ;[M80] IF SO TIME TO TRADE
1626 072F : 18 F4                    jr      REMER           ;
1627 0731
1628 0731 : CD D1 10   [M80] LET:    call    PTRGET          ;[M80] GET POINTER TO VARIABLE INTO [D,E]
1629 0734 : CF                       rst     SYNCHK          ;[M80]
1630 0735 : B0                       byte    EQUATK          ;[M80] CHECK FOR "="
1631 0736 : D5                       push    de              ;[M80] SAVE THE VARIABLE POINTER
1632 0737 : 3A AB 38                 ld      a,(VALTYP)      ;{M80} REMEMBER THE VARIABLE TYPE
1633 073A : F5                       push    af              ;
1634 073B : CD 85 09                 call    FRMEVL          ;[M80] GET THE VALUE OF THE FORMULA
1635 073E : F1                       pop     af              ;[M80] GET THE VALTYP OF THE VARIABLE INTO [A] INTO FAC
1636 073F : E3                       ex      (sp),hl         ;[M80] [H,L]=POINTER TO VARIABLE, TEXT POINTER ON TOP OF STACK
1637 0740 : 22 CE 38                 ld      (SAVTXT),hl     ;[???] PLACE TO SAVE THE VALUE
1638 0743 : 1F                       rra                     ;
1639 0744 : CD 77 09                 call    CHKVAL          ;[M65] MAKE SURE "VALTYP" MATCHES CARRY AND SET ZERO FLAG FOR NUMERIC
1640 0747 : CA 79 07                 jp      z,COPNUM        ;[M80] NUMERIC, SO FORCE IT AND COPY
1641 074A
1642 074A : E5         [M80] INPCOM: push    hl              ;
1643 074B : 2A E4 38                 ld      hl,(FACLO)      ;[M80] GET POINTER TO THE DESCRIPTOR OF THE RESULT
1644 074E : E5                       push    hl              ;[M80] SAVE THE POINTER AT THE DESCRIPTOR
1645 074F : 23                       inc     hl              ;
1646 0750 : 23                       inc     hl              ;
1647 0751 : 5E                       ld      e,(hl)          ;
1648 0752 : 23                       inc     hl              ;
1649 0753 : 56                       ld      d,(hl)          ;
1650 0754 : 2A 4F 38                 ld      hl,(TXTTAB)     ;[M80] IF THE DATA IS IN BUF, COPY
1651 0757 : E7                       rst     COMPAR          ;[M80] SINCE BUF CHANGES ALL THE TIME
1652 0758 : 30 0E                    jr      nc,INBUFC       ;[M80] GO COPY, IF DATA REALLY IS IN BUF
1653 075A : 2A DA 38                 ld      hl,(STREND)     ;[M80] SEE IF IT POINTS INTO STRING SPACE
1654 075D : E7                       rst     COMPAR          ;[M80] IF NOT DON'T COPY
1655 075E : D1                       pop     de              ;[M80] GET BACK THE POINTER AT THE DESCRIPTOR
1656 075F : 30 0F                    jr      nc,DNTCPY       ;[M80] DON'T COPY LITERALS
1657 0761 : 21 BD 38                 ld      hl,DSCTMP       ;[M80] NOW, SEE IF ITS A VARIABLE BY SEEING IF THE DESCRIPTOR
1658 0764 : E7                       rst     COMPAR          ;[M80] IS IN THE TEMPORARY STORAGE AREA (BELOW DSCTMP)
1659 0765 : 30 09                    jr      nc,DNTCPY       ;[M80] DON'T COPY IF ITS NOT A VARIABLE
1660 0767 : 3E                       byte    $3E             ;[M80] SKIP THE NEXT BYTE WITH A "MVI A,"
1661 0768 : D1         [M80] INBUFC: pop     de              ;[M80] GET THE POINTER TO THE DESCRIPTOR IN [D,E]
1662 0769 : CD E4 0F                 call    FRETMS          ;[M80] FREE UP A TEMORARY POINTING INTO BUF
1663 076C : EB                       ex      de,hl           ;[M80] STRCPY COPIES [H,L]
1664 076D : CD 39 0E                 call    STRCPY          ;[M80] COPY VARIABLES IN STRING SPACE OR STRINGS WITH DATA IN BUF
1665 0770 : CD E4 0F   (M80) DNTCPY: call    FRETMS          ;[M80] FREE UP TEMPORARY WITHOUT FREEING UP ANY STRING SPACE
1666 0773 : E1                       pop     hl              ;[M80]
1667 0774 : CD 3D 15                 call    MOVE            ;[M80] COPY A DESCRIPTOR OR A VALUE
1668 0777 : E1                       pop     hl              ;[M80] GET THE TEXT POINTER BACK
1669 0778 : C9                       ret                     ;
1670 0779
1671 0779 : E5         [M80] COPNUM: push    hl
1672 077A : CD 3A 15                 call    MOVMF           ;COPY A DESCRIPTOR OR A VALUE
1673 077D : D1                       pop     de              ;FOR "FOR" POP OFF POINTER AT LOOP VARIABLE INTO [D,E]
1674 077E : E1                       pop     hl              ;GET THE TEXT POINTER BACK
1675 077F : C9                       ret
1676 0780
1677 0780                    ;{M80} ON..GOTO, ON GOSUB CODE
1678 0780 : F7         [M80] ONGOTO: rst     HOOKDO          ;
1679 0781 : 19         {~~~} HOOK25: byte    25              ;
1680 0782 : CD 54 0B   {M80] NTOERR: call    GETBYT          ;[M80] GET VALUE INTO [E]
1681 0785 : 7E               OMGOTO  ld      a,(hl)          ;[M80] GET THE TERMINATOR BACK
1682 0786 : 47                       ld      b,a             ;[M80] SAVE THIS CHARACTER FOR LATER
1683 0787 : FE 8C                    cp      GOSUTK          ;[M80] AN "ON ... GOSUB" PERHAPS?
1684 0789 : 28 03                    jr      z,ISGOSU        ;[M80] YES, SOME FEATURE USE
1685 078B : CF                       rst     SYNCHK          ;
1686 078C : 88                       byte    GOTOTK          ;[M80] OTHERWISE MUST BE "GOTO"
1687 078D : 2B                       dec     hl              ;[M80] BACK UP CHARACTER POINTER
1688 078E : 4B         (M80) ISGOSU: ld      c,e             ;[M80] GET COUNT INTO [C]
1689 078F : 0D         (M80) LOOPON: dec     c               ;[M80] SEE IF ENOUGH SKIPS
1690 0790 : 78                       ld      a,b             ;[M80] PUT DISPATCH CHARACTER IN PLACE
1691 0791 : CA 51 06                 jp      z,GONE2         ;[M80] IF DONE, GO OFF
1692 0794 : CD 9D 06                 call    LINGET          ;[M80] SKIP OVER A LINE #
1693 0797 : FE 2C                    cp      ','             ;[M80] IS IT A COMMA?
1694 0799 : C0                       ret     nz              ;{M80} NO COMMA MUST BE THE END OF THE LINE
1695 079A : 18 F3                    jr      LOOPON          ;[M80] CONTINUE GOBBLING LINE #S
1696 079C
1697 079C                    ;[M80] IF ... THEN CODE
1698 079C : CD 85 09   [M80] IFS:    call    FRMEVL          ;[M80] EVALUATE A FORMULA
1699 079F : 7E                       ld      a,(hl)          ;[M80] GET TERMINATING CHARACTER OF FORMULA
1700 07A0 : FE 88                    cp      GOTOTK          ;[M80] ALLOW "GOTO" AS WELL
1701 07A2 : 28 03                    jr      z,OKGOTO        ;
1702 07A4 : CF                       rst     SYNCHK          ;
1703 07A5 : A5                       byte    THENTK          ;[M80] MUST HAVE A THEN
1704 07A6 : 2B                       dec     hl              ;
1705 07A7 : CD 75 09   [M80] OKGOTO: call    CHKNUM          ;[M65] 0=FALSE. ALL OTHERS TRUE
1706 07AA : EF                       rst     FSIGN           ;
1707 07AB : CA 1E 07                 jp      z,REM           ;[M65] SKIP REST OF STATEMENT
1708 07AE : D7         {M80} DOCOND: rst     CHRGET          ;[M80] PICK UP THE FIRST LINE # CHARACTER
1709 07AF : DA DC 06                 jp      c,GOTO          ;[M80] DO A "GOTO"
1710 07B2 : C3 50 06                 jp      GONE3           ;[M80] EXECUTE STATEMENT, NOT GOTO
1711                         ;
1712 07B5 : 3E 01      [M80] LPRINT: ld      a,1             ;SAY NON ZERO
1713 07B7 : 32 47 38                 ld      (PRTFLG),a      ;SAVE AWAY
1714 07BA : 2B         [M80] NEWCHR: dec     hl              ;
1715 07BB : D7                       rst     CHRGET          ;[M80] GET ANOTHER CHARACTER
1716 07BC : F7         [M80] PRINT:  rst     HOOKDO          ;
1717 07BD : 06         {~~~} HOOK6:  byte    6               ;
1718 07BE : CC EA 19                 call    z,CRDO          ;[M80] PRINT CRLF IF END WITHOUT PUNCTUATION
1719 07C1 : CA 66 08   (M80) PRINTC: jp      z,FINPRT        ;{M80} FINISH BY RESETTING FLAGS, TERMINATOR SHOULD NOY CRLF
1720 07C4 : FE A0                    cp      TABTK           ;
1721 07C6 : CA 3A 08                 jp      z,TABER         ;[M80] THE TAB FUNCTION?
1722 07C9 : FE A3                    cp      SPCTK           ;
1723 07CB : CA 3A 08                 jp      z,TABER         ;[M80] THE SPC FUNCTION?
1724 07CE : E5                       push    hl              ;{M80} SAVE THE TEXT POINTER
1725 07CF : FE 2C                    cp      ','             ;
1726 07D1 : 28 44                    jr      z,COMPRT        ;[M80] IS IT A COMMA?
1727 07D3 : FE 3B                    cp      $3B             ;{M80} IS IT A ";"
1728 07D5 : CA 61 08                 jp      z,NOTABR        ;
1729 07D8 : C1                       pop     bc              ;[M80] GET RID OF OLD TEXT POINTER
1730 07D9 : CD 85 09                 call    FRMEVL          ;[M80] EVALUATE THE FORMULA
1731 07DC : E5                       push    hl              ;[M80] SAVE TEXT POINTER
1732 07DD : 3A AB 38                 ld      a,(VALTYP)      ;[M80] SEE IF WE HAVE A STRING
1733 07E0 : B7                       or      a               ;
1734 07E1 : C2 11 08                 jp      nz,STRDON       ;[M80] IF SO, PRINT SPECIALY
1735 07E4 : CD 80 16                 call    FOUT            ;[M80] MAKE A NUMBER INTO A STRING
1736 07E7 : CD 5F 0E                 call    STRLIT          ;[M80] MAKE IT  A STRING
1737 07EA : 36 20                    ld      (hl),' '        ;[M80] PUT A SPACE AT THE END
1738 07EC : 2A E4 38                 ld      hl,(FACLO)      ;[M80] SIZE BYTE IS FIRST IN DESCRIPTOR
1739 07EF : 3A 47 38                 ld      a,(PRTFLG)      ;
1740 07F2 : B7                       or      a               ;
1741 07F3 : 28 08                    jr      z,ISTTY         ;[M80] LPT OR TTY?
1742 07F5 : 3A 46 38                 ld      a,(LPTPOS)      ;
1743 07F8 : 86                       add     a,(hl)          ;
1744 07F9 : FE 84                    cp      LPTSIZ          ;[M80] CHECK FOR OVERLAP
1745 07FB : 18 0D                    jr      LINCHK          ;[M80] START ON A NEW LINE
1746 07FD : 3A 48 38   (M80) ISTTY:  ld      a,(LINLEN)      ;
1747 0800 : 47                       ld      b,a             ;
1748 0801 : 3C                       inc     a               ;[M80] NO OVERFLOW LINE WIDTH?
1749 0802 : 28 09                    jr      z,LINCH2        ;[M80] YES
1750 0804 : 3A 00 38                 ld      a,(TTYPOS)      ;[M80] SEE WHERE WE ARE
1751 0807 : 86                       add     a,(hl)          ;
1752 0808 : 3D                       dec     a               ;[M80] ACTUALLY EQUAL TO LINE LENGTH IS OK
1753 0809 : B8                       cp      b               ;
1754 080A : D4 EA 19   (M80) LINCHK: call    nc,CRDO         ;[M80] IF SO CRLF
1755 080D : CD A0 0E   (M80) LINCH2: call    STRPRT          ;[M80] PRINT THE NUMBER
1756 0810 : AF                       xor     a               ;
1757 0811 : C4 A0 0E   (M80) STRDON: call    nz,STRPRT       ;[M80] PRINT THE NUMBER
1758 0814 : E1                       pop     hl              ;
1759 0815 : 18 A3                    jr      NEWCHR          ;[M80[ PRINT SOME MORE
1760 0817 : 3A 47 38   (M80) COMPRT: ld      a,(PRTFLG)      ;[M80[ OUTPUT TO THE LINE PRINTER?
1761 081A : B7                       or      a               ;[M80[ NON-ZERO MEANS YES
1762 081B : 28 08                    jr      z,ISCTTY        ;[M80[ NO, DO TELETYPE COMMA
1763 081D : 3A 46 38                 ld      a,(LPTPOS)      ;[M80[ ARE WE USING INFINITE WIDTH?
1764 0820 : FE 70                    cp      112             ;[M80[ CHECK IF NO MORE COMMA FIELDS
1765 0822 : C3 2D 08                 jp      CHKCOM          ;[M80[ USE TELETYPE CHECK
1766 0825 : 3A 49 38   (M80) ISCTTY: ld      a,(CLMLST)      ;[M80] POSITION OF LAST COMMA COLUMN
1767 0828 : 47                       ld      b,a             ;
1768 0829 : 3A 00 38                 ld      a,(TTYPOS)      ;[M80] GET TELETYPE POSITION
1769 082C : B8                       cp      b               ;
1770 082D : D4 EA 19   (M80) CHKCOM: call    nc,CRDO         ;[M80] TYPE CRLF
1771 0830 : D2 61 08                 jp      nc,NOTABR       ;[M80] AND QUIT IF BEYOND THE LAST COMMA FIELD
1772 0833 : D6 0E      (M80) MORCOM: sub     CLMWID          ;[M80] GET [A] MODULUS CLMWID
1773 0835 : 30 FC                    jr      nc,MORCOM       ;
1774 0837 : 2F                       cpl                     ;[M80] FILL OUT TO AN EVEN CLMWID: CLMWID-[A] MOD CLMWID SPACES
1775 0838 : 18 20                    jr      ASPA2           ;[M80] GO PRINT [A]+1 SPACES
1776 083A : F5         (M80) TABER:  push    af              ;[M80] REMEMBER IF [A]=SPCTK OR TABTK
1777 083B : CD 53 0B                 call    GTBYTC          ;[M80] EVALUATE THE ARGUMENT
1778 083E : CF                       rst     SYNCHK          ;
1779 083F : 29                       byte    ')'             ;
1780 0840 : 2B                       dec     hl              ;
1781 0841 : F1                       pop     af              ;[M80] GET BACK SPCTK OR TABTK
1782 0842 : D6 A3                    sub     SPCTK           ;[M80] WAS IT SPCTK?
1783 0844 : E5                       push    hl              ;[M80] SAVE THE TEXT POINTER
1784 0845 : 28 0F                    jr      z,DOSIZT        ;[M80] VALUE IN [A]
1785 0847 : 3A 47 38                 ld      a,(PRTFLG)      ;[M80] LINE PRINTER OR TTY?
1786 084A : B7                       or      a               ;[M80] NON-ZERO MEANS LPT
1787 084B : CA 53 08                 jp      z,TTYIST        ;
1788 084E : 3A 46 38                 ld      a,(LPTPOS)      ;[M80] GET LINE PRINTER POSITION
1789 0851 : 18 03                    jr      DOSIZT          ;
1790 0853 : 3A 00 38   (M80) TTYIST: ld      a,(TTYPOS)      ;[M80] GET TELETYPE PRINT POSITION
1791 0856 : 2F         (M80) DOSIZT: cpl                     ;[M80] PRINT [E]-[A] SPACES
1792 0857 : 83                       add     a,e             ;
1793 0858 : 30 07                    jr      nc,NOTABR       ;[M80] PRINT IF PAST CURRENT
1794 085A : 3C         (M80) ASPA2:  inc     a               ;
1795 085B : 47                       ld      b,a             ;[M80] [B]=NUMBER OF SPACES TO PRINT
1796 085C : 3E 20                    ld      a,' '           ;[M80] [A]=SPACE
1797 085E : DF         (M80) REPOUT: rst     OUTCHR          ;[M80] PRINT [A]
1798 085F : 10 FD                    djnz    REPOUT          ;[M80] DECREMENT THE COUNT
1799 0861 : E1         (M80) NOTABR: pop     hl              ;[M80] PICK UP TEXT POINTER
1800 0862 : D7                       rst     CHRGET          ;[M80] AND THE NEXT CHARACTER
1801 0863 : C3 C1 07                 jp      PRINTC          ;{M80} WE JUST PRINTED SPACES, DON'T CALL CRDO IF END OF THE LINE
1802 0866 : F7         (M80) FINPRT: rst     HOOKDO          ;
1803 0867 : 07         {~~~} HOOK7:  byte    7               ;
1804 0868 : AF                       xor     a               ;
1805 0869 : 32 47 38                 ld      (PRTFLG),a      ;[M80] ZERO OUT PTRFIL
1806 086C : C9                       ret                     ;
1807 086D
1808 086D : 3F 52 65 64      TRYAGN: byte    "?Redo from start",13,10,0
1809 0871 : 6F 20 66 72
1810 0875 : 6F 6D 20 73
1811 0879 : 74 61 72 74
1812 087D : 0D 0A 00
1813 0880
1814 0880                  + ;[M80]  HERE WHEN THE DATA THAT WAS TYPED IN OR IN "DATA" STATEMENTS
1815 0880                  | ;[M80]  IS IMPROPERLY FORMATTED. FOR "INPUT" WE START AGAIN.
1816 0880                  | ;[M80]  FOR "READ" WE GIVE A SYNTAX ERROR AT THE DATA LINE.
1817 0880                  | ;
1818 0880 : F7               TRMNOK: rst     HOOKDO          ;
1819 0881 : 08         {~~~} HOOK8:  byte    8               ;
1820 0882 : 3A CD 38                 ld      a,(FLGINP)      ;[M80] WAS IT READ OR INPUT?
1821 0885 : B7                       or      a               ;[M80] ZERO=INPUT
1822 0886 : C2 BE 03                 jp      nz,DATSNE       ;[M80] GIVE ERROR AT DATA LINE
1823 0889 : C1                       pop     bc              ;[M80] GET RID OF THE POINTER INTO THE VARIABLE LIST
1824 088A : 21 6D 08                 ld      hl,TRYAGN       ;[M80] PRINT "?REDO FROM START"
1825 088D : CD 9D 0E                 call    STROUT          ;
1826 0890 : C3 01 0C                 jp      GTMPRT          ;
1827 0893
1828 0893 : F7         [M80] INPUT:  rst     HOOKDO          ;
1829 0894 : 1A         {~~~} HOOK26: byte    26              ;
1830 0895 : CD 45 0B                 call    ERRDIR          ;[M65] DIRECT IS NOT OK
1831 0898 : 7E                       ld      a,(hl)          ;
1832 0899 : FE 22      {M80} QTINP:  cp      '"'             ;[M80] IS IT A QUOTE?
1833 089B : 3E 00                    ld      a,0             ;[M80] BE TALKATIVE
1834 089D : C2 AA 08                 jp      nz,NOTQTI       ;[M65] NO MESSAGE
1835 08A0 : CD 60 0E                 call    STRLTI          ;[M65] LITERALIZE THE STRING IN TEXT
1836 08A3 : CF         {M80} NTICMA: rst     SYNCHK          ;
1837 08A4 : 3B                       byte    ';'             ;[M80] MUST END WITH SEMICOLON
1838 08A5 : E5         {M80} INPCMA: push    hl              ;[M80] REMEMBER WHERE IT ENDED
1839 08A6 : CD A0 0E                 call    STRPRT          ;[M80] PRINT IT OUT
1840 08A9 : 3E                       byte    $3E             ;;[LD A,] over next instruction
1841 08AA : E5         (M80) NOTQTI: push    hl              ;{M80} SAVE TEXT POINTER
1842 08AB : CD 5B 0D                 call    QINLIN          ;[M65] TYPE "?" AND INPUT A LINE OF TEXT.
1843 08AE : C1                       pop     bc              ;{M80} GET BACK THE TEXT POINTER
1844 08AF : DA 26 0C                 jp      c,STPEND        ;{M80} IF CONTROL-C, STOP
1845 08B2 : 23                       inc     hl              ;
1846 08B3 : 7E                       ld      a,(hl)          ;
1847 08B4 : B7                       or      a               ;
1848 08B5 : 2B                       dec     hl              ;
1849 08B6 : C5                       push    bc              ;
1850 08B7 : CA 1B 07                 jp      z,DATAH         ;
1851 08BA : 36 2C      {M80} INPCN3: ld      (hl),','        ;[M80] SETUP COMMA AT BUFMIN
1852 08BC : 18 05                    jr      INPCON          ;
1853 08BE
1854 08BE                  + ;[M80] READ STATEMENT
1855 08BE                  | ;[M80] IN THE PROCESSING OF DATA AND READ STATEMENTS:
1856 08BE                  | ;[M80] ONE POINTER POINTS TO THE DATA (IE THE NUMBERS BEING FETCHED)
1857 08BE                  | ;[M80] AND ANOTHER POINTS TO THE LIST OF VARIABLES
1858 08BE                  | ;[M80]
1859 08BE                  | ;[M80] THE POINTER INTO THE DATA ALWAYS STARTS POINTING TO A
1860 08BE                  | ;[M80] TERMINATOR -- A , : OR END-OF-LINE
1861 08BE : E5         [M80] READ:   push    hl              ;[M80] SAVE THE TEXT POINTER
1862 08BF : 2A DC 38                 ld      hl,(DATPTR)     ;[M80] GET LAST DATA LOCATION
1863 08C2 : F6                       byte    $F6             ;[M80] "ORI" TO SET [A] NON-ZERO
1864 08C3 : AF         (M80) INPCON: xor     a               ;[M80] SET FLAG THAT THIS IS AN INPUT
1865 08C4 : 32 CD 38                 ld      (FLGINP),a      ;[M80] STORE THE FLAG
1866 08C7 : E3                       ex      (sp),hl         ;[M80] [H,L]=VARIABLE LIST POINTER
1867 08C8 : 01                       byte    $01             ;[M80] "LD BC," OVER THE NEXT 2
1868 08C9 : CF         [M80] LOPDT2: rst     SYNCHK
1869 0BCA : 2C                       byte    ','             ;[M80] MAKE SURE THERE IS A ","
1870 08CB : CD D1 10   {M80} LOPDAT: call    PTRGET          ;[M80] GET THE POINTER TO A VARIABLE INTO [D,E]
1871 08CE : E3                       ex      (sp),hl         ;;Swap with Data List Pointer
1872 08CF                    ;[M80] NOTE AT THIS POINT WE HAVE A VARIABLE WHICH WANTS DATA
1873 08CF                    ;[M80] AND SO WE MUST GET DATA OR COMPLAIN
1874 08CF : D5                       push    de              ;[M80] SAVE THE POINTER TO THE VARIABLE
1875 08D0 : 7E                       ld      a,(hl)          ;[M80] READ DATA LIST TERMINATOR
1876 08D1 : FE 2C                    cp      ','             ;
1877 08D3 : 28 1B                    jr      z,DATBK         ;[M80] A COMMA SO A VALUE MUST FOLLOW
1878 08D5 : 3A CD 38                 ld      a,(FLGINP)      ;[M80] SEE WHAT TYPE OF STATEMENT THIS WAS
1879 08D8 : B7                       or      a               ;;???ZERO FOR INPUT, OTHERWISE READ
1880 08D9 : C2 53 09                 jp      nz,DATLOP       ;[M80] SEARCH FOR ANOTHER DATA STATEMENT
1881 08DC
1882 08DC : 3E 3F      {M80} GETAGN: ld      a,'?'           ;[M80] TYPE "?" AND INPUT A LINE OF TEXT
1883 08DE : DF                       rst     OUTCHR          ;
1884 08DF : CD 5B 0D                 call    QINLIN          ;
1885 08E2 : D1                       pop     de              ;
1886 08E3 : C1                       pop     bc              ;[M80] TAKE OFF SINCE MAYBE LEAVING
1887 08E4 : DA 26 0C                 jp      c,STPEND        ;[M80] IF EMPTY LEAVE
1888 08E7 : 23                       inc     hl              ;
1889 08E8 : 7E                       ld      a,(hl)          ;
1890 08E9 : 2B                       dec     hl              ;
1891 08EA : B7                       or      a               ;
1892 08EB : C5                       push    bc              ;[M80] PUT BACK  SINCE DIDN'T LEAVE
1893 08EC : CA 1B 07                 jp      z,DATAH
1894 08EF : D5                       push    de              ;{M80} SAVE THE POINTER TO THE VARIABLE
1895 08F0
1896 08F0 : F7         [M80] DATBK:  rst     HOOKDO          ;;Call Extended Hook 28
1897 08F1 : 1C         {~~~} HOOK28: byte    28              ;
1898 08F2 : 3A AB 38                 ld      a,(VALTYP)      ;[M80] IS IT A STRING?
1899 08F5 : B7                       or      a               ;
1900 08F6 : 28 1F                    jr      z,NUMINS        ;[M80] IF NUMERIC, USE FIN TO GET IT
1901 08F8 : D7                       rst     CHRGET          ;
1902 08F9 : 57                       ld      d,a             ;[M80] ASSUME QUOTED STRING
1903 08FA : 47                       ld      b,a             ;[M80] SETUP TERMINATORS
1904 08FB : FE 22                    cp      '"'             ;[M80] QUOTE ?
1905 08FD : 28 0C                    jr      z,NOWGET        ;[M80] TERMINATORS OK
1906 08FF : 3A CD 38                 ld      a,(FLGINP)      ;[M80] INPUT SHOULDN'T TERMINATE ON ":"
1907 0902 : B7                       or      a               ;[M80] SEE IF READ OR INPUT
1908 0903 : 57                       ld      d,a             ;[M80] SET D TO ZERO FOR INPUT
1909 0904 : 28 02                    jr      z,NCOLST        ;
1910 0906 : 16 3A                    ld      d,':'           ;[M80] UNQUOTED STRING TERMINATORS
1911 0908 : 06 2C      (M80) NCOLST: ld      b,','           ;[M80] ARE COLON AND COMMA
1912 090A : 2B                       dec     hl              ;[M80] START CHARACTER MUST BE INCLUDED IN THE QUOTED STRING
1913 090B : CD 63 0E   (M80) NOWGET: call    STRLT2          ;[M80] MAKE STRING DESCRIPTOR FOR VALUE AND COPY IF NECESSARY
1914 090E : EB                       ex      de,hl           ;
1915 090F : 21 20 09                 ld      hl,STRDN2       ;[M80] RETURN LOC
1916 0912 : E3                       ex      (sp),hl         ;[M80] [H,L]=PLACE TO STORE VARIABLE VALUE
1917 0913 : D5                       push    de              ;[M80] TEXT POINTER GOES ON
1918 0914 : C3 4A 07                 jp      INPCOM          ;[M80] DO ASSIGNMENT
1919 0917 : D7         (M80) NUMINS: rst     CHRGET          ;
1920 0918 : CD E5 15                 call    FIN             ;[M80] CALL # INPUTTER
1921 091B : E3                       ex      (sp),hl         ;*** tail end of [M80] FIN?
1922 091C : CD 3A 15                 call    MOVMF           ;
1923 091F : E1                       pop     hl              ;
1924 0920 : 2B         (M80) STRDN2: dec     hl              ;
1925 0921 : D7                       rst     CHRGET          ;
1926 0922 : 28 05                    jr      z,TRMOK         ;
1927 0924 : FE 2C                    cp      ','             ;
1928 0926 : C2 80 08                 jp      nz,TRMNOK       ;[M80] ENDED PROPERLY?
1929 0929 : E3         [M80] TRMOK:  ex      (sp),hl         ;
1930 092A : 2B                       dec     hl              ;[M80] LOOK AT TERMINATOR
1931 092B : D7                       rst     CHRGET          ;[M80] AND SET UP CONDITION CODES
1932 092C : C2 C9 08                 jp      nz,LOPDT2       ;[M80] NOT ENDING, CHECK FOR COMMA AND GET ANOTHER VARIABLE
1933 092F : D1                       pop     de              ;[M80] POP OFF THE POINTER INTO DATA
1934 0930 : 3A CD 38                 ld      a,(FLGINP)      ;[M80] FETCH THE STATEMENT TYPE FLAG
1935 0933 : B7                       or      a               ;
1936 0934 : EB                       ex      de,hl           ;[M80] INPUT STATEMENT
1937 0935 : C2 1A 0C                 jp      nz,RESFIN       ;[M80] UPDATE DATPTR
1938 0938 : D5                       push    de              ;[M80] SAVE THE TEXT POINTER
1939 0939 : B6                       or      (hl)            ;
1940 093A : 21 42 09                 ld      hl,EXIGNT       ;
1941 093D : C4 9D 0E                 call    nz,STROUT       ;[M65] TYPE "?EXTRA IGNORED"
1942 0940 : E1                       pop     hl              ;
1943 0941 : C9                       ret                     ;[M65[ DO NEXT STATEMENT
1944 0942
1945 0942 : 3F 45 78 74[M65] EXIGNT: byte    "?Extra ignored",13,10,0
1946 0946 : 72 61 20 69
1947 094A : 67 6E 6F 72
1948 094E : 65 64 0D 0A
1949 0952 : 00
1950 0953
1951 0953                  + ;[M80] THE SEARCH FOR DATA STATMENTS IS MADE BY USING THE EXECUTION CODE
1952 0953                  | ;[M80] FOR DATA TO SKIP OVER STATEMENTS. THE START WORD OF EACH STATEMENT
1953 0953                  | ;[M80] IS COMPARED WITH $DATA. EACH NEW LINE NUMBER
1954 0953                  | ;[M80] IS STORED IN DATLIN SO THAT IF AN ERROR OCCURS WHILE READING
1955 0953                  | ;[M80] DATA THE ERROR MESSAGE WILL GIVE THE LINE NUMBER OF THE
1956 0953                  | ;[M80] ILL-FORMATTED DATA
1957 0953                  | ;
1958 0953 : CD 1C 07   [M80] DATLOP: call    DATA            ;
1959 0956 : B7                       or      a               ;
1960 0957 : 20 11                    jr      nz,NOWLIN       ;
1961 0959 : 23                       inc     hl              ;
1962 095A : 7E                       ld      a,(hl)          ;
1963 095B : 23                       inc     hl              ;
1964 095C : B6                       or      (hl)            ;
1965 095D : 1E 06                    ld      e,ERROD         ;[M80] NO DATA IS ERROR ERROD
1966 095F : CA DB 03                 jp      z,ERROR         ;[M80] IF SO COMPLAIN
1967 0962 : 23                       inc     hl              ;[M80] SKIP PAST LINE #
1968 0963 : 5E                       ld      e,(hl)          ;[M80] GET DATA LINE #
1969 0964 : 23                       inc     hl              ;
1970 0965 : 56                       ld      d,(hl)          ;
1971 0966 : ED 53 C9 38              ld      (DATLIN),de     ;
1972 096A : D7               NOWLIN: rst     CHRGET          ;[M80] GET THE STATEMENT TYPE
1973 096B : FE 83                    cp      DATATK          ;[M80] IS IS "DATA"?
1974 096D : 20 E4                    jr      nz,DATLOP       ;[M80] NOT DATA SO LOOK SOME MORE
1975 096F : C3 F0 08                 jp      DATBK           ;[M80] CONTINUE READING
1976 0972
1977 0972                 +  ;[M65] THESE ROUTINES CHECK FOR CERTAIN "VALTYP".
1978 0972                 |  ;[M65] [C] IS NOT PRESERVED.
1979 0972                 |  ;
1980 0972 : CD 85 09   [M65] FRMNUM: call    FRMEVL          ;{M80} EVALUATE A FORMULA
1981 0975 : F6         [M65] CHKNUM: byte    $F6             ;;"OR $37" to skip next instruction
1982 0976 : 37         [M65] CHKSTR: scf                     ;;Set Carry to match strings
1983 0977 : 3A AB 38   [M65] CHKVAL: ld      a,(VALTYP)      ;
1984 097A : 8F                       adc     a,a             ;;Shift Left and Copy in Cary
1985 097B : B7                       or      a               ;;Set Flags
1986 097C : E8                       ret     pe              ;;Return if Overflow
1987 097D : C3 D9 03   [M65] CHKERR: jp      TMERR           ;;Else TYPE MISMATCH Error
1988 0980
1989 0980                  + ;[M80] THE FORMULA EVALUATOR STARTS WITH
1990 0980                  | ;[M80] [H,L] POINTING TO THE FIRST CHARACTER OF THE FORMULA.
1991 0980                  | ;[M80] AT THE END [H,L] POINTS TO THE TERMINATOR.
1992 0980                  | ;[M80] THE RESULT IS LEFT IN THE FAC.
1993 0980                  | ;[M80] ON RETURN [A] DOES NOT REFLECT THE TERMINATING CHARACTER
1994 0980                  | ;[M80]
1995 0980                  | ;[M80] THE FORMULA EVALUATOR USES THE OPERATOR TABLE (OPTAB)
1996 0980                  | ;[M80] TO DETERMINE PRECEDENCE AND DISPATCH ADDRESSES FOR
1997 0980                  | ;[M80] EACH OPERATOR.
1998 0980                  | ;[M80] A TEMPORARY RESULT ON THE STACK HAS THE FOLLOWING FORMAT
1999 0980                  | ;[M80]
2000 0980                  | ;[M80] THE ADDRESS OF 'RETAOP' -- THE PLACE TO RETURN ON COMPLETION
2001 0980                  | ;[M80] OF OPERATOR APPLICATION
2002 0980                  | ;[M80]
2003 0980                  | ;[M80] THE FLOATING POINT TEMPORARY RESULT
2004 0980                  | ;[M80]
2005 0980                  | ;[M80] THE ADDRESS OF THE OPERATOR ROUNTINE
2006 0980                  | ;[M80]
2007 0980                  | ;[M80] THE PRECEDENCE OF THE OPERATOR
2008 0980                  | ;[M80]
2009 0980                  | ;[M80] TOTAL 10 BYTES
2010 0980                  | ;
2011 0980 : CF         [M80] FRMEQL: rst     SYNCHK          ;
2012 0981 : B0                       byte    EQUATK          ;[M80] CHECK FOR EQUAL SIGN
2013 0982 : 01                       byte    $01             ;[M80] "LD BC," OVER THE NEXT 2
2014 0983 : CF         [M80] FRMPRN: rst     SYNCHK          ;[M80] GET PAREN BEFORE FORMULA
2015 0984 : 28                       byte    '('             ;
2016 0975
2017 0985                  + ;;Evaluate Formula
2018 0985                  | ;[M65] THE FORMULA EVALUATOR STARTS WITH
2019 0985                  | ;[M65] [H,L] POINTING TO THE FIRST CHARACTER OF THE FORMULA.
2020 0985                  | ;[M65] AT THE END [H,L] POINTS TO THE TERMINATOR.
2021 0985                  | ;[M65] THE RESULT IS LEFT IN THE FAC.
2022 0985                  | ;[M65] ON RETURN [A] DOES NOT REFLECT THE TERMINATOR.
2023 0985                  | ;
2024 0985                  | ;[M65] THE FORMULA EVALUATOR USES THE OPERATOR LIST (OPTAB)
2025 0985                  | ;[M65] TO DETERMINE PRECEDENCE AND DISPATCH ADDRESSES FOR
2026 0985                  | ;[M65] EACH OPERATOR.
2027 0985                  | ;[M65] A TEMPORARY RESULT ON THE STACK HAS THE FOLLOWING FORMAT.
2028 0985                  | ;[M65]       THE ADDRESS OF THE OPERATOR ROUTINE.
2029 0985                  | ;[M65]       THE FLOATING POINT TEMPORARY RESULT.
2030 0985                  | ;[M65]       THE PRECEDENCE OF THE OPERATOR.
2031 0985                  | ;
2032 0985 : 2B         [M80] FRMEVL: dec     hl              ;[M80] BACK UP CHARACTER POINTER
2033 0986 : 16 00      [M80] FRMCHK: ld      d,0             ;[M80] INITIAL DUMMY PRECEDENCE IS 0
2034 0988 : D5         [M80] LPOPER: push    de              ;[M80] SAVE PRECEDENCE
2035 0989 : 0E 01                    ld      c,1             ;[M80] EXTRA SPACE NEEDED FOR RETURN ADDRESS
2036 098B : CD A0 0B                 call    GETSTK          ;[M80] MAKE SURE THERE IS ROOM FOR RECURSIVE CALLS
2037 098E : CD FD 09                 call    EVAL            ;[M80] EVALUATE SOMETHING
2038 0991 : 22 D0 38   [N80] TSTOP:  ld      (TENP2),hl      ;[M80] SAVE TEXT POINTER
2039 0994 : 2A D0 38   [M80] RETAOP: ld      hl,(TENP2)      ;[M80] RESTORE TEXT PTR
2040 0997 : C1                       pop     bc              ;[M80] POP OFF THE PRECEDENCE OF OLDOP
2041 0998 : 78                       ld      a,b             ;
2042 0999 : FE 78                    cp      $78             ;
2043 099B : D4 75 09                 call    nc,CHKNUM       ;
2044 099E : 7E         {M80} NOTSTV  ld      a,(hl)          ;[M80] GET NEXT CHARACTER
2045 099F : 22 C3 38                 ld      (TENP3),hl      ;[M80] SAVE UPDATED CHARACTER POINTER
2046 09A2 : FE A8                    cp      PLUSTK          ;[M80] IS IT AN OPERATOR?
2047 09A4 : D8                       ret     c               ;
2048 09A5 : FE B2                    cp      LESSTK+1        ;
2049 09A7 : D0                       ret     nc              ;[M80] NO, ALL DONE
2050 09A8 : FE AF                    cp      GREATK          ;[M80] SOME KIND OF RELATIONAL?
2051 09AA : D2 E2 09                 jp      nc,DORELS       ;[M80] YES, DO IT
2052 09AD : D6 A8                    sub     PLUSTK          ;[M80] SUBTRACT OFFSET FOR FIRST ARITHMETIC
2053 09AF : 5F                       ld      e,a             ;[M80] MUST MULTIPLY BY 3
2054 09B0 : 20 08                    jr      nz,NTPLUS       ;[M80] NOT ADDITION OP
2055 09B2 : 3A AB 38                 ld      a,(VALTYP)      ;[M80] SEE IF LEFT PART IS STRING
2056 09B5 : 3D                       dec     a               ;[M80] SEE IF LEFT PART IS STRING
2057 09B6 : 7B                       ld      a,e             ;[M80] REFETCH OP-VALUE
2058 09B7 : CA 7C 0F                 jp      z,CAT           ;[M80] MUST BE CAT
2059 09BA : 07         (M80) NTPLUS: rlca                    ;[M65] MULTIPLY BY 2
2060 09BB : 83                       add     a,e             ;[M65] BY THREE.
2061 09BC : 5F                       ld      e,a             ;[M65] SET UP FOR LATER
2062 09BD : 21 4C 03   {M65} QPREC1: ld      hl,OPTAB        ;[M80] CREATE INDEX INTO OPTAB
2063 09C0 : 16 00                    ld      d,0             ;[M80] MAKE HIGH BYTE OF OFFSET=0
2064 09C2 : 19                       add     hl,de           ;[M80] ADD IN CALCULATED OFFSET
2065 09C3 : 78                       ld      a,b             ;[M80] [A] GETS OLD PRECEDENCE
2066 09C4 : 56                       ld      d,(hl)          ;[M80] REMEMBER NEW PRECEDENCE
2067 09C5 : BA                       cp      d               ;[M80] OLD-NEW
2068 09C6 : D0                       ret     nc              ;[M80] APPLY OLD OP IF >= PRECEDENCE
2069 09C7 : 23                       inc     hl              ;
2070 09C8 : CD 75 09                 call    CHKNUM          ;
2071 09CB
2072 09CB : C5         [M80] FINTMP: push    bc              ;[M80] SAVE THESE THINGS FOR RETAOP
2073 09CC : 01 94 09                 ld      bc,RETAOP       ;[M80] GENERAL OPERATOR APPLICATION ROUTINE -- DOES TYPE CONVERSIONS
2074 09CF : C5                       push    bc              ;[M80] SAVE PLACE TO GO
2075 09D0 : 43                       ld      b,e             ;;Save dispatch offset and precedence
2076 09D1 : 4A                       ld      c,d             ;
2077 09D2 : CD 13 15                 call    PUSHF           ;[M80] PUT FAC ON STACK
2078 09D5 : 58                       ld      e,b             ;
2079 09D6 : 51                       ld      d,c             ;;Restore dispatch offset and precedence
2080 09D7 : 4E                       ld      c,(hl)          ;;Load FINRE2 address from FINREA into BC
2081 09D8 : 23                       inc     hl              ;
2082 09D9 : 46                       ld      b,(hl)          ;
2083 09DA : 23                       inc     hl              ;;Now HL contains FINRE2 address
2084 09DB : C5                       push    bc              ;;Push FINRE2 address
2085 09DC : 2A C3 38                 ld      hl,(TENP3)      ;REGET THE TEXT POINTER
2086 09DF : C3 88 09                 jp      LPOPER          ;PUSH ON THE PRECEDENCE AND READ MORE FORMULA
2087 09E2
2088 09E2                    ;;Evaluate Logical Operators
2089 09E2 : 16 00      [M80] DORELS: ld      d,0             ;{M80} ASSUME NO RELATION OPS, SETUP HIGH ORDER OF INDEX INTO OPTAB
2090 09E4 : D6 AF      (M80) LOPREL: sub     GREATK          ;[M80] IS THIS ONE RELATION?
2091 09E6 : DA D0 0A                 jp      c,FINREL        ;[M80] RELATIONS ALL THROUGH
2092 09E9 : FE 03                    cp      LESSTK-GREATK+1 ;[M80] IS IT REALLY RELATIONAL?
2093 09EB : D2 D0 0A                 jp      nc,FINREL       ;[M80] NO JUST BIG
2094 09EE : FE 01                    cp      1               ;[M80] SET UP BITS BY MAPPING
2095 09F0 : 17                       rla                     ;[M80] 0 TO 1 1 TO 2 AND 2 TO 4
2096 09F1 : AA                       xor     d               ;[M80] BRING IN THE OLD BITS
2097 09F2 : BA                       cp      d               ;[M80] MAKE SURE RESULT IS BIGGER
2098 09F3 : 57                       ld      d,a             ;[M80] SAVE THE MASK
2099 09F4 : DA C4 03                 jp      c,SNERR         ;[M80] DON'T ALLOW TWO OF THE SAME
2100 09F7 : 22 C3 38                 ld      (TENP3),hl      ;[M80] SAVE CHARACTER POINTER
2101 09FA : D7                       rst     CHRGET          ;[M80] GET THE NEXT CANDIDATE
2102 09FB : 18 E7                    jr      LOPREL          ;
2103 09FD
2104 09FD                    ;[M80] EVALUATE VARIABLE, CONSTANT, FUNCTION CALL
2105 09FD : F7         [M80] EVAL:   rst     HOOKDO          ;
2106 09FE : 09         {~~~} HOOK9:  byte    9               ;
2107 09FF : AF                       xor     a               ;
2108 0A00 : 32 AB 38                 ld      (VALTYP),a      ;[M65] ASSUME VALUE WILL BE NUMERIC
2109 0A03 : D7                       rst     CHRGET          ;
2110 0A04 : CA D6 03                 jp      z,MOERR         ;[M80] TEST FOR MISSING OPERAND - IF NONE GIVE ERROR
2111 0A07 : DA E5 15                 jp      c,FIN           ;[M80] IF NUMERIC, INTERPRET CONSTANT
2112 0A0A : CD C6 0C                 call    ISLETC          ;[M80] VARIABLE NAME?
2113 0A0D : D2 4E 0A                 jp      nc,ISVAR        ;[M80] AN ALPHABETIC CHARACTER MEANS YES
2114 0A10 : FE A8                    cp      PLUSTK          ;[M80] IGNORE "+"
2115 0A12 : 28 E9                    jr      z,EVAL          ;
2116 0A14 : FE 2E      {M65} QDOT:   cp      '.'             ;[M65] LEADING CHARACTER OF CONSTANT?
2117 0A16 : CA E5 15                 jp      z,FIN           ;
2118 0A19 : FE A9                    cp      MINUTK          ;[M80] NEGATION?
2119 0A1B : CA 3D 0A                 jp      z,DOMIN         ;[M65] SHO IS.
2120 0A1E : FE 22                    cp      '"'             ;[M80] STRING CONSTANT?
2121 0A20 : CA 60 0E                 jp      z,STRLTI        ;[M80] IF SO BUILD A TEMPORARY DESCRIPTOR
2122 0A23 : FE A6                    cp      NOTTK           ;[M80] CHECK FOR "NOT" OPERATOR
2123 0A25 : CA 05 0B                 jp      z,NOTER         ;
2124 0A28 : FE A4                    cp      INKETK          ;[M80] INKEY$ FUNCTION?
2125 0A2A : CA FB 19                 jp      z,INKEY         ;
2126 0A2D : FE A2                    cp      FNTK            ;
2127 0A2F : CA 40 0B                 jp      z,FNDOER        ;
2128 0A32 : D6 B2                    sub     ONEFUN          ;[M80] IS IT A FUNCTION CALL
2129 0A34 : D2 5F 0A                 jp      nc,ISFUN        ;[M80] YES, DO IT
2130 0A37                    ;[M80] ONLY POSSIBILITY LEFT IS A FORMULA IN PARENTHESES
2131 0A37 : CD 83 09   [M80] PARCHK: call    FRMPRN          ;[M80] RECURSIVELY EVALUATE THE FORMULA
2132 0A3A : CF                       rst     SYNCHK          ;
2133 0A3B : 29                       byte    ')'             ;
2134 0A3C : C9                       ret                     ;
2135 0A3D
2136 0A3D : 16 7D      [M80] DOMIN:  ld      d,125           ;[M80] A PRECEDENCE BELOW ^ BUT ABOVE ALL ELSE
2137 0A3F : CD 88 09                 call    LPOPER          ;[M80] SO ^ GREATER THAN UNARY MINUS
2138 0A42 : 2A D0 38                 ld      hl,(TENP2)      ;[M80] GET TEXT POINTER
2139 0A45 : E5                       push    hl              ;
2140 0A46 : CD 0B 15                 call    NEG             ;
2141 0A49 : CD 75 09   [M80] LABBCK: call    CHKNUM          ;[M80] FUNCTIONS THAT DON'T RETURN
2142 0A4C : E1                       pop     hl              ;[M80] STRING VALUES COME BACK HERE
2143 0A4D : C9                       ret                     ;
2144 0A4E
2145 0A4E : CD D1 10   [M80] ISVAR:  call    PTRGET          ;[M80] GET A POINTER TO THE VARIABLE IN [D,E]
2146 0A51 : E5         [M80] RETVAR: push    hl              ;[M80] SAVE THE TEXT POINTER
2147 0A52 : EB                       ex      de,hl           ;{M80} PUT THE POINTER TO THE VARIABLE OR STRING DESCRIPTOR
2148 0A53 : 22 E4 38                 ld      (FACLO),hl      ;[M80]IN CASE IT'S STRING STORE POINTER TO THE DESCRIPTOR IN FACLO.
2149 0A56 : 3A AB 38                 ld      a,(VALTYP)      ;[M80]FOR STRINGS WE JUST LEAVE
2150 0A59 : B7                       or      a               ;[M80]A POINTER IN THE FAC
2151 0A5A : CC 20 15                 call    z,MOVFM         ;[M80]THE FAC USING [H,L] AS THE POINTER.
2152 0A5D : E1                       pop     hl              ;[M80]RESTORE THE TEXT POINTER
2153 0A5E : C9                       ret                     ;
2154 0A5F
2155 0A5F                    ;[M80] MOST FUNCTIONS TAKE A SINGLE ARGUMENT.
2156 0A5F                    ;[M80] THE RETURN ADDRESS OF THESE FUNCTIONS IS A SMALL ROUTINE
2157 0A5F                    ;[M80] THAT CHECKS TO MAKE SURE VALTYP IS 0 (NUMERIC) AND POPS OFF
2158 0A5F                    ;[M80] THE TEXT POINTER. SO NORMAL FUNCTIONS THAT RETURN STRING RESULTS (I.E. CHR$)
2159 0A5F                    ;[M80] MUST POP OFF THE RETURN ADDRESS OF LABBCK, AND POP OFF THE
2160 0A5F                    ;[M80] TEXT POINTER AND THEN RETURN TO FRMEVL.
2161 0A5F                    ;[M80]
2162 0A5F                    ;[M80] THE SO CALLED "FUNNY" FUNCTIONS CAN TAKE MORE THAN ONE ARGUMENT.
2163 0A5F                    ;[M80] THE FIRST OF WHICH MUST BE STRING AND THE SECOND OF WHICH
2164 0A5F                    ;[M80] MUST BE A NUMBER BETWEEN 0 AND 256. THE TEXT POINTER IS
2165 0A5F                    ;[M80] PASSED TO THESE FUNCTIONS SO ADDITIONAL ARGUMENTS
2166 0A5F                    ;[M80] CAN BE READ. THE TEXT POINTER IS PASSED IN [D,E].
2167 0A5F                    ;[M80] THE CLOSE PARENTHESIS MUST BE CHECKED AND RETURN IS DIRECTLY
2168 0A5F                    ;[M80] TO FRMEVL WITH [H,L] SETUP AS THE TEXT POINTER POINTING BEYOND THE ")".
2169 0A5F                    ;[M80] THE POINTER TO THE DESCRIPTOR OF THE STRING ARGUMENT
2170 0A5F                    ;[M80] IS STORED ON THE STACK UNDERNEATH THE VALUE OF THE INTEGER
2171 0A5F                    ;[M80] ARGUMENT (2 BYTES)
2172 0A5F                    ;
2173 0A5F              [M80] NUMGFN  =       (CHRTK-ONEFUN)*2+1
2174 0A5F : F7         [M80] ISFUN:  rst     HOOKDO          ;
2175 0A60 : 1B         {~~~} HOOK27  byte    27              ;
2176 0A61 : FE 18                    cp      POINTK-ONEFUN   ;;Is it POINT()
2177 0A63 : CA 68 1A                 jp      z,POINT         ;;Yes, go do it
2178 0A66 : 06 00      {M80} NTMRND: ld      b,0             ;
2179 0A68 : 07                       rlca                    ;[M80] MULTIPLY BY 2
2180 0A69 : 4F                       ld      c,a             ;
2181 0A6A : C5                       push    bc              ;[M80] SAVE THE FUNCTION # ON THE STACK
2182 0A6B : D7                       rst     CHRGET          ;
2183 0A6C : 79                       ld      a,c             ;[M80] LOOK AT FUNCTION #
2184 0A6D : FE 29                    cp      NUMGFN          ;[M80] IS IT PAST LASNUM?
2185 0A6F : 38 16                    jr      c,OKNORM        ;[M80] NO, MUST BE A NORMAL FUNCTION
2186 0A71 : CD 83 09                 call    FRMPRN          ;[M80] EAT OPEN PAREN AND FIRST ARG
2187 0A74 : CF                       rst     SYNCHK          ;
2188 0A75 : 2C                       byte    ','             ;[M80] TWO ARGS SO COMMA MUST DELIMIT
2189 0A76 : CD 76 09                 call    CHKSTR          ;[M80] MAKE SURE THE FIRST ONE WAS STRING
2190 0A79 : EB                       ex      de,hl           ;[M80] [D,E]=TXTPTR
2191 0A7A : 2A E4 38                 ld      hl,(FACLO)      ;[M80] GET PTR AT STRING DESCRIPTOR
2192 0A7D : E3                       ex      (sp),hl         ;[M80] GET FUNCTION #, SAVE THE STRING PTR
2193 0A7E : E5                       push    hl              ;[M80] PUT THE FUNCTION # ON
2194 0A7F : EB                       ex      de,hl           ;[M80] [H,L]=TXTPTR
2195 0A80 : CD 54 0B                 call    GETBYT          ;[M80] [E]=VALUE OF FORMULA
2196 0A83 : EB                       ex      de,hl           ;[M80] TEXT POINTER INTO [D,E], [H,L]=INT VALUE OF SECOND ARGUMENT
2197 0A84 : E3                       ex      (sp),hl         ;[M80] SAVE INT VALUE OF SECOND ARG. [H,L]=FUNCTION NUMBER
2198 0A85 : 18 08                    jr      FINGO           ;[M80] DISPATCH TO FUNCTION
2199 0A87 : CD 37 0A   [M80] OKNORM: call    PARCHK          ;[M80] CHECK OUT THE ARGUMEN AND MAKE SURE ITS FOLLOWED BY ")"
2200 0A8A : E3                       ex      (sp),hl         ;[M80] [H,L]=FUNCTION # AND SAVE TEXT POINTER
2201 0A8B : 11 49 0A                 ld      de,LABBCK       ;[M80] RETURN ADDRESS
2202 0A8E : D5                       push    de              ;[M80] MAKE THEM REALLY COME BACK
2203 0A8F : 01 15 02   (M80) FINGO:  ld      bc,FUNDSP       ;[M80] FUNCTION DISPATCH TABLE
2204 0A92 : 09                       add     hl,bc           ;[M80] ADD ON THE OFFSET
2205 0A93 : 4E                       ld      c,(hl)          ;{M80} FASTER THAN "PUSH HL"
2206 0A94 : 23                       inc     hl              ;
2207 0A95 : 66                       ld      h,(hl)          ;
2208 0A96 : 69                       ld      l,c             ;
2209 0A97 : E9                       jp      (hl)            ;[M80] GO PERFORM THE FUNCTION
2210 0A98
2211 0A98                    ;[M80] THE FOLOWING ROUTINE IS CALLED FROM FIN
2212 0A98                    ;[M80] TO SCAN LEADING SIGNS FOR NUMBERS.
2213 0A98 : 15         [M80] MINPLS: dec     d               ;[M80] SET SIGN OF EXPONENT FLAG
2214 0A99 : FE A9                    cp      MINUTK          ;[M80] NEGATIVE EXPONENT?
2215 0A9B : C8                       ret     z               ;
2216 0A9C : FE 2D                    cp      '-'             ;[M80] NO, RESET FLAG
2217 0A9E : C8                       ret     z               ;
2218 0A9F : 14                       inc     d               ;
2219 0AA0 : FE 2B                    cp      '+'             ;
2220 0AA2 : C8                       ret     z               ;
2221 0AA3 : FE A8                    cp      PLUSTK          ;[M80] IGNORE "+"
2222 0AA5 : C8                       ret     z               ;
2223 0AA6 : 2B                       dec     hl              ;[M80] CHECK IF LAST CHARACTER WAS A DIGIT
2224 0AA7 : C9                       ret                     ;[M80] RETURN WITH NON-ZERO SET
2225 0AA8
2226 0AA8                  + ;;AND and OR Operators
2227 0AA8                  | ;
2228 0AA8                  | ;[M80] DANDOR APPLIES THE "AND" AND "OR" OPERATOR
2229 0AA8                  | ;[M80] AND SHOULD BE USED TO IMPLEMENT ALL LOGICAL OPERATORS.
2230 0AA8                  | ;[M80] WHENEVER AN OPERATOR IS APPLIED, ITS PRECEDENCE IS IN [B].
2231 0AA8                  | ;[M80] THIS FACT IS USED TO DISTINGUISH BETWEEN "AND" AND "OR".
2232 0AA8                  | ;[M80] THE RIGHT HAND ARGUMENT IS COERCED TO INTEGER, JUST AS
2233 0AA8                  | ;[M80] THE LEFT HAND ONE WAS WHEN IT WAS PUSHED ON THE STACK.
2234 0AA8 : F6         [M65] OROP:   byte    $F6             ;[M80] OR $AF" TO SET THE PRECEDENCE "OR"=70
2235 0AA9 : AF         [M65] ANDOP:  xor     a               ;;leave 0 in A for AND
2236 0AAA : F5         [M80] DANDOR: push    af              ;[M80] SAVE THE PRECEDENCE or Operator...
2237 0AAB : CD 75 09                 call    CHKNUM          ;[M65] MUST BE NUMBER
2238 0AAE : CD 82 06                 call    FRCINT          ;COERCE RIGHT HAND ARGUMENT TO INTEGER
2239 0AB1 : F1                       pop     af              ;GET BACK THE PRECEDENCE TO DISTINGUISH "AND" AND "OR"
2240 0AB2 : EB                       ex      de,hl           ;
2241 0AB3 : C1                       pop     bc              ;
2242 0AB4 : E3                       ex      (sp),hl         ;
2243 0AB5 : EB                       ex      de,hl           ;
2244 0AB6 : CD 23 15                 call    MOVFR           ;
2245 0AB9 : F5                       push    af              ;
2246 0ABA : CD 82 06                 call    FRCINT          ;
2247 0ABD : F1                       pop     af              ;
2248 0ABE : C1                       pop     bc              ;
2249 0ABF : 79                       ld      a,c             ;
2250 0AC0 : 21 21 0B                 ld      hl,GIVINT       ;{M80} PLACE TO JUMP WHEN DONE
2251 0AC3 : C2 CB 0A                 jp      nz,NOTAND       ;
2252 0AC6 : A3                       and     e               ;
2253 0AC7 : 4F                       ld      c,a             ;
2254 0AC8 : 78                       ld      a,b             ;
2255 0AC9 : A2                       and     d               ;
2256 0ACA : E9                       jp      (hl)            ;[M80] RETURN THE INTEGER [A,L]
2257 0ACB : B3         [M80] NOTAND: or      e               ;
2258 0ACC : 4F                       ld      c,a             ;
2259 0ACD : 78                       ld      a,b             ;
2260 0ACE : B2                       or      d               ;
2261 0ACF : E9                       jp      (hl)            ;[M80] RETURN THE INTEGER [A,L]
2262 0AD0
2263 0AD0                  + ;[M80] HERE TO BUILD AN ENTRY FOR A RELATIONAL OPERATOR
2264 0AD0                  | ;[M80] STRINGS ARE TREATED SPECIALLY. NUMERIC COMPARES ARE DIFFERENT
2265 0AD0                  | ;[M80] FROM MOST OPERATOR ENTRIES ONLY IN THE FACT THAT AT THE
2266 0AD0                  | ;[M80] BOTTOM INSTEAD OF HAVING RETAOP, DOCMP AND THE RELATIONAL
2267 0AD0                  | ;[M80] BITS ARE STORED. STRINGS HAVE STRCMP,THE POINTER AT THE STRING DESCRIPTOR,
2268 0AD0                  | ;[M80] DOCMP AND THE RELATIONAL BITS.
2269 0AD0                  | ;
2270 0AD0 : 21 E2 0A   [M80] FINREL: ld      hl,FINREA
2271 0AD3 : 3A AB 38                 ld      a,(VALTYP)      ;[M80] SEE IF WE HAVE A NUMERIC COMPARE
2272 0AD6 : 1F                       rra                     ;{M65} GET VALUE TYPE INTO CARRY
2273 0AD7 : 7A                       ld      a,d             ;
2274 0AD8 : 17                       rla                     ;{M65} PUT VALTYP INTO LOW ORDER BIT OF MASK
2275 0AD9 : 5F                       ld      e,a             ;[M80] DISPATCH OFFSET FOR COMPARES IN APPLOP
2276 0ADA : 16 64                    ld      d,100           ;{MM80] [A]=OLD PRECEDENCE
2277 0ADC : 78                       ld      a,b             ;
2278 0ADD : BA                       cp      d               ;[M80] RELATIONALS HAVE PRECEDENCE 100
2279 0ADE : D0                       ret     nc              ;[M80] APPLY EARLIER OPERATOR IF IT HAS HIGHER PRECEDENCE
2280 0ADF : C3 CB 09                 jp      FINTMP          ;
2281 0AE2
2282 0AE2 : E4 0A            FINREA: word    FINRE2
2283 0AE4 : 79         (M65) FINRE2: ld      a,c
2284 0AE5 : B7                       or      a
2285 0AE6 : 1F                       rra
2286 0AE7 : C1                       pop     bc
2287 0AE8 : D1                       pop     de
2288 0AE9 : F5                       push    af
2289 0AEA : CD 77 09                 call    CHKVAL          ;[M80] SEE IF WE HAVE A NUMERIC COMPARE
2290 0AED : 21 FB 0A                 ld      hl,DOCMP        ;[M80] ROUTINE TO TAKE COMPARE ROUTINE RESULTAND RELATIONAL BITS AND RETURN THE ANSWER
2291 0AF0 : E5                       push    hl
2292 0AF1 : CA 5B 15                 jp      z,FCOMP         ;{M89} COMPARE NUMBERS RETURNING $7F IF FAC IS LESS THAN THE REGISTERS
2293 0AF4 : AF                       xor     a
2294 0AF5 : 32 AB 38                 ld      (VALTYP),a
2295 0AF8 : C3 FC 0D                 jp      STRCMP
2296 0AFB
2297 0AFB : 3C         [M80] DOCMP:  inc     a               ;[M80] SETUP BITS
2298 0AFC : 8F                       adc     a,a             ;[M80] 4=LESS 2=EQUAL 1=GREATER
2299 0AFD : C1                       pop     bc              ;[M80] WHAT DID HE WANT?
2300 0AFE : A0                       and     b               ;[M80] ANY BITS MATCH?
2301 0AFF : C6 FF                    add     a,$FF           ;[M80] MAP 0 TO 0
2302 0B01 : 9F                       sbc     a,a             ;[M80] AND ALL OTHERS TO 377
2303 0B02 : C3 F6 14                 jp      FLOAT           ;[M80] CONVERT [A] TO AN INTEGER SIGNED
2304 0B05
2305 0B05 : 16 5A      [M80] NOTER:  ld      d,90            ;[M80] "NOT" HAS PRECEDENCE 90, SO FORMULA EVALUATION
2306 0B07 : CD 88 09                 call    LPOPER          ;[M80] IS ENTERED WITH A DUMMY ENTRY OF 90 ON THE STACK
2307 0B0A : CD 75 09                 call    CHKNUM          ;[M65] MUST BE NUMBER
2308 0B0D : CD 82 06                 call    FRCINT          ;[M80] COERCE THE ARGUMENT TO INTEGER
2309 0B10 : 7B                       ld      a,e             ;[M80] COMPLEMENT [D,E]
2310 0B11 : 2F                       cpl                     ;
2311 0B12 : 4F                       ld      c,a             ;
2312 0B13 : 7A                       ld      a,d             ;
2313 0B14 : 2F                       cpl                     ;
2314 0B15 : CD 21 0B                 call    GIVINT          ;[M80] UPDATE THE FAC
2315 0B18                            ;[M80] FRMEVL, AFTER SEEING THE PRECEDENCE OF 90 THINKS IT IS APPLYING AN OPERATOR
2316 0B18                            ;[M80] SO IT HAS THE TEXT POINTER IN TEMP2 SO RETURN TO REFETCH IT
2317 0B18 : C1                       pop     bc              ;
2318 0B19 : C3 94 09                 jp      RETAOP          ;
2319 0B1C
2320 0B1C                    ;{M80} SUBTRACTS [D,E] FROM [H,L] AND FLOAT THE RESULT LEAVING IT IN FAC
2321 0B1C                    ;;;Named GIVDBL in [M80] and [GWB] but Aquarius only supports floats
2322 0B1C : 7D               GIVFLT: ld      a,l             ;[M80] [H,L]=[H,L]-[D,E]
2323 0B1D : 93                       sub     e               ;
2324 0B1E : 4F                       ld      c,a             ;
2325 0B1F : 7C                       ld      a,h             ;[M80] SAVE HIGH BYTE IN [H]
2326 0B20 : 9A                       sbc     a,d             ;
2327 0B21 : 41         [M80] GIVINT: ld      b,c             ;;Float [C,D], entered from NOTER
2328 0B22 : 50               FLOATB: ld      d,b             ;;Float [B], entered from SNGFLT
2329 0B23 : 1E 00            FLOATD: ld      e,0             ;;Float [D], entered from POINT
2330 0B25 : 21 AB 38                 ld      hl,VALTYP       ;
2331 0B28 : 73                       ld      (hl),e          ;[M80] SET VALTYP TO "FLOATING POINT"
2332 0B29 : 06 90      {M80} INEGAD: ld      b,144           ;{M80} SET EXPONENT
2333 0B2B : C3 FB 14                 jp      FLOATR          ;[M80] GO FLOAT THE NUMBER
2334 02BE
2335 0B2E : 3A 46 38   [M80] LPOS:   ld      a,(LPTPOS)      ;{M80} GET PRINT HEAD POSITION
2336 0B31 : 18 03                    jr      SNGFLT          ;
2337 0B33
2338 0B33 : 3A 00 38   [M80] POS:    ld      a,(TTYPOS)      ;[M80] GET TELETYPE POSITION
2339 0B36
2340 0B36 : 47         [M80] SNGFLT: ld      b,a             ;[M80] MAKE [A] AN UNSIGNED INTEGER
2341 0B37 : AF                       xor     a               ;
2342 0B38 : C3 22 0B                 jp      FLOATB          ;
2343 0B3B
2344 0B3B                  + ;{M80} SIMPLE USER DEFINED FUNCTION CODE
2345 0B3B                  | ;[M80] NOTE ONLY SINGLE ARGUMENTS ARE ALLOWED TO FUNCTIONS
2346 0B3B                  | ;[M80] AND FUNCTIONS MUST BE OF THE SINGLE LINE FORM:
2347 0B3B                  | ;[M80] DEF FNA(X)=X^2+X-2
2348 0B3B                  | ;[M80] NO STRINGS CAN BE INVOLVED WITH THESE FUNCTIONS
2349 0B3B                  | ;[M80]
2350 0B3B                  | ;[M80] IDEA: CREATE A FUNNY SIMPLE VARIABLE ENTRY
2351 0B3B                  | ;[M80] WHOSE FIRST CHARACTER (SECOND WORD IN MEMORY)
2352 0B3B                  | ;[M80] HAS THE 200 BIT SET.
2353 0B3B                  | ;[M80] THE VALUE WILL BE:
2354 0B3B                  | ;[M80]
2355 0B3B                  | ;[M80]       A TXTPTR TO THE FORMULA
2356 0B3B                  | ;[M80]       THE NAME OF THE PARAMETER VARIABLE
2357 0B3B                  | ;[M80]
2358 0B3B                  | ;[M80] FUNCTION NAMES CAN BE LIKE "FNA4"
2359 0B3B                  | ;[M80]
2360 0B3B                    ;;Not Implemented in 8K BASIC
2361 0B3B : F7         [M80] DEF:    rst     HOOKDO          ;;If not hooked
2362 0B3C : 0F         {~~~} HOOK15: byte    15
2363 0B3D : C3 C4 03                 jp      SNERR           ;;Syntax Error
2364 0B40                    ;
2365 0B40 : F7         [M80] FNDOER: rst     HOOKDO          ;;If not hooked
2366 0B41 : 10         {~~~} HOOK16: byte    16
2367 0B42 : C3 C4 03                 jp      SNERR           ;;Syntax Error
2368 0B45
2369 0B45                    ;[M65] SUBROUTINE TO SEE IF WE ARE IN DIRECT MODE AND COMPLAIN IF SO.
2370 0B45 : E5               ERRDIR: push    hl              ;
2371 0B46 : 2A 4D 38                 ld      hl,(CURLIN)     ;[M65] DIR MODE HAS [CURLIN]=$FFFF
2372 0B49 : 23                       inc     hl              ;[M65] SO NOW, IS RESULT ZERO?
2373 0B4A : 7C                       ld      a,h             ;
2374 0B4B : B5                       or      l               ;
2375 0B4C : E1                       pop     hl              ;
2376 0B4D : C0                       ret     nz              ;[M65] YES
2377 0B4E : 1E 16                    ld      e,ERRID         ;[M65] INPUT DIRECT ERROR CODE
2378 0B50 : C3 DB 03                 jp      ERROR           ;
2379 0B53
2380 0B53 : D7         [M80] GTBYTC: rst     CHRGET          ;
2381 0B54 : CD 72 09   [M80] GETBYT: call    FRMNUM          ;[M80] EVALUATE A FORMULA
2382 0B57 : CD 7E 06   [M80] CONINT: call    INTFR2          ;[M80] CONVERT THE FAC TO AN INTEGER IN [D,E]
2383 0B5A : 7A                       ld      a,d             ;[M80] SET THE CONDITION CODES BASED ON THE HIGH ORDER
2384 0B5B : B7                       or      a               ;
2385 0B5C : C2 97 06                 jp      nz,FCERR        ;[M80] WASN'T ERROR
2386 0B5F : 2B                       dec     hl              ;[M80] fUNCTIONS CAN GET HERE WITH BAD [H,L] BUT NOT SERIOUS
2387 0B60 : D7                       rst     CHRGET          ;[M80] SET CONDITION CODES ON TERMINATOR
2388 0B61 : 7B                       ld      a,e             ;[M80] RETURN THE RESULT IN [A] AND [E]
2389 0B62 : C9                       ret                     ;
2390 0B63
2391 0B63 : CD 82 06   [M80] PEEK:   call    FRCINT          ;[M80] GET AN INTEGER IN [D,E]
2392 0B66 : CD 88 0B                 call    PROMEM          ;{M80} DONT ALLOW IF PROTECTED MEMORY
2393 0B69 : 1A                       ld      a,(de)          ;[M80] GET THE VALUE TO RETURN
2394 0B6A : C3 36 0B                 jp      SNGFLT          ;[M80] AND FLOAT IT
2395 0B6D
2396 0B6D : CD 72 09   [M80] POKE:   call    FRMNUM          ;[M80] READ A FORMULA
2397 0B70 : CD 82 06                 call    FRCINT          ;{M80} FORCE VALUE INTO INT IN [D,E]
2398 0B73 : CD 88 0B                 call    PROMEM          ;{M80} DONT ALLOW IF PROTECTED MEMORY
2399 0B76 : D5                       push    de              ;[M80] PUT VALUE ON STACK
2400 0B77 : CF                       rst     SYNCHK          ;
2401 0B78 : 2C                       byte    ','             ;[M80] CHECK FOR A COMMA
2402 0B79 : CD 54 0B                 call    GETBYT
2403 0B7C : D1                       pop     de              ;[M80] GET THE ADDRESS BACK
2404 0B7D : 12                       ld      (de),a          ;[M80] STORE IT AWAY
2405 0B7E : C9                       ret                     ;[M80] SCANNED EVERYTHING
2406 0B7F
2407 0B7F : CD 85 09   {~~~} FRMINT: call    FRMEVL          ;;*** More Orphan Code?
2408 0B82 : E5                       push    hl
2409 0B83 : CD 82 06                 call    FRCINT
2410 0B86 : E1                       pop     hl
2411 0B87 : C9                       ret
2412 0B88
2413 0B88                  + ;;Check for illegal Address in PEEK and POKE
2414 0B88                  | ;;;Label based on {M80] PRODIR
2415 0B88 : E5               PROMEM: push    hl              ;
2416 0B89 : 21 FF 2F                 ld      hl,$2FFF        ;
2417 0B8C : E7                       rst     COMPAR          ;{M80} IS [D.E] LESS THAN 3000H?
2418 0B8D : E1                       pop     hl              ;
2419 0B8E : D2 97 06                 jp      nc,FCERR        ;{M80} YES, BLOW HIM UP NOW
2420 0B91 : C9                       ret                     ;
2421 0B92
2422 0B92                  + ;[M80] THIS IS THE BLOCK TRANSFER ROUTINE
2423 0B92                  | ;[M80] IT MAKES SPACE BY SHOVING EVERYTHING FORWARD
2424 0B92                  | ;[M80]
2425 0B92                  | ;[M80] [H,L] = DESTINATION OF HIGH ADDRESS
2426 0B92                  | ;[M80] [D,E] = LOW ADDRESS TO BE TRANSFERRED
2427 0B92                  | ;[M80] [B,C] = HIGH ADDRESS TO BE TRANSFERRED
2428 0B92                  | ;[M80]
2429 0B92                  | ;[M80] A CHECK IS MADE TO MAKE SURE A REASONABLE AMOUNT
2430 0B92                  | ;[M80] OF SPACE REMAINS BETWEEN THE TOP OF THE STACK AND
2431 0B92                  | ;[M80] THE HIGHEST LOCATION TRANSFERRED INTO
2432 0B92                  | ;[M80]
2433 0B92                  | ;[M80] ON EXIT [H,L]=[D,E]=LOW [B,C]=LOCATION LOW WAS MOVED INTO
2434 0B92                  | ;
2435 0B92 : CD A9 0B   [M80] BLTU:   call    REASON          ;[M80] CHECK DESTINATION TO MAKE SURE STACK WON'T BE OVERRUN
2436 0B95 : C5         [M80] BLTUC:  push    bc              ;[M80] EXCHANGE [B,C] AND [H,L]
2437 0B96 : E3                       ex      (sp),hl         ;
2438 0B97 : C1                       pop     bc              ;
2439 0B98 : E7         (M80) BLTLOP: rst     COMPAR          ;[M80] SEE IF WE ARE DONE
2440 0B99 : 7E                       ld      a,(hl)          ;[M80] GET THE WORD TO TRANSFER
2441 0B9A : 02                       ld      (bc),a          ;[M80] TRANSFER IT
2442 0B9B : C8                       ret     z               ;
2443 0B9C : 0B                       dec     bc              ;
2444 0B9D : 2B                       dec     hl              ;[M80] BACKUP FOR NEXT GUY
2445 0B9E : 18 F8                    jr      BLTLOP          ;
2446 0BA0
2447 0BA0                  + ;;Check Stack Size
2448 0BA0                  | ;[M80] THIS ROUTINE IS USED TO MAKE SURE A CERTAIN NUMBER
2449 0BA0                  | ;[M80] OF LOCATIONS REMAIN AVAILABLE FOR THE
2450 0BA0                  | ;[M80] STACK. THE CALL IS :
2451 0BA0                  | ;[M80]       LD      C,number of 2 byte entries necessary
2452 0BA0                  | ;[M80]       CALL    GETSTK
2453 0BA0                  | ;
2454 0BA0                  | ;[M80] THIS ROUTINE MUST BE CALLED BY ANY ROUTINE WHICH PUTS
2455 0BA0                  | ;[M80] AN ARBITRARY AMOUNT OF STUFF ON THE STACK
2456 0BA0                  | ;[M80] (I.E. ANY RECURSIVE ROUTINE LIKE FRMEVL)
2457 0BA0                  | ;[M80] IT IS ALSO CALLED BY ROUTINES SUCH AS "GOSUB" AND "FOR"
2458 0BA0                  | ;[M80] WHICH MAKE PERMANENT ENTRIES ON THE STACK
2459 0BA0                  | ;[M80] ROUTINES WHICH MERELY USE AND FREE UP THE GUARANTEED
2460 0BA0                  | ;[M80] NUMLEV STACK LOCATIONS NEED NOT CALL THIS
2461 0BA0                  | ;
2462 0BA0 : E5               GETSTK: push    hl              ;[M80] SAVE [H,L]
2463 0BA1 : 2A DA 38                 ld      hl,(STREND)     ;
2464 0BA4 : 06 00                    ld      b,0             ;
2465 0BA6 : 09                       add     hl,bc           ;
2466 0BA7 : 09                       add     hl,bc           ;[M80] SEE IF WE CAN HAVE THIS MANY
2467 0BA8 : 3E                       byte    $3E             ;;"LD A," over next instruction
2468 0BA9 : E5               REASON: push    hl              ;;Save text pointer
2469 0BAA : 3E D0                    ld      a,208           ;[M80]  EXAMINE [H,L] TO MAKE SURE
2470 0BAC : 95                       sub     l               ;[M80]  AT LEAST 104 LOCATIONS
2471 0BAD : 6F                       ld      l,a             ;[M80]  REMAIN BETWEEN IT AND THE
2472 0BAE : 3E FF                    ld      a,$FF           ;[M80]  TOP OF THE STACK
2473 0BB0 : 9C                       sbc     a,h             ;
2474 0BB1 : 67                       ld      h,a             ;[M80] NOW SEE IF [SP] IS LARGER
2475 0BB2 : 38 03                    jr      c,OMERR         ;[M80] IN CASE [H,L] WAS TOO BIG
2476 0BB4 : 39                       add     hl,sp           ;[M80] IF SO, CARRY WILL BE SET
2477 0BB5 : E1                       pop     hl              ;[M80] GET BACK ORIGINAL [H,L]
2478 0BB6 : D8                       ret     c               ;[M80] WAS OK?
2479 0BB7
2480 0BB7 : 11 0C 00   [M80] OMERR:  ld      de,ERROM        ;;"OUT OF MEMORY"
2481 0BBA : C3 DB 03                 jp      ERROR           ;
2482 0BBD
2483 0BBD                    ;[M80] THE "NEW" COMMAND CLEARS THE PROGRAM TEXT AS WELL AS VARIABLE SPACE
2484 0BBD                    ;;SCRATH is the entry point from the Statement Dispatch Table for the NEW command
2485 0BBD                    ;;SCRTCH is the entry point from an aborted CLOAD command
2486 0BBD : C0         [M80] SCRATH: ret     nz              ;[M80] MAKE SURE THERE IS A TERMINATOR
2487 0BBE : F7         [M80] SCRTCH: rst     HOOKDO          ;Call Hook Dispatch Routine
2488 0BBF : 0C         {~~~} HOOK12: byte    12              ;
2489 0BC0 : 2A 4F 38                 ld      hl,(TXTTAB)     ;[M80] GET POINTER TO START OF TEXT
2490 0BC3 : AF                       xor     a               ;[M80] SET [A]=0
2491 0BC4 : 77                       ld      (hl),a          ;[M80] SAVE AT END OFF TEXT
2492 0BC5 : 23                       inc     hl              ;[M80] BUMP POINTER
2493 0BC6 : 77                       ld      (hl),a          ;[M80] SAVE ZERO
2494 0BC7 : 23                       inc     hl              ;[M80] BUMP POINTER
2495 0BC8 : 22 D6 38                 ld      (VARTAB),hl     ;[M80] NEW START OF VARIABLES
2496 0BC8
2497 0BC8                  + ;;Clear Variablea, Reset Stack, and Reset Text Pointer
2498 0BC8                  | ;;Leaves BASIC program intact
2499 0BC8                  | ;;Entry Point from RUN and FINI
2500 0BCB : 2A 4F 38   [M80] RUNC:   ld      hl,(TXTTAB)     ;[M80] POINT AT THE START OF TEXT
2501 0BCE : 2B                       dec     hl              ;
2502 0BCF
2503 0BCF                  + ;[M80] CLEARC IS A SUBROUTINE WHICH INITIALIZES THE VARIABLE AND
2504 0BCF                  | ;[M80] ARRAY SPACE BY RESETING ARYTAB [THE END OF SIMPLE VARIABLE SPACE]
2505 0BCF                  | ;[M80] AND STREND [THE END OF ARRAY STORAGE]. IT FALLS INTO STKINI
2506 0BCF                  | ;[M80] WHICH RESETS THE STACK. [H,L] IS PRESERVED.
2507 0BCF                  | ;
2508 0BCF : 22 CE 38   [M80] CLEARC: ld      (SAVTXT),hl     ;
2509 0BD2 : 2A AD 38                 ld      hl,(MEMSIZ)     ;[M65] FREE UP STRING SPACE
2510 0BD5 : 22 C1 38                 ld      (FRETOP),hl     ;
2511 0BD8 : AF         {M80} GODFRE: xor     a               ;
2512 0BD9 : CD 05 0C                 call    RESTOR          ;[M65] RESTOR DATA
2513 0BDC : 2A D6 38                 ld      hl,(VARTAB)     ;[M65] LIBERATE THE
2514 0BDF : 22 D8 38                 ld      (ARYTAB),hl     ;[M65] VARIABLES AND
2515 0BE2 : 22 DA 38                 ld      (STREND),hl     ;[M65] ARRAYS
2516 0BE5
2517 0BE5                  + ;[M80] STKINI RESETS THE STACK POINTER ELIMINATING
2518 0BE5                  | ;[M80] GOSUB & FOR CONTEXT.  STRING TEMPORARIES ARE FREED
2519 0BE5                  | ;[M80] UP, SUBFLG IS RESET, CONTINUING IS DISALLOWED,
2520 0BE5                  | ;[M80] AND A DUMMY ENTRY IS PUT ON THE STACK. THIS IS SO
2521 0BE5                  | ;[M80] FNDFOR WILL ALWAYS FIND A NON-"FOR" ENTRY AT THE BOTTOM
2522 0BE5                  | ;[M80] OF THE STACK. [A]=0 AND [D,E] IS PRESERVED.
2523 0BE5                  | ;
2524 0BE5 : C1         [M80] STKINI: pop     bc              ;[M80] GET RETURN ADDRESS HERE
2525 0BE6 : 2A 4B 38                 ld      hl,(TOPMEM)     ;
2526 0BE9 : F9                       ld      sp,hl           ;[M80] INITIALIZE STACK
2527 0BEA : CD D8 1F                 call    STKSAV          ;[M80] MAKE SURE SAVSTK OK JUST IN CASE.
2528 0BED : 22 AF 38   {M80} STKERR: ld      (TEMPPT),hl     ;
2529 0BF0 : CD BE 19                 call    FINLPT          ;{M80] BACK TO NORMAL PRINT MODE
2530 0BF3 : AF                       xor     a               ;[M80] ZERO OUT A
2531 0BF4 : 6F                       ld      l,a             ;[M80] ZERO OUT H
2532 0BF5 : 67                       ld      h,a             ;[M80] ZERO OUT L
2533 0BF6 : 22 D4 38                 ld      (OLDTXT),hl     ;
2534 0BF9 : 32 CB 38                 ld      (SUBFLG),a      ;[M80] ALLOW SUBSCRIPTS
2535 0BFC : 22 DE 38                 ld      (VARNAM),hl      ;
2536 0BFF : E5                       push    hl              ;[M80] PUT ZERO (NON $FOR,$GOSUB) ON THE STACK
2537 0C00 : C5                       push    bc              ;[M80] PUT RETURN ADDRESS BACK ON
2538 0C01 : 2A CE 38   [M80] GTMPRT: ld      hl,(SAVTXT)     ;[M80] GET SAVED [H,L]
2539 0C04 : C9                       ret
2540 0C05
2541 0C05                    ;;The RESTORE Command
2542 0C05 : EB         [M80] RESTOR: ex      de,hl           ;[M80] SAVE [H,L] IN [D,E]
2543 0C06 : 2A 4F 38                 ld      hl,(TXTTAB)     ;
2544 0C09 : 28 0E                    jr      z,BGNRST        ;[M80] RESTORE DATA POINTER TO BEGINNING OF PROGRAM
2545 0C0B : EB                       ex      de,hl           ;[M80] TEXT POINTER BACK TO [H,L]
2546 0C0C : CD 9C 06                 call    SCNLIN          ;[M80] GET THE FOLLOWING LINE NUMBER
2547 0C0F : E5                       push    hl              ;[M80] SAVE TEXT POINTER
2548 0C10 : CD 9F 04                 call    FNDLIN          ;[M80] FIND THE LINE NUMBER
2549 0C13 : 60                       ld      h,b             ;[M80] GET POINTER TO LINE IN [H,L]
2550 0C14 : 69                       ld      l,c             ;
2551 0C15 : D1                       pop     de              ;[M80] TEXT POINTER BACK TO [D,E]
2552 0C16 : D2 F3 06                 jp      nc,USERR        ;[M80] SHOULD HAVE FOUND LINE
2553 0C19 : 2B         (M80) BGNRST: dec     hl              ;[M80] INITIALIZE DATPTR TO [TXTTAB]-1
2554 0C1A : 22 DC 38   [M80] RESFIN: ld      (DATPTR),hl     ;[M80] READ FINISHES COME TO RESFIN
2555 0C1D : EB                       ex      de,hl           ;[M80] GET THE TEXT POINTER BACK
2556 0C1E : C9                       ret
2557 0C1F                    ;;The STOP and END Statements
2558 0C1F                    ;;STOPC is entry point to END from WARMST
2559 0C1F : C0         [M80] STOP:   ret     nz              ;[M80] MAKE SURE "STOP" STATEMENTS HAVE A TERMINATOR
2560 0C20 : F6         [M65] STOPC:  byte    $F6             ;;"OR" to skip next instruction
2561 0C21 : C0         [M80] ENDS:   ret     nz              ;[M80] MAKE SURE "END" STATEMENTS HAVE A TERMINATOR
2562 0C22 : 22 CE 38   {M80} CONSTP: ld      (SAVTXT),hl     ;
2563 0C25 : 21                       byte    $21             ;{M80} SKIP OVER OR USING "LD H,"
2564 0C26 : F6 FF      [M80] STPEND: or      $FF             ;[M80] SET NON-ZERO TO FORCE PRINTING OF BREAK MESSAGE
2565 0C28 : C1                       pop     bc              ;[M80] POP OFF NEWSTT ADDRESS
2566 0C29 : 2A 4D 38   [M80] ENDCON: ld      hl,(CURLIN)     ;[M80] SAVE CURLIN
2567 0C2C : F5                       push    af              ;{M80} SAVE MESSAGE FLAG, ZERO MEANS DON'T PRINT "BREAK"
2568 0C2D : 7D                       ld      a,l             ;
2569 0C2E : A4                       and     h               ;[M80] SEE IF DIRECT
2570 0C2F : 3C                       inc     a               ;
2571 0C30 : 28 09                    jr      z,DIRIS         ;[M80] IF NOT SET UP FOR CONTINUE
2572 0C32 : 22 D2 38                 ld      (OLDLIN),hl     ;[M80] SAVE OLD LINE #
2573 0C35 : 2A CE 38                 ld      hl,(SAVTXT)     ;[M80] GET POINTER TO START OF STATEMENT
2574 0C38 : 22 D4 38                 ld      (OLDTXT),hl     ;[M80] SAVE IT
2575 0C3B : CD BE 19   [M80] DIRIS:  call    FINLPT          ;{M80} BACK TO NORMAL PRINT MODE
2576 0C3E : CD DE 19                 call    CRDONZ          ;[M80] PRINT CR IF TTYPOS .NE. 0
2577 0C41 : F1                       pop     af              ;[M80] GET BACK ^C FLAG
2578 0C42 : 21 73 03                 ld      hl,BRKTXT       ;[M80] "BREAK"
2579 0C45 : C2 F4 03                 jp      nz,ERRFN1       ;[M80] CALL STROUT AND FALL INTO READY
2580 0C48 : C3 02 04                 jp      READY           ;
2581 0C4B
2582 0C4B                    ;;The CONT Command
2583 0C4B : 2A D4 38   [M80] CONT:   ld      hl,(OLDTXT)     ;[M80] ZERO INDICATES THERE IS NOTHING TO CONTINUE
2584 0C4E : 7C                       ld      a,h             ;[M80] "STOP","END",TYPING CRLF
2585 0C4F : B5                       or      l               ;[M80] TO "INPUT" AND ^C SETUP OLDTXT
2586 0C50 : 11 20 00   {M80} RESERR: ld      de,ERRCN        ;[M80] "CAN'T CONTINUE"
2587 0C53 : CA DB 03                 jp      z,ERROR         ;
2588 0C56 : ED 5B D2 38              ld      de,(OLDLIN)     ;
2589 0C5A : ED 53 4D 38              ld      (CURLIN),de     ;[M80] SET UP OLD LINE # AS CURRENT LINE #
2590 0C5E : C9                       ret                     ;
2591 0C5F
2592 0C5F                    ;;This looks like orphan code
2593 0C5F : C3 97 06                 jp      FCERR
2594 0C62
2595 0C62                    ;;CSAVE* and CLOAD*
2596 0C62   3E               CSARY:  byte    $3E             ;;"LD A," sets A = 62 for CSAVE*
2597 0C63 : AF               CLARY:  xor     a               ;;Set A = 0 for CLOAD*
2598 0C64 : B7                       or      a               ;;Set flags
2599 0C65 : F5                       push    af              ;;and save them
2600 0C66 : D7                       rst     CHRGET          ;;Skip '*'
2601 0C67 : 3E 01                    ld      a,1             ;
2602 0C69 : 32 CB 38                 ld      (SUBFLG),a      ;;Don't look for '(' after variable name
2603 0C6C : CD D1 10                 call    PTRGET          ;;Get pointer to variable
2604 0C6F : C2 97 06                 jp      nz,FCERR        ;;Doesn't exist? FC Error
2605 0C72 : 32 CB 38                 ld      (SUBFLG),a      ;;Turn subscripts back on
2606 0C75 : CD 75 09                 call    CHKNUM          ;;Must be numeric variable or TM Error
2607 0C78 : F1                       pop     af              ;
2608 0C79 : E5                       push    hl              ;;Text Pointer
2609 0C7A : F5                       push    af              ;;CSAVE/CLOAD flag
2610 0C7B : C5                       push    bc              ;;Pointer to Number of Dimensions
2611 0C7C : 06 23                    ld      b,'#'           ;
2612 0C7E : 28 12                    jr      z,CLARYP        ;;If flag is 0, do CLOAD
2613 0C80                    ;;Write Array Header to Tape
2614 0C80 : CD 7F 1B   {~~~} CSARYH: call    PRECRD          ;;"Press <RECORD>" and wait for RETURN
2615 0C83 : CD BC 1B                 call    WRSYNC          ;;Write SYNC to tape
2616 0C86 : 78                       ld      a,b             ;;Write filename "######"
2617 0C87 : CD 87 1B                 call    WRBYT2          ;
2618 0C8A : CD 87 1B                 call    WRBYT2          ;
2619 0C8D : CD 87 1B                 call    WRBYT2          ;
2620 0C90 : 18 11                    jr      RWARY           ;;Write Array
2621 0C92                    ;;Read Array Header from Tape
2622 0C92 : CD 2E 1B   (~~~) CLARYP: call    PPLAY           ;;"Press <PLAY>", wait for RETURN
2623 0C95 : CD CE 1B   {~~~} CLARYH: call    RDSYNC          ;;Wait for SYNC
2624 0C98 : 0E 06      (~~~) CLARYF: ld      c,6             ;;Look for filename "@@@@@@"
2625 0C9A : CD 4D 1B   (~~~) CLARYL: call    RDBYTE
2626 0C9D : B8                       cp      b
2627 0C9E : 20 F8                    jr      nz,CLARYF
2628 0CA0 : 0D                       dec     c
2629 0CA1 : 20 F7                    jr      nz,CLARYL
2630 0CA3                    ;;Read Array from or Write Array to Tape
2631 0CA3                    ;;DE=End of Array+1, Stack: Array Pointer, CSAVE Flag, Text Pointer
2632 0CA3 : E1               RWARY:  pop     hl              ;;Restore Array Pointer
2633 0CA4 : EB                       ex      de,hl           ;;DE = Array Pointer, HL = Array Length
2634 0CA5 : 19                       add     hl,de           ;;HL = End of Array plus 1
2635 0CA6 : EB                       ex      de,hl           ;;HL = Array Pointer, DE = End of Array
2636 0CA7 : 4E                       ld      c,(hl)          ;
2637 0CA8 : 06 00                    ld      b,0             ;;BC = Number of Dimensions
2638 0CAA : 09                       add     hl,bc           ;;Each dimension size is two bytes
2639 0CAB : 09                       add     hl,bc           ;;So add twice
2640 0CAC : 23                       inc     hl              ;;Add one more for Number of Dimensions
2641 0CAD                    ;;HL=Start Address, DE=End Address+1, Stack: CSAVE Flag Z, Text Pointer
2642 0CAD : E7         (~~~) RWMEM:  rst     COMPAR          ;;Are we there yet?
2643 0CAE : 28 0D                    jr      z,RWARYD        ;;Yes, you can get out
2644 0CB0 : F1                       pop     af              ;;Get CSAVE/CLOAD flag
2645 0CB1 : F5                       push    af              ;;And save it again
2646 0CB2 : 7E                       ld      a,(hl)          ;;Read byte from array
2647 0CB3 : C4 8A 1B                 call    nz,WRBYTE       ;;If CSAVE* write to tape
2648 0CB6 : CC 4D 1B                 call    z,RDBYTE        ;;If CLOAD* read from tape
2649 0CB9 : 77                       ld      (hl),a          ;;Write byte into array
2650 0CBA : 23                       inc     hl              ;;Bump pointer
2651 0CBB : 18 F0                    jr      RWMEM           ;;and do next byte
2652 0CBD : F1               RWARYD: pop     af              ;;Get CSAVE/CLOAD flag
2653 0CBE : C2 1C 1C                 jp      nz,WRTAIL       ;;If CSAVE* write trailer and return
2654 0CC1 : E1                       pop     hl              ;;Restore text pointer
2655 0CC2 : C3 7E 1B                 jp      RWARYR          ;;and Return
2656 0CC5                    ;
2657 0CC5                  + ;[M80] TEST FOR A LETTER / CARRY ON=NOT A LETTER
2658 0CC5                  | ;[M80]               CARRY OFF=A LETTER
2659 0CC5                  | ;
2660 0CC5 : 7E         [M80] ISLET:  ld      a,(hl)
2661 0CC6 : FE 41      [M65] ISLETC: cp      'A'
2662 0CC8 : D8                       ret     c               ;[M80] IF LESS THAN "A", RETURN EARLY
2663 0CC9 : FE 5B                    cp      'Z'+1
2664 0CCB : 3F                       ccf
2665 0CCC : C9                       ret
2666 0CCD                    ;
2667 0CCD                  + ;[M80] THIS CODE IS FOR THE "CLEAR" COMMAND WITH AN ARGUMENT
2668 0CCD                  | ;[M80] TO CHANGE THE AMOUNT OF STRING SPACE ALLOCATED.
2669 0CCD                  | ;[M80] IF NO FORMULA IS GIVEN THE AMOUNT OF STRING SPACE
2670 0CCD                  | ;[M80] REMAINS UNCHANGED.
2671 0CCD                  | ;
2672 0CCD                  | ;;Second Parameter is End of Basic Memory
2673 0CCD : F7         (M80) CLEAR:  rst     HOOKDO          ;;Call Hook Dispatch Routine
2674 0CCE : 0B         {~~~} HOOK11: byte    11              ;
2675 0CCF : CA CF 0B                 jp      z,CLEARC        ;[M80] IF NO FORMULA JUST CLEAR
2676 0CD2 : CD 7B 06                 call    INTID2          ;[M80] GET AN INTEGER INTO [D,E]
2677 0CD5 : 2B                       dec     hl              ;
2678 0CD6 : D7                       rst     CHRGET          ;[M80] SEE IF ITS THE END
2679 0CD7 : E5                       push    hl              ;
2680 0CD8 : 2A AD 38                 ld      hl,(MEMSIZ)     ;[M80] GET HIGHEST ADDRESS
2681 0CDB : 28 0E                    jr      z,CLEARS        ;[M80] SHOULD FINISH THERE
2682 0CDD : E1                       pop     hl              ;
2683 0CDE : CF                       rst     SYNCHK          ;
2684 0CDF : 2C                       byte    ','             ;
2685 0CE0 : D5                       push    de              ;;Save First Parameter
2686 0CE1 : CD 7B 06                 call    INTID2          ;;Get Second Parameter
2687 0CE4 : 2B                       dec     hl              ;
2688 0CE5 : D7                       rst     CHRGET          ;
2689 0CE6 : C2 C4 03                 jp      nz,SNERR        ;{M80} IF NOT TERMINATOR, GOOD BYE
2690 0CE9 : E3                       ex      (sp),hl         ;
2691 0CEA : EB                       ex      de,hl           ;
2692 0CEB                    ;;Set VARTAB, TOPMEM, and MEMSIZ
2693 0CEB                    ;;On Entry HL = top of memory, from MEMSIZ or second parameter
2694 0CEB                    ;;         DE = string space, from the first parameter
2695 0CEB : 7D         (M80) CLEARS: ld      a,l             ;[M80] SUBTRACT [H,L]-[D,E] INTO [D,E]
2696 0CEC : 93                       sub     e               ;
2697 0CED : 5F                       ld      e,a             ;;Leaving start of String Space in [D,E]
2698 0CEE : 7C                       ld      a,h             ;
2699 0CEF : 9A                       sbc     a,d             ;
2700 0CF0 : 57                       ld      d,a             ;
2701 0CF1 : DA B7 0B                 jp      c,OMERR         ;[M80] WANTED MORE THAN TOTAL!
2702 0CF4 : E5                       push    hl              ;[M80] SAVE MEMSIZ
2703 0CF5 : 2A D6 38                 ld      hl,(VARTAB)     ;[M80] TOP LOCATION IN USE
2704 0CF8 : 01 28 00                 ld      bc,40           ;[M80] TOP LOCATION IN USE
2705 0CFB : 09                       add     hl,bc           ;[M80] LEAVE BREATHING ROOM
2706 0CFC : E7                       rst     COMPAR          ;[M80] ROOM?
2707 0CFD : D2 B7 0B                 jp      nc,OMERR        ;[M80] NO, DON'T EVEN CLEAR
2708 0D00 : EB                       ex      de,hl           ;[M80] NEW STACK LOCATION [H,L]
2709 0D01 : 22 4B 38                 ld      (TOPMEM),hl     ;[M80] SET UP NEW STACK LOCATION
2710 0D04 : E1                       pop     hl              ;[M80] GET BACK MEMSIZ
2711 0D05 : 22 AD 38                 ld      (MEMSIZ),hl     ;[M80] SET IT UP, MUST BE OK
2712 0D08 : E1                       pop     hl              ;[M80] REGAIN THE TEXT POINTER
2713 0D09 : C3 CF 0B                 jp      CLEARC          ;[M80] GO CLEAR
2714 0D0C
2715 0D0C                    ;;DE = HL - DE  *** Orphan Code?
2716 0D0C : 7D                       ld      a,l
2717 0D0D : 93                       sub     e
2718 0D0E : 5F                       ld      e,a
2719 0D0F : 7C                       ld      a,h
2720 0D10 : 9A                       sbc     a,d
2721 0D11 : 57                       ld      d,a
2722 0D12 : C9                       ret
2723 0D13
2724 0D13                    ;;The NEXT STATEMENT
2725 0D13                    ;;See FOR for description of the stack entry
2726 0D13 : 11 00 00   [M80] NEXT:   ld      de,0            ;{M80} FOR "NEXT" WITHOUT ARGS CALL FNDFOR WITH [D,E]=0
2727 0D16 : C4 D1 10   (M80) NEXTC:  call    nz,PTRGET       ;{M80} GET POINTER TO LOOP VARIABLE INTO [D,E]
2728 0D19 : 22 CE 38                 ld      (SAVTXT),hl     ;{M80} SAVE TEXT POINTER IN CASE LOOP TERMINATES
2729 0D1C : CD 9F 03                 call    FNDFOR          ;{M80} LOOK FOR ENTRY WHOSE VARIABLE NAME MATCHES THIS ONES
2730 0D1F : C2 CA 03                 jp      nz,NFERR        ;[M80] "NEXT WITHOUT FOR"
2731 0D22 : F9                       ld      sp,hl           ;[M80] SETUP STACK POINTER BY CHOPPING AT THIS POINT
2732 0D23 : D5                       push    de              ;[M80] PUT THE VARIABLE PTR BACK ON
2733 0D24 : 7E                       ld      a,(hl)          ;
2734 0D25 : F5                       push    af              ;
2735 0D26 : 23                       inc     hl              ;
2736 0D27 : D5                       push    de              ;{M80} PUT POINTER TO LOOP VARIABLE ONTO STACK
2737 0D28 : CD 20 15                 call    MOVFM           ;[M80] STEP VALUE INTO THE FAC
2738 0D2B : E3                       ex      (sp),hl         ;{M80} PUT POINTER INTO FOR ENTRY ONTO STACK
2739 0D2C : E5                       push    hl              ;{M80} PUT POINTER TO LOOP VARIABLE BACK ONTO STACK
2740 0D2D : CD 53 12   {M80} NXTDO:  call    FADDS           ;
2741 0D30 : E1                       pop     hl              ;{M80} POP OFF POINTER TO LOOP VARIABLE
2742 0D31 : CD 3A 15                 call    MOVMF           ;[M80] MOV FAC INTO LOOP VARIABLE
2743 0D34 : E1                       pop     hl              ;[M80] GET THE ENTRY POINTER
2744 0D35 : CD 31 15                 call    MOVRM           ;[M80] GET THE FINAL INTO THE REGISTERS
2745 0D38 : E5                       push    hl              ;[M80] SAVE THE ENTRY POINTER
2746 0D39 : CD 5B 15                 call    FCOMP           ;{M80} RETURN 255 IF FAC < REGISTERS, 0 IF =, 1 IF >
2747 0D3C : E1         {M80} FINNXT: pop     hl              ;{M80} POP OFF "FOR" POINTER NOW POINTING PAST FINAL VALUE
2748 0D3D : C1                       pop     bc              ;[M80] GET THE SIGN OF THE INCREMENT
2749 0D3E : 90                       sub     b               ;{M80} SUBTRACT SIGN FROM (CURRENT VALUE-FINAL VALUE)
2750 0D3F : CD 31 15                 call    MOVRM           ;{M80} "FOR" LINE # INTO [D,E], TEXT POINTER INTO [B,C]
2751 0D42 : 28 09                    jr      z,LOOPDN        ;{M80} IF ZERO THEN THE LOOP IS FINISHED
2752 0D44 : EB                       ex      de,hl           ;
2753 0D45 : 22 4D 38                 ld      (CURLIN),hl     ;[M80] STORE THE LINE #
2754 0D48 : 69                       ld      l,c             ;[M80] SETUP THE TEXT POINTER
2755 0D49 : 60                       ld      h,b             ;
2756 0D4A : C3 28 06                 jp      NXTCON          ;
2757 0D4D
2758 0D4D : F9         (M80) LOOPDN: ld      sp,hl           ;{M80} ELIMINATE FOR ENTRY SINCE [H,L] MOVED ALL THE WAY THE ENTRY
2759 0D4E : 2A CE 38                 ld      hl,(SAVTXT)     ;UPDATE SAVED STACK
2760 0D51 : 7E                       ld      a,(hl)          ;IS THERE A COMMA AT THE END
2761 0D52 : FE 2C                    cp      ','             ;IF SO LOOK AT ANOTHER
2762 0D54 : C2 2C 06                 jp      nz,NEWSTT       ;VARIABLE NAME TO "NEXT"
2763 0D57 : D7                       rst     CHRGET          ;READ FIRST CHARCTER
2764 0D58 : CD 16 0D                 call    NEXTC           ;DO NEXT, BUT DON'T ALLOW BLANK VARIABLE NAME
2765 0D5B
2766 0D5B                  + ;;Input Line
2767 0D5B                  | ;[M80] THIS IS THE LINE INPUT ROUTINE IT READS CHARACTERS INTO BUF
2768 0D5B                  | ;[M80] THE ROUTINE IS ENTERED AT INLIN, AT QINLIN TO TYPE A QUESTION MARK
2769 0D5B                  | ;[M80] AND A SPACE FIRST
2770 0D5B : 3E 3F      [M80] QINLIN: ld      a,'?'           ;
2771 0D5D : DF                       rst     OUTCHR          ;
2772 0D5E : 3E 20                    ld      a,' '           ;
2773 0D60 : DF                       rst     OUTCHR          ;
2774 0D61 : C3 85 0D   {M65} GINLIN: jp      INLIN           ;;;For relative jumps
2775 0D64
2776 0D64 : 3A 4A 38   [M80] RUBOUT: ld      a,(RUBSW)       ;[M80] ARE WE ALREADY RUBBING OUT?
2777 0D67 : B7                       or      a               ;[M80] SET CC'S
2778 0D68 : 3E 5C                    ld      a,'\'           ;[M80] GET READY TO TYPE BACKSLASH
2779 0D6A : 32 4A 38                 ld      (RUBSW),a       ;[M80] MAKE RUBSW NON-ZERO IF NOT ALREADY
2780 0D6D : 20 05                    jr      nz,NOTBEG       ;[M80] NOT RUBBING BACK TO BEGGINING
2781 0D6F : 05                       dec     b               ;[M80] AT BEGINNING OF LINE?
2782 0D70 : 28 13                    jr      z,INLIN         ;[M80] SET FIRST BYTE IN BUF TO ZERO
2783 0D72 : DF                       rst     OUTCHR          ;[M80] SEND BACKSLASH
2784 0D73 : 04                       inc     b               ;[M80] EFFECTIVELY SKIP NEXT INSTRUCTION
2785 0D74 : 05         (M80) NOTBEG: dec     b               ;[M80] BACK UP CHAR COUNT BY 1
2786 0D75 : 2B                       dec     hl              ;[M80] AND LINE POSIT
2787 0D76 : 28 09                    jr      z,INLINN        ;[M80] AND RE-SET UP INPUT
2788 0D78 : 7E                       ld      a,(hl)          ;[M80] OTHERWISE GET CHAR TO ECHO
2789 0D79 : DF                       rst     OUTCHR          ;[M80] SEND IT
2790 0D7A : 18 12                    jr      INLINC          ;[M80] AND GET NEXT CHAR
2791 0D7C
2792 0D7C : 05         [M65] LINLIN: dec     b               ;[M80] AT START OF LINE?
2793 0D7D : 2B         {M80} LINLN2: dec     hl              ;[M65] BACKARROW SO BACKUP PNTR AND
2794 0D7E : DF                       rst     OUTCHR          ;[M80] SEND BACKSPACE
2795 0D7F : 20 0D                    jr      nz,INLINC       ;
2796 0D81 : DF         (M80) INLINN: rst     OUTCHR          ;
2797 0D82
2798 0D82 : CD EA 19   [M80] INLINU: call    CRDO            ;[M80] TYPE A CRLF
2799 0D85 : 21 60 38   [M80] INLIN:  ld      hl,BUF          ;
2800 0D88 : 06 01                    ld      b,1             ;[M80] CHARACTER COUNT
2801 0D8A : AF                       xor     a               ;[M80] CLEAR TYPE AHEAD CHAR
2802 0D8B : 32 4A 38                 ld      (RUBSW),a       ;[M80] LIKE SO
2803 0D8E : CD DA 19   [M80] INLINC: call    INCHR           ;[M80] GET A CHAR
2804 0D91 : 4F         {M80} INLNC1: ld      c,a             ;[M80] SAVE CURRENT CHAR IN [C]
2805 0D92 : FE 7F                    cp      127             ;[M80] CHARACTER DELETE?
2806 0D94 : 28 CE                    jr      z,RUBOUT        ;[M80] DO IT
2807 0D96 : 3A 4A 38                 ld      a,(RUBSW)       ;[M80] BEEN DOING A RUBOUT?
2808 0D99 : B7                       or      a               ;[M80] SET CC'S
2809 0D9A : 28 07                    jr      z,NOTRUB        ;[M80] NOPE.
2810 0D9C : 3E 5C                    ld      a,'\'           ;[M80] GET READY TO TYPE SLASH
2811 0D9E : DF                       rst     OUTCHR          ;[M80] SEND IT
2812 0D9F : AF                       xor     a               ;[M80] CLEAR RUBSW
2813 0DA0 : 32 4A 38                 ld      (RUBSW),a       ;[M80] LIKE SO
2814 0DA3 : 79         (M80) NOTRUB: ld      a,c             ;[M80] GET BACK CURRENT CHAR
2815 ;;;The following comment is in both [M65] and [M80], so it likely ended up in the Aquarius
2816 ;;;source code as well. Bob Albrecht is a key figure in the early history of microcomputers.
2817 ;;;He founded the People's Computer Company, a newsletter that operated with a walk-in
2818 ;;;storefront to teach children "about having fun with computers" and later became
2819 ;;;Dr. Dobb's Journal of Computer Calisthenics and Orthodontia.  He brought the first
2820 ;;;Altair 8800 to the Homebrew Computer Club and was one of the main supporters
2821 ;;;of the effort to make Tiny BASIC a standard on many early machines.
2822 0DA4 : FE 07      {M80} CHKFUN: cp      7               ;[M80] IS IT BOB ALBRECHT RINGING THE BELL
2823 0DA6 : 28 41                    jr      z,GOODCH        ;[M80] FOR SCHOOL KIDS?
2824 0DA8 : FE 03                    cp      3               ;[M80] CONTROL-C?
2825 0DAA : CC EA 19                 call    z,CRDO          ;[M80] TYPE CHAR, AND CRLFT
2826 0DAD : 37                       scf                     ;[M80] RETURN WITH CARRY ON
2827 0DAE : C8                       ret     z               ;[M80] IF IT WAS CONTROL-C
2828 0DAF : FE 0D                    cp      13              ;
2829 0DB1 : CA E5 19                 jp      z,FININL        ;[M80] IS IT A CARRIAGE RETURN?
2830 0DB4 : FE 15                    cp      21              ;[M80] ;LINE DELETE? (CONTROL-U)
2831 0DB6 : CA 82 0D                 jp      z,INLINU        ;[M80] GO DO IT
2832 0DB9 : 00                       nop                     ;;;Whatever was removed isn't in the
2833 0DBA : 00                       nop                     ;;;available source codes
2834 0DBB : 00                       nop                     ;
2835 0DBC : 00                       nop                     ;
2836 0DBD : 00                       nop                     ;
2837 0DBE : FE 08                    cp      8               ;[M80] BACKSPACE? (CONTROL-H)?
2838 0DC0 : CA 7C 0D                 jp      z,LINLIN        ;[M65] YES
2839 0DC3 : FE 18                    cp      24              ;[M80] AT START OF LINE?
2840 0DC5 : 20 05                    jr      nz,NTCTLX       ;[M80] IS IT CONTROL-X (LINE DELETE)
2841 0DC7 : 3E 23                    ld      a,'#'           ;[M80] SEND NUMBER SIGN
2842 0DC9 : C3 81 0D                 jp      INLINN          ;[M80] SEND # SIGN AND ECHO
2843 0DCC
2844 0DCC : FE 12      (M80) NTCTLX: cp      18              ;[M80] CONTROL-R?
2845 0DCE : 20 14                    jr      nz,NTCTLR       ;[M80] NO
2846 0DD0 : C5                       push    bc              ;[M80] SAVE [B,C]
2847 0DD1 : D5                       push    de              ;[M80] SAVE [D,E]
2848 0DD2 : E5                       push    hl              ;[M80] SAVE [H,L]
2849 0DD3 : 36 00                    ld      (hl),0          ;[M80] STORE TERMINATOR
2850 0DD5 : CD EA 19                 call    CRDO            ;[M80] DO CRLF
2851 0DD8 : 21 60 38                 ld      hl,BUF          ;[M80] POINT TO START OF BUFFER
2852 0DDB : CD 9D 0E                 call    STROUT          ;;Print It
2853 0DDE : E1                       pop     hl              ;[M80] RESTORE [H,L]
2854 0DDF : D1                       pop     de              ;[M80] RESTORE [D,E]
2855 0DE0 : C1                       pop     bc              ;[M80] RESTORE [B,C]
2856 0DE1 : C3 8E 0D                 jp      INLINC          ;[M80] GET NEXT CHAR
2857 0DE4
2858 0DE4 : FE 20      (M80) NTCTLR: cp      ' '             ;[M80] CHECK FOR FUNNY CHARACTERS
2859 0DE6 : DA 8E 0D                 jp      c,INLINC        ;
2860 0DE9
2861 0DE9 : 78         (M80) GOODCH: ld      a,b             ;[M80] GET CURRENT LENGTH
2862 0DEA : FE 49                    cp      ENDBUF-BUF      ;[M80] ;Set Carry if longer than Buffer
2863 0DEC : 3E 07                    ld      a,7             ;[M80] GET BELL CHAR
2864 0DEE : D2 F8 0D                 jp      nc,OUTBEL       ;[M80] NO CAUSE FOR BELL
2865 0DF1 : 79         {M80} OUTBND: ld      a,c             ;[M80] RESTORE  CURRENT CHARACTER INTO [A]
2866 0DF2 : 71                       ld      (hl),c          ;[M80] STORE THIS CHARACTER
2867 0DF3 : 32 CC 38                 ld      (USFLG),a       ;[M80] FLAG THAT VALUE HAS BEEN PRINTED
2868 0DF6 : 23                       inc     hl              ;[M80] INCREMENT CHARACTER COUNT
2869 0DF7 : 04                       inc     b               ;[M80] BUMP POINTER INTO BUF
2870 0DF8 : DF         (M80) OUTBEL: rst     OUTCHR          ;[M80] SEND THE CHAR
2871 0DF9 : C3 8E 0D                 jp      INLINC          ;{M80} GET NEXT CHAR
2872 0DFC
2873 0DFC                  + ;[M80] THE FOLLOWING ROUTINE COMPARES TWO STRINGS
2874 0DFC                  | ;[M80] ONE WITH DESC IN [D,E] OTHER WITH DESC. IN [FACLO, FACLO+1]
2875 0DFC                  | ;[M80] A=0 IF STRINGS EQUAL
2876 0DFC                  | ;{M80} A=127 IF B,C,D,E .GT. FACLO
2877 0DFC                  | ;{M80} A=1 IF B,C,D,E .LT. FACLO
2878 0DFC                  | ;
2879 0DFC : D5         [M80] STRCMP: push    de
2880 0DFD : CD C9 0F                 call    FREFAC          ;[M80] FREE UP FAC STRING, GET POINTER TO DESCRIPTOR IN [H,L]
2881 0E00 : 7E                       ld      a,(hl)          ;[M80] SAVE THE LENGTH OF THE FAC STRING IN [A]
2882 0E01 : 23                       inc     hl              ;
2883 0E02 : 23                       inc     hl              ;
2884 0E03 : 4E                       ld      c,(hl)          ;[M80] SAVE THE POINTER AT THE FAC STRING DATA IN [B,C]
2885 0E04 : 23                       inc     hl              ;
2886 0E05 : 46                       ld      b,(hl)          ;
2887 0E06 : D1                       pop     de              ;[M80] GET THE STACK STRING POINTER
2888 0E07 : C5                       push    bc              ;[M80] SAVE THE POINTER AT THE FAC STRING DATA
2889 0E08 : F5                       push    af              ;[M80] SAVE THE FAC STRING LENGTH
2890 0E09 : CD CD 0F                 call    FRETMP          ;[M80] FREE UP STACK STRING, RETURN POINTER TO DESCRIPTOR IN [H,L]
2891 0E0C : CD 31 15                 call    MOVRM           ;
2892 0E0F : F1                       pop     af              ;
2893 0E10 : 57                       ld      d,a             ;
2894 0E11 : E1                       pop     hl              ;[M80] GET BACK 2ND CHARACTER POINTER
2895 0E12 : 7B         (M80) CSLOOP: ld      a,e             ;[M80] BOTH STRINGS ENDED
2896 0E13 : B2                       or      d               ;[M80] TEST BY OR'ING THE LENGTHS TOGETHER
2897 0E14 : C8                       ret     z               ;[M80] IF SO, RETURN WITH A ZERO
2898 0E15 : 7A                       ld      a,d             ;[M80] GET FACLO STRING LENGTH
2899 0E16 : D6 01                    sub     1               ;[M80] SET CARRY AND MAKE [A]=255 IF [D]=0
2900 0E18 : D8                       ret     c               ;[M80] RETURN IF THAT STRING ENDED
2901 0E19 : AF                       xor     a               ;[M80] MUST NOT HAVE BEEN ZERO, TEST CASE
2902 0E1A : BB                       cp      e               ;[M80] OF B,C,D,E STRING HAVING ENDED FIRST
2903 0E1B : 3C                       inc     a               ;[M80] RETURN WITH A=1
2904 0E1C : D0                       ret     nc              ;[M80] TEST THE CONDITION
2905 0E1D                    ;[M80] HERE WHEN NEITHER STRING ENDED
2906 0E1D : 15                       dec     d               ;[M80] DECREMENT BOTH CHARACTER COUNTS
2907 0E1E : 1D                       dec     e               ;
2908 0E1F : 0A                       ld      a,(bc)          ;[M80] GET CHARACTER FROM B,C,D,E STRING
2909 0E20 : 03                       inc     bc              ;
2910 0E21 : BE                       cp      (hl)            ;[M80] COMPARE WITH FACLO STRING
2911 0E22 : 23                       inc     hl              ;[M80] BUMP POINTERS (INX DOESNT CLOBBER CC'S)
2912 0E23 : 28 ED                    jr      z,CSLOOP        ;[M80] IF BOTH THE SAME, MUST BE MORE TO STRINGS
2913 0E25 : 3F                       ccf                     ;[M80] HERE WHEN STRINGS DIFFER
2914 0E26 : C3 F1 14                 jp      SIGNS           ;[M80] SET [A] ACCORDING TO CARRY
2915 0E29
2916 0E29                  + ;;CONVERT NUMBER TO STRING
2917 0E29                  | ;[M80] THE STR$ FUNCTION TAKES A NUMBER AND GIVES A STRING WITH
2918 0E29                  | ;[M80] THE CHARACTERS THE OUTPUT OF THE NUMBER WOULD HAVE GIVEN
2919 0E29 : CD 75 09   [M65] STR:    call    CHKNUM          ;[M80] IS A NUMERIC
2920 0E2C : CD 80 16                 call    FOUT            ;[M80] DO ITS OUTPUT
2921 0E2F : CD 5F 0E                 call    STRLIT          ;[M80] SCAN IT AND TURN IT INTO A STRING
2922 0E32 : CD C9 0F                 call    FREFAC          ;[M80] FREE UP THE TEMP
2923 0E35 : 01 1D 10                 ld      bc,FINBCK       ;
2924 0E38 : C5                       push    bc              ;[M80] SET UP ANSWER IN NEW TEMP
2925 0E39
2926 0E39                  + ;;COPY A STRING
2927 0E39                  | ;[M80] STRCPY CREATES A COPY OF THE STRING
2928 0E39                  | ;[M80] WHOSE DESCRIPTOR IS POINTED TO BY [H,L].
2929 0E39                  | ;[M80] ON RETURN [D,E] POINTS TO DSCTMP
2930 0E39                  | ;[M80] WHICH HAS THE STRING INFO (LENGTH,WHERE COPIED TO)
2931 0E39                  | ;
2932 0E39 : 7E         [M80] STRCPY: ld      a,(hl)          ;[M80] GET LENGTH
2933 0E3A : 23                       inc     hl              ;[M80] MOVE UP TO THE POINTER
2934 0E3B : 23                       inc     hl              ;[M80] GET POINTER TO POINTER OF ARG
2935 0E3C : E5                       push    hl              ;[M80] GET THE SPACE
2936 0E3D : CD B3 0E                 call    GETSPA          ;[M80] FIND OUT WHERE STRING TO COPY
2937 0E40 : E1                       pop     hl              ;
2938 0E41 : 4E                       ld      c,(hl)          ;
2939 0E42 : 23                       inc     hl              ;
2940 0E43 : 46                       ld      b,(hl)          ;
2941 0E44 : CD 53 0E                 call    STRAD2          ;[M80] SETUP DSCTMP
2942 0E47 : E5                       push    hl              ;[M80] SAVE POINTER TO DSCTMP
2943 0E48 : 6F                       ld      l,a             ;[M80] GET CHARACTER COUNT INTO [L]
2944 0E49 : CD BD 0F                 call    MOVSTR          ;[M80] MOVE THE CHARS IN
2945 0E4C : D1                       pop     de              ;[M80] RESTORE POINTER TO DSCTMP
2946 0E4D : C9                       ret                     ;[M80] RETURN
2947 0E4E
2948 0E4E : 3E 01      [M80] STRIN1: ld      a,1             ;[M80] MAKE ONE CHAR STRING (CHR$, INKEY$)
2949 0E50 : CD B3 0E   [M80] STRINI: call    GETSPA          ;[M80] GET SOME STRING SPACE ([A] CHARS)
2950 0E53 : 21 BD 38   [M80] STRAD2: ld      hl,DSCTMP       ;[M80] GET DESC. TEMP
2951 0E56 : E5         {M80} STRADI: push    hl              ;[M80] SAVE DESC. POINTER
2952 0E57 : 77                       ld      (hl),a          ;[M80] SAVE CHARACTER COUNT
2953 0E58 : 23                       inc     hl              ;[M80] STORE [D,E]=POINTER TO FREE SPACE
2954 0E59 : 23               STRADX: inc     hl              ;
2955 0E5A : 73                       ld      (hl),e          ;
2956 0E5B : 23                       inc     hl              ;
2957 0E5C : 72                       ld      (hl),d          ;
2958 0E5D : E1                       pop     hl              ;[M80] AND RESTORE [H,L] AS THE DESCRIPTOR POINTER
2959 0E5E : C9                       ret                     ;
2960 0E5F
2961 0E5F                  + ;;Build Descriptor for String Litersl
2962 0E5F                  | ;[M80] STRLT2 TAKES THE STRING LITERAL WHOSE FIRST CHARACTER
2963 0E5F                  | ;[M80] IS POINTED BY [H,L]+1 AND BUILDS A DESCRIPTOR FOR IT.
2964 0E5F                  | ;[M80] THE DESCRIPTOR IS INITIALLY BUILT IN DSCTMP, BUT PUTNEW
2965 0E5F                  | ;[M80] TRANSFERS IT INTO A TEMPORARY AND LEAVES A POINTER
2966 0E5F                  | ;[M80] AT THE TEMPORARY IN FACLO. THE CHARACTERS OTHER THAN
2967 0E5F                  | ;[M80] ZERO THAT TERMINATE THE STRING SHOULD BE SET UP IN [B]
2968 0E5F                  | ;[M80] AND [D]. IT THE TERMINATOR IS A QUOTE, THE QUOTE IS SKIPPED
2969 0E5F                  | ;[M80] OVER. LEADING QUOTES SHOULD BE SKIPPED BEFORE CALL. ON RETURN
2970 0E5F                  | ;[M80] THE CHARACTER AFTER THE STRING LITERAL IS POINTED TO
2971 0E5F                  | ;[M80] BY [H,L] AND IS IN [A], BUT THE CONDITION CODES ARE
2972 0E5F                  | ;[M80] NOT SET UP.
2973 0E5F                  | ;
2974 0E5F : 2B         [M80] STRLIT: dec     hl              ;;Back up to '"'
2975 0E60 : 06 22      [M80] STRLTI: ld      b,'"'           ;[M80] ASSUME STR ENDS ON QUOTE
2976 0E62 : 50         {M80} STRLT3: ld      d,b             ;
2977 0E63 : E5         [M80] STRLT2: push    hl              ;[M80] SAVE POINTER TO START OF LITERAL
2978 0E64 : 0E FF                    ld      c,255           ;[M80] INITIALIZE CHARACTER COUNT
2979 0E66 : 23         (M80) STRGET: inc     hl              ;;Move past '"'
2980 0E67 : 7E                       ld      a,(hl)          ;[M80] GET CHAR
2981 0E68 : 0C                       inc     c               ;[M80] BUMP CHARACTER COUNT
2982 0E69 : B7                       or      a               ;[M80] IF 0, (END OF LINE) DONE
2983 0E6A : 28 06                    jr      z,STRFIN        ;[M80] TEST
2984 0E6C : BA                       cp      d               ;
2985 0E6D : 28 03                    jr      z,STRFIN        ;
2986 0E6F : B8                       cp      b               ;[M80] CLOSING QUOTE
2987 0E70 : 20 F4                    jr      nz,STRGET       ;[M80] NO, GO BACK FOR MORE
2988 0E72 : FE 22      (M80) STRFIN: cp      '"'             ;[M80] IF QUOTE TERMINATES THE STRING
2989 0E74 : CC 6B 06                 call    z,CHRGTR        ;[M80] SKIP OVER THE QUOTE
2990 0E77 : E3                       ex      (sp),hl         ;[M80] SAVE POINTER AT END OF STRING
2991 0E78 : 23                       inc     hl              ;
2992 0E79 : EB                       ex      de,hl           ;[M80] GET POINTER TO TEMP
2993 0E7A : 79                       ld      a,c             ;[M80] GET CHARACTER COUNT IN A
2994 0E7B : CD 53 0E                 call    STRAD2          ;[M80] SAVE STR INFO
2995 0E7E
2996 0E7E                  + ;;Set Pointer to Temporary String Descriptor
2997 0E7E                  | ;[M80] SOME STRING FUNCTION IS RETURNING A RESULT IN DSCTMP
2998 0E7E                  | ;[M80] WE WANT TO SETUP A TEMP DESCRIPTOR WITH DCSTMP IN IT
2999 0E7E                  | ;[M80] PUT A POINTER TO THE DESCRIPTOR IN FACLO AND FLAG THE
3000 0E7E                  | ;[M80] RESULT AS TYPE STRING
3001 0E7E                  |
3002 0E7E : 11 BD 38   [M80] PUTNEW: ld      de,DSCTMP       ;[M80] [D,E] POINT AT RESULT DESCRIPTOR
3003 0E81 : 2A AF 38                 ld      hl,(TEMPPT)     ;[M80] [H,L]=POINTER TO FIRST FREE TEMP
3004 0E84 : 22 E4 38                 ld      (FACLO),hl      ;[M80] POINTER AT WHERE RESULT DESCRIPTOR WILL BE
3005 0E87 : 3E 01                    ld      a,1             ;
3006 0E89 : 32 AB 38                 ld      (VALTYP),a      ;[M80] FLAG THIS AS A STRING
3007 0E8C : CD 3D 15                 call    MOVE            ;[M80] AND MOVE THE VALUE INTO A TEMPORARY
3008 0E8F : E7                       rst     COMPAR          ;;IF TEMPPT POINTS TO DSCTMP, THERE ARE NO FREE TEMPS
3009 0E90 : 22 AF 38                 ld      (TEMPPT),hl     ;[M80] SAVE NEW TEMPORARY POINTER
3010 0E93 : E1                       pop     hl              ;[M80] GET THE TEXT POINTER
3011 0E94 : 7E                       ld      a,(hl)          ;[M80] GET CURRENT CHARACTER INTO [A]
3012 0E95 : C0                       ret     nz              ;
3013 0E96 : 11 1E 00                 ld      de,ERRST        ;[M80] "STRING TEMPORARY" ERROR
3014 0E99 : C3 DB 03                 jp      ERROR           ;[M80] GO TELL HIM
3015 0E9C
3016 0E9C                  + ;;Output String
3017 0E9C                  | ;[M80] PRINT THE STRING POINTED TO BY [H,L] WHICH ENDS WITH A ZERO
3018 0E9C                  | ;[M80] IF THE STRING IS BELOW DSCTMP IT WILL BE COPIED INTO STRING SPACE
3019 0E9C                  | ;
3020 0E9C : 23               STROUI: inc     hl              ;[M80] POINT AT NEXT CHARACTER
3021 0E9D : CD 5F 0E   [M80] STROUT: call    STRLIT          ;[M80] GET A STRING LITERAL
3022 0EA0                    ; PRINT THE STRING WHOSE DESCRIPTOR IS POINTED TO BY FACLO.
3023 0EA0 : CD C9 0F   [M80] STRPRT: call    FREFAC          ;[M80] RETURN TEMP POINTER BY FACLO
3024 0EA3 : CD 31 15                 call    MOVRM           ;[M80] [D]=LENGTH [B,C]=POINTER AT DATA
3025 0EA6 : 1C                       inc     e               ;[M80] CHECK FOR NULL STRING
3026 0EA7 : 1D         [M80' STRPR2: dec     e               ;[M80] DECREMENT THE LENGTH
3027 0EA8 : C8                       ret     z               ;[M80] ALL DONE
3028 0EA9 : 0A                       ld      a,(bc)          ;[M80] GET CHARACTER TO PRINT
3029 0EAA : DF                       rst     OUTCHR          ;
3030 0EAB : FE 0D                    cp      13              ;
3031 0EAD : CC F0 19                 call    z,CRFIN         ;[M65] TYPE REST OF CARRIAGE RETURN
3032 0EB0 : 03                       inc     bc              ;[M80] POINT TO THE NEXT CHARACTER
3033 0EB1 : 18 F4                    jr      STRPR2          ;[M80] AND PRINT IT...
3034 0EB3
3035 0EB3                  + ;[M80] GETSPA - GET SPACE FOR CHARACTER STRING
3036 0EB3                  | ;[M80] MAY FORCE GARBAGE COLLECTION.
3037 0EB3                  | ;[M80]
3038 0EB3                  | ;[M80] # OF CHARS (BYTES) IN [A]
3039 0EB3                  | ;[M80] RETURNS WITH POINTER IN [D,E] OTHERWISE IF CANT GET SPACE
3040 0EB3                  | ;[M80] BLOWS OFF TO "OUT OF STRING SPACE" TYPE ERROR.
3041 0EB3                  | ;
3042 0EB3 : B7         [M80] GETSPA: or      a               ;[M80] MUST BE NON ZERO. SIGNAL NO GARBAG YET
3043 0EB4 : 0E                       byte    $0E             ;[M80] "MVI C" AROUND THE NEXT BYTE
3044 0EB5 : F1         [M80] TRYGI2: pop     af              ;[M80] IN CASE COLLECTED WHAT WAS LENGTH?
3045 0EB6 : F5                       push    af              ;[M80] SAVE IT BACK
3046 0EB7 : 2A 4B 38                 ld      hl,(TOPMEM)     ;
3047 0EBA : EB                       ex      de,hl           ;[M80] IN [D,E]
3048 0EBB : 2A C1 38                 ld      hl,(FRETOP)     ;[M80] GET TOP OF FREE SPACE IN [H,L]
3049 0EBE : 2F                       cpl                     ;[M80] -# OF CHARS
3050 0EBF : 4F                       ld      c,a             ;[M80] IN [B,C]
3051 0EC0 : 06 FF                    ld      b,$FF           ;
3052 0EC2 : 09                       add     hl,bc           ;[M80] SUBTRACT FROM TOP OF FREE
3053 0EC3 : 23                       inc     hl              ;
3054 0EC4 : E7                       rst     COMPAR          ;[M80] COMPARE THE TWO
3055 0EC5 : 38 07                    jr      c,GARBAG        ;[M80] NOT ENOUGH ROOM FOR STRING, OFFAL TIME
3056 0EC7 : 22 C1 38                 ld      (FRETOP),hl     ;[M80] SAVE NEW BOTTOM OF MEMORY
3057 0ECA : 23                       inc     hl              ;[M80] MOVE BACK TO POINT TO STRING
3058 0ECB : EB                       ex      de,hl           ;[M80] RETURN WITH POINTER IN [D,E]
3059 0ECC : F1                       pop     af              ;
3060 0ECD : C9                       ret                     ;
3061 0ECE
3062 0ECE                    ;Garbage Collector - Removes Orphaned Strings
3063 0ECE : F1         [M80] GARBAG: pop     af              ;[M80] HAVE WE COLLECTED BEFORE?
3064 0ECF : 11 1A 00                 ld      de,ERRSO        ;[M80] GET READY FOR OUT OF STRING SPACE ERROR
3065 0ED2 : CA DB 03                 jp      z,ERROR         ;[M80] GO TELL USER HE LOST
3066 0ED5 : BF                       cp      a               ;[M80] SET ZERO FLAG TO SAY WEVE GARBAGED
3067 0ED6 : F5                       push    af              ;[M80] SAVE FLAG BACK ON STACK
3068 0ED7 : 01 B5 0E                 ld      bc,TRYGI2       ;[M80] PLACE FOR GARBAG TO RETURN TO.
3069 0EDA : C5                       push    bc              ;[M80] SAVE ON STACK
3070 0EDB : 2A AD 38   [M80] GARBA2: ld      hl,(MEMSIZ)     ;[M80] START FROM TOP DOWN
3071 0EDE : 22 C1 38   (M80) FNDVAR: ld      (FRETOP),hl     ;[M80] LIKE SO
3072 0EE1 : 21 00 00                 ld      hl,0            ;[M80] GET DOUBLE ZERO
3073 0EE4 : E5                       push    hl              ;[M80] SAY DIDNT SEE VARS THIS PASS
3074 0EE5 : 2A DA 38                 ld      hl,(STREND)     ;[M80] FORCE DVARS TO IGNORE STRINGS IN PROGRAM TEXT
3075 0EE8 : E5                       push    hl              ;[M80] FORCE FIND HIGH ADDRESS
3076 0EE9 : 21 B1 38                 ld      hl,TEMPST       ;[M80] GET START OF STRING TEMPS
3077 0EEC : ED 5B AF 38(M80) TVAR:   ld      de,(TEMPPT)     ;[M80] SEE IF DONE
3078 0EF0 : E7                       rst     COMPAR          ;[M80] TEST
3079 0EF1 : 01 EC 0E                 ld      bc,TVAR         ;[M80] FORCE JUMP TO TVAR
3080 0EF4 : C2 32 0F                 jp      nz,DVAR2        ;[M80] DO TEMP VAR GARBAGE COLLECT
3081 0EF7 : 2A D6 38                 ld      hl,(VARTAB)     ;[M80] GET STARTING POINT IN [H,L]
3082 0EFA
3083 0EFA : ED 5B D8 38(M80) SVAR:   ld      de,(ARYTAB)     ;[M80] GET STOPPING LOCATION
3084 0EFE : E7                       rst     COMPAR          ;[M80] SEE IF AT END OF SIMPS
3085 0EFF : 28 0A                    jr      z,ARYVA4        ;
3086 0F01 : 23                       inc     hl              ;{M80} BUMP POINTER
3087 0F02 : 7E                       ld      a,(hl)          ;[M80] GET VALTYP
3088 0F03 : 23                       inc     hl              ;[M80] POINT AT THE VALUE
3089 0F04 : B7                       or      a               ;
3090 0F05 : CD 35 0F                 call    DVARS           ;
3091 0F08 : 18 F0                    jr      SVAR            ;
3092 0F0A                    ;;;Subsection of [M80] ARYVAR
3093 0F0A : C1         (M80) ARYVA2: pop     bc              ;[M80] GET RID OF STACK GARBAGE
3094 0F0B : ED 5B DA 38(M80) ARYVA4: ld      de,(STREND)     ;[M80] GET RID OF STACK GARBAGE
3095 0F0F : E7                       rst     COMPAR          ;[M80] SEE IF DONE WITH ARRAYS
3096 0F10 : CA 57 0F                 jp      z,GRBPAS        ;[M80] YES, SEE IF DONE COLLECTING
3097 0F13 : CD 31 15                 call    MOVRM           ;
3098 0F16 : 7A                       ld      a,d             ;
3099 0F17 : E5                       push    hl              ;
3100 0F18 : 09                       add     hl,bc           ;[M80] ADDING BASE TO LENGTH
3101 0F19 : B7                       or      a               ;[M80]
3102 0F1A : F2 0A 0F                 jp      p,ARYVA2        ;;Loop
3103 0F1D : 22 C5 38                 ld      (TEMP8),hl      ;[M80] SAVE END OF ARRAY
3104 0F20 : E1                       pop     hl              ;[M80] GET BACK CURRENT POSITION
3105 0F21 : 4E                       ld      c,(hl)          ;[M80] PICK UP NUMBER OF DIMS
3106 0F22 : 06 00                    ld      b,0             ;[M80] MAKE DOUBLE WITH HIGH ZERO
3107 0F24 : 09                       add     hl,bc           ;[M80] GO PAST DIMS
3108 0F25 : 09                       add     hl,bc           ;[M80] BY ADDING ON TWICE #DIMS (2 BYTE GUYS)
3109 0F26 : 23                       inc     hl              ;[M80] ONE MORE TO ACCOUNT FOR #DIMS.
3110 0F27 : EB         (M80) ARYSTR: ex      de,hl           ;[M80] SAVE CURRENT POSIT IN [D,E]
3111 0F28 : 2A C5 38                 ld      hl,(TEMP8)      ;[M80] GET END OF ARRAY
3112 0F2B : EB                       ex      de,hl           ;[M80] FIX [H,L] BACK TO CURRENT
3113 0F2C : E7                       rst     COMPAR          ;[M80] SEE IF AT END OF ARRAY
3114 0F2D : 28 DC                    jr      z,ARYVA4        ;[M80] END OF ARRAY, TRY NEXT ARRAY
3115 0F2F : 01 27 0F                 ld      bc,ARYSTR       ;[M80] ADDR OF WHERE TO RETURN TO
3116 0F32 : C5         (M80) DVAR2:  push    bc              ;[M80] GOES ON STACK
3117 0F33 : F6 80                    or      $80             ;;Set Flags
3118 0F35 : 7E         [M80] DVARS:  ld      a,(hl)          ;[M80] GET VALTYP
3119 0F36 : 23                       inc     hl              ;[M80] BUMP POINTER TWICE
3120 0F37 : 23                       inc     hl              ;
3121 0F38 : 5E                       ld      e,(hl)          ;[M80] [D,E]=AMOUNT TO SKIP
3122 0F39 : 23                       inc     hl              ;
3123 0F3A : 56                       ld      d,(hl)          ;
3124 0F3B : 23                       inc     hl              ;
3125 0F3C : F0                       ret     p               ;
3126 0F3D : B7                       or      a               ;
3127 0F3E : C8                       ret     z               ;[M80] NULL STRING, RETURN
3128 0F3F : 44                       ld      b,h             ;[M80] MOVE [B,C] BACK TO [H,L]
3129 0F40 : 4D                       ld      c,l             ;
3130 0F41 : 2A C1 38                 ld      hl,(FRETOP)     ;[M80] GET POINTER TO TOP OF STRING FREE SPACE
3131 0F44 : E7                       rst     COMPAR          ;[M80] IS THIS STRINGS POINTER .LT. FRETOP
3132 0F45 : 60                       ld      h,b             ;[M80] MOVE [B,C] BACK TO [H,L]
3133 0F46 : 69                       ld      l,c             ;
3134 0F47 : D8                       ret     c               ;[M80] IF NOT, NO NEED TO MESS WITH IT FURTHUR
3135 0F48 : E1                       pop     hl              ;[M80] GET RETURN ADDRESS OFF STACK
3136 0F49 : E3                       ex      (sp),hl         ;[M80] GET MAX SEEN SO FAR & SAVE RETURN ADDRESS
3137 0F4A : E7                       rst     COMPAR          ;[M80] LETS SEE
3138 0F4B : E3                       ex      (sp),hl         ;[M80] SAVE MAX SEEN & GET RETURN ADDRESS OFF STACK
3139 0F4C : E5                       push    hl              ;[M80] SAVE RETURN ADDRESS BACK
3140 0F4D : 60                       ld      h,b             ;[M80] MOVE [B,C] BACK TO [H,L]
3141 0F4E : 69                       ld      l,c             ;[
3142 0F4F : D0                       ret     nc              ;[M80] IF NOT, LETS LOOK AT NEXT VAR
3143 0F50 : C1                       pop     bc              ;[M80] GET RETURN ADDR OFF STACK
3144 0F51 : F1                       pop     af              ;[M80] POP OFF MAX SEEN
3145 0F52 : F1                       pop     af              ;[M80] AND VARIABLE POINTER
3146 0F53 : E5                       push    hl              ;[M80] SAVE NEW VARIABLE POINTER
3147 0F54 : D5                       push    de              ;[M80] AND NEW MAX POINTER
3148 0F55 : C5                       push    bc              ;[M80] SAVE RETURN ADDRESS BACK
3149 0F56 : C9                       ret                     ;[M80] AND RETURN
3150 0F57
3151 0F57                    ;[M80] HERE WHEN MADE ONE COMPLETE PASS THRU STRING VARS
3152 0F57 : D1         [M80] GRBPAS: pop     de              ;[M80] POP OFF MAX POINTER
3153 0F58 : E1                       pop     hl              ;[M80] AND GET VARIABLE POINTER
3154 0F59 : 7C                       ld      a,h             ;[M80] GET LOW IN
3155 0F5A : B5                       or      l               ;[M80] SEE IF ZERO POINTER
3156 0F5B : C8                       ret     z               ;[M80] IF END OF COLLECTION, THEN MAYBE RETURN TO GETSPA
3157 0F5C : 2B                       dec     hl              ;[M80] CURRENTLY JUST PAST THE DESCRIPTOR
3158 0F5D : 46                       ld      b,(hl)          ;[M80] [B]=HIGH BYTE OF DATA POINTER
3159 0F5E : 2B                       dec     hl              ;
3160 0F5F : 4E                       ld      c,(hl)          ;[M80] [B,C]=POINTER AT STRING DATA
3161 0F60 : E5                       push    hl              ;[M80] SAVE LOCATION TO UPDTE POINTER AFTER STRING IS MOVED
3162 0F61 : 2B                       dec     hl              ;
3163 0F62 : 2B                       dec     hl              ;
3164 0F63 : 6E                       ld      l,(hl)          ;[M80] [L]=STRING LENGTH
3165 0F64 : 26 00                    ld      h,0             ;[M80] [H,L] GET CHARACTER COUNT
3166 0F66 : 09                       add     hl,bc           ;[M80] [H,L]=POINTER BEYOND STRING
3167 0F67 : 50                       ld      d,b             ;
3168 0F68 : 59                       ld      e,c             ;[M80] [D,E]=ORIGINAL POINTER
3169 0F69 : 2B                       dec     hl              ;[M80] DON'T MOVE ONE BEYOND STRING
3170 0F6A : 44                       ld      b,h             ;[M80] GET TOP OF STRING IN [B,C]
3171 0F6B : 4D                       ld      c,l             ;
3172 0F6C : 2A C1 38                 ld      hl,(FRETOP)     ;[M80] GET TOP OF FREE SPACE
3173 0F6F : CD 95 0B                 call    BLTUC           ;[M80] MOVE STRING
3174 0F72 : E1                       pop     hl              ;[M80] GET BACK POINTER TO DESC.
3175 0F73 : 71                       ld      (hl),c          ;[M80] SAVE FIXED ADDR
3176 0F74 : 23                       inc     hl              ;[M80] MOVE POINTER
3177 0F75 : 70                       ld      (hl),b          ;[M80] HIGH PART
3178 0F76 : 60                       ld      h,b             ;
3179 0F77 : 69                       ld      l,c             ;[M80] [H,L]=NEW POINTER
3180 0F78 : 2B                       dec     hl              ;[M80] FIX UP FRETOP
3181 0F79 : C3 DE 0E                 jp      FNDVAR          ;[M80] AND TRY TO FIND HIGH AGAIN
3182 0FC7                    ;
3183 0FC7                    ;[M80] STRING CONCATENATION
3184 0FC7                    ;[M80] THE FOLLOWING ROUTINE CONCATENATES TWO STRINGS
3185 0FC7                    ;[M80] THE FACLO CONTAINS THE FIRST ONE AT THIS POINT,
3186 0FC7                    ;[M80] [H,L] POINTS BEYOND THE + SIGN AFTER IT
3187 0FC7                    ;
3188 0F7C : C5         [M80] CAT:    push    bc              ;[M80] PUT OLD PRECEDENCE BACK ON
3189 0F7D : E5                       push    hl              ;[M80] SAVE TEXT POINTER
3190 0F7E : 2A E4 38                 ld      hl,(FACLO)      ;[M80] GET POINTER TO STRING DESC.
3191 0F81 : E3                       ex      (sp),hl         ;[M80] SAVE ON STACK & GET TEXT POINTER BACK
3192 0F82 : CD FD 09                 call    EVAL            ;[M80] EVALUATE REST OF FORMULA
3193 0F85 : E3                       ex      (sp),hl         ;[M80] SAVE TEXT POINTER, GET BACK DESC.
3194 0F86 : CD 76 09                 call    CHKSTR          ;
3195 0F89 : 7E                       ld      a,(hl)          ;
3196 0F8A : E5                       push    hl              ;[M80] SAVE DESC. POINTER.
3197 0F8B : 2A E4 38                 ld      hl,(FACLO)      ;[M80] GET POINTER TO 2ND DESC.
3198 0F8E : E5                       push    hl              ;[M80] SAVE IT
3199 0F8F : 86                       add     a,(hl)          ;[M80] ADD TWO LENGTHS TOGETHER
3200 0F90 : 11 1C 00                 ld      de,ERRLS        ;[M80] SEE IF RESULT .LT. 256
3201 0F93 : DA DB 03                 jp      c,ERROR         ;[M80] ERROR "LONG STRING"
3202 0F96 : CD 50 0E                 call    STRINI          ;[M80] GET INITIAL STRING
3203 0F99 : D1                       pop     de              ;[M80] GET 2ND DESC.
3204 0F9A : CD CD 0F                 call    FRETMP          ;
3205 0F9D : E3                       ex      (sp),hl         ;[M80] SAVE POINTER TO IT
3206 0F9E : CD CC 0F                 call    FRETM2          ;[M80] FREE UP 1ST TEMP
3207 0FA1 : E5                       push    hl              ;[M80] SAVE DESC. POINTER (FIRST)
3208 0FA2 : 2A BF 38                 ld      hl,(DSCTMP+2)   ;[M80] GET POINTER TO FIRST
3209 0FA5 : EB                       ex      de,hl           ;[M80] IN [D,E]
3210 0FA6 : CD B4 0F                 call    MOVINS          ;[M80] MOVE IN THE FIRST STRING
3211 0FA9 : CD B4 0F                 call    MOVINS          ;[M80] AND THE SECOND
3212 0FAC : 21 91 09                 ld      hl,TSTOP        ;[M80] CAT REENTERS FORMULA EVALUATION AT TSTOP
3213 0FAF : E3                       ex      (sp),hl         ;
3214 0FB0 : E5                       push    hl              ;[M80] TEXT POINTER OFF FIRST
3215 0FB1 : C3 7E 0E                 jp      PUTNEW          ;[M80] THEN RETURN ADDRESS OF TSTOP
3216 0FB4
3217 0FB4 : E1         [M80] MOVINS: pop     hl              ;[M80] GET RETURN ADDR
3218 0FB5 : E3                       ex      (sp),hl         ;[M80] PUT BACK, BUT GET DESC.
3219 0FB6 : 7E                       ld      a,(hl)          ;[M80] [A]=STRING LENGTH
3220 0FB7 : 23                       inc     hl              ;
3221 0FB8 : 23                       inc     hl              ;
3222 0FB9 : 4E                       ld      c,(hl)          ;[M80] [B,C]=POINTER AT STRING DATA
3223 0FBA : 23                       inc     hl              ;
3224 0FBB : 46                       ld      b,(hl)          ;
3225 0FBC : 6F                       ld      l,a             ;[M80] [L]=STRING LENGTH
3226 0FBD : 2C         [M80] MOVSTR: inc     l               ;
3227 0FBE : 2D         (M80) MOVLP:  dec     l               ;[M80] SET CC'S
3228 0FBF : C8                       ret     z               ;[M80] 0, NO BYTE TO MOVE
3229 0FC0 : 0A                       ld      a,(bc)          ;[M80] GET CHAR
3230 0FC1 : 12                       ld      (de),a          ;[M80] SAVE IT
3231 0FC2 : 03                       inc     bc              ;[M80] MOVE POINTERS
3232 0FC3 : 13                       inc     de              ;
3233 0FC4 : 18 F8                    jr      MOVLP           ;[M80] KEEP DOING IT
3234 0FC6
3235 0FC6                  + ;[M80] FREE UP STRING TEMPORARY - FRESTR, FREFAC, FRETMP, FRETMS
3236 0FC6                  | ;[M80] FRETMP IS PASSED A POINTER TO A STRING DESCRIPTOR IN [D,E]
3237 0FC6                  | ;[M80] THIS VALUE IS RETURNED IN [H,L]. ALL THE OTHER REGISTERS ARE MODIFIED.
3238 0FC6                  | ;[M80] A CHECK TO IS MADE TO SEE IF THE STRING DESCRIPTOR [D,E] POINTS
3239 0FC6                  | ;[M80] TO IS THE LAST TEMPORARY DESCRIPTOR ALLOCATED BY PUTNEW.
3240 0FC6                  | ;[M80] IF SO, THE TEMPORARY IS FREED UP BY THE UPDATING OF TEMPPT.
3241 0FC6                  | ;[M80] IF A TEMPORARY IS FREED UP, A FURTHER CHECK IS MADE TO SEE IF THE
3242 0FC6                  | ;[M80] STRING DATA THAT THAT STRING TEMPORARY POINTED TO IS THE
3243 0FC6                  | ;[M80] THE LOWEST PART OF STRING SPACE IN USE.
3244 0FC6                  | ;[M80] IF SO, FRETMP IS UPDATED TO REFLECT THE FACT THAT THAT SPACE IS NO
3245 0FC6                  | ;[M80] LONGER IN USE.
3246 0FC6                  | ;
3247 0FC6 : CD 76 09   [M80] FRESTR: call    CHKSTR          ;[M80] MAKE SURE ITS A STRING
3248 0FC9 : 2A E4 38   [M80] FREFAC: ld      hl,(FACLO)      ;
3249 0FCC : EB         [M80] FRETM2: ex      de,hl           ;[M80] FREE UP THE TEMP IN THE FACLO
3250 0FCD : CD E4 0F   [M80] FRETMP: call    FRETMS          ;[M80] FREE UP THE TEMPORARY
3251 0FD0 : EB                       ex      de,hl           ;[M80] PUT THE STRING POINTER INTO [H,L]
3252 0FD1 : C0                       ret     nz              ;
3253 0FD2 : D5                       push    de              ;[M80] SAVE [D,E] TO RETURN IN [H,L]
3254 0FD3 : 50                       ld      d,b             ;[M80] [D,E]=POINTER AT STRING
3255 0FD4 : 59                       ld      e,c             ;
3256 0FD5 : 1B                       dec     de              ;[M80] SUBTRACT ONE
3257 0FD6 : 4E                       ld      c,(hl)          ;[M80] [C]=LENGTH OF THE STRING FREED UP
3258 0FD7 : 2A C1 38                 ld      hl,(FRETOP)     ;[M80] SEE IF ITS THE FIRST ONE IN STRING SPACE
3259 0FDA : E7                       rst     COMPAR          ;
3260 0FDB : 20 05                    jr      nz,NOTLST       ;[M80] NO SO DON'T ADD
3261 0FDD : 47                       ld      b,a             ;[M80] MAKE [B]=0
3262 0FDE : 09                       add     hl,bc           ;[M80] ADD
3263 0FDF : 22 C1 38                 ld      (FRETOP),hl     ;[M80] AND UPDATE FRETOP
3264 0FE2 : E1         (M80) NOTLST: pop     hl              ;[M80] GET POINTER AT CURRENT DESCRIPTOR
3265 0FE3 : C9                       ret
3266 0FE4
3267 0FE4 : 2A AF 38   [M80] FRETMS: ld      hl,(TEMPPT)     ;[M80] GET TEMP POINTER
3268 0FE7 : 2B                       dec     hl              ;[M80] LOOK AT WHAT IS IN THE LAST TEMP
3269 0FE8 : 46                       ld      b,(hl)          ;[M80] [B,C]=POINTER AT STRING
3270 0FE9 : 2B                       dec     hl              ;[M80] DECREMENT TEMPPT BY STRSIZ
3271 0FEA : 4E                       ld      c,(hl)          ;
3272 0FEB : 2B                       dec     hl              ;
3273 0FEC : 2B                       dec     hl              ;
3274 0FED : E7                       rst     COMPAR          ;[M80] SEE IF [D,E] POINT AT THE LAST
3275 0FEE : C0                       ret     nz              ;[M80] RETURN NOW IF NOW FREEING DONE
3276 0FEF : 22 AF 38                 ld      (TEMPPT),hl     ;[M80] UPDATE THE TEMP POINTER SINCE
3277 0FF2 : C9                       ret                     ;
3278 0FF3
3279 0FF3                  + ;[M80] THE FUNCTION LEN($)
3280 0FF3                  | ;[M80] RETURNS THE LENGTH OF THE STRING PASSED AS AN ARGUMENT
3281 0FF3 : 01 36 0B   [M80] LEN:    ld      bc,SNGFLT       ;[M80] CALL SNGFLT WHEN DONE
3282 0FF6 : C5                       push    bc              ;[M80] LIKE SO
3283 0FF7 : CD C6 0F   [M80] LEN1:   call    FRESTR          ;[M80] FREE UP TEMP POINTED TO BY FACLO
3284 0FFA : AF                       xor     a               ;[M80] FORCE NUMERIC FLAG
3285 0FFB : 57                       ld      d,a             ;[M80] SET HIGH OF [D,E] TO ZERO FOR VAL
3286 0FFC : 32 AB 38                 ld      (VALTYP),a      ;
3287 0FFF : 7E                       ld      a,(hl)          ;
3288 1000 : B7                       or      a               ;[M80] SET CONDITION CODES ON LENGTH
3289 1001 : C9                       ret                     ;[M80] RETURN
3290 1002
3291 1002                    ;[M80] THE FOLLOWING IS THE ASC($) FUNCTION.
3292 1002                    ;[M80] IT RETURNS AN INTEGER WHICH IS THE DECIMAL ASCII EQUIVALENT
3293 1002 : 01 36 0B   [M80] ASC:    ld      bc,SNGFLT       ;[M80] WHERE TO GO WHEN DONE
3294 1005 : C5                       push    bc              ;[M80] SAVE RETURN ADDR ON STACK
3295 1006 : CD F7 0F   [M80] ASC2:   call    LEN1            ;[M80] SET UP ORIGINAL STR
3296 1009 : CA 97 06                 jp      z,FCERR         ;[M80] NULL STR, BAD ARG.
3297 100C : 23                       inc     hl              ;[M80] BUMP POINTER
3298 100D : 23                       inc     hl              ;
3299 100E : 5E                       ld      e,(hl)          ;[M80] [D,E]=POINTER AT STRING DATA
3300 100F : 23                       inc     hl              ;
3301 1010 : 56                       ld      d,(hl)          ;
3302 1011 : 1A                       ld      a,(de)          ;[M80] [A]=FIRST CHARACTER
3303 1012 : C9                       ret                     ;
3304 1013
3305 1013                  + ;;CHR$ Function
3306 1013                  | ;[M80] CHR$(#) CREATES A STRING WHICH CONTAINS AS ITS ONLY
3307 1013                  | ;[M80] CHARACTER THE ASCII EQUIVALENT OF THE INTEGER ARG (#)
3308 1013                  | ;[M80] WHICH MUST BE .LE. 255.
3309 1013 : CD 4E 0E   [M65] CHR:    call    STRIN1          ;[M80] GET STRING IN DSCTMP
3310 1016 : CD 57 0B                 call    CONINT          ;[M80] GET INTEGER IN RANGE
3311 1019 : 2A BF 38   [M80] SETSTR: ld      hl,(DSCTMP+2)   ;[M80] GET ADDR OF STR
3312 101C : 73                       ld      (hl),e          ;[M80] SAVE ASCII BYTE
3313 101D : C1         [M80] FINBCK: pop     bc              ;[M80] RETURN TO HIGHER LEVEL & SKIP THE CHKNUM CALL
3314 101E : C3 7E 0E                 jp      PUTNEW          ;[M80] GO CALL PUTNEW
3315 1021
3316 1021                  + ;[M80] THE FOLLOWING IS THE LEFT$($,#) FUNCTION.
3317 1021                  | ;[M80] IT TAKES THE LEFTMOST # CHARS OF THE STR.
3318 1021                  | ;[M80] IF # IS .GT. THAN THE LEN OF THE STR, IT RETURNS THE WHOLE STR.
3319 1021 : CD A0 10   [M65] LEFT:   call    PREAM           ;[M80] TEST THE PARAMETERS
3320 1024 : AF                       xor     a               ;[M80] LEFT NEVER CHANGES STRING POINTER
3321 1025 : E3         [M80] LEFT3:  ex      (sp),hl         ;[M80] SAVE TEXT POINTER
3322 1026 : 4F                       ld      c,a             ;[M80] OFFSET NOW IN [C]
3323 1027 : E5         [M80] LEFT2:  push    hl              ;[M80] SAVE DESC. FOR  FRETMP
3324 1028 : 7E                       ld      a,(hl)          ;[M80] GET STRING LENGTH
3325 1029 : B8                       cp      b               ;[M80] ENTIRE STRING WANTED?
3326 102A : 38 02                    jr      c,ALLSTR        ;[M80] IF #CHARS ASKED FOR.GE.LENGTH,YES
3327 102C : 78                       ld      a,b             ;[M80] GET TRUNCATED LENGTH OF STRING
3328 102D : 11                       byte    $11             ;[M80] SKIP OVER MVI USING "LD D,"
3329 102E : 0E 00      [M80] ALLSTR: ld      c,0             ;[M80] MAKE OFFSET ZERO
3330 1030 : C5                       push    bc              ;[M80] SAVE OFFSET ON STACK
3331 1031 : CD B3 0E                 call    GETSPA          ;[M80] GET SPACE FOR NEW STRING
3332 1034 : C1                       pop     bc              ;[M80] GET BACK OFFSET
3333 1035 : E1                       pop     hl              ;[M80] GET BACK DESC POINTER.
3334 1036 : E5                       push    hl              ;[M80] BUT KEEP ON STACK
3335 1037 : 23                       inc     hl              ;[M80] MOVE TO STRING POINTER FIELD
3336 1038 : 23                       inc     hl              ;
3337 1039 : 46                       ld      b,(hl)          ;[M80] GET POINTER LOW
3338 103A : 23                       inc     hl              ;
3339 103B : 66                       ld      h,(hl)          ;[M80] POINTER HIGH
3340 103C : 68                       ld      l,b             ;[M80] GET LOW IN  L
3341 103D : 06 00                    ld      b,000H          ;[M80] GET READY TO ADD OFFSET TO POINTER
3342 103F : 09                       add     hl,bc           ;[M80] ADD  IT
3343 1040 : 44                       ld      b,h             ;[M80] GET OFFSET POINTER IN [B,C]
3344 1041 : 4D                       ld      c,l             ;
3345 1042 : CD 53 0E                 call    STRAD2          ;[M80] SAVE INFO IN DSCTMP
3346 1045 : 6F                       ld      l,a             ;[M80] GET#  OF CHARS TO  MOVE IN L
3347 1046 : CD BD 0F                 call    MOVSTR          ;[M80] MOVE THEM IN
3348 1049 : D1                       pop     de              ;[M80] GET BACK DESC. POINTER
3349 104A : CD CD 0F                 call    FRETMP          ;[M80] FREE IT UP.
3350 104D : C3 7E 0E                 jp      PUTNEW          ;[M80] PUT TEMP IN TEMP LIST
3351 1050
3352 1050 : CD A0 10   [M80] RIGHT:  call    PREAM           ;[M80] CHECK ARG
3353 1053 : D1                       pop     de              ;[M80] GET DESC. POINTER
3354 1054 : D5                       push    de              ;[M80] SAVE BACK FOR LEFT
3355 1055 : 1A                       ld      a,(de)          ;[M80] GET PRESENT LEN OF STR
3356 1056 : 90                       sub     b               ;[M80] SUBTRACT 2ND PARM
3357 1057 : 18 CC                    jr      LEFT3           ;[M80] CONTINUE WITH LEFT CODE
3358 1059
3359 1059                  + ;[M80] MID ($,#) RETURNS STR WITH CHARS FROM # POSITION ONWARD.
3360 1059                  | ;[M80] IF # IS GT LEN($) THEN RETURN NULL STRING.
3361 1059                  | ;[M80] MID ($,#,#) RETURNS STR WITH CHARS FROM # POSITION
3362 1059                  | ;[M80] FOR #2 CHARS. IF #2 GOES PAST END OF STRING, RETURN
3363 1059                  | ;[M80] AS MUCH AS POSSIBLE.
3364 1059 : EB         [M80] MID:    ex      de,hl           ;[M80] PUT THE TEXT POINTER IN [H,L]
3365 105A : 7E                       ld      a,(hl)          ;[M80] GET THE FIRST CHARACTER
3366 105B : CD A3 10                 call    PREAM2          ;[M80] GET OFFSET OFF STACK AND MAKE
3367 105E : 04                       inc     b               ;
3368 105F : 05                       dec     b               ;[M80] SEE IF EQUAL TO ZERO
3369 1060 : CA 97 06                 jp      z,FCERR         ;[M80] IT MUST NOT BE 0
3370 1063 : C5                       push    bc              ;
3371 1064 : 1E FF      [M80] MIDRST: ld      e,$FF           ;[M80] IF TWO ARG GUY, TRUNCATE
3372 1066 : FE 29                    cp      ')'             ;[M80] [E] SAYS USE ALL CHARS
3373 1068 : 28 05                    jr      z,MID2          ;[M80] IF ONE ARGUMENT THIS IS CORRECT
3374 106A : CF                       rst     SYNCHK          ;
3375 106B : 2C                       byte    ','             ;[M80] COMMA? MUST DELINEATE 3RD ARG
3376 106C : CD 54 0B                 call    GETBYT          ;[M80] GET ARGUMENT  IN  [E]
3377 106F : CF         [M80] MID2:   rst     SYNCHK          ;
3378 1070 : 29                       byte    ')'             ;[M80] MUST BE FOLLOWED BY )
3379 1071 : F1                       pop     af              ;[M80] GET OFFSET BACK IN A
3380 1072 : E3                       ex      (sp),hl         ;[M80] SAVE TEXT POINTER, GET DESC.
3381 1073 : 01 27 10                 ld      bc,LEFT2        ;[M80] WHERE TO RETURN TO.
3382 1076 : C5                       push    bc              ;[M80] GOES ON STACK
3383 1077 : 3D                       dec     a               ;[M80] SUB ONE FROM OFFSET
3384 1078 : BE                       cp      (hl)            ;[M80] POINTER PAST END OF STR?
3385 1079 : 06 00                    ld      b,0             ;[M80] ASSUME NULL LENGTH STR
3386 107B : D0                       ret     nc              ;[M80] YES, JUST USE NULL STR
3387 107C : 4F                       ld      c,a             ;[M80] SAVE OFFSET OF CHARACTER POINTER
3388 107D : 7E                       ld      a,(hl)          ;[M80] GET PRESENT LEN OF STR
3389 107E : 91                       sub     c               ;[M80] SUBTRACT INDEX (2ND ARG)
3390 107F : BB                       cp      e               ;[M80] IS IT TRUNCATION
3391 1080 : 47                       ld      b,a             ;[M80] GET CALCED LENGTH IN B
3392 1081 : D8                       ret     c               ;[M80] IF NOT USE PARTIAL STR
3393 1082 : 43                       ld      b,e             ;[M80] USE TRUNCATED LENGTH
3394 1083 : C9                       ret                     ;[M80] RETURN TO LEFT2
3395 1084
3396 1084                  + ;[M80] THE VAL FUNCTION TAKES A STRING AND TURN IT INTO A NUMBER
3397 1084                  | ;[M80] BY INTERPRETING THE ASCII DIGITS. ETC..
3398 1084                  | ;[M80] EXCEPT FOR THE PROBLEM THAT A TERMINATOR MUST BE SUPPLIED
3399 1084                  | ;[M80] BY REPLACING THE CHARACTER BEYOND THE STRING, VAL
3400 1084                  | ;[M80] IS MERELY A CALL TO FLOATING INPUT (FIN).
3401 1084                  | ;
3402 1084                  | ;[M80] IF STRING IS HIGHEST IN STRING SPACE WE ARE MODIFYING [MEMSIZ]
3403 1084                  | ;[M80] AND THIS IS WHY [MEMSIZ] CAN'T BE USED TO STORE STRING DATA
3404 1084                  | ;[M80] BECAUSE WHAT IF THE USER TOOK VAL OFF THAT HIGH STRING
3405 1084 : CD F7 0F   [M80] VAL:    call    LEN1            ;[M80] DO SETUP, SET RESULT=REAL
3406 1087 : CA C3 12                 jp      z,ZERO          ;[M80] MAKE SURE TYPE SET UP OK IN EXTENDED
3407 108A : 5F                       ld      e,a             ;[M80] GET LENGTH OF STR
3408 108B : 23                       inc     hl              ;[M80] TO HANDLE THE FACT THE IF
3409 108C : 23                       inc     hl              ;
3410 108D : 7E                       ld      a,(hl)          ;
3411 108E : 23                       inc     hl              ;
3412 108F : 66                       ld      h,(hl)          ;[M80] TWO STRINGS "1" AND "2"
3413 1090 : 6F                       ld      l,a             ;[M80] ARE STORED NEXT TO EACH OTHER
3414 1091 : E5                       push    hl              ;[M80] AND FIN IS CALLED POINTING TO
3415 1092 : 19                       add     hl,de           ;[M80] THE FIRST TWELVE WILL BE RETURNED
3416 1093 : 46                       ld      b,(hl)          ;[M80] THE IDEA IS TO STORE 0 IN THE
3417 1094 : 72                       ld      (hl),d          ;[M80] STRING BEYOND THE ONE VAL
3418 1095 : E3                       ex      (sp),hl         ;[M80] IS BEING CALLED ON
3419 1096 : C5                       push    bc              ;[M80] THE FIRST CHARACTER OF THE NEXT STRING
3420 1097 : 2B                       dec     hl              ;[M80] ***CALL CHRGET TO MAKE SURE
3421 1098 : D7                       rst     CHRGET          ;[M80] VAL(" -3")=-3
3422 1099 : CD E5 15                 call    FIN             ;[M80] IN EXTENDED, GET ALL THE PRECISION WE CAN
3423 109C : C1                       pop     bc              ;[M80] GET THE MODIFIED CHARACTER OF THE NEXT STRING INTO [B]
3424 109D : E1                       pop     hl              ;[M80] GET THE POINTER TO THE MODIFIED CHARACTER
3425 109E : 70                       ld      (hl),b          ;[M80] RESTORE THE CHARACTER
3426 109F : C9                       ret                     ;
3427 10A0
3428 10A0                    ;[M80] USED BY RIGHT$ AND LEFT$ FOR PARAMETER CHECKING AND SETUP
3429 10A0 : EB         [M80] PREAM:  ex      de,hl           ;[M80] PUT THE TEXT POINTER IN [H,L]
3430 10A1 : CF                       rst     SYNCHK          ;
3431 10A2 : 29                       byte    ')'             ;[M80] PARAM LIST SHOULD END
3432 10A3                    ;[M80] USED BY MID$ FOR PARAMETER CHECKING AND SETUP
3433 10A3 : C1         [M80] PREAM2: pop     bc              ;[M80] GET RETURN ADDR OFF STACK
3434 10A4 : D1                       pop     de              ;[M80] GET LENGTH OF ARG OFF STACK
3435 10A5 : C5                       push    bc              ;[M80] SAVE RETURN ADDR BACK ON
3436 10A6 : 43                       ld      b,e             ;[M80] SAVE INIT LENGTH
3437 10A7 : C9                       ret
3438 10A8
3439 10A8 :                  ;[M65] FRE FUNCTION AND INTEGER TO FLOATING ROUTINES
3440 10A8 : 2A DA 38   [M80] FRE:    ld      hl,(STREND)     ;
3441 10AB : EB                       ex      de,hl           ;
3442 10AC : 21 00 00                 ld      hl,0            ;
3443 10AF : 39                       add     hl,sp           ;
3444 10B0 : 3A AB 38                 ld      a,(VALTYP)      ;
3445 10B3 : B7                       or      a               ;
3446 10B4 : CA 1C 0B                 jp      z,GIVFLT        ;
3447 10B7 : CD C9 0F                 call    FREFAC          ;[M80] FREE UP ARGUMENT AND SETUP TO GIVE FREE STRING SPACE
3448 10BA : CD DB 0E                 call    GARBA2          ;[M80] DO GARBAGE COLLECTION
3449 10BD : ED 5B 4B 38              ld      de,(TOPMEM)     ;
3450 10C1 : 2A C1 38                 ld      hl,(FRETOP)     ;[M80] TOP OF FREE AREA
3451 10C4 : C3 1C 0B                 jp      GIVFLT          ;[M80] RETURN [H,L]-[D,E]
3452 10C7
3453 10C7 : 2B         [M80] DIMCON: dec     hl              ;[M80] SEE IF COMMA ENDED THIS VARIABLE
3454 10C8 : D7                       rst     CHRGET          ;
3455 10C9 : C8                       ret     z               ;[M80] IF TERMINATOR, GOOD BYE
3456 10CA : CF                       rst     SYNCHK          ;
3457 10CB : 2C                       byte    ','             ;[M80] MUST BE COMMA
3458 10CC
3459 10CC                  + ;{M80} DIMENSION
3460 10CC                  | ;[M80] THE "DIM" CODE SETS DIMFLG AND THEN FALLS INTO THE VARIABLE
3461 10CC                  | ;[M80] SEARCH ROUTINE. THE VARIABLE SEARCH ROUTINE LOOKS AT
3462 10CC                  | ;[M80] DIMFLG AT THREE DIFFERENT POINTS:
3463 10CC                  | ;[M80]
3464 10CC                  | ;[M80]  1) IF AN ENTRY IS FOUND, DIMFLG BEING ON INDICATES
3465 10CC                  | ;[M80]          A "DOUBLY DIMENSIONED" VARIABLE
3466 10CC                  | ;[M80]  2) WHEN A NEW ENTRY IS BEING BUILT DIMFLG'S BEING ON
3467 10CC                  | ;[M80]          INDICATES THE INDICES SHOULD BE USED FOR
3468 10CC                  | ;[M80]          THE SIZE OF EACH INDICE. OTHERWISE THE DEFAULT
3469 10CC                  | ;[M80]          OF TEN IS USED.
3470 10CC                  | ;[M80]  3) WHEN THE BUILD ENTRY CODE FINISHES, ONLY IF DIMFLG IS
3471 10CC                  | ;[M80]          OFF WILL INDEXING BE DONE
3472 10CC                  | ;
3473 10CC : 01 C7 10   [M80] DIM:    ld      bc,DIMCON       ;[M80] PLACE TO COME BACK TO
3474 10CF : C5                       push    bc              ;
3475 10D0 : F6                       byte    $F6             ;;"OR" to skip next instruction
3476 10D1
3477 10D1                  + ;{M80} VARIABLE SEARCHING
3478 10D1                  | ;[M80] ROUTINE TO READ THE VARIABLE NAME AT THE CURRENT TEXT POSITION
3479 10D1                  | ;[M80] AND PUT A POINTER TO ITS VALUE IN [D,E]. [H,L] IS UPDATED
3480 10D1                  | ;[M80] TO POINT TO THE CHARACTER AFTER THE VARIABLE NAME.
3481 10D1                  | ;[M80] VALTYP IS SETUP. NOTE THAT EVALUATING SUBSCRIPTS IN
3482 10D1                  | ;[M80] A VARIABLE NAME CAN CAUSE RECURSIVE CALLS TO PTRGET SO AT
3483 10D1                  | ;[M80] THAT POINT ALL VALUES MUST BE STORED ON THE STACK.
3484 10D1                  | ;[M80] ON RETURN, [A] DOES NOT REFLECT THE VALUE OF THE TERMINATING CHARACTER
3485 10D1                  | ;;VALTYP is set to 1f a '$' follows the variable name, or 0 if one doesn't.
3486 10D1                  | ;;  A pointer to the variable contents is returned in DE. The contents are a
3487 10D1                  | ;;  four byte floating point numbwe for numeric variables and a two byte
3488 10D1                  | ;;  pointer to the string data for a string variable.
3489 10D1                  | ;;If SUBFLG = 0 and a '(' follows the variable name, the array table is searched.
3490 10D1                  | ;;  If the array is found, the indexes are evaluated and a pointer to the array
3491 10D1                  | ;;  element is returned in DE.
3492 10D1                  | ;;If SUBFLG = 1, the array table is searched for the variable name.
3493 10D1                  | ;;  If found, the pointer to the next array entry is returned in DE, and
3494 10D1                  | ;;  a pointer to the number of dimensions is returned in BC.
3495 10D1 : AF         [M80] PTRGET: xor      a              ;[M80] MAKE [A]=0
3496 10D2 : 32 AA 38                 ld      (DIMFLG),a      ;[M80] FLAG IT AS SUCH
3497 10D5 : 4E                       ld      c,(hl)          ;[M80] GET FIRST CHARACTER IN [C]
3498 10D6 : CD C5 0C   {M80} PTRGT2: call    ISLET           ;[M80] CHECK FOR LETTER
3499 10D9 : DA C4 03                 jp      c,SNERR         ;[M80] MUST HAVE A LETTER
3500 10DC : AF                       xor     a               ;
3501 10DD : 47                       ld      b,a             ;[M80] ASSUME NO SECOND CHARACTER
3502 10DE : 32 AB 38                 ld      (VALTYP),a      ;[M80] ZERO NAMCNT
3503 10E1 : D7                       rst     CHRGET          ;[M80] GET CHAR
3504 10E2 : 38 05                    jr      c,ISSEC         ;[M80] YES, WAS NUMERIC
3505 10E4 : CD C6 0C                 call    ISLETC          ;[M80] SET CARRY IF NOT ALPHABETIC
3506 10E7 : 38 09                    jr      c,NOSEC         ;[M80] ALLOW ALPHABETICS
3507 10E9 : 47         (M80) ISSEC:  ld      b,a             ;[M80] IT IS A NUMBER--SAVE IN B
3508 10EA : D7         (M80) EATEM:  rst     CHRGET          ;[M80] GET CHAR
3509 10EB : 38 FD                    jr      c,EATEM         ;[M65] SKIP NUMERICS
3510 10ED : CD C6 0C   {M80} VMORC1: call    ISLETC          ;
3511 10F0 : 30 F8                    jr      nc,EATEM        ;[M65] SKIP ALPHABETICS
3512 10F2 : D6 24      (M80) NOSEC:  sub     '$'             ;[M65] IS IT A STRING?
3513 10F4 : 20 08                    jr      nz,NOTSTR       ;[M65] IF NOT, [VALTYP]=0.
3514 10F6 : 3C                       inc     a               ;[M65] SET [VALTYP]=1 (STRING !)
3515 10F7 : 32 AB 38                 ld      (VALTYP),a      ;
3516 10FA : 0F                       rrca                    ;
3517 10FB : 80                       add     a,b             ;
3518 10FC : 47                       ld      b,a             ;
3519 10FD : D7                       rst     CHRGET          ;[M80] READ PAST TYPE MARKER
3520 10FE : 3A CB 38   (M65) NOTSTR: ld      a,(SUBFLG)      ;[M80] GET FLAG WHETHER TO ALLOW ARRAYS
3521 1101 : 3D                       dec     a               ;[M80] IF SUBFLG=1, "ERASE" HAS CALLED
3522 1102 : CA A0 11                 jp      z,ERSFIN        ;[M80] PTRGET, AND SPECIAL HANDLING MUST BE DONE
3523 1105 : F2 0E 11                 jp      p,NOARYS        ;[M80] NO ARRAYS ALLOWED
3524 1108 : 7E                       ld      a,(hl)          ;[M80] GET CHAR BACK
3525 1109 : D6 28                    sub     '('             ;[M80] (CHECK FOR "(") WON'T MATCH IF SUBFLG SET
3526 110B : CA 7A 11                 jp      z,ISARY         ;[M80] IT IS!
3527 110E
3528 110E : AF         (M80) NOARYS: xor     a               ;[M80]ALLOW PARENS AGAIN
3529 110F : 32 CB 38                 ld      (SUBFLG),a      ;[M80]SAVE IN FLAG LOCATION
3530 1112 : E5                       push    hl              ;[M80] SAVE THE TEXT POINTER
3531 1113 : 50                       ld      d,b             ;;???Variable Name
3532 1114 : 59                       ld      e,c
3533 1115 : 2A DE 38                 ld      hl,(VARNAM)
3534 1118 : E7                       rst     COMPAR
3535 1119 : 11 E0 38                 ld      de,VARPNT
3536 111C : CA 1A 14                 jp      z,POPHRT
3537 111F : 2A D8 38                 ld      hl,(ARYTAB)
3538 1122 : EB                       ex      de,hl           ;{M80} [D,E]=POINTER INTO ARRAYS
3539 1123 : 2A D6 38                 ld      hl,(VARTAB)     ;{M80} [H,L]=POINTER INTO SIMPLE VARIABLES
3540 1126 : E7         (M80) LOPFND: rst     COMPAR          ;
3541 1127 : CA 3D 11                 jp      z,SMKVAR        ;[M80] IF SO, CREATE VARIABLE
3542 112A : 79                       ld      a,c             ;[M80] ARE LOW BYTES DIFFERENT
3543 112B : 96                       sub     (hl)            ;[M80] TEST
3544 112C : 23                       inc     hl              ;
3545 112D : C2 32 11                 jp      nz,LOPFN2       ;{M80} NO
3546 1130 : 78                       ld      a,b             ;[M80] ARE HIGH BYTES DIFFERENT
3547 1131 : 96                       sub     (hl)            ;[M80] THE SAME?
3548 1132 : 23         (~~~) LOPFN2: inc     hl              ;
3549 1133 : CA 6C 11                 jp      z,NTFPRT        ;{M80} YES
3550 1136 : 23                       inc     hl              ;
3551 1137 : 23                       inc     hl              ;
3552 1138 : 23                       inc     hl              ;
3553 1139 : 23                       inc     hl              ;;Skip past variable
3554 113A : C3 26 11                 jp      LOPFND          ;
3555                                 ;
3556 113D
3557 113D : E1         (M80) SMKVAR: pop     hl              ;
3558 113E : E3                       ex      (sp),hl         ;
3559 113F : D5                       push    de              ;
3560 1140 : 11 51 0A                 ld      de,RETVAR       ;[M80] DID EVAL CALL US?
3561 1143 : E7                       rst     COMPAR          ;[M80] IF SO, DON'T MAKE A NEW VARIABLE
3562 1144 : D1                       pop     de              ;[M80] RESTORE THE POSITION
3563 1145 : CA 6F 11                 jp      z,FINZER        ;[M80] MAKE FAC ZERO (ALL TYPES) AND SKIP RETURN
3564 1148 : E3                       ex      (sp),hl         ;[M80] PUT RETURN ADDRESS BACK
3565 1149 : E5                       push    hl              ;[M80] PUT THE TEXT POINTER BACK
3566 114A : C5                       push    bc              ;[M80] SAVE THE LOOKS
3567 114B : 01 06 00                 ld      bc,6            ;[M80] MAKE THE LENGTH INCLUDE EVERYTHING UP BY
3568 114E : 2A DA 38                 ld      hl,(STREND)     ;[M80] THE CURRENT END OF STORAGE
3569 1151 : E5                       push    hl              ;[M80] SAVE THIS #
3570 1152 : 09                       add     hl,bc           ;[M80] ADD ON THE AMOUNT OF SPACE EXTRA NOW BEING USED
3571 1153 : C1                       pop     bc              ;[M80] POP OFF HIGH ADDRESS TO MOVE
3572 1154 : E5                       push    hl              ;[M80] SAVE NEW CANDIDATE FOR STREND
3573 1155 : CD 92 0B                 call    BLTU            ;{M80} BLOCK TRANSFER AND CHECK FOR STACK OVERFLOW
3574 1158 : E1                       pop     hl              ;[M80] [H,L]=NEW STREND
3575 1159 : 22 DA 38                 ld      (STREND),hl     ;[M80] BLOCK TRANSFER WAS DONE, SO UPDATE POINTERS
3576 115C : 60                       ld      h,b             ;[M80] GET BACK [H,L] POINTING AT THE END
3577 115D : 69                       ld      l,c             ;[M80] OF THE NEW VARIABLE
3578 115E : 22 D8 38                 ld      (ARYTAB),hl     ;[M80] UPDATE THE ARRAY TABLE POINTER
3579 1161 : 2B         (M80) ZEROER: dec     hl              ;[M80] [H,L] IS RETURNED POINTING TO THE
3580 1162 : 36 00                    ld      (hl),0          ;[M80] END OF THE VARIABLE SO WE
3581 1164 : E7                       rst     COMPAR          ;[M80] ZERO BACKWARDS TO [D,E] WHICH
3582 1165 : 20 FA                    jr      nz,ZEROER       ;[M80] POINTS TO THE START OF THE VARIABLE
3583 1167 : D1                       pop     de              ;
3584 1168 : 73                       ld      (hl),e          ;[M80] PUT DESCRIPTION
3585 1169 : 23                       inc     hl              ;
3586 116A : 72                       ld      (hl),d          ;[M80] OF THIS VARIABLE INTO MEMORY
3587 116B : 23                       inc     hl              ;
3588 116C : EB         (M80) NTFPRT: ex      de,hl           ;[M80] TABLE POINTER BACK INTO [D,E]
3589 116D : E1                       pop     hl              ;[M80] GET BACK THE TEXT POINTER
3590 116E : C9                       ret                     ;
3591 116F
3592 116F                    ; MAKE ALL TYPES ZERO AND SKIP RETURN
3593 116F : 32 E7 38   [M80] FINZER: ld      (FAC),a         ;[M80] MAKE FLOATS ZERO
3594 1172 : 21 6D 03                 ld      hl,REDDY-1      ;[M80] MAKE IT A NULL STRING BY
3595 1175 : 22 E4 38                 ld      (FACLO),hl      ;[M80] POINTING AT A ZERO
3596 1178 : E1         {M80} POPHR2: pop     hl              ;[M80] GET THE TEXT POINTER
3597 1179 : C9                       ret                     ;[M80] RETURN FROM EVAL
3598 117A
3599 117A                  + ;[M80] FORMAT OF ARRAYS IN CORE
3600 117A                  | ;[M80]
3601 117A                  | ;[M80] DESCRIPTOR
3602 117A                  | ;[M80]       LOW BYTE = SECOND CHARCTER (200 BIT IS STRING FLAG)
3603 117A                  | ;[M80]       HIGH BYTE = FIRST CHARACTER
3604 117A                  | ;[M80] LENGTH OF ARRAY IN CORE IN BYTES (DOES NOT INCLUDE DESCRIPTOR)
3605 117A                  | ;[M80] NUMBER OF DIMENSIONS 1 BYTE
3606 117A                  | ;[M80] FOR EACH DIMENSION STARTING WITH THE FIRST A LIST
3607 117A                  | ;[M80] (2 BYTES EACH) OF THE MAX INDICE+1
3608 117A                  | ;[M80] THE VALUES
3609 117A                  | ;
3610 117A : E5         [M80] ISARY:  push    hl              ;[M80] SAVE DIMFLG AND VALTYP FOR RECURSION
3611 117B : 2A AA 38                 ld      hl,(DIMFLG)     ;
3612 117E : E3                       ex      (sp),hl         ;[M80] TEXT POINTER BACK INTO [H,L]
3613 117F : 57                       ld      d,a             ;[M80] SET # DIMENSIONS =0
3614 1180 : D5         [M80] INDLOP: push    de              ;[M80] SAVE NUMBER OF DIMENSIONS
3615 1181 : C5                       push    bc              ;[M80] SAVE LOOKS
3616 1182 : CD 7A 06                 call    INTIDX          ;[M80] EVALUATE INDICE INTO [D,E]
3617 1185 : C1         {M80} OPTB0:  pop     bc              ;[M80] POP OFF THE LOOKS
3618 1186 : F1                       pop     af              ;[M80] [A] = NUMBER OF DIMENSIONS SO FAR;
3619 1187 : EB                       ex      de,hl           ;[M80] [D,E]=TEXT POINTER, [H,L]=INDICE
3620 1188 : E3                       ex      (sp),hl         ;[M80] PUT NDICE ON STACK, [H,L]=VALTYP & DIMFLG
3621 1189 : E5                       push    hl              ;[M80] RESAVE VALTYP AND DIMFLG
3622 118A : EB                       ex      de,hl           ;[M80] [H,L]=TEXT POINTER
3623 118B : 3C                       inc     a               ;[M80] INCREMENT # OF DIMENSIONS
3624 118C : 57                       ld      d,a             ;[M80] [D]=NUMBER OF DIMENSIONS
3625 118D : 7E                       ld      a,(hl)          ;[M80] GET TERMINATING CHARACTER
3626 118E : FE 2C                    cp      ','             ;[M80] A COMMA SO MORE INDICES FOLLOW?
3627 1190 : CA 80 11                 jp      z,INDLOP        ;[M80] IF SO, READ MORE
3628 1193 : CF                       rst     SYNCHK          ;
3629 1194 : 29                       byte    ')'             ;{M80} MAKE SURE THERE IS A BRACKET
3630 1195 : 22 D0 38   {M80} SUBSOK: ld      (TENP2),hl      ;[M80 ]SAVE THE TEXT POINTER
3631 1198 : E1                       pop     hl              ;[M80 ][H,L]= VALTYP & DIMFLG
3632 1199 : 22 AA 38                 ld      (DIMFLG),hl     ;[M80 ]SAVE VALTYP AND DIMFLG
3633 119C : 1E 00                    ld      e,0             ;{M80 }WHEN [D,E] IS POPPED INTO PSW, ZERO FLAG WON'T BE SET
3634 119E : D5                       push    de              ;[M80 ]SAVE NUMBER OF DIMENSIONS
3635 119F : 11                       byte    $11             ;[M80] "LD H," OVER THE NEXT TWO BYTES
3636 11A0
3637 11A0                    ;;Get Pointer to Array
3638 11A0                    ;;BC = Array Variable Name on Entry
3639 11A0                    ;;     Pointer to Number of Dimensions on Exit
3640 11A0 : E5         [M80] ERSFIN: push    hl              ;[M80] SAVE THE TEXT POINTER
3641 11A1 : F5                       push    af              ;[M80] SAVE A DUMMY NUMBER OF DIMENSIONS WITH THE ZERO FLAG SET
3642 11A2
3643 11A2                    ;[M80] AT THIS POINT [B,C]=LOOKS. THE TEXT POINTER IS IN TEMP2.
3644 11A2                    ;[M80] THE INDICES ARE ALL ON THE STACK, FOLLOWED BY THE NUMBER OF DIMENSIONS.
3645 11A2 : 2A D8 38                 ld      hl,(ARYTAB)     ;[M80] [H,L]=PLACE TO START THE SEARCH
3646 11A5 : 3E                       byte    $3E             ;[M80] "LD A," AROUND THE NEXT BYTE
3647 11A6 : 19         (M80) LOPFDA: add     hl,de           ;[M80] SKIP OVER THIS ARRAY SINCE IT'S NOT THE ONE
3648 11A7 : ED 5B DA 38              ld      de,(STREND)     ;[M80] GET THE PLACE TO STOP INTO [H,L]
3649 11AB : E7                       rst     COMPAR          ;[M80] STOPPING TIME?
3650 11AC : 28 25                    jr      z,NOTFDD        ;[M80] YES, COULDN'T FIND THIS ARRAY
3651 11AE : 7E                       ld      a,(hl)          ;[M80] GET FIRST CHARACTER
3652 11AF : 23                       inc     hl
3653 11B0 : B9                       cp      c               ;[M80] SEE IF IT MATCHES
3654 11B1 : 20 02                    jr      nz,NMARY1       ;[M80] NOT THIS ONE
3655 11B3 : 7E                       ld      a,(hl)          ;[M80] GET SECOND CHARACTER
3656 11B4 : B8                       cp      b               ;[M80] ANOTHER MATCH?
3657 11B5 : 23         (M80) NMARY1: inc     hl              ;[M80] POINT TO SIZE ENTRY
3658 11B6 : 5E         {M80} CNOMAT: ld      e,(hl)          ;[M80] [D,E]=LENGTH
3659 11B7 : 23                       inc     hl              ;[M80] OF THE ARRAY BEING LOOKED AT
3660 11B8 : 56                       ld      d,(hl)
3661 11B9 : 23                       inc     hl
3662 11BA : 20 EA                    jr      nz,LOPFDA       ;[M80] IF NO MATCH, SKIP THIS ONE AND TRY AGAIN
3663 11BC : 3A AA 38                 ld      a,(DIMFLG)      ;[M80] SEE IF CALLED BY "DIM"
3664 11BF : B7                       or      a               ;[M80] ZERO MEANS NO
3665 11C0 : C2 CD 03                 jp      nz,DDERR        ;[M80] "REDIMENSIONED VARIABLE" IF "DIM" CALLING PTRGET
3666 11C3
3667 11C3                  + ;[M80] TEMP2=THE TEXT POINTER
3668 11C3                  | ;[M80] WE HAVE LOCATED THE VARIABLE WE WERE LOOKING FOR
3669 11C3                  | ;[M80] AT THIS POINT [H,L] POINTS BEYOND THE SIZE TO THE NUMBER OF DIMENSIONS
3670 11C3                  | ;[M80] THE INDICES ARE ON THE STACK FOLLOWED BY THE NUMBER OF DIMENSIONS
3671 11C3                  | ;
3672 11C3 : F1                       pop     af              ;[M80] [A]=NUMBER OF DIMENSIONS
3673 11C4 : 44                       ld      b,h             ;[M80] SET [B,C] TO POINT AT NUMBER OF DIMENSIONS
3674 11C5 : 4D                       ld      c,l
3675 11C6 : CA 1A 14                 jp      z,POPHRT        ;[M80] "ERASE" IS DONE, SO RETURN TO DO THE ACTUAL ERASURE
3676 11C9 : 96                       sub     (hl)            ;{M80} MAKE SURE DIMENSIONS MATCH
3677 11CA : CA 2B 12                 jp      z,GETDEF        ;[M80] JUMP OFF AND READ E INDICES....
3678 11CD : 11 10 00   [M80] BSERR:  ld      de,ERRBS        ;[M80] "SUBSCRIPT OUT OF RANGE"
3679 11D0 : C3 DB 03                 jp      ERROR
3680 11D3
3681 11D3                  + ;[M80] HERE WHEN VARIABLE IS NOT FOUND IN THE ARRAY TABLE
3682 11D3                  | ;[M80]
3683 11D3                  | ;[M80] BUILDING AN ENTRY:
3684 11D3                  | ;[M80]
3685 11D3                  | ;[M80]  PUT DOWN THE DESCRIPTOR
3686 11D3                  | ;[M80]  SETUP NUMER OF DIMENSIONS
3687 11D3                  | ;[M80]  MAKE SURE THERE IS ROOM FOR THE NEW ENTRY
3688 11D3                  | ;[M80]  REMEMBER VARPTR
3689 11D3                  | ;[M80]  TALLY=4 (VALTYP FOR THE EXTENDED)
3690 11D3                  | ;[M80]  SKIP 2 LOCS FOR LATER FILL IN -- THE SIZE
3691 11D3                  | ;[M80] LOOP:    GET AN INDICE
3692 11D3                  | ;[M80]  PUT NUMBER +1 DOWN AT VARPTR AND INCREMENT VARPTR
3693 11D3                  | ;[M80]  TALLY= TALLY * NUMBER+1
3694 11D3                  | ;[M80]  DECREMENT NUMBER-DIMS
3695 11D3                  | ;[M80]  JNZ     LOOP
3696 11D3                  | ;[M80]  CALL REASON WITH [H,L] REFLECTING LAST LOC OF VARIABLE
3697 11D3                  | ;[M80]  UPDATE STREND
3698 11D3                  | ;[M80]  ZERO BACKWARDS
3699 11D3                  | ;[M80]  MAKE TALLY INCLUDE MAXDIMS
3700 11D3                  | ;[M80]  PUT DOWN TALLY
3701 11D3                  | ;[M80]  IF CALLED BY DIMENSION, RETURN
3702 11D3                  | ;[M80]  OTHERWISE INDEX INTO THE VARIABLE AS IF IT
3703 11D3                  | ;[M80]  WERE FOUND ON THE INITIAL SEARCH
3704 11D3                  | ;
3705 11D3 : 11 04 00   [M80] NOTFDD: ld      de,4            ;[M80] [D,E]=SIZE OF ONE VALUE (VALTYP)
3706 11D6 : F1                       pop     af              ;[M80] [A]=NUMBER OF DIMENSIONS
3707 11D7 : CA 97 06                 jp      z,FCERR         ;[M80] "ILLEGAL FUNCTION CALL"
3708 11DA : 71                       ld      (hl),c          ;[M80] PUT DOWN THE DESCRIPTOR
3709 11DB : 23                       inc     hl
3710 11DC : 70                       ld      (hl),b
3711 11DD : 23                       inc     hl
3712 11DE : 4F                       ld      c,a             ;{M80} [C]=ENTRIES NEEDED TO STORE SIZE OF EACH DIMENSION
3713 11DF : CD A0 0B                 call    GETSTK          ;[M80] GET SPACE FOR DIMENSION ENTRIES
3714 11E2 : 23                       inc     hl              ;[M80] SKIP OVER THE SIZE LOCATIONS
3715 11E3 : 23                       inc     hl
3716 11E4 : 22 C3 38                 ld      (TENP3),hl      ;SAVE THE LOCATION TO PUT THE SIZE IN
3717 11E7 : 71                       ld      (hl),c          ;STORE THE NUMBER OF DIMENSIONS
3718 11E8 : 23                       inc     hl
3719 11E9 : 3A AA 38                 ld      a,(DIMFLG)      ;{M80} CALLED BY DIMENSION?
3720 11EC : 17                       rla                     ;[M80] SET CARRY IF SO
3721 11ED : 79                       ld      a,c             ;[M80] [A]=NUMBER OF DIMENSIONS
3722 11EE : 01 0B 00   (M80) LOPPTA: ld      bc,11           ;[M80] MAP 0 TO 11 AND 1 TO 10
3723 11F1 : 30 02                    jr      nc,NOTDIM       ;[M80] DEFAULT DIMENSIONS TO TEN
3724 11F3 : C1         (M80) POPDIM: pop     bc              ;[M80] POP OFF AN INDICE INTO [B,C]
3725 11F4 : 03                       inc     bc              ;[M80] ADD ONE TO IT FOR THE ZERO ENTRY
3726 11F5 : 71         (M80) NOTDIM: ld      (hl),c          ;[M80] PUT THE MAXIMUM DOWN
3727 11F6 : F5                       push    af              ;[M80] SAVE NUMBER OF DIMENSIONS AND DIMFLG (CARRY)
3728 11F7 : 23                       inc     hl
3729 11F8 : 70                       ld      (hl),b
3730 11F9 : 23                       inc     hl
3731 11FA : E5                       push    hl
3732 11FB : CD CA 15                 call    UMULT           ;[M80] MULTIPLY [B,C]=NEWMAX BY CURTOL=[D,E]
3733 11FE : EB                       ex      de,hl
3734 11FF : E1                       pop     hl
3735 1200 : F1                       pop     af              ;[M80] GET NUMBER OF DIMENSIONS AND DIMFLG (CARRY) BACK
3736 1201 : 3D                       dec     a               ;[M80] DECREMENT THE NUMBER OF DIMENSIONS LEFT
3737 1202 : 20 EA                    jr      nz,LOPPTA       ;[M80] HANDLE THE OTHER INDICES
3738 1204 : F5                       push    af              ;[M80] SAVE DIMFLG (CARRY)
3739 1205 : 42                       ld      b,d             ;[M80] [B,C]=SIZE
3740 1206 : 4B                       ld      c,e
3741 1207 : EB                       ex      de,hl           ;[M80] [D,E]=START OF VALUES
3742 1208 : 19                       add     hl,de           ;[M80] [H,L]=END OF VALUES
3743 1209 : DA B7 0B                 jp      c,OMERR         ;[M80] OUT OF MEMORY POINTER BEING GENERATED?
3744 120C : CD A9 0B                 call    REASON          ;[M80] SEE IF THERE IS ROOM FOR THE VALUES
3745 120F : 22 DA 38                 ld      (STREND),hl     ;[M80] UPDATE THE END OF STORAGE
3746 1212 : 2B         (M80) ZERITA: dec     hl              ;[M80] ZERO THE NEW ARRAY
3747 1213 : 36 00                    ld      (hl),000H
3748 1215 : E7                       rst     COMPAR          ;[M80] BACK AT THE BEGINNING?
3749 1216 : 20 FA                    jr      nz,ZERITA       ;[M80] NO, ZERO MORE
3750 1218 : 03                       inc     bc              ;(M80) ADD ONE TO INCLUDE BYTE FOR NUMBER OF DIMENSIONS
3751 1219 : 57                       ld      d,a             ;[M80[ [D]=ZERO
3752 121A : 2A C3 38                 ld      hl,(TENP3)      ;[M80[ GET A POINTER AT THE NUMBER OF DIMENSIONS
3753 121D : 5E                       ld      e,(hl)          ;[M80[ [E]=NUMBER OF DIMENSIONS
3754 121E : EB                       ex      de,hl           ;[M80[ [H,L]=NUMBER OF DIMENSIONS
3755 121F : 29                       add     hl,hl           ;[M80[ [H,L]=NUMBER OF DIMENSIONS TIMES TWO
3756 1220 : 09                       add     hl,bc           ;[M80[ ADD ON THE SIZE TO GET THE TOTAL NUMBER OF BYTES USED
3757 1221 : EB                       ex      de,hl           ;[M80[ [D,E]=TOTAL SIZE
3758 1222 : 2B                       dec     hl              ;[M80[ BACK UP TO POINT TO LOCATION TO PUT
3759 1223 : 2B                       dec     hl              ;[M80[ THE SIZE OF THE ARRAY IN BYTES IN.
3760 1224 : 73                       ld      (hl),e          ;[M80[ PUT DOWN THE SIZE
3761 1225 : 23                       inc     hl
3762 1226 : 72                       ld      (hl),d
3763 1227 : 23                       inc     hl
3764 1228 : F1                       pop     af              ;[M80] GET BACK DIMFLG (CARRY) AND SET [A]=0
3765 1229 : 38 21                    jr      c,FINNOW
3766 122B
3767 122B                    ;[M80] AT THIS POINT [H,L] POINTS BEYOND THE SIZE TO THE NUMBER OF DIMENSIONS
3768 122B                    ;[M80] STRATEGY:
3769 122B                    ;[M80]  NUMDIM=NUMBER OF DIMENSIONS
3770 122B                    ;[M80]  CURTOL=0
3771 122B                    ;[M80] INLPNM:GET A NEW INDICE
3772 122B                    ;[M80]  POP NEW MAX INTO CURMAX
3773 122B                    ;[M80]  MAKE SURE INDICE IS NOT TOO BIG
3774 122B                    ;[M80]  MUTLIPLY CURTOL BY CURMAX
3775 122B                    ;[M80]  ADD INDICE TO CURTOL
3776 122B                    ;[M80]  NUMDIM=NUMDIM-1
3777 122B                    ;[M80]  JNZ     INLPNM
3778 122B                    ;[M80]  USE CURTOL*4 (VALTYP FOR EXTENDED) AS OFFSET
3779 122B                    ;
3780 122B : 47         [M80] GETDEF: ld      b,a             ;[M80] [B,C]=CURTOL=ZERO
3781 122C : 4F                       ld      c,a
3782 122D : 7E                       ld      a,(hl)          ;[M80] [A]=NUMBER OF DIMENSIONS
3783 122E : 23                       inc     hl              ;[M80] POINT PAST THE NUMBER OF DIMENSIONS
3784 122F : 16                       byte    $16             ;[M80] "LD D," AROUND THE NEXT BYTE
3785 1230 : E1         [M80] INLPNM: pop     hl              ;[M80] [H,L]= POINTER INTO VARIABLE ENTRY
3786 1231 : 5E                       ld      e,(hl)          ;[M80] [D,E]=MAXIMUM FOR THE CURRENT INDICE
3787 1232 : 23                       inc     hl
3788 1233 : 56                       ld      d,(hl)
3789 1234 : 23                       inc     hl              ;[M80] [H,L]=CURRENT INDICE
3790 1235 : E3                       ex      (sp),hl         ;[M80] POINTER INTO THE VARIABLE GOES ON THE STACK
3791 1236 : F5                       push    af              ;[M80] SAVE THE NUMBER OF DIMENSIONS
3792 1237 : E7                       rst     COMPAR          ;[M80] SEE IF THE CURRENT INDICE IS TOO BIG
3793 1238 : D2 CD 11                 jp      nc,BSERR        ;[M80] IF SO "BAD SUBSCRIPT" ERROR
3794 123B : E5                       push    hl
3795 123C : CD CA 15                 call    UMULT           ;[M80] CURTOL=CURTOL*CURRENT MAXIMUM
3796 123F : D1                       pop     de
3797 1240 : 19                       add     hl,de           ;[M80] ADD THE INDICE TO CURTOL
3798 1241 : F1                       pop     af              ;[M80] GET THE NUMBER OF DIMENSIONS IN [A]
3799 1242 : 3D                       dec     a               ;[M80] SEE IF ALL THE INDICES HAVE BEEN PROCESSED
3800 1243 : 44                       ld      b,h             ;[M80] [B,C]=CURTOL IN CASE WE LOOP BACK
3801 1244 : 4D                       ld      c,l
3802 1245 : 20 E9                    jr      nz,INLPNM       ;[M80] PROCESS THE REST OF THE INDICES
3803 1247 : 29                       add     hl,hl           ;[M80] MULTIPLY BY TWO
3804 1248 : 29                       add     hl,hl           ;[M80] NOW MULTIPLIED BY FOUR
3805 1249 : C1         {M80} DONMUL: pop     bc              ;[M80] POP OFF THE ADDRESS OF WHERE THE VALUES BEGIN
3806 124A : 09                       add     hl,bc           ;[M80] ADD IT ONTO CURTOL TO GET PLACE VALUE IS STORED
3807 124B : EB                       ex      de,hl           ;[M80] RETURN THE POINTER IN [D,E]
3808 124C : 2A D0 38   (M80) FINNOW: ld      hl,(TENP2)      ;[M80] REGET THE TEXT POINTER
3809 124F : C9                       ret
3810 1250
3811 1250                  + ;[M80] MATHPK FOR BASIC MCS 8080  GATES/ALLEN/DAVIDOFF
3812 1250                  | ;
3813 1250                  | ;[M80] EXTERNAL LOCATIONS USED BY THE MATH-PACKAGE
3814 1250                  | ;
3815 1250                  | ;[M80] THE FLOATING ACCUMULATOR
3816 1250                  | ;(M80) FACLO:   [LOW ORDER OF MANTISSA (LO)]
3817 1250                  | ;(M80) FACMO:   [MIDDLE ORDER OF MANTISSA (MO)]
3818 1250                  | ;(M80) FACHO:   [HIGH ORDER OF MANTISSA (HO)]
3819 1250                  | ;(M80) FAC:     [EXPONENT]
3820 1250                  | ;(M80)          [TEMPORARY COMPLEMENT OF SIGN IN MSB]
3821 1250                  | ;(M80] ARGLO:           [LOCATION OF SECOND ARGUMENT]
3822 1250                  | ;(M80] ARG:
3823 1250                  | ;(M80] FBUFFR:  BUFFER FOR FOUT
3824 1250                  | ;[M80]
3825 1250                  | ;[M80] THE FLOATING POINT FORMAT IS AS FOLLOWS:
3826 1250                  | ;[M80]
3827 1250                  | ;[M80] THE SIGN IS THE FIRST BIT OF THE MANTISSA
3828 1250                  | ;[M80] THE MANTISSA IS 24 BITS LONG
3829 1250                  | ;[M80] THE BINARY POINT IS TO THE LEFT OF THE MSB
3830 1250                  | ;[M80] NUMBER = MANTISSA * 2 ^ EXPONENT
3831 1250                  | ;[M80] THE MANTISSA IS POSITIVE, WITH A ONE ASSUMED TO BE WHERE THE SIGN BIT IS
3832 1250                  | ;[M80] THE SIGN OF THE EXPONENT IS THE FIRST BIT OF THE EXPONENT
3833 1250                  | ;[M80] THE EXPONENT IS STORED IN EXCESS 200 I.E. WITH A BIAS OF 200
3834 1250                  | ;[M80] SO, THE EXPONENT IS A SIGNED 8-BIT NUMBER WITH 200 ADDED TO IT
3835 1250                  | ;[M80] AN EXPONENT OF ZERO MEANS THE NUMBER IS ZERO, THE OTHER BYTES ARE IGNORED
3836 1250                  | ;[M80] TO KEEP THE SAME NUMBER IN THE FAC WHILE SHIFTING:
3837 1250                  | ;[M80]  TO SHIFT RIGHT, EXP:=EXP+1
3838 1250                  | ;[M80]  TO SHIFT LEFT,  EXP:=EXP-1
3839 1250                  | ;[M80]
3840 1250                  | ;[M80] SO, IN MEMORY THE NUMBER LOOKS LIKE THIS:
3841 1250                  | ;[M80]  [BITS 17-24 OF THE MANTISSA]
3842 1250                  | ;[M80]  [BITS 9-16 OF THE MANTISSA]
3843 1250                  | ;[M80]  [THE SIGN IN BIT 7, BITS 2-8 OF THE MANTISSA ARE IN BITS 6-0]
3844 1250                  | ;[M80]  [THE EXPONENT AS A SIGNED NUMBER + 200]
3845 1250                  | ;[M80] (REMEMBER THAT BIT 1 OF THE MANTISSA IS ALWAYS A ONE)
3846 1250                  | ;[M80]
3847 1250                  | ;[M80] ARITHMETIC ROUTINE CALLING CONVENTIONS:
3848 1250                  | ;[M80]
3849 1250                  | ;[M80] FOR ONE ARGUMENT FUNCTIONS:
3850 1250                  | ;[M80]  THE ARGUMENT IS IN THE FAC, THE RESULT IS LEFT IN THE FAC
3851 1250                  | ;[M80] FOR TWO ARGUMENT OPERATIONS:
3852 1250                  | ;[M80]  THE FIRST ARGUMENT IS IN B,C,D,E I.E. THE "REGISTERS"
3853 1250                  | ;[M80]  THE SECOND ARGUMENT IS IN THE FAC
3854 1250                  | ;[M80]  THE RESULT IS LEFT IN THE FAC
3855 1250                  | ;[M80]
3856 1250                  | ;[M80] THE "S" ENTRY POINTS TO THE TWO ARGUMENT OPERATIONS HAVE (HL) POINTING TO
3857 1250                  | ;[M80] THE FIRST ARGUMENT INSTEAD OF THE FIRST ARGUMENT BEING IN THE REGISTERS.
3858 1250                  | ;[M80] MOVRM IS CALLED TO GET THE ARGUMENT IN THE REGISTERS.
3859 1250                  | ;[M80] THE "T" ENTRY POINTS ASSUME THE FIRST ARGUMENT IS ON THE STACK.
3860 1250                  | ;[M80] POPR IS USED TO GET THE ARGUMENT IN THE REGISTERS.
3861 1250                  | ;[M80] NOTE: THE "T" ENTRY POINTS SHOULD ALWAYS BE JUMPED TO AND NEVER CALLED
3862 1250                  | ;[M80] BECAUSE THE RETURN ADDRESS ON THE STACK WILL BE CONFUSED WITH THE NUMBER.
3863 1250                  | ;[M80]
3864 1250                  | ;[M80] ON THE STACK, THE TWO LO'S ARE PUSHED ON FIRST AND THEN THE HO AND SIGN.
3865 1250                  | ;[M80] THIS IS DONE SO IF A NUMBER IS STORED IN MEMORY, IT CAN BE PUSHED ON THE
3866 1250                  | ;[M80] STACK WITH TWO PUSHM'S.  THE LOWER BYTE OF EACH PART IS IN THE LOWER
3867 1250                  | ;[M80] MEMORY ADDRESS SO WHEN THE NUMBER IS POPPED INTO THE REGISTERS, THE HIGHER
3868 1250                  | ;[M80] ORDER BYTE WILL BE IN THE HIGHER ORDER REGISTER OF THE REGISTER PAIR, I.E.
3869 1250                  | ;[M80] THE HIGHER ORDER BYTE WILL BE POPPED INTO B, D OR H.
3870 1250
3871 1250                    ;[M80] FLOATING POINT ADDITION AND SUBTRACTION
3872 1250 : 21 57 17   [M80] FADDH:  ld      hl,FHALF        ;[M80] ENTRY TO ADD 1/2
3873 1253 : CD 31 15   [M80] FADDS:  call    MOVRM           ;[M80] GET ARGUMENT INTO THE REGISTERS
3874 1256 : 18 09                    jr      FADD            ;[M80] DO THE ADDITION
3875 1258
3876 1258 :                  ;[M80] SUBTRACTION      FAC:=ARG-FAC
3877 1258 : CD 31 15   [M80] FSUBS:  call    MOVRM           ;[M80] ENTRY IF POINTER TO ARG IS IN (HL)
3878 125B : 21                       byte    $21             ;;"LD HL," to skip next instruction
3879 125C : C1         [M80] FSUBT:  pop     bc              ;;ENTRY TO FSUB IF ARGUMENT IS ON STACK
3880 125D : D1                       pop     de
3881 125E : CD 0B 15   [M80] FSUB:   call    NEG             ;[M80] NEGATE SECOND ARGUMENT
3882 1261
3883 1261 :                  ;[M80] ADDITION FAC:=ARG+FAC
3884 1261 : 78         [M80] FADD:   ld      a,b             ;[M80] CHECK IF FIRST ARGUMENT IS ZERO
3885 1262 : B7                       or      a               ;[M80] GET EXPONENT
3886 1263 : C8                       ret     z               ;[M80] IT IS, RESULT IS NUMBER IN FAC
3887 1264 : 3A E7 38                 ld      a,(FAC)         ;[M80] GET EXPONENT
3888 1267 : B7                       or      a               ;[M80] SEE IF THE NUMBER IS ZERO
3889 1268 : CA 23 15                 jp      z,MOVFR         ;[M80] IT IS, ANSWER IS IN REGISTERS
3890 126B
3891 126B                  + ;;Align Numbers
3892 126B                  | ;[M80] WE WANT TO GET THE SMALLER NUMBER IN THE REGISTERS SO WE CAN SHIFT IT RIGHT
3893 126B                  | ;[M80] AND ALIGN THE BINARY POINTS OF THE TWO NUMBERS.  THEN WE CAN JUST ADD OR
3894 126B                  | ;[M80] SUBTRACT THEM (DEPENDING ON THEIR SIGNS) BYTEWISE.
3895 126B : 90                       sub     b               ;[M80] CHECK RELATIVE SIZES
3896 126C : 30 0C                    jr      nc,FADD1        ;[M80] IS FAC SMALLER?
3897 126E : 2F                       cpl                     ;[M80] YES, NEGATE SHIFT COUNT
3898 126F : 3C                       inc     a
3899 1270 : EB                       ex      de,hl           ;[M80] SWITCH FAC AND REGISTERS, SAVE (DE)
3900 1271 : CD 13 15                 call    PUSHF           ;[M80] PUT FAC ON STACK
3901 1274 : EB                       ex      de,hl           ;[M80] GET (DE) BACK WHERE IT BELONGS
3902 1275 : CD 23 15                 call    MOVFR           ;[M80] PUT REGISTERS IN THE FAC
3903 1278 : C1                       pop     bc
3904 1279 : D1                       pop     de              ;[M80] GET THE OLD FAC IN THE REGISTERS
3905 127A
3906 127A : FE 19      [M80] FADD1:  cp      25              ;ARE WE WITHIN 24 BITS?
3907 127C : D0                       ret     nc
3908 127D : F5                       push    af              ;SAVE SHIFT COUNT
3909 127E : CD 46 15                 call    UNPACK          ;UNPACK THE NUMBERS
3910 1281 : 67                       ld      h,a             ;SAVE SUBTRACTION FLAG
3911 1282 : F1                       pop     af              ;GET SHIFT COUNT BACK
3912 1283 : CD 30 13                 call    SHIFTR          ;SHIFT REGISTERS RIGHT THE RIGHT AMOUNT
3913 1286
3914 1286                  + ;;Add or Subtract Numbers
3915 1286                  | ;[M80] IF THE NUMBERS HAVE THE SAME SIGN, THEN WE ADD THEM.  IF THE SIGNS ARE
3916 1286                  | ;[M80] DIFFERENT, THEN WE HAVE TO SUBTRACT THEM.  WE HAVE TO DO THIS BECAUSE THE
3917 1286                  | ;[M80] MANTISSAS ARE POSITIVE.  JUDGING BY THE EXPONENTS, THE LARGER NUMBER IS IN
3918 1286                  | ;[M80] THE FAC, SO IF WE SUBTRACT, THE SIGN OF THE RESULT SHOULD BE THE SIGN OF THE
3919 1286                  | ;[M80] FAC; HOWEVER, IF THE EXPONENTS ARE THE SAME, THE NUMBER IN THE REGISTERS
3920 1286                  | ;[M80] COULD BE BIGGER, SO AFTER WE SUBTRACT THEM, WE HAVE TO CHECK IF THE RESULT
3921 1286                  | ;[M80] WAS NEGATIVE.  IF IT WAS, WE NEGATE THE NUMBER IN THE REGISTERS AND
3922 1286                  | ;[M80] COMPLEMENT THE SIGN OF THE FAC.  (HERE THE FAC IS UNPACKED)
3923 1286                  | ;[M80] IF WE HAVE TO ADD THE NUMBERS, THE SIGN OF THE RESULT IS THE SIGN OF THE
3924 1286                  | ;[M80] FAC.  SO, IN EITHER CASE, WHEN WE ARE ALL DONE, THE SIGN OF THE RESULT
3925 1286                  | ;[M80] WILL BE THE SIGN OF THE FAC.
3926 1286 : 7C                       ld      a,h             ;[M80] GET SUBTRACTION FLAG
3927 1287 : B7                       or      a
3928 1288 : 21 E4 38                 ld      hl,FACLO        ;[M80] SET POINTER TO LO'S
3929 128B : F2 9F 12                 jp      p,FADD3         ;[M80] SUBTRACT IF THE SIGNS WERE DIFFERENT
3930 128E : CD 10 13                 call    FADDA           ;[M80] ADD THE NUMBERS
3931 1291 : 30 5E                    jr      nc,ROUND        ;[M80] ROUND RESULT IF THERE WAS NO OVERFLOW
3932 1293 : 23                       inc     hl              ;[M80] THERE WAS OVERFLOW
3933 1294 : 34                       inc     (hl)            ;[M80] INCREMENT EXPONENT
3934 1295 : CA D3 03                 jp      z,OVERR
3935 1298 : 2E 01                    ld      l,1             ;[M80] SHIFT RESULT RIGHT ONE, SHIFT CARRY IN
3936 129A : CD 52 13                 call    SHRADD
3937 129D : 18 52                    jr      ROUND           ;[M80] ROUND RESULT AND WE ARE DONE
3938 129F
3939 129F                    ;[M80] HERE TO SUBTRACT C,D,E,B FROM ((HL)+0,1,2),0
3940 129F : AF         [M80] FADD3:  xor     a               ;[M80] SUBTRACT NUMBERS, NEGATE UNDERFLOW BYTE
3941 12A0 : 90                       sub     b
3942 12A1 : 47                       ld      b,a             ;[M80] SAVE IT
3943 12A2 : 7E                       ld      a,(hl)          ;[M80] SUBTRACT LOW ORDERS
3944 12A3 : 9B                       sbc     a,e
3945 12A4 : 5F                       ld      e,a
3946 12A5 : 23                       inc     hl              ;[M80] UPDATE POINTER TO NEXT BYTE
3947 12A6 : 7E                       ld      a,(hl)          ;[M80] SUBTRACT MIDDLE ORDERS
3948 12A7 : 9A                       sbc     a,d
3949 12A8 : 57                       ld      d,a
3950 12A9 : 23                       inc     hl              ;[M80] UPDATE POINTER TO HIGH ORDERS
3951 12AA : 7E                       ld      a,(hl)          ;[M80] SUBTRACT HIGH ORDERS
3952 12AB : 99                       sbc     a,c
3953 12AC : 4F                       ld      c,a
3954 12AD
3955 12AD                    ;[M80] BECAUSE WE WANT A POSITIVE MANTISSA, CHECK IF WE HAVE TO NEGATE THE NUMBER
3956 12AD : DC 1C 13   [M80] FADFLT: call    c,NEGR
3957 1280
3958 12B0                  + ;NORMALIZE C,D,E,B
3959 12B0                  | ;ALTERS A,B,C,D,E,H,L
3960 12B0                  | ;HERE WE SHIFT THE MANTISSA LEFT UNTIL THE MSB IS A ONE.
3961 12B0                  | ;EXCEPT IN 4K, THE IDEA IS TO SHIFT LEFT BY 8 AS MANY TIMES AS
3962 12B0                  | ;POSSIBLE.
3963 12B0                  | ;
3964 12B0 : 68         [M80] NORMAL: ld      l,b             ;[M80] PUT LOWEST 2 BYTES IN (HL)
3965 12B1 : 63                       ld      h,e
3966 12B2 : AF                       xor     a               ;[M80] ZERO SHIFT COUNT
3967 12B3 : 47         (M80) NORM1:  ld      b,a             ;[M80] SAVE SHIFT COUNT
3968 12B4 : 79                       ld      a,c             ;[M80] DO WE HAVE 1 BYTE OF ZEROS
3969 12B5 : B7                       or      a
3970 12B6 : 20 27                    jr      nz,NORM3        ;[M80] NO, SHIFT ONE PLACE AT A TIME
3971 12B8                  - ;[M80] THIS LOOP SPEEDS THINGS UP BY SHIFTING 8 PLACES AT ONE TIME
3972 12B8 : 4A                       ld      c,d             ;[M80] YES, SHIFT OVER 1 BYTE
3973 12B9 : 54                       ld      d,h
3974 12BA : 65                       ld      h,l
3975 12BB : 6F                       ld      l,a             ;SHIFT IN 8 ZEROS FOR THE LOW ORDER
3976 12BC : 78                       ld      a,b             ;UPDATE SHIFT COUNT
3977 12BD : D6 08                    sub     8
3978 12BF : FE E0                    cp      0E0H            ;DID WE SHIFT IN 4 BYTES OF ZEROS?
3979 12C1 : 20 F0                    jr      nz,NORM1        ;NO, TRY TO SHIFT OVER 8 MORE
3980 12C3
3981 12C3                  + ;[M80] ZERO FAC
3982 12C3                  | ;[M80] ALTERS A ONLY
3983 12C3                  | ;[M80] EXITS WITH A=0
3984 12C3                  | ;[M80] BY OUR FLOATING POINT FORMAT, THE NUMBER IS ZERO IF THE EXPONENT IS ZERO
3985 12C3                  | ;
3986 12C3 : AF               ZERO:   xor     a               ;[M80] ZERO A
3987 12C4 : 32 E7 38         ZERO0:  ld      (FAC),a         ;[M80] ZERO THE FAC'S EXPONENT, ENTRY IF A=0
3988 12C7 : C9                       ret                     ;[M80] ALL DONE
3989 12C8
3990 12C8 : 7C         [M80] NORM2:  ld      a,h             ;CHECK FOR CASE OF NORMALIZING A SMALL INT
3991 12C9 : B5                       or      l
3992 12CA : B2                       or      d
3993 12CB : 20 0A                    jr      nz,NORM2U       ;DO USUAL THING
3994 12CD : 79                       ld      a,c             ;GET BYTE TO SHIFT
3995 12CE : 05         (M80) NORM2F: dec     b               ;[M80] DECRMENT SHIFT COUNT
3996 12CF : 17                       rla                     ;[M80] SHIFT LEFT
3997 12D0 : 30 FC                    jr      nc,NORM2F       ;[M80] NORMALIZE LIKE SOB
3998 12D2 : 04                       inc     b               ;[M80] CORRECT SHIFT COUNT
3999 12D3 : 1F                       rra                     ;[M80] WE DID IT ONE TOO MANY TIMES
4000 12D4 : 4F                       ld      c,a             ;[M80] RESULT TO [C]
4001 12D5 : 18 0B                    jr      NORM3A          ;[M80] ALL DONE
4002 12D7 : 05         (M80) NORM2U: dec     b               ;[M80] DECREMENT SHIFT COUNT
4003 12D8 : 29                       add     hl,hl           ;[M80] ROTATE (HL) LEFT ONE, SHIFT IN A ZERO
4004 12D9 : 7A                       ld      a,d             ;[M80] ROTATE NEXT HIGHER ORDER LEFT ONE
4005 12DA : 17                       rla                     ;
4006 12DB : 57                       ld      d,a             ;
4007 12DC : 79                       ld      a,c             ;[M80] ROTATE HIGH ORDER LEFT ONE
4008 12DD : 8F                       adc     a,a             ;[M80] SET CONDITION CODES
4009 12DE : 4F                       ld      c,a             ;
4010 12DF : F2 C8 12   (M80) NORM3:  jp      p,NORM2         ;[M80] WE HAVE MORE NORMALIZATION TO DO
4011 12E2 : 78         (M80) NORM3A: ld      a,b             ;[M80] ALL NORMALIZED, GET SHIFT COUNT
4012 12E3 : 5C                       ld      e,h             ;[M80] PUT LO'S BACK IN E,B
4013 12E4 : 45                       ld      b,l             ;
4014 12E5 : B7                       or      a               ;[M80] CHECK IF WE DID NO SHIFTING
4015 12E6 : 28 09                    jr      z,ROUND         ;
4016 12E8 : 21 E7 38                 ld      hl,FAC          ;[M80] LOOK AT FAC'S EXPONENT
4017 12EB : 86                       add     a,(hl)          ;[M80] UPDATE EXPONENT
4018 12EC : 77                       ld      (hl),a          ;
4019 12ED : 30 D4                    jr      nc,ZERO         ;[M80] CHECK FOR UNDERFLOW
4020 12EF : 28 D2                    jr      z,ZERO          ;[M80] NUMBER IS ZERO, ALL DONE
4021 12F1
4022 12F1                  + ;[M80] ROUND RESULT IN C,D,E,B AND PUT NUMBER IN THE FAC
4023 12F1                  | ;[M80] ALTERS A,B,C,D,E,H,L
4024 12F1                  | ;[M80] WE ROUND C,D,E UP OR DOWN DEPENDING UPON THE MSB OF B
4025 12F1                  | ;
4026 12F1 : 78         [M80] ROUND:  ld      a,b             ;[M80] SEE IF WE SHOULD ROUND UP
4027 12F2 : 21 E7 38   [M80] ROUNDB: ld      hl,FAC          ;[M80] ENTRY FROM FDIV, GET POINTER TO EXPONENT
4028 12F5 : B7                       or      a
4029 12F6 : FC 03 13                 call    m,ROUNDA        ;[M80] DO IT IF NECESSARY
4030 12F9 : 46                       ld      b,(hl)          ;[M80] PUT EXPONENT IN B
4031 12FA                  - ;[80] HERE WE PACK THE HO AND SIGN
4032 12FA : 23                       inc     hl              ;[M80]  POINT TO SIGN
4033 12FB : 7E                       ld      a,(hl)          ;[M80]  GET SIGN
4034 12FC : E6 80                    and     080H            ;[M80]  GET RID OF UNWANTED BITS
4035 12FE : A9                       xor     c               ;[M80]  PACK SIGN AND HO
4036 12FF : 4F                       ld      c,a             ;[M80]  SAVE IT IN C
4037 1300 : C3 23 15                 jp      MOVFR           ;[M80]  SAVE NUMBER IN FAC
4038 1303
4039 1303                    ;[M80] SUBROUTNE FOR ROUND:  ADD ONE TO C,D,E
4040 1303 : 1C               ROUNDA: inc     e               ;[M80] ADD ONE TO THE LOW ORDER, ENTRY FROM QINT
4041 1304 : C0                       ret     nz              ;[M80] ALL DONE IF IT IS NOT ZERO
4042 1305 : 14                       inc     d               ;[M80] ADD ONE TO NEXT HIGHER ORDER
4043 1306 : C0                       ret     nz              ;[M80] ALL DONE IF NO OVERFLOW
4044 1307 : 0C                       inc     c               ;[M80] ADD ONE TO THE HIGHEST ORDER
4045 1308 : C0                       ret     nz              ;[M80] RETURN IF NO OVEFLOW
4046 1309 : 0E 80                    ld      c,$80           ;[M80] THE NUMBER OVERFLOWED, SET NEW HIGH ORDER
4047 130B : 34                       inc     (hl)            ;[M80] UPDATE EXPONENT
4048 130C : C0                       ret     nz              ;[M80] RETURN IF IT DID NOT OVERFLOW
4049 130D : C3 D3 03                 jp      OVERR           ;[M80] OVERFLOW
4050 1310
4051 1310                  + ;[M80] ADD (HL)+2,1,0 TO C,D,E
4052 1310                  | ;[M80] THIS CODE IS USED BY FADD, FOUT
4053 1310 : 7E         [M80] FADDA:  ld      a,(hl)          ;[M80] GET LOWEST ORDER
4054 1311 : 83                       add     a,e             ;[M80] ADD IN OTHER LOWEST ORDER
4055 1312 : 5F                       ld      e,a             ;[M80] SAVE IT
4056 1313 : 23                       inc     hl              ;[M80] UPDATE POINTER TO NEXT BYTE
4057 1314 : 7E                       ld      a,(hl)          ;[M80] ADD MIDDLE ORDERS
4058 1315 : 8A                       adc     a,d
4059 1316 : 57                       ld      d,a
4060 1317 : 23                       inc     hl              ;[M80] UPDATE POINTER TO HIGH ORDER
4061 1318 : 7E                       ld      a,(hl)          ;[M80] ADD HIGH ORDERS
4062 1319 : 89                       adc     a,c
4063 131A : 4F                       ld      c,a
4064 131B : C9                       ret                     ;[M80] ALL DONE
4065 131C
4066 131C                  + ;[M80] NEGATE NUMBER IN C,D,E,B
4067 131C                  | ;[M80] THIS CODE IS USED BY FADD, QINT
4068 131C                  | ;[M80] ALTERS A,B,C,D,E,L
4069 131C                  | ;
4070 131C : 21 E8 38   [M80] NEGR:   ld      hl,FAC+1        ;[M80] NEGATE FAC
4071 131F : 7E                       ld      a,(hl)          ;[M80] GET SIGN
4072 1320 : 2F                       cpl                     ;[M80] COMPLEMENT IT
4073 1321 : 77                       ld      (hl),a          ;[M80] SAVE IT AGAIN
4074 1322 : AF                       xor     a               ;[M80] ZERO A
4075 1323 : 6F                       ld      l,a             ;[M80] SAVE ZERO IN L
4076 1324 : 90                       sub     b               ;[M80] NEGATE LOWEST ORDER
4077 1325 : 47                       ld      b,a             ;[M80] SAVE IT
4078 1326 : 7D                       ld      a,l             ;[M80] GET A ZERO
4079 1327 : 9B                       sbc     a,e             ;[M80] NEGATE NEXT HIGHEST ORDER
4080 1328 : 5F                       ld      e,a             ;[M80] SAVE IT
4081 1329 : 7D                       ld      a,l             ;[M80] GET A ZERO
4082 132A : 9A                       sbc     a,d             ;[M80] NEGATE NEXT HIGHEST ORDER
4083 132B : 57                       ld      d,a             ;[M80] SAVE IT
4084 132C : 7D                       ld      a,l             ;[M80] GET ZERO BACK
4085 132D : 99                       sbc     a,c             ;[M80] NEGATE HIGHEST ORDER
4086 132E : 4F                       ld      c,a             ;[M80] SAVE IT
4087 132F : C9                       ret                     ;[M80] ALL DONE
4088 1330
4089 1330                  + ;[M80] SHIFT C,D,E RIGHT
4090 1330                  | ;[M80] A = SHIFT COUNT
4091 1330                  | ;[M80] ALTERS A,B,C,D,E,L
4092 1330                  | ;[M80] THE IDEA (EXCEPT IN 4K) IS TO SHIFT RIGHT 8 PLACES AS MANY TIMES AS
4093 1330                  | ;[M80]  POSSIBLE
4094 1330                  | ;
4095 1330 : 06 00      [M80] SHIFTR: ld      b,0             ;[M80] ZERO OVERFLOW BYTE
4096 1332 : D6 08      (M80) SHFTR1: sub     8               ;[M80] CAN WE SHIFT IT 8 RIGHT?
4097 1334 : 38 07                    jr      c,SHFTR2        ;[M80] NO, SHIFT IT ONE PLACE AT A TIME
4098 1334                  - ;[M80] THIS LOOP SPEEDS THINGS UP BY SHIFTING 8 PLACES AT ONE TIME
4099 1336 : 43                       ld      b,e             ;[M80] SHIFT NUMBER 1 BYTE RIGHT
4100 1337 : 5A                       ld      e,d
4101 1338 : 51                       ld      d,c
4102 1339 : 0E 00                    ld      c,0             ;[M80 PUT 0 IN HO
4103 133B : 18 F5                    jr      SHFTR1          ;[M80 TRY TO SHIFT 8 RIGHT AGAIN
4104 133D : C6 09      (M80) SHFTR2: add     a,9             ;[M80 CORRECT SHIFT COUNT
4105 133F : 6F                       ld      l,a             ;[M80 SAVE SHIFT COUNT
4106 133D                  - ;[M80] TEST FOR CASE (VERY COMMON) WHERE SHIFTING SMALL INTEGER RIGHT.
4107 133D                  - ;[M80] THIS HAPPENS IN FOR LOOPS, ETC.
4108 1340 : 7A                       ld      a,d             ;[M80] SEE IF THREE LOWS ARE ZERO.
4109 1341 : B3                       or      e
4110 1342 : B0                       or      b
4111 1343 : 20 09                    jr      nz,SHFTR3       ;[M80] IF SO, DO USUAL.
4112 1345 : 79                       ld      a,c             ;[M80] GET HIGH BYTE TO SHIFT
4113 1346 : 2D         (M80) SHFTRF: dec     l               ;[M80] DONE SHIFTING?
4114 1347 : C8                       ret     z               ;[M80] YES, DONE
4115 1348 : 1F                       rra                     ;[M80] ROTATE ONE RIGHT
4116 1349 : 4F                       ld      c,a             ;[M80] SAVE RESULT
4117 134A : 30 FA                    jr      nc,SHFTRF       ;[M80] ZAP BACK AND DO NEXT ONE IF NONE
4118 134C : 18 06                    jr      SHFTC           ;[M80] CONTINUE SHIFTING
4119 134E : AF         (M80) SHFTR3: xor     a               ;[M80] CLEAR CARRY
4120 134F : 2D                       dec     l               ;[M80] ARE WE DONE SHIFTING?
4121 1350 : C8                       ret     z               ;[M80] RETURN IF WE ARE
4122 1351 : 79                       ld      a,c             ;[M80] GET HO
4123 1352 : 1F         [M80] SHRADD: rra                     ;[M80] ENTRY FROM FADD, SHIFT IT RIGHT
4124 1353 : 4F                       ld      c,a             ;[M80] SAVE IT
4125 1354 : 7A         (M80) SHFTC:  ld      a,d             ;[M80] SHIFT NEXT BYTE RIGHT
4126 1355 : 1F                       rra
4127 1356 : 57                       ld      d,a
4128 1357 : 7B                       ld      a,e             ;[M80] SHIFT LOW ORDER RIGHT
4129 1358 : 1F                       rra
4130 1359 : 5F                       ld      e,a
4131 135A : 78                       ld      a,b             ;[M80] SHIFT OVERFLOW BYTE RIGHT
4132 135B : 1F                       rra
4133 135C : 47                       ld      b,a
4134 135D : 18 EF                    jr      SHFTR3          ;[M80] SEE IF WE ARE DONE
4135 135F
4136 135F :                  ;[M80] CONSTANTS USED BY LOG
4137 135F : 00 00 00 81(M80) FONE:   byte    $00,$00,$00,$81 ;1
4138 1363 : 04         [M80] LOGP:   byte    4                ;[M80] HART 2524 COEFFICIENTS
4139 1364 : 9A F7 19 83              byte    $9A,$F7,$19,$83  ;[M80] 4.8114746
4140 1368 : 24 63 43 83              byte    $24,$63,$43,$83  ;[M80] 6.105852
4141 136C : 75 CD 8D 84              byte    $75,$CD,$8D,$84  ;[M80] -8.86266
4142 1370 : A9 7F 83 82              byte    $A9,$7F,$83,$82  ;[M80] -2.054667
4143 1374 : 04         [M80] LOGQ:   byte    4
4144 1375 : 00 00 00 81              byte    $00,$00,$00,$81  ;[M80] 1.0
4145 1379 : E2 B0 4D 83              byte    $E2,$B0,$4D,$83  ;[M80] 6.427842
4146 137D : 0A 72 11 83              byte    $0A,$72,$11,$83  ;[M80] 4.545171
4147 1381 : F4 04 35 7F              byte    $F4,$04,$35,$7F  ;[M80] .3535534
4148 1385
4149 1385 :                + ;[M80] NATURAL LOG FUNCTION
4150 1385 :                | ;[M80] CALCULATION IS BY:
4151 1385 :                | ;[M80]  LN(F*2^N)=(N+LOG2(F))*LN(2)
4152 1385 :                | ;[M80] AN APPROXIMATION POLYNOMIAL IS USED TO CALCULATE LOG2(F)
4153 1385 : EF         [M80] LOG:    rst     FSIGN           ;[M80] CHECK FOR A NEGATIVE OR ZERO ARGUMENT
4154 1386 : B7                       or      a               ;[M80] SET CC'S PROPERLY
4155 1387 : EA 97 06                 jp      pe,FCERR        ;[M80] FAC .LE. 0, BLOW HIM OUT OF THE WATER
4156 138A : CD 95 13                 call    LOG2
4157 138D : 01 31 80                 ld      bc,$8031
4158 1390 : 11 18 72                 ld      de,$7218        ;[M80] GET LN(2)
4159 1393 : 18 36                    jr      FMULT           ;[M80] COMPLETE LOG CALCULATION: USE HART 2524 CALCULATION
4160 1395
4161 1395                    ;[M80] USE HART 2524 CALCULATION
4162 1395 : CD 2E 15   [M80] LOG2:   call    MOVRF           ;[M80] MOVE FAC TO REGISTERS TOO
4163 1398 : 3E 80                    ld      a,080H
4164 139A : 32 E7 38                 ld      (FAC),a         ;[M80] ZERO THE EXPONENT
4165 139D : A8                       xor     b               ;[M80] REMOVE 200 EXCESS FROM X
4166 139E : F5                       push    af              ;[M80] SAVE EXPONENT
4167 139F : CD 13 15                 call    PUSHF           ;[M80] SAVE THE FAC (X)
4168 13A2 : 21 63 13                 ld      hl,LOGP         ;[M80] POINT TO P CONSTANTS
4169 13A5 : CD 46 18                 call    POLY            ;[M80] CALCULATE P(X)
4170 13A8 : C1                       pop     bc              ;[M80] FETCH X
4171 13A9 : E1                       pop     hl              ;[M80] PUSHF WOULD ALTER DE
4172 13AA : CD 13 15                 call    PUSHF           ;[M80] PUSH P(X) ON THE STACK
4173 13AD : EB                       ex      de,hl           ;[M80] GET LOW BYTES OF X TO (DE)
4174 13AE : CD 23 15                 call    MOVFR           ;[M80] AND MOVE TO FAC
4175 13B1 : 21 74 13                 ld      hl,LOGQ         ;[M80] POINT TO Q COEFFICIENTS
4176 13B4 : CD 46 18                 call    POLY            ;[M80] COMPUTE Q(X)
4177 13B7 : C1                       pop     bc              ;[M80] FETCH P(X) TO REGISTERS
4178 13B8 : D1                       pop     de              ;
4179 13B9 : CD 2F 14                 call    FDIV            ;[M80] CALCULATE P(X)/Q(X)
4180 13BC : F1                       pop     af              ;[M80] RE-FETCH EXPONENT
4181 13BD : CD 13 15                 call    PUSHF           ;[M80] SAVE EVALUATION
4182 13C0 : CD F6 14                 call    FLOAT           ;[M80] FLOAT THE EXPONENT
4183 13C3 : C1                       pop     bc              ;
4184 13C4 : D1                       pop     de              ;
4185 13C5 : C3 61 12                 jp      FADD            ;[M80] GET EVAL. BACK
4186 13C8
4187 13C8                    ;;***Unused code?
4188 13C8                    ;;;IMULT in [M80] fell into here
4189 13C8 : 21                       byte    $21             ;;[LD HL.] to skip next two instructions
4190 13C9 : C1         (M80) FMULTT: pop     bc              ;[M80] GET FIRST ARGUMENT OFF STACK, ENTRY FROM POLYX
4191 13CA : D1                       pop     de
4192 13CB
4193 13CB                  + ;[M80] MULTIPLICATION           FAC:=ARG*FAC
4194 13CB                  | ;[M80] ALTERS A,B,C,D,E,H,L
4195 13CB                  | ;
4196 13CB                  | ;[M80] THE PRODUCT WILL BE FORMED IN C,D,E,B. THIS WILL BE IN C,H,L,B PART OF THE
4197 13CB                  | ;[M80] TIME IN ORDER TO USE THE "DAD" INSTRUCTION.  AT FMULT2, WE GET THE NEXT
4198 13CB                  | ;[M80] BYTE OF THE MANTISSA IN THE FAC TO MULTIPLY BY.  ((HL) POINTS TO IT)
4199 13CB                  | ;[M80] (THE FMULT2 SUBROUTINE PRESERVES (HL))  IN 8K, IF THE BYTE IS ZERO, WE JUST
4200 13CB                  | ;[M80] SHIFT THE PRODUCT 8 RIGHT.  THIS BYTE IS THEN SHIFTED RIGHT AND SAVED IN D
4201 13CB                  | ;[M80] (H IN 4K).  THE CARRY DETERMINES IF WE SHOULD ADD IN THE SECOND FACTOR
4202 13CB                  | ;[M80] IF WE DO, WE ADD IT TO C,H,L.  B IS ONLY USED TO DETERMINE WHICH WAY WE
4203 13CB                  | ;[M80] ROUND.  WE THEN SHIFT C,H,L,B (C,D,E,B) IN 4K RIGHT ONE TO GET READY FOR THE
4204 13CB                  | ;[M80] NEXT TIME THROUGH THE LOOP.  NOTE THAT THE CARRY IS SHIFTED INTO THE MSB OF
4205 13CB                  | ;[M80] C.  E HAS A COUNT (L IN 4K) TO DETERMINE WHEN WE HAVE LOOKED AT ALL THE BITS
4206 13CB                  | ;[M80] OF D (H IN 4K).
4207 13CB                  | ;
4208 13CB : EF         [M80] FMULT:  rst     FSIGN           ;[M80] CHECK IF FAC IS ZERO
4209 13CC : C8                       ret     z               ;[M80] IF IT IS, RESULT IS ZERO
4210 13CD : 2E 00                    ld      l,0             ;[M80] ADD THE TWO EXPONENTS, L IS A FLAG
4211 13CF : CD AC 14                 call    MULDIV          ;[M80] FIX UP THE EXPONENTS
4212 13D2                  - ;[M80] SAVE THE NUMBER IN THE REGISTERS SO WE CAN ADD IT FAST
4213 13D2 : 79                       ld      a,c             ;[M80] GET HO
4214 13D3 : 32 F6 38                 ld      (RESHO),a       ;[M80] STORE HO OF REGISTERS
4215 13D6 : EB                       ex      de,hl           ;[M80] STORE THE TWO LO'S OF THE REGISTERS
4216 13D7 : 22 F7 38                 ld      (RESMO),hl      ;
4217 13DA : 01 00 00                 ld      bc,0            ;[M80] ZERO THE PRODUCT REGISTERS
4218 13DD : 50                       ld      d,b             ;
4219 13DE : 58                       ld      e,b             ;
4220 13DF : 21 B0 12                 ld      hl,NORMAL       ;
4221 13E2 : E5                       push    hl              ;[M80]  ON THE STACK
4222 13E3 : 21 EB 13                 ld      hl,FMULT2       ;[M80] PUT FMULT2 ON THE STACK TWICE, SO AFTER
4223 13E6 : E5                       push    hl              ;[M80]  WE MULTIPLY BY THE LO BYTE, WE WILL
4224 13E7 : E5                       push    hl              ;[M80]  MULTIPLY BY THE MO AND HO
4225 13E8 : 21 E4 38                 ld      hl,FACLO        ;[M80] GET ADDRESS OF LO OF FAC
4226 13EB : 7E         (M80) FMULT2: ld      a,(hl)          ;[M80] GET BYTE TO MULTIPLY BY
4227 13EC : 23                       inc     hl              ;[M80] MOVE POINTER TO NEXT BYTE
4228 13ED : B7                       or      a               ;
4229 13EE : 28 2C                    jr      z,FMULT3        ;[M80] ARE WE MULTIPLYING BY ZERO?
4230 13F0 : E5                       push    hl              ;[M80] SAVE POINTER
4231 13F1 : 2E 08                    ld      l,8             ;[M80] SET UP A COUNT
4232 13F3 : 1F         (M80) FMULT4: rra                     ;ROTATE BYTE RIGHT
4233 13F4 : 67                       ld      h,a             ;SAVE IT
4234 13F5 : 79                       ld      a,c             ;GET HO
4235 13F6 : 30 0B                    jr      nc,FMULT5        ;DON'T ADD IN NUMBER IF BIT WAS ZERO
4236 13F8 : E5                       push    hl              ;SAVE COUNTERS
4237 13F9 : 2A F7 38                 ld      hl,(RESMO)
4238 13FC : 19                       add     hl,de
4239 13FD : EB                       ex      de,hl
4240 13FE : E1                       pop     hl
4241 13FF : 3A F6 38                 ld      a,(RESHO)
4242 1402 : 89                       adc     a,c
4243 1403 : 1F         (M80) FMULT5: rra                     ;[M80] ROTATE RESULT RIGHT ONE
4244 1404 : 4F                       ld      c,a             ;
4245 1405 : 7A                       ld      a,d             ;[M80] ROTATE NEXT BYTE
4246 1406 : 1F                       rra                     ;
4247 1407 : 57                       ld      d,a             ;
4248 1408 : 7B                       ld      a,e             ;[M80] ROTATE NEXT LOWER ORDER
4249 1409 : 1F                       rra                     ;
4250 140A : 5F                       ld      e,a             ;
4251 140B : 78                       ld      a,b             ;[M80] ROTATE LO
4252 140C : 1F                       rra                     ;
4253 140D : 47                       ld      b,a             ;
4254 140E : E6 10                    and     010H            ;[M80] SEE IF WE ROTATED THRU ST
4255 1410 : 28 04                    jr      z,FML5B1        ;[M80] IF NOT DON'T WORRY
4256 1412 : 78                       ld      a,b             ;[M80] RE FETCH LO
4257 1413 : F6 20                    or      020H            ;[M80] "OR" IN STICKY
4258 1415 : 47                       ld      b,a             ;[M80] BACK TO LO
4259 1416 : 2D               FML5B1: dec     l               ;[M80] ARE WE DONE?
4260 1417 : 7C                       ld      a,h             ;[M80] GET NUMBER WE ARE MULTIPLYING BY
4261 1418 : 20 D9                    jr      nz,FMULT4       ;[M80] MULTIPLY AGAIN IF WE ARE NOT DONE
4262 141A : E1         [M80] POPHRT: pop     hl              ;[M80] GET POINTER TO NUMBER TO MULTIPLY BY
4263 141B : C9                       ret                     ;[M80] ALL DONE
4264 141C : 43         [M80] FMULT3: ld      b,e             ;[M80] MULTIPLY BY ZERO: SHIFT EVERYTHING 8 RIGHT
4265 141D : 5A                       ld      e,d             ;
4266 141E : 51                       ld      d,c             ;
4267 141F : 4F                       ld      c,a             ;[M80] SHIFT IN 8 ZEROS ON THE LEFT
4268 1420 : C9                       ret                     ;[M80] ALL DONE
4269 1421
4270 1421                  + ;[M80]  DIVIDE FAC BY 10
4271 1421                  - ;[M80]  ALTERS A,B,C,D,E,H,L
4272 1421 : CD 13 15   [M80] DIV10:  call    PUSHF           ;[M80] WE HAVE TO DIVIDE -- SAVE COUNT
4273 1424 : 01 20 84                 ld      bc,$8420        ;[M80] 10.0
4274 1427 : 11 00 00                 ld      de,$0000
4275 142A : CD 23 15                 call    MOVFR           ;[M80] MOVE TEN INTO THE FAC
4276 142D : C1         [M80] FDIVT:  pop     bc              ;[F80] GET NUMBER BACK IN REGISTERS
4277 142E : D1                       pop     de              ;[F80] FALL INTO DIVIDE AND WE ARE DONE
4278 142F
4279 142F                    ;[M80] DIVISION       FAC:=ARG/FAC
4280 142F                    ;[M80] ALTERS A,B,C,D,E,H,L
4281 142F : EF         [M80] FDIV:   rst     FSIGN           ;[M80] CHECK FOR DIVISION BY ZERO
4282 1430 : CA C7 03                 jp      z,DV0ERR        ;[M80] DON'T ALLOW DIVIDE BY ZERO
4283 1433 : 2E FF                    ld      l,255           ;[M80] SUBTRACT THE TWO EXPONENTS, L IS A FLAG
4284 1435 : CD AC 14                 call    MULDIV          ;[M80] FIX UP THE EXPONENTS AND THINGS
4285 1438 : 34                       inc     (hl)
4286 1439 : CA D3 03                 jp      z,OVERR         ;[M80] OVERFLOW
4287 143C : 34                       inc     (hl)
4288 143D : CA D3 03                 jp      z,OVERR         ;[M80] OVERFLOW
4289 1440                  - ;[M80] HERE WE SAVE THE FAC IN MEMORY SO WE CAN SUBTRACT IT FROM THE NUMBER
4290 1440                  - ;[M80] IN THE REGISTERS QUICKLY.
4291 1440 : 2B                       dec     hl              ;[M80] POINT TO HO
4292 1441 : 7E                       ld      a,(hl)          ;[M80] GET HO
4293 1442 : 32 19 38                 ld      (FDIVA+1),a       ;[M80] SAVE IT
4294 1445 : 2B                       dec     hl              ;[M80] SAVE MIDDLE ORDER
4295 1446 : 7E                       ld      a,(hl)
4296 1447 : 32 15 38                 ld      (FDIVB+1),a       ;[M80] PUT IT WHERE NOTHING WILL HURT IT
4297 144A : 2B                       dec     hl              ;[M80] SAVE LO
4298 144B : 7E                       ld      a,(hl)
4299 144C : 32 11 38                 ld      (FDIVC+1),a
4300 144F                  - ;[M80] THE NUMERATOR WILL BE KEPT IN B,H,L.  THE QUOTIENT WILL BE FORMED IN C,D,E.
4301 144F                  | ;[M80] TO GET A BIT OF THE QUOTIENT, WE FIRST SAVE B,H,L ON THE STACK, THEN
4302 144F                  | ;[M80] SUBTRACT THE DENOMINATOR THAT WE SAVED IN MEMORY.  THE CARRY INDICATES
4303 144F                  | ;[M80] WHETHER OR NOT B,H,L WAS BIGGER THAN THE DENOMINATOR.  IF B,H,L WAS BIGGER,
4304 144F                  | ;[M80] THE NEXT BIT OF THE QUOTIENT IS A ONE.  TO GET THE OLD B,H,L OFF THE STACK,
4305 144F                  | ;[M80] WE POP THEM INTO THE PSW.  IF THE DENOMINATOR WAS BIGGER, THE NEXT BIT OF
4306 144F                  | ;[M80] THE QUOTIENT IS ZERO, AND WE GET THE OLD B,H,L BACK BY POPPING IT OFF THE
4307 144F                  | ;[M80] STACK.  WE HAVE TO KEEP AN EXTRA BIT OF THE QUOTIENT IN FDIVG+1 IN CASE THE
4308 144F                  | ;[M80] DENOMINATOR WAS BIGGER,  THEN B,H,L WILL GET SHIFTED LEFT.  IF THE MSB  OF
4309 144F                  | ;[M80] B WAS ONE, IT HAS TO BE STORED SOMEWHERE, SO WE STORE IT IN FDIVG+1.  THEN
4310 144F                  | ;[M80] THE NEXT TIME THROUGH THE LOOP B,H,L WILL LOOK BIGGER BECAUSE IT HAS AN
4311 144F                  | ;[M80] EXTRA HO BIT IN FDIVG+1. WE ARE DONE DIVIDING WHEN THE MSB OF C IS A ONE.
4312 144F                  | ;[M80] THIS OCCURS WHEN WE HAVE CALCULATED 24 BITS OF THE QUOTIENT.  WHEN WE JUMP
4313 144F                  | ;[M80] TO ROUND, THE 25TH BIT OF THE QUOTIENT DETERMINES WHETHER WE ROUND OR NOT.
4314 144F                  | ;[M80] IT IS IN THE MSB OF A.  IF INITIALLY THE DENOMINATOR IS BIGGER THAN THE
4315 144F                  | ;[M80] NUMERATOR, THE FIRST BIT OF THE QUOTIENT WILL BE ZERO.  THIS MEANS WE
4316 144F                  | ;[M80] WILL GO THROUGH THE DIVIDE LOOP 26 TIMES, SINCE IT STOPS ON THE 25TH BIT
4317 144F                  | ;[M80] AFTER THE FIRST NON-ZERO BIT OF THE QUOTIENT.  SO, THIS QUOTIENT WILL LOOK
4318 144F                  | ;[M80] SHIFTED LEFT ONE FROM THE QUOTIENT OF TWO NUMBERS IN WHICH THE NUMERATOR IS
4319 144F                  | ;[M80] BIGGER.  THIS CAN ONLY OCCUR ON THE FIRST TIME THROUGH THE LOOP, SO C,D,E
4320 144F                  | ;[M80] ARE ALL ZERO.  SO, IF WE FINISH THE LOOP AND C,D,E ARE ALL ZERO, THEN WE
4321 144F                  | ;[M80] MUST DECREMENT THE EXPONENT TO CORRECT FOR THIS.
4322 144F : 41                       ld      b,c             ;[M80] GET NUMBER IN B,H,L
4323 1450 : EB                       ex      de,hl
4324 1451 : AF                       xor     a               ;[M80] ZERO C,D,E AND HIGHEST ORDER
4325 1452 : 4F                       ld      c,a
4326 1453 : 57                       ld      d,a
4327 1454 : 5F                       ld      e,a
4328 1455 : 32 1C 38                 ld      (FDIVG+1),a
4329 1458 : E5         [M80] FDIV1:  push    hl              ;[M80] SAVE LO'S OF NUMBER
4330 1459 : C5                       push    bc              ;[M80] SAVE HO OF NUMBER
4331 145A : 7D                       ld      a,l             ;[M80] SUBTRACT NUMBER THAT WAS IN FAC
4332 145B : CD 10 38                 call    FDIVC           ;;Call Divide Routine in RAM for apeed
4333 145E : DE 00                    sbc     a,0             ;[M80] SUBTRACT LO
4334 1460 : 3F                       ccf                     ;[M80] SET CARRY TO CORESPOND TO NEXT QUOTIENT BIT
4335 1461 : 30 07                    jr      nc,FDIV2        ;[M80] GET OLD NUMBER BACK IF WE SUBTRACTED TOO MUCH
4336 1463 : 32 1C 38                 ld      (FDIVG+1),a     ;[M80] UPDATE HIGHEST ORDER
4337 1466 : F1                       pop     af              ;[M80] THE SUBTRACTION WAS GOOD
4338 1467 : F1                       pop     af              ;[M80] GET PREVIOUS NUMBER OFF STACK
4339 1468 : 37                       scf                     ;[M80] NEXT BIT IN QUOTIENT IS A ONE
4340 1469 : D2                       byte    $D2             ;[M80] "JNC" AROUND NEXT 2 BYTES
4341 146A : C1         (M80) FDIV2:  pop     bc              ;[M80] WE SUBTRACTED TOO MUCH
4342 146B : E1                       pop     hl              ;[M80] GET OLD NUMBER BACK
4343 146C : 79                       ld      a,c             ;[M80] ARE WE DONE?
4344 146D : 3C                       inc     a               ;[M80] SET SIGN FLAG WITHOUT AFFECTING CARRY
4345 146E : 3D                       dec     a
4346 146F : 1F                       rra                     ;[M80]PUT CARRY IN MSB
4347 1470 : F2 87 14                 jp      p,DIV2A         ;[M80]NOT READY TO ROUND YET
4348 1473 : 17                       rla                     ;[M80]BIT BACK TO CARRY
4349 1474 : 3A 1C 38                 ld      a,(FDIVG+1)     ;[M80]FETCH EXTRA BIT
4350 1477 : 1F                       rra                     ;[M80]BOTH NOW IN A
4351 1478 : E6 C0                    and     $C0             ;[M80]CLEAR SUPERFLUOUS BITS
4352 147A : F5                       push    af              ;[M80]SAVE FOR LATER
4353 147B : 78                       ld      a,b             ;[M80]FETCH HO OF REMAINDER
4354 147C : B4                       or      h               ;[M80]FETCH HO
4355 147D : B5                       or      l               ;[M80]SEE IF OTHER REMAINDER BITS AND IF SO SET ST
4356 147E : 28 02                    jr      z,DIV2AA        ;[M80]IF NOT IGNORE
4357 1480 : 3E 20                    ld      a,020H          ;[M80]ST BIT
4358 1482 : E1         (M80) DIV2AA: pop     hl              ;[M80]AND THE REST OF REMAINDER
4359 1483 : B4                       or      h               ;[M80]"OR" IN REST
4360 1484 : C3 F2 12                 jp      ROUNDB          ;[M80]USE REMAINDER
4361 1487 : 17         (M80) DIV2A:  rla                     ;[M80]WE AREN'T, GET OLD CARRY BACK
4362 1488 : 7B                       ld      a,e             ;[M80]ROTATE EVERYTHING LEFT ONE
4363 1489 : 17                       rla                     ;[M80]ROTATE NEXT BIT OF QUOTIENT IN
4364 148A : 5F                       ld      e,a
4365 148B : 7A                       ld      a,d
4366 148C : 17                       rla
4367 148D : 57                       ld      d,a
4368 148E : 79                       ld      a,c
4369 148F : 17                       rla
4370 1490 : 4F                       ld      c,a
4371 1491 : 29                       add     hl,hl           ;[M80] ROTATE A ZERO INTO RIGHT END OF NUMBER
4372 1492 : 78                       ld      a,b             ;[M80] THE HO BYTE, FINALLY!
4373 1493 : 17         {M80} FDIV2A: rla
4374 1494 : 47                       ld      b,a
4375 1495 : 3A 1C 38   {M80} FDIV2B: ld      a,(FDIVG+1)
4376 1498 : 17                       rla
4377 1499 : 32 1C 38                 ld      (FDIVG+1),a
4378 149C : 79                       ld      a,c             ;[M80] ADD ONE TO EXPONENT IF THE FIRST SUBTRACTION
4379 149D : B2                       or      d               ;[M80]  DID NOT WORK
4380 149E : B3                       or      e
4381 149F : 20 B7                    jr      nz,FDIV1        ;[M80] THIS ISN'T THE CASE
4382 14A1 : E5                       push    hl              ;[M80] SAVE PART OF NUMBER
4383 14A2 : 21 E7 38                 ld      hl,FAC          ;[M80] GET POINTER TO FAC
4384 14A5 : 35                       dec     (hl)            ;[M80] DECREMENT EXPONENT
4385 14A6 : E1                       pop     hl              ;[M80] GET NUMBER BACK
4386 14A7 : 20 AF                    jr      nz,FDIV1        ;[M80] DIVIDE MORE IF NO OVERFLOW OCCURED
4387 14A9 : C3 C3 12                 jp      ZERO            ;[M80] UNDERFLOW!!
4388 14AC
4389 14AC                  + ;[M80] CHECK SPECIAL CASES AND ADD EXPONENTS FOR FMULT, FDIV
4390 14AC                  | ;[M80] ALTERS A,B,H,L
4391 14AC                  | ;
4392 14AC : 78         [M80] MULDIV: ld      a,b             ;[M80] IS NUMBER IN REGISTERS ZERO?
4393 14AD : B7                       or      a
4394 14AE : 28 1D                    jr      z,MULDV2        ;[M80] IT IS, ZERO FAC AND WE ARE DONE
4395 14B0 : 7D                       ld      a,l             ;[M80] GET ADD OR SUBTRACT FLAG
4396 14B1 : 21 E7 38                 ld      hl,FAC          ;[M80] GET POINTER TO EXPONENT
4397 14B4 : AE                       xor     (hl)            ;[M80] GET EXPONENT
4398 14B5 : 80                       add     a,b             ;[M80] ADD IN REGISTER EXPONENT
4399 14B6 : 47                       ld      b,a             ;[M80] SAVE IT
4400 14B7 : 1F                       rra                     ;[M80] CHECK FOR OVERFLOW
4401 14B8 : A8                       xor     b               ;[M80] OVERFLOW IF SIGN IS THE SAME AS CARRY
4402 14B9 : 78                       ld      a,b             ;[M80] GET SUM
4403 14BA : F2 CC 14                 jp      p,MULDV1        ;[M80] WE HAVE OVERFLOW!!
4404 14BD : C6 80                    add     a,$80           ;{M80} PUT EXPONENT IN EXCESS 128
4405 14BF : 77                       ld      (hl),a          ;[M80] SAVE IT IN THE FAC
4406 14C0 : CA 1A 14                 jp      z,POPHRT        ;[M80] WE HAVE UNDEFLOW!! RETURN.
4407 14C3 : CD 46 15                 call    UNPACK          ;[M80] UNPACK THE ARGUMENTS
4408 14C6 : 77                       ld      (hl),a          ;[M80] SAVE THE NEW SIGN
4409 14C7 : 2B         {M80} DCXHRT: dec     hl              ;[M80] POINT TO EXPONENT
4410 14C8 : C9                       ret                     ;[M80] ALL DONE, LEAVE HO IN A
4411 14C8
4412 14C9 : EF         {M80} MLDVEX: rst     FSIGN           ;[M80] ENTRY FROM EXP, PICK UNDERFLOW IF NEGATIVE
4413 14CA : 2F                       cpl                     ;[M80] PICK OVERFLOW IF POSITIVE
4414 14CB : E1                       pop     hl              ;[M80] DON'T SCREW UP STACK
4415 14CC : B7         [M80] MULDV1: or      a               ;[M80] IS ERROR OVERFLOW OR UNDEFLOW?
4416 14CD : E1         [M80] MULDV2: pop     hl              ;[M80] GET OLD RETURN ADDRESS OFF STACK
4417 14CE : F2 C3 12                 jp      p,ZERO
4418 14D1 : C3 D3 03                 jp      OVERR           ;[M80] OVERFLOW
4419 14D1
4420 14D1                  + ;[M80] MULTIPLY FAC BY 10
4421 14D1                  | ;[M80] ALTERS A,B,C,D,E,H,L
4422 14D4 : CD 2E 15   [M80] MUL10:  call    MOVRF           ;[M80] GET NUMBER IN REGISTERS
4423 14D7 : 78                       ld      a,b             ;[M80] GET EXPONENT
4424 14D8 : B7                       or      a               ;[M80] RESULT IS ZERO IF ARG IS ZERO
4425 14D9 : C8                       ret     z               ;[M80] IT IS
4426 14DA : C6 02                    add     a,002H          ;[M80] MULTIPLY BY 4 BY ADDING 2 TO EXPONENT
4427 14DC : DA D3 03                 jp      c,OVERR         ;{M80} OVERFLOW
4428 14DF : 47                       ld      b,a             ;[M80] RESTORE EXPONENT
4429 14E0 : CD 61 12                 call    FADD            ;[M80] ADD IN ORIGINAL NUMBER TO GET 5 TIMES IT
4430 14E3 : 21 E7 38                 ld      hl,FAC          ;[M80] ADD 1 TO EXPONENT TO MULTIPLY NUMBER BY
4431 14E6 : 34                       inc     (hl)            ;[M80]  2 TO GET 10 TIMES ORIGINAL NUMBER
4432 14E7 : C0                       ret     nz              ;[M80] ALL DONE IF NO OVERFLOW
4433 14E8 : C3 D3 03                 jp      OVERR           ;{M80} OVERFLOW
4434 14EB
4435 14EB                    ;;Jumped to from FSIGN
4436 14EB : 3A E6 38   [M80] SIGNC:  ld      a,(FACHO)       ;[M80] GET SIGN OF FACHO, IT IS NON-ZERO
4437 14EE : FE                       byte    $FE             ;"CP" AROUND NEXT BYTE
4438 14EF : 2F         [M80] FCOMPS: cpl                     ;ENTRY FROM FCOMP, COMPLEMENT SIGN
4439 14F0 : 17         (M80) ICOMPS: rla                     ;ENTRY FROM ICOMP, PUT SIGN BIT IN CARRY
4440 14F1 : 9F         [M80] SIGNS:  sbc     a,a             ;A=0 IF CARRY WAS 0, A=377 IF CARRY WAS 1
4441 14F2 : C0                       ret     nz              ;RETURN IF NUMBER WAS NEGATIVE
4442 14F3 : 3C         (M80) INRART: inc     a               ;PUT ONE IN A IF NUMBER WAS POSITIVE
4443 14F4 : C9                       ret                     ;ALL DONE
4444 14F5
4445 14F5                    ;;The SGN() Function
4446 14F5 : EF               SGN:    rst     FSIGN           ;;Get sign of FAC
4447 14F6
4448 14F6                  + ;[M80] FLOAT THE SIGNED INTEGER IN A
4449 14F6                  | ;[M80] ALTERS A,B,C,D,E,H,L
4450 14F6 : 06 88      [M80] FLOAT:  ld      b,$88           ;[M80] SET EXPONENT CORRECTLY
4451 14F8 : 11 00 00                 ld      de,0            ;[M80] ZERO D,E
4452 14FB
4453 14FB                  + ;[M80] FLOAT THE SIGNED NUMBER IN B,A,D,E
4454 14FB                  | ;[M80] ALTERS A,B,C,D,E,H,L
4455 14FB : 21 E7 38   [M80] FLOATR: ld      hl,FAC          ;[M80] GET POINTER TO FAC
4456 14FE : 4F                       ld      c,a             ;[M80] PUT HO IN C
4457 14FF : 70                       ld      (hl),b          ;[M80] PUT EXPONENT IN THE FAC
4458 1500 : 06 00                    ld      b,0             ;[M80] ZERO OVERFLOW BYTE
4459 1502 : 23                       inc     hl              ;[M80] POINT TO SIGN
4460 1503 : 36 80                    ld      (hl),128        ;[M80] ASSUME A POSITIVE NUMBER
4461 1505 : 17                       rla                     ;[M80] PUT SIGN IN CARRY
4462 1506 : C3 AD 12                 jp      FADFLT          ;[M80] GO AND FLOAT THE NUMBER
4463 1509
4464 1509                    ;[M80] ABSOLUTE VALUE OF FAC
4465 1509 : EF         [M80] ABS:    rst     FSIGN           ;[M80] GET THE SIGN OF THE FAC IN A
4466 150A : F0                       ret     p               ;[M80] IF IT IS POSITIVE, WE ARE DONE
4467 150B
4468 150B                    ;[M80] NEGATE ANY TYPE VALUE IN THE FAC
4469 150B : 21 E6 38   [M80] NEG:    ld      hl,FACHO        ;[M80[ GET POINTER TO SIGN
4470 150E : 7E                       ld      a,(hl)          ;[M80[ GET SIGN
4471 150F : EE 80                    xor     $80             ;[M80[ COMPLEMENT SIGN BIT
4472 1511 : 77                       ld      (hl),a          ;[M80[ SAVE IT
4473 1512 : C9                       ret                     ;[M80[ ALL DONE
4474 1513
4475 1513                    ;[M80] PUT FAC ON STACK, ALTERS D,E
4476 1513 : EB         [M80] PUSHF:  ex      de,hl           ;[M80] SAVE (HL)
4477 1514 : 2A E4 38                 ld      hl,(FACLO)      ;[M80] GET LO'S
4478 1517 : E3                       ex      (sp),hl         ;[M80] SWITCH LO'S AND RET ADDR
4479 1518 : E5                       push    hl              ;[M80] PUT RET ADDR BACK ON STACK
4480 1519 : 2A E6 38                 ld      hl,(FACHO)      ;[M80] GET HO'S
4481 151C : E3                       ex      (sp),hl         ;[M80] SWITCH HO'S AND RET ADDR
4482 151D : E5                       push    hl              ;[M80] PUT RET ADDR BACK ON STACK
4483 151E : EB                       ex      de,hl           ;[M80] GET OLD (HL) BACK
4484 151F : C9                       ret                     ;[M80] ALL DONE
4485 1520
4486 1520 : CD 31 15   [M80] MOVFM:  call    MOVRM           ;[M80] MOVE NUMBER FROM MEMORY [(HL)] TO FAC
4487 1523 : EB         [M80] MOVFR:  ex      de,hl           ;[M80] MOVE REGISTERS (B,C,D,E) TO FAC
4488 1524 : 22 E4 38                 ld      (FACLO),hl      ;[M80] PUT THEM WHERE THEY BELONG
4489 1527 : 60                       ld      h,b             ;[M80] GET HO'S IN (HL)
4490 1528 : 69                       ld      l,c             ;
4491 1529 : 22 E6 38                 ld      (FACHO),hl      ;[M80] PUT HO'S WHERE THEY BELONG
4492 152C : EB                       ex      de,hl           ;[M80] GET OLD (HL) BACK
4493 152D : C9                       ret                     ;[M80] ALL DONE
4494 152E
4495 152E : 21 E4 38   [M80] MOVRF:  ld      hl,FACLO        ;[M80] MOVE FAC TO REGISTERS (B,C,D,E)
4496 1531 : 5E         [M80] MOVRM:  ld      e,(hl)          ;[M80] GET NUMBER IN REGISTERS (B,C,D,E) FROM MEMORY [(HL)]
4497 1532 : 23                       inc     hl              ;[M80] POINT TO MO
4498 1533 : 56                       ld      d,(hl)          ;[M80] GET MO, ENTRY FOR BILL
4499 1534 : 23                       inc     hl              ;[M80] POINT TO HO
4500 1535 : 4E                       ld      c,(hl)          ;[M80] GET HO
4501 1536 : 23                       inc     hl              ;[M80] POINT TO EXPONENT
4502 1537 : 46                       ld      b,(hl)          ;[M80] GET EXPONENT
4503 1538 : 23         [M80] INXHRT: inc     hl              ;[M80] INC POINTER TO BEGINNING OF NEXT NUMBER
4504 1539 : C9                       ret                     ;[M80] ALL DONE
4505 153A
4506 153A                  + ;[M80] MOVE NUMBER FROM FAC TO MEMORY [(HL)]
4507 153A                  | ;[M80] ALTERS A,B,D,E,H,L
4508 153A : 11 E4 38   [M80] MOVMF:  ld      de,FACLO        ;GET POINTER TO FAC
4509 153D
4510 153D                  + ;MOVE NUMBER FROM (DE) TO (HL)
4511 153D                  | ;ALTERS A,B,D,E,H,L
4512 153D                  | ;EXITS WITH (DE):=(DE)+4, (HL):=(HL)+4
4513 153D : 06 04      [M80] MOVE:   ld      b,4             ;[M80] SET COUNTER
4514 153F : 1A         (M80) MOVE1:  ld      a,(de)          ;[M80] GET WORD
4515 1540 : 77                       ld      (hl),a          ;[M80] PUT IT WHERE IT BELONGS
4516 1541 : 13                       inc     de              ;[M80] INCREMENT POINTERS TO NEXT WORD
4517 1542 : 23                       inc     hl
4518 1543 : 10 FA                    djnz    MOVE1
4519 1545 : C9                       ret
4520 1546
4521 1546                  + ;[M80] UNPACK THE FAC AND THE REGISTERS
4522 1546                  | ;[M80] ALTERS A,C,H,L
4523 1546                  | ;[M80] WHEN THE NUMBER IN THE FAC IS UNACKED, THE ASSUMED ONE IN THE
4524 1546                  | ;[M80] MANTISSA IS RESTORED, AND THE COMPLEMENT OF THE SIGN IS PLACED
4525 1546                  | ;[M80] IN FAC+1
4526 1546 : 21 E6 38   [M80] UNPACK: ld      hl,FACHO        ;[M80] POINT TO HO AND SIGN
4527 1549 : 7E                       ld      a,(hl)          ;[M80] GET HO AND SIGN
4528 154A : 07                       rlca                    ;[M80] DUPLICATE THE SIGN IN CARRY AND THE LSB
4529 154B : 37                       scf                     ;[M80] RESTORE THE HIDDEN ONE
4530 154C : 1F                       rra                     ;[M80] RESTORE THE NUMBER IN A
4531 154D : 77                       ld      (hl),a          ;[M80] SAVE HO
4532 154E : 3F                       ccf                     ;[M80] GET THE COMPLEMENT OF THE SIGN
4533 154F : 1F                       rra                     ;[M80] GET IT IN THE SIGN BIT
4534 1550 : 23                       inc     hl              ;[M80] POINT TO TEMPORARY SIGN BYTE
4535 1551 : 23                       inc     hl
4536 1552 : 77                       ld      (hl),a          ;[M80] SAVE COMPLEMENT OF SIGN
4537 1553 : 79                       ld      a,c             ;[M80] GET HO AND SIGN OF THE REGISTERS
4538 1554 : 07                       rlca                    ;[M80] DUPLICATE THE SIGN IN CARRY AND THE LSB
4539 1555 : 37                       scf                     ;[M80] RESTORE THE HIDDEN ONE
4540 1556 : 1F                       rra                     ;[M80] RESTORE THE HO IN A
4541 1557 : 4F                       ld      c,a             ;[M80] SAVE THE HO
4542 1558 : 1F                       rra                     ;[M80] GET THE SIGN BACK
4543 1559 : AE                       xor     (hl)            ;[M80] COMPARE SIGN OF FAC AND SIGN OF REGISTERS
4544 155A : C9                       ret                     ;[M80] ALL DONE
4545 155B
4546 155B                  + ;[M80] COMPARE TWO NUMBERS
4547 155B                  | ;[M80] A=1 IF ARG .LT. FAC
4548 155B                  | ;[M80] A=0 IF ARG=FAC
4549 155B                  | ;[M80] A=-1 IF ARG .GT. FAC
4550 155B                  | ;[M80] DOREL DEPENDS UPON THE FACT THAT FCOMP RETURNS WITH CARRY ON
4551 155B                  | ;{M80}  IFF A HAS $7F
4552 155B                  | ;[M80] ALTERS A,H,L
4553 155B                  | ;
4554 155B : 78         [M80] FCOMP:  ld      a,b             ;[M80] CHECK IF ARG IS ZERO
4555 155C : B7                       or      a               ;
4556 155D : CA 28 00                 jp      z,FSIGN         ;
4557 1560 : 21 EF 14                 ld      hl,FCOMPS       ;[M80] WE JUMP TO FCOMPS WHEN WE ARE DONE
4558 1563 : E5                       push    hl              ;[M80] PUT THE ADDRESS ON THE STACK
4559 1564 : EF                       rst     FSIGN           ;[M80] CHECK IF FAC IS ZERO
4560 1565 : 79                       ld      a,c             ;[M80] IF IT IS, RESULT IS MINUS THE SIGN OF ARG
4561 1566 : C8                       ret     z               ;[M80] IT IS
4562 1567 : 21 E6 38                 ld      hl,FACHO        ;[M80] POINT TO SIGN OF FAC
4563 156A : AE                       xor     (hl)            ;[M80] SEE IF THE SIGNS ARE THE SAME
4564 156B : 79                       ld      a,c             ;[M80] IF THEY ARE DIFFERENT, RESULT IS SIGN OF ARG
4565 156C : F8                       ret     m               ;[M80] THEY ARE DIFFERENT
4566 156D : CD 73 15                 call    FCOMP2          ;[M80] CHECK THE REST OF THE NUMBER
4567 1570 : 1F         {M80} FCOMPD: rra                     ;[M80] NUMBERS ARE DIFFERENT, CHANGE SIGN IF
4568 1571 : A9                       xor     c               ;[M80]  BOTH NUMBERS ARE NEGATIVE
4569 1572 : C9                       ret                     ;[M80] GO SET UP A
4570 1573 : 23         (M80) FCOMP2: inc     hl              ;POINT TO EXPONENT
4571 1574 : 78                       ld      a,b             ;GET EXPONENT OF ARG
4572 1575 : BE                       cp      (hl)            ;COMPARE THE TWO
4573 1576 : C0                       ret     nz              ;NUMBERS ARE DIFFERENT
4574 1577 : 2B                       dec     hl              ;POINT TO HO
4575 1578 : 79                       ld      a,c             ;GET HO OF ARG
4576 1579 : BE                       cp      (hl)            ;COMPARE WITH HO OF FAC
4577 157A : C0                       ret     nz              ;THEY ARE DIFFERENT
4578 157B : 2B                       dec     hl              ;POINT TO MO OF FAC
4579 157C : 7A                       ld      a,d             ;GET MO OF ARG
4580 157D : BE                       cp      (hl)            ;COMPARE WITH MO OF FAC
4581 157E : C0                       ret     nz              ;THE NUMBERS ARE DIFFERENT
4582 157F : 2B                       dec     hl              ;POINT TO LO OF FAC
4583 1580 : 7B                       ld      a,e             ;GET LO OF ARG
4584 1581 : 96                       sub     (hl)            ;SUBTRACT LO OF FAC
4585 1582 : C0                       ret     nz              ;NUMBERS ARE DIFFERENT
4586 1583 : E1                       pop     hl              ;NUMBERS ARE THE SAME, DON'T SCREW UP STACK
4587 1584 : E1                       pop     hl              ;
4588 1585 : C9                       ret                     ;ALL DONE
4589 1586
4590 1586                  + ;[M80] QUICK GREATEST INTEGER FUNCTION
4591 1586                  | ;[M80] LEAVES INT(FAC) IN C,D,E (SIGNED) ALTERS A,B,C,D,E
4592 1586                  | ;[M80] ASSUMES THE EXPONENT OF FAC IS IN A AND FAC .LT. 2^23 = 8388608
4593 1586                  | ;[M80]
4594 1586                  | ;[M80] THE HARD CASE IN QINT IS NEGATIVE NON-INTEGERS.  TO HANDLE THIS, IF THE
4595 1586                  | ;[M80] NUMBER IS NEGATIVE, WE REGARD THE 3-BYTE MANTISSA AS A 3-BYTE INTEGER AND
4596 1586                  | ;[M80] SUBTARCT ONE.  THEN ALL THE FRACTIONAL BITS ARE SHIFTED OUT BY SHIFTING THE
4597 1586                  | ;[M80] MANTISSA RIGHT.  THEN, IF THE NUMBER WAS NEGATIVE, WE ADD ONE.  SO, IF WE
4598 1586                  | ;[M80] HAD A NEGATIVE INTEGER, ALL THE BITS TO THE RIGHT OF THE BINARY POINT WERE
4599 1586                  | ;[M80] ZERO.  SO THE NET EFFECT IS WE HAVE THE ORIGINAL NUMBER IN C,D,E.  IF THE
4600 1586                  | ;[M80] NUMBER WAS A NEGATIVE NON-INTEGER, THERE IS AT LEAST ONE NON-ZERO BIT TO THE
4601 1586                  | ;[M80] RIGHT OF THE BINARY POINT.  SO THE NET EFFECT IS THAT WE GET THE ABSOLUTE
4602 1586                  | ;[M80] VALUE OF INT(FAC) IN C,D,E.  C,D,E IS THEN NEGATED IF THE ORIGINAL NUMBER WAS
4603 1586                  | ;[M80] NEGATIVE SO THE RESULT WILL BE SIGNED.
4604 1586                  | ;
4605 1586 : 47         [M80] QINT:   ld      b,a             ;[M80] ZERO B,C,D,E IN CASE THE NUMBER IS ZERO
4606 1587 : 4F                       ld      c,a
4607 1588 : 57                       ld      d,a
4608 1589 : 5F                       ld      e,a
4609 158A : B7                       or      a               ;[M80] SET CONDITION CODES
4610 158B : C8                       ret     z               ;[M80] IT IS ZERO, WE ARE DONE
4611 158C : E5                       push    hl              ;[M80] SAVE (HL)
4612 158D : CD 2E 15                 call    MOVRF           ;[M80] GET NUMBER IN THE REGISTERS
4613 1590 : CD 46 15                 call    UNPACK          ;[M80] UNPACK THE NUMBER
4614 1593 : AE                       xor     (hl)            ;[M80] GET SIGN OF NUMBER
4615 1594 : 67                       ld      h,a             ;[M80] DON'T LOSE IT
4616 1595 : FC AA 15                 call    m,QINTA         ;[M80] SUBTRACT 1 FROM LO IF NUMBER IS NEGATIVE
4617 1598 : 3E 98                    ld      a,$98           ;[M80] SEE HOW MANY WE HAVE TO SHIFT TO CHANGE
4618 159A : 90                       sub     b               ;[M80]  NUMBER TO AN INTEGER
4619 159B : CD 30 13                 call    SHIFTR          ;[M80] SHIFT NUMBER TO GET RID OF FRACTIONAL BITS
4620 159E : 7C                       ld      a,h             ;[M80] GET SIGN
4621 159F : 17                       rla                     ;[M80] PUT SIGN IN CARRY SO IT WILL NOT BE CHANGED
4622 15A0 : DC 03 13                 call    c,ROUNDA        ;[M80] IF NUMBER WAS NEGATIVE, ADD ONE
4623 15A3 : 06 00                    ld      b,0             ;[M80] FORGET THE BITS WE SHIFTED OUT
4624 15A5 : DC 1C 13                 call    c,NEGR          ;[M80] NEGATE NUMBER IF IT WAS NEGATIVE
4625 15A8 : E1                       pop     hl              ;[M80] GET OLD (HL) BACK
4626 15A9 : C9                       ret                     ;[M80] ALL DONE
4627 ;;;The last comment seems to be directed to Bill Gates, most likely from Monte Davidoff,
4628 ;;;who wrote the floating point math routines for Altair Basic.
4629 15AA : 1B         [M80] QINTA:  dec     de              ;[M80] SUBTRACT ONE FROM C,D,E
4630 15AB : 7A                       ld      a,d             ;[M80] WE HAVE TO SUBTRACT ONE FROM C IF
4631 15AC : A3                       and     e               ;[M80]  D AND E ARE BOTH ALL ONES
4632 15AD : 3C                       inc     a               ;[M80] SEE IF BOTH WERE -1
4633 15AE : C0                       ret     nz              ;[M80] THEY WERE NOT, WE ARE DONE
4634 15AF : 0B                       dec     bc              ;[M80] THIS IS FOR BILL.  C WILL NEVER BE ZERO
4635 15B0 : C9                       ret                     ;[M80]  (THE MSB WILL ALWAYS BE ONE) SO "DCX    B"
4636 15B1                                                    ;[M80] z AND "DCR       C" ARE FUNCTIONALLY EQUIVALENT
4637 15B1                    ;[M80] GREATEST INTEGER FUNCTION
4638 15B1 : 21 E7 38   [M80] INT:    ld      hl,FAC          ;[M80] GET EXPONENT
4639 15B4 : 7E                       ld      a,(hl)
4640 15B5 : FE 98                    cp      $98             ;[M80] SEE IF NUMBER HAS ANY FRACTIONAL BITS
4641 15B7 : 3A E4 38                 ld      a,(FACLO)       ;[M80] THE ONLY GUY WHO NEEDS THIS DOESN'T CARE ABOUT THE SIGN
4642 15BA : D0                       ret     nc              ;[M80] IT DOES NOT
4643 15BB : 7E                       ld      a,(hl)          ;[M80] GET EXPONENT BACK
4644 15BC : CD 86 15                 call    QINT            ;[M80] IT DOES, SHIFT THEM OUT
4645 15BF : 36 98                    ld      (hl),$98        ;[M80] CHANGE EXPONENT SO IT WILL BE CORRECT
4646 15C1 : 7B                       ld      a,e             ;[M80] GET LO
4647 15C2 : F5                       push    af              ;[M80] SAVE IT
4648 15C3 : 79                       ld      a,c             ;[M80] NEGATE NUMBER IF IT IS NEGATIVE
4649 15C4 : 17                       rla                     ;[M80] PUT SIGN IN CARRY
4650 15C5 : CD AD 12                 call    FADFLT          ;[M80] REFLOAT NUMBER
4651 15C8 : F1                       pop     af              ;[M80] GET LO BACK
4652 15C9 : C9                       ret                     ;[M80] ALL DONE
4653 15CA
4654 15CA                  # ;[M80] INTEGER ARITHMETIC ROUTINES
4655 15CA
4656 15CA                  + ;[M80] INTEGER MULTIPLY FOR MULTIPLY DIMENSIONED ARRAYS
4657 15CA                  | ;[M80]  (DE):=(BC)*(DE)
4658 15CA                  | ;[M80] OVERFLOW CAUSES A BS ERROR
4659 15CA                  | ;[M80] ALTERS A,B,C,D,E
4660 15CA : 21 00 00   [M80] UMULT:  ld      hl,0            ;[M80] ZERO PRODUCT REGISTERS
4661 15CD : 78                       ld      a,b             ;[M80] CHECK IF (BC) IS ZERO
4662 15CE : B1                       or      c               ;[M80] IF SO, JUST RETURN, (HL) IS ALREADY ZERO
4663 15CF : C8                       ret     z               ;[M80] THIS IS DONE FOR SPEED
4664 15D0 : 3E 10                    ld      a,16            ;[M80] THIS IS DONE FOR SPEED
4665 15D2 : 29         (M80) UMULT1: add     hl,hl           ;[M80] ROTATE (HL) LEFT ONE
4666 15D3 : DA CD 11                 jp      c,BSERR         ;{M80} IF OVERFLOW, BAD SUBSCRIPT ERROR
4667 15D6 : EB                       ex      de,hl
4668 15D7 : 29                       add     hl,hl           ;[M80] ROTATE (DE) LEFT ONE
4669 15D8 : EB                       ex      de,hl
4670 15D9 : D2 E0 15                 jp      nc,UMULT2       ;[M80] ADD IN (BC) IF HO WAS 1
4671 15DC : 09                       add     hl,bc
4672 15DD : DA CD 11                 jp      c,BSERR
4673 15E0 : 3D         (M80) UMULT2: dec     a               ;[M80] CHECK FOR OVERFLOW
4674 15E1 : C2 D2 15                 jp      nz,UMULT1       ;[M80] SEE IF DONE
4675 15E4 : C9                       ret
4676 15E5
4677 15E5                  + ;[M80] FLOATING POINT INPUT ROUTINE
4678 15E5                  | ;[M80] ALTERS ALL REGISTERS
4679 15E5                  | ;[M80] THE NUMBER IS LEFT IN FAC
4680 15E5                  | ;[M80] AT ENTRY, (HL) POINTS TO THE FIRST CHARACTER IN A TEXT BUFFER.
4681 15E5                  | ;[M80] THE FIRST CHARACTER IS ALSO IN A.  WE PACK THE DIGITS INTO THE FAC
4682 15E5                  | ;[M80] AS AN INTEGER AND KEEP TRACK OF WHERE THE DECIMAL POINT IS.
4683 15E5                  | ;[M80] C IS 377 IF WE HAVE NOT SEEN A DECIMAL POINT, 0 IF WE HAVE.
4684 15E5                  | ;[M80] B IS THE NUMBER OF DIGITS AFTER THE DECIMAL POINT.
4685 15E5                  | ;[M80] AT THE END, B AND THE EXPONENT (IN E) ARE USED TO DETERMINE HOW MANY
4686 15E5                  | ;[M80] TIMES WE MULTIPLY OR DIVIDE BY TEN TO GET THE CORRECT NUMBER.
4687 15E5 : FE 2D      [M80] FIN:    cp      '-'             ;[M80] SEE IF NUMBER IS NEGATIVE
4688 15E7 : F5                       push    af              ;[M80] SAVE SIGN
4689 15E8 : 28 05                    jr      z,FIN1
4690 15EA : FE 2B                    cp      '+'             ;[M80] IGNORE MINUS SIGN
4691 15EC : 28 01                    jr      z,FIN1          ;[M80] IGNORE A LEADING SIGN
4692 15EE : 2B                       dec     hl              ;[M80] SET CHARACTER POINTER BACK ONE
4693 15EF : CD C3 12   (M80) FIN1:   call    ZERO            ;{M80} GO ZERO THE FAC
4694 15F2 : 47                       ld      b,a
4695 15F3 : 57                       ld      d,a             ;;[D,E] = $0000
4696 15F4 : 5F                       ld      e,a
4697 15F5 : 2F                       cpl
4698 15F6 : 4F                       ld      c,a             ;;[B,C] = $00FF
4699 15F7                  - ;[M80] HERE TO CHECK FOR A DIGIT, A DECIMAL POINT, "E" OR "D"
4700 15F7 : D7         [M80] FINC:   rst     CHRGET          ;[M80] GET THE NEXT CHARACTER OF THE NUMBER
4701 15F8 : DA 3F 16                 jp      c,FINDIG        ;[M80] WE HAVE A DIGIT
4702 15FB : FE 2E                    cp      '.'             ;[M80] CHECK FOR A DECIMAL POINT
4703 15FD : CA 1A 16                 jp      z,FINDP         ;[M80] WE HAVE ONE, I GUESS
4704 1600 : FE 65                    cp      'e'
4705 1602 : CA 0A 16                 jp      z,FINC1
4706 1605 : FE 45                    cp      'E'             ;[M80] CHECK FOR A SINGLE PRECISION EXPONENT
4707 1607 : C2 1E 16                 jp      nz,FINE
4708 160A : D7         (M80) FINC1:  rst     CHRGET
4709 160B : CD 98 0A                 call    MINPLS
4710 160E : D7         (M80) FINEC:  rst     CHRGET          ;[M80] GET THE NEXT CHARATER
4711 160F : DA 61 16                 jp      c,FINEDG        ;[M80] PACK THE NEXT DIGIT INTO THE EXPONENT
4712 1612 : 14                       inc     d               ;[M80] IT WAS NOT A DIGIT, PUT THE CORRECT SIGN ON
4713 1613 : C2 1E 16                 jp      nz,FINE         ;[M80]  THE EXPONENT, IT IS POSITIVE
4714 1616 : AF                       xor     a               ;[M80] THE EXPONENT IS NEGATIVE
4715 1617 : 93                       sub     e               ;[M80] NEGATE IT
4716 1618 : 5F                       ld      e,a             ;[M80] SAVE IT AGAIN
4717 1619 : 0C                       inc     c
4718 161A                    ;[M80] HERE TO SET THE DECIMAL POINT FLAG
4719 161A : 0C         (M80) FINDP:  inc     c               ;[M80] SET THE FLAG
4720 161B : CA F7 15                 jp      z,FINC          ;[M80] CONTINUE LOOKING FOR DIGITS
4721 161E                    ;[M80] HERE TO FINISH UP THE NUMBER
4722 161E : E5         (M80) FINE:   push    hl              ;[M80] SAVE THE TEXT POINTER
4723 161F : 7B                       ld      a,e             ;[M80] FIND OUT HOW MANY TIMES WE HAVE TO MULTIPLY
4724 1620 : 90                       sub     b               ;[M80]  OR DIVIDE BY TEN
4725 1621                    ;[M80] HERE TO MULTIPLY OR DIVIDE BY TEN THE CORRECT NUMBER OF TIMES
4726 1621 : F4 37 16   [M80] FINE2:  call    p,FINMUL        ;[M80] MULTIPLY IF WE HAVE TO
4727 1624 : F2 2D 16                 jp      p,FINE3
4728 1627 : F5                       push    af
4729 1628 : CD 21 14                 call    DIV10           ;[M80] DIVIDE IF WE HAVE TO
4730 162B : F1                       pop     af              ;[M80] GET THE SIGN
4731 162C : 3C                       inc     a
4732 162D : C2 21 16   (~~~) FINE3:  jp      nz,FINE2        ;[M80] MULTIPLY OR DIVIDE AGAIN IF WE ARE NOT DONE
4733 1630                    ;[M80] HERE TO PUT THE CORRECT SIGN ON THE NUMBER
4734 1630 : D1                       pop     de              ;[M80] GET THE TEXT POINTER
4735 1631 : F1                       pop     af              ;[M80] GET THE SIGN
4736 1632 : CC 0B 15                 call    z,NEG           ;[M80] NEGATE IF NECESSARY
4737 1635 : EB                       ex      de,hl           ;[M80] GET THE TEXT POINTER IN (HL)
4738 1636 : C9                       ret
4739 1637
4740 1637                  + ;[M80] THIS SUBROUTINE MULIPLIES BY TEN ONCE.
4741 1637                  | ;[M80] IT IS A SUBROUTINE BECAUSE IT SAVES BYTES WHEN WE CHECK IF A IS ZERO
4742 1637                  | ;[M80] ALTERS ALL REGISTERS
4743 1637 : C8         [M80] FINMUL: ret     z               ;[M80] RETURN IF EXPONENT IS ZERO, ENTRY FROM FOUT
4744 1638 : F5         [M80] FINMLT: push    af
4745 1639 : CD D4 14                 call    MUL10           ;[M80] MULTIPLY BY 10.0
4746 163C : F1                       pop     af
4747 163D : 3D         {M80} DCRART: dec     a               ;[M80] DECREASE IT
4748 163E : C9                       ret                     ;[M80] ALL DONE
4749 163F
4750 163F                    ;[M80] HERE TO PACK THE NEXT DIGIT OF THE NUMBER INTO THE FAC
4751 163F                    ;[M80] WE MULTIPLY THE FAC BY TEN AND ADD IN THE NEXT DIGIT
4752 163F : D5         [M80] FINDIG: push    de              ;[M80] SAVE EXPONENT INFORMATION
4753 1640 : 57                       ld      d,a             ;[M80] INCREMENT DECIMAL PLACE COUNT IF WE ARE
4754 1641 : 78                       ld      a,b             ;[M80]  PAST THE DECIMAL POINT
4755 1642 : 89                       adc     a,c             ;
4756 1643 : 47                       ld      b,a             ;
4757 1644 : C5                       push    bc              ;[M80] SAVE DECIMAL POINT INFORMATION
4758 1645 : E5                       push    hl              ;[M80] SAVE TEXT POINTER
4759 1646 : D5                       push    de              ;
4760 1647 : CD D4 14                 call    MUL10           ;
4761 164A : F1                       pop     af              ;[M80] GET THE DIGIT
4762 164B : D6 30                    sub     '0'             ;[M80] CONVERT IT TO ASCII
4763 164D : CD 56 16                 call    FINLOG          ;[M65] ADD IT IN
4764 1650 : E1                       pop     hl              ;
4765 1651 : C1                       pop     bc              ;
4766 1652 : D1                       pop     de              ;
4767 1653 : C3 F7 15                 jp      FINC            ;
4768 1656
4769 1656 : CD 13 15   [M65] FINLOG: call    PUSHF           ;[M65] SAVE FAC FOR LATER
4770 1659 : CD F6 14                 call    FLOAT           ;[M65] FLOAT THE VALUE IN ACCA
4771 165C : C1         [M80] FADDT:  pop     bc              ;[M80] GET ARG IN REGISTERS, ENTRY TO FADD IF
4772 165D : D1                       pop     de              ;[M80]  ARGUMENT IS ON STACK.  JUMP TO FADD
4773 165E : C3 61 12                 jp      FADD            ;[M80] ADD IT IN
4774 1661
4775 1661 : 7B         [M80] FINEDG: ld      a,e             ;EXPONENT DIGIT -- MULTIPLY EXPONENT BY 10
4776 1662 : 07                       rlca                    ;FIRST BY 4
4777 1663 : 07                       rlca
4778 1664 : 83                       add     a,e             ;ADD 1 TO MAKE 5
4779 1665 : 07                       rlca                    ;NOW DOUBLE TO GET 10
4780 1666 : 86                       add     a,(hl)          ;ADD IT IN
4781 1667 : D6 30                    sub     '0'             ;SUBTRACT OFF ASCII CODE
4782 1669 : 5F                       ld      e,a             ;STORE EXPONENT
4783 166A : C3 0E 16                 jp      FINEC
4784 166D
4785 166D                    ;[M80] FLOATING POINT OUTPUT ROUTINE
4786 166D : E5         [M80] INPRT:  push    hl              ;[M80] ENTRY TO LINPRT
4787 166E : 21 69 03                 ld      hl,INTXT        ;[M80] SAVE LINE NUMBER
4788 1671 : CD 9D 0E                 call    STROUT          ;[M80] PRINT MESSAGE
4789 1674 : E1                       pop     hl
4790 1675
4791 1675                  + ;[M80] PRINT THE 2 BYTE NUMBER IN H,L
4792 1675                  | ;[M80] ALTERS ALL REGISTERS
4793 1675 : 11 9C 0E   [M80] LINPRT: ld      de,STROUI
4794 1678 : D5                       push    de
4795 1679 : EB                       ex      de,hl
4796 167A : AF                       xor     a
4797 167B : 06 98                    ld      b,$98
4798 167D : CD FB 14                 call    FLOATR
4799 1680
4800 1680                  + ;[M80] FLOATING OUTPUT OF FAC
4801 1680                  | ;[M80] ALTERS ALL REGISTERS
4802 1680                  | ;[M80] THE ORIGINAL CONTENTS OF THE FAC IS LOST
4803 1680                  | ;[M80]
4804 1680                  | ;[M80]        OUTPUT THE VALUE IN THE FAC ACCORDING TO THE FORMAT SPECIFICATIONS
4805 1680                  | ;[M80]        IN A,B,C
4806 1680                  | ;[M80]        ALL REGISTERS ARE ALTERED
4807 1680                  | ;[M80]        THE ORIGINAL CONTENTS OF THE FAC IS LOST
4808 1680                  | ;[M80]
4809 1680                  | ;[M80]        THE FORMAT IS SPECIFIED IN A, B AND C AS FOLLOWS:
4810 1680                  | ;[M80]        THE BITS OF A MEAN THE FOLLOWING:
4811 1680                  | ;[M80] BIT 7  0 MEANS FREE FORMAT OUTPUT, I.E. THE OTHER BITS OF A MUST BE ZERO,
4812 1680                  | ;[M80]        TRAILING ZEROS ARE SUPPRESSED, A NUMBER IS PRINTED IN FIXED OR FLOATING
4813 1680                  | ;[M80]        POINT NOTATION ACCORDING TO ITS MAGNITUDE, THE NUMBER IS LEFT
4814 1680                  | ;[M80]        JUSTIFIED IN ITS FIELD, B AND C ARE IGNORED.
4815 1680                  | ;[M80]        1 MEANS FIXED FORMAT OUTPUT, I.E. THE OTHER BITS OF A ARE CHECKED FOR
4816 1680                  | ;[M80]        FORMATTING INFORMATION, THE NUMBER IS RIGHT JUSTIFIED IN ITS FIELD,
4817 1680                  | ;[M80]        TRAILING ZEROS ARE NOT SUPPRESSED.  THIS IS USED FOR PRINT USING.
4818 1680                  | ;[M80] BIT 6  1 MEANS GROUP THE DIGITS IN THE INTEGER PART OF THE NUMBER INTO GROUPS
4819 1680                  | ;[M80]        OF THREE AND SEPARATE THE GROUPS BY COMMAS
4820 1680                  | ;[M80]        0 MEANS DON'T PRINT THE NUMBER WITH COMMAS
4821 1680                  | ;[M80] BIT 5  1 MEANS FILL THE LEADING SPACES IN THE FIELD WITH ASTERISKS ("*")
4822 1680                  | ;[M80] BIT 4  1 MEANS OUTPUT THE NUMBER WITH A FLOATING DOLLAR SIGN ("$")
4823 1680                  | ;[M80] BIT 3  1 MEANS PRINT THE SIGN OF A POSITIVE NUMBER AS A PLUS SIGN ("+")
4824 1680                  | ;[M80]        INSTEAD OF A SPACE
4825 1680                  | ;[M80] BIT 2  1 MEANS PRINT THE SIGN OF THE NUMBER AFTER THE NUMBER
4826 1680                  | ;[M80] BIT 1  UNUSED
4827 1680                  | ;[M80] BIT 0  1 MEANS PRINT THE NUMBER IN FLOATING POINT NOTATION I.E. "E NOTATION"
4828 1680                  | ;[M80]        IF THIS BIT IS ON, THE COMMA SPECIFICATION (BIT 6) IS IGNORED.
4829 1680                  | ;[M80]        0 MEANS PRINT THE NUMBER IN FIXED POINT NOTATION.  NUMBERS .GE. 1E16
4830 1680                  | ;[M80]        CANNOT BE PRINTED IN FIXED POINT NOTATION.
4831 1680                  | ;[M80]
4832 1680                  | ;[M80]        B AND C TELL HOW BIG THE FIELD IS:
4833 1680                  | ;[M80] B   =  THE NUMBER OF PLACES IN THE FIELD TO THE LEFT OF THE DECIMAL POINT
4834 1680                  | ;[M80]        (B DOES NOT INCLUDE THE DECIMAL POINT)
4835 1680                  | ;[M80] C   =  THE NUMBER OF PLACES IN THE FIELD TO THE RIGHT OF THE DECIMAL POINT
4836 1680                  | ;[M80]        (C INCLUDES THE DECIMAL POINT)
4837 1680                  | ;[M80]        B AND C DO NOT INCLUDE THE 4 POSITIONS FOR THE EXPONENT IF BIT 0 IS ON
4838 1680                  | ;[M80]        FOUT ASSUMES B+C .LE. 24 (DECIMAL)
4839 1680                  | ;[M80]        IF THE NUMBER IS TOO BIG TO FIT IN THE FIELD, A PERCENT SIGN ("%") IS
4840 1680                  | ;[M80]        PRINTED AND THE FIELD IS EXTENDED TO HOLD THE NUMBER.
4841 1680                  | ;
4842 1680 : 21 E9 38   [M80] FOUT:   ld      hl,FBUFFR+1     ;[M80] GET A POINTER INTO FBUFFR
4843 1683 : E5                       push    hl              ;{M80} SAVE IT
4844 1684 : EF                       rst     FSIGN
4845 1685 : 36 20                    ld      (hl),' '        ;[M80] PUT A SPACE FOR POSITIVE NUMBERS IN THE BUFFER
4846 1687 : F2 8C 16                 jp      p,FOUT2         ;[M80] IF WE HAVE A NEGATIVE NUMBER, NEGATE IT
4847 168A : 36 2D                    ld      (hl),'-'        ;[M80]  AND PUT A MINUS SIGN IN THE BUFFER
4848 168C : 23               FOUT2:  inc     hl              ;[M80] POINT TO WHERE THE NEXT CHARACTER GOES
4849 168D : 36 30                    ld      (hl),'0'        ;[M80] PUT A ZERO IN THE BUFFER IN CASE THE NUMBER IS ZERO
4850 168F : CA 42 17                 jp      z,FOUTZR        ;[M80] IF THE NUMBER IS ZERO, FINISH IT UP
4851 1692 : E5                       push    hl              ;[M80] SAVE THE BUFFER POINTER
4852 1693 : FC 0B 15                 call    m,NEG           ;[M80] NEGATE THE NUMBER
4853 1696 : AF                       xor     a               ;[M80] ZERO THE EXPONENT
4854 1697 : F5                       push    af              ;[M80] SAVE IT
4855 1698 : CD 48 17                 call    FOUNVC          ;[M80] IS THE FAC TOO BIG OR TOO SMALL?
4856 169B : 01 43 91   [M80] FOUNV1: ld      bc,$9143        ;
4857 169E : 11 F8 4F                 ld      de,$4FF8        ;[M80] GET 99999.95 TO SEE IF THE FAC IS BIG
4858 16A1 : CD 5B 15                 call    FCOMP           ;[M80]  ENOUGH YET
4859 16A4 : B7                       or      a               ;[M80] GO DO THE CHECK
4860 16A5 : E2 B9 16   {M80} FOUNV5: jp      po,FOUTCS       ;[M80] IT ISN'T ANY MORE, WE ARE DONE
4861 16A8 : F1                       pop     af              ;[M80] IT IS, MULTIPLY BY TEN
4862 16A9 : CD 38 16                 call    FINMLT          ;
4863 16AC : F5                       push    af              ;[M80] SAVE THE EXPONENT AGAIN
4864 16AD : C3 9B 16                 jp      FOUNV1          ;[M80] NOW SEE IF IT IS BIG ENOUGH
4865 16B0 : CD 21 14   (M80) FOUNV2: call    DIV10           ;[M80] THE FAC IS TOO BIG, DIVIDE IT BY TEN
4866 16B3 : F1                       pop     af              ;
4867 16B4 : 3C                       inc     a               ;
4868 16B5 : F5                       push    af              ;
4869 16B6 : CD 48 17                 call    FOUNVC          ;[M80] SEE IF THE FAC IS SMALL ENOUGH
4870 16B9 : CD 50 12   (M80) FOUTCS: call    FADDH           ;[M80] ROUND NUMBER TO NEAREST INTEGER
4871 16BC : 3C                       inc     a               ;[M80] MAKE A NON-ZERO, SINCE NUMBER IS POSITIVE AND NON-ZERO
4872 16BD : CD 86 15                 call    QINT            ;[M80] GET INTEGER PART IN C,D,E
4873 16C0 : CD 23 15                 call    MOVFR           ;[M80] SAVE NUMBER IN FAC
4874 16C3 : 01 06 03                 ld      bc,$0306        ;;[B] = 3, [C] = 6
4875 16C6 : F1                       pop     af              ;
4876 16C7 : 81                       add     a,c             ;
4877 16C8 : 3C                       inc     a               ;
4878 16C9 : FA D5 16                 jp      m,FOUCDC        ;
4879 16CC : FE 08                    cp      8               ;
4880 16CE : D2 D5 16                 jp      nc,FOUCDC       ;
4881 16D1 : 3C                       inc     a               ;
4882 16D2 : 47                       ld      b,a             ;
4883 16D3 : 3E 02                    ld      a,2             ;
4884 16D5 : 3D         (M80) FOUCDC: dec     a               ;
4885 16D6 : 3D                       dec     a               ;
4886 16D7 : E1                       pop     hl              ;[M80] GET THE BUFFER POINTER BACK
4887 16D8 : F5                       push    af              ;
4888 16D9 : 11 5E 17                 ld      de,FOSTBL       ;
4889 16DC : 05         {M80} FOUTAN: dec     b               ;
4890 16DD : C2 E6 16                 jp      nz,FOUTED       ;
4891 16E0 : 36 2E                    ld      (hl),'.'        ;[M80] PUT IN D.P.
4892 16E2 : 23                       inc     hl              ;[M80] POINT TO NEXT BUFFER POSTION
4893 16E3 : 36 30                    ld      (hl),'0'        ;
4894 16E5 : 23                       inc     hl              ;
4895 16E6 : 05         (M80) FOUTED: dec     b               ;[M80] ENTRY TO PUT A DECIMAL POINT IN THE BUFFER
4896 16E7 : 36 2E      {M80} FOUTDP: ld      (hl),'.'        ;{M80} PUT THE DECIMAL POINT IN
4897 16E9 : CC 38 15                 call    z,INXHRT        ;
4898 16EC : C5         {M80} FOUTCV: push    bc              ;[M80[ SAVE THE DECIMAL POINT AND COMMA COUNTS
4899 16ED : E5                       push    hl              ;[M80[ SAVE THE BUFFER POINTER
4900 16EE : D5                       push    de              ;[M80[ SAVE (DE)
4901 16EF : CD 2E 15                 call    MOVRF           ;{M80} GET NUMBER IN THE REGISTERS
4902 16F2 : E1                       pop     hl              ;[M80] GET THE BUFFER POINTER BACK
4903 16F3 : 06 2F      {M80} FOUCD1: ld      b,'0'-1         ;[M80] SET UP THE COUNT FOR THE DIGIT
4904 16F5 : 04         (M80) FOUCD2: inc     b               ;[M80] INCREMENT THE DIGIT COUNT
4905 16F6 : 7B                       ld      a,e             ;{M80} SUBTRACT THE TWO NUMBERS
4906 16F7 : 96                       sub     (hl)            ;;Subtract LO
4907 16F8 : 5F                       ld      e,a             ;
4908 16F9 : 23                       inc     hl              ;
4909 16FA : 7A                       ld      a,d             ;
4910 16FB : 9E                       sbc     a,(hl)          ;;Subtract MO
4911 16FC : 57                       ld      d,a             ;
4912 16FD : 23                       inc     hl              ;
4913 16FE : 79                       ld      a,c             ;
4914 16FF : 9E                       sbc     a,(hl)          ;;Subtract HO
4915 1700 : 4F                       ld      c,a             ;
4916 1701 : 2B                       dec     hl              ;
4917 1702 : 2B                       dec     hl              ;;Backup Pointer
4918 1703 : D2 F5 16                 jp      nc,FOUCD2       ;[M80] IF NOT LESS THAN THE POWER OF TEN, SUBTRACT AGAIN
4919 1706 : CD 10 13                 call    FADDA           ;[M80] ADD THE TWO NUMBERS
4920 1709 : 23                       inc     hl
4921 170A : CD 23 15                 call    MOVFR           ;{M80} PUT REGISTERS IN THE FAC
4922 170D : EB                       ex      de,hl           ;[M80] PUT THE POWER OF TEN POINTER IN (DE).
4923 170E : E1                       pop     hl              ;[M80] GET THE BUFFER POINTER BACK
4924 170F : 70                       ld      (hl),b          ;[M80] PUT THE DIGIT INTO THE BUFFER
4925 1710 : 23                       inc     hl              ;[M80] INCREMENT THE BUFFER POINTER
4926 1711 : C1                       pop     bc              ;[M80] GET THE DECIMAL POINT AND COMMA COUNTS
4927 1712 : 0D                       dec     c               ;[M80] HAVE WE PRINTED THE LAST DIGIT?
4928 1713 : C2 E6 16                 jp      nz,FOUTED       ;[M80] NO, GO DO THE NEXT ONE
4929 1716 : 05                       dec     b               ;
4930 1717 : CA 26 17                 jp      z,FOFLDN        ;
4931 171A : 2B         (M80) FOFRS2: dec     hl              ;[M80] MOVE BACK TO THE LAST CHARACTER
4932 171B : 7E                       ld      a,(hl)          ;[M80] GET IT AND SEE IF IT WAS ZERO
4933 171C : FE 30                    cp      '0'             ;
4934 171E : CA 1A 17                 jp      z,FOFRS2        ;[M80] IT WAS, CONTINUE SUPPRESSING
4935 1721 : FE 2E                    cp      '.'             ;[M80] HAVE WE SUPPRESSED ALL THE FRACTIONAL DIGITS?
4936 1723 : C4 38 15                 call    nz,INXHRT       ;[M80] YES, IGNORE THE DECIMAL POINT ALSO
4937 1726 : F1         (M80) FOFLDN: pop     af              ;[M80] GET THE EXPONENT BACK
4938 1727 : CA 45 17                 jp      z,FOUTDN        ;[M80] WE ARE DONE IF WE ARE IN FIXED POINT NOTATION
4939 172A : 36 45                    ld      (hl),'E'        ;
4940 172C : 23                       inc     hl              ;
4941 172D : 36 2B                    ld      (hl),'+'        ;[M80] A PLUS IF POSITIVE
4942 172F : F2 36 17                 jp      p,FOUCE1        ;
4943 1732 : 36 2D                    ld      (hl),'-'        ;[M80] A MINUS IF NEGATIVE
4944 1734 : 2F                       cpl                     ;[M80] NEGATE EXPONENT
4945 1735 : 3C                       inc     a               ;
4946 1736                    ;[M80] CALCULATE THE TWO DIGIT EXPONENT
4947 1736 : 06 2F      (M80) FOUCE1: ld      b,'0'-1         ;[M80] INITIALIZE TEN'S DIGIT COUNT
4948 1738 : 04         (M80) FOUCE2: inc     b               ;[M80] INCREMENT DIGIT
4949 1739 : D6 0A                    sub     10              ;[M80] SUBTRACT TEN
4950 173B : D2 38 17                 jp      nc,FOUCE2       ;[M80] DO IT AGAIN IF RESULT WAS POSITIVE
4951 173E : C6 3A                    add     a,'0'+10        ;[M80] ADD BACK IN TEN AND CONVERT TO ASCII
4952 1740 : 23                       inc     hl              ;[M80] PUT THE EXPONENT IN THE BUFFER
4953 1741 : 70                       ld      (hl),b          ;[M80] PUT TEN'S DIGIT OF EXPONENT IN BUFFER
4954 1742 : 23         (M80) FOUTZR: inc     hl              ;[M80] WHEN WE JUMP TO HERE, A IS ZERO
4955 1743 : 77                       ld      (hl),a          ;[M80] PUT ONE'S DIGIT IN BUFFER
4956 1744 : 23                       inc     hl              ;[M80] INCREMENT POINTER
4957 1745                    ;HERE TO FINISH UP PRINTING A FREE FORMAT ZERO
4958 1745 : 71         (M80) FOUTDN: ld      (hl),c          ;[M80] PUT A ZERO AT THE END OF THE NUMBER
4959 1746 : E1                       pop     hl              ;
4960 1747 : C9                       ret                     ;
4961 1748
4962 1748 : 01 74 94   [M80] FOUNVC: ld      bc,$9474        ;
4963 174B : 11 F7 23                 ld      de,$23F7        ;[M80] GET 999999.5 TO SEE IF THE FAC IS TOO BIG
4964 174E : CD 5B 15                 call    FCOMP           ;
4965 1751 : B7                       or      a               ;
4966 1752 : E1         {M80} FONVC2: pop     hl              ;
4967 1753 : E2 B0 16                 jp      po,FOUNV2       ;[M80] GO DO THE CHECK
4968 1756 : E9                       jp      (hl)            ;[M80] IT ISN'T TOO BIG, JUST RETURN
4969 1757
4970 1757 : 00 00 00 80      FHALF:  byte    $00,$00,$00,$80 ;[M65] 1/2
4971 175B : 40                       ld      b,b
4972 175C : 42                       ld      b,d
4973 175D : 0F                       rrca
4974 175E
4975 175E                    ;[M80] SINGLE PRECISION POWER OF TEN TABLE
4976 175E : A0 86 01   [M80] FOSTBL: byte    $A0,$86,$01     ;[M80] 1E5
4977 1761 : 10 27 00                 byte    $10,$27,$00     ;[M80] 1E4
4978 1764 : E8 03 00                 byte    $E8,$03,$00     ;[M80] 1000
4979 1767 : 64 00 00                 byte    $64,$00,$00     ;[M80] 100
4980 176A : 0A 00 00                 byte    $0A,$00,$00     ;[M80] 10
4981 176E : 01 00 00                 byte    $01,$00,$00     ;[M80] 1
4982 176E
4983 1770                    ;[M80] SUBROUTINE FOR FPWR, ATN
4984 1770 : 21 0B 15         PSHNEG: ld      hl,NEG          ;[M80] GET THE ADDRESS OF NEG
4985 1773 : E3                       ex      (sp),hl         ;[M80] SWITCH RET ADDR AND ADDR OF NEG
4986 1774 : E9                       jp      (hl)            ;[M80] RETURN, THE ADDRESS OF NEG IS ON THE STACK
4987 1775
4988 1775 :                  ;[M80] SQUARE ROOT FUNCTION: WE USE SQR(X)=X^.5
4989 1775 : CD 13 15   [M80] SQR:    call    PUSHF           ;[M80] SAVE ARG X
4990 1778 : 21 57 17                 ld      hl,FHALF        ;[M80] GET 1/2
4991 177B : CD 20 15                 call    MOVFM           ;[M80] SQR(X)=X^.5
4992 177E
4993 177E : C1         [M80] FPWRT:  pop     bc              ;[M80] GET ARG IN REGISTERS, ENTRY TO FPWR IF
4994 177F : D1                       pop     de              ;[M80]  ARGUMENT IS ON STACK.  FALL INTO FPWR
4995 1780
4996 1780                  + ;[M80] EXPONENTIATION    ---    X^Y
4997 1780                  | ;[M80] N.B.  0^0=1
4998 1780                  | ;[M80] FIRST WE CHECK IF Y=0, IF SO, THE RESULT IS 1.
4999 1780                  | ;[M80] NEXT, WE CHECK IF X=0, IF SO, THE RESULT IS 0.
5000 1780                  | ;[M80] THEN WE CHECK IF X IS POSITIVE, IF NOT, WE CHECK THAT Y IS A
5001 1780                  | ;[M80] NEGATIVE INTEGER, AND WHETHER IT IS EVEN OR ODD.  IF Y IS A NEGATIVE
5002 1780                  | ;[M80] INTEGER, WE NEGATE X.  IF NOT, LOG WILL GIVE AN FC ERROR WHEN WE CALL
5003 1780                  | ;[M80] IT.  IF X IS NEGATIVE AND Y IS ODD, WE PUSH THE ADDRESS OF NEG ON THE
5004 1780                  | ;[M80] STACK SO WE WILL RETURN TO IT AND GET A NEGATIVE RESULT.  TO COMPUTE
5005 1780                  | ;[M80] THE RESULT WE USE X^Y=EXP(Y*LOG(X))
5006 1780 : EF         [M80] FPWR:   rst     FSIGN           ;[M80] SEE IF Y IS ZERO
5007 1781 : 78                       ld      a,b             ;[M80] SEE IF X IS ZERO
5008 1782 : CA CD 17                 jp      z,EXP           ;[M80] IT IS, RESULT IS ONE
5009 1785 : F2 8C 17                 jp      p,POSEXP        ;[M80] POSITIVE EXPONENT
5010 1788 : B7                       or      a               ;[M80] IS IT ZERO TO MINUS POWER?
5011 1789 : CA C7 03                 jp      z,DV0ERR        ;[M80] GIVE DIV BY ZERO AND CONTINUE
5012 178C : B7         [M80] POSEXP: or      a               ;
5013 178D : CA C4 12                 jp      z,ZERO0         ;[M80]IT IS, RESULT IS ZERO
5014 1790 : D5                       push    de              ;[M80] SAVE X ON STACK
5015 1791 : C5                       push    bc              ;
5016 1792 : 79                       ld      a,c             ;[M80] CHECK THE SIGN OF X
5017 1793 : F6 7F                    or      $7F             ;[M80] TURN THE ZERO FLAG OFF
5018 1795 : CD 2E 15                 call    MOVRF           ;[M80] GET Y IN THE REGISTERS
5019 1798 : F2 B5 17                 jp      p,FPWR1         ;[M80] NO PROBLEMS IF X IS POSITIVE
5020 179B : F5                       push    af              ;
5021 179C : 3A E7 38                 ld      a,(FAC)         ;
5022 179F : FE 99                    cp      $99             ;
5023 17A1 : 38 03                    jr      c,FPWRT1        ;
5024 17A3 : F1                       pop     af              ;
5025 17A4 : 18 0F                    jr      FPWR1           ;
5026 17A6 : F1         (M65) FPWRT1: pop     af              ;
5027 17A7 : D5                       push    de              ;
5028 17A8 : C5                       push    bc              ;[M80] SAVE Y
5029 17A9 : CD B1 15                 call    INT             ;[M80] SEE IF Y IS AN INTEGER
5030 17AC : C1                       pop     bc              ;
5031 17AD : D1                       pop     de              ;[M80] GET Y BACK
5032 17AE : F5                       push    af              ;[M80] SAVE LO OF INT FOR EVEN AND ODD INFORMATION
5033 17AF : CD 5B 15                 call    FCOMP           ;[M80] SEE IF WE HAVE AN INTEGER
5034 17B2 : E1                       pop     hl              ;[M80] GET EVEN-ODD INFORMATION
5035 17B3 : 7C                       ld      a,h             ;[M80] PUT EVEN-ODD FLAG IN CARRY
5036 17B4 : 1F                       rra                     ;
5037 17B5 : E1         (M80) FPWR1:  pop     hl              ;[M80] GET X BACK IN FAC
5038 17B6 : 22 E6 38                 ld      (FACHO),hl      ;[M80] STORE HO'S
5039 17B9 : E1                       pop     hl              ;[M80] GET LO'S OFF STACK
5040 17BA : 22 E4 38                 ld      (FACLO),hl      ;[M80] STORE THEM IN FAC
5041 17BD : DC 70 17                 call    c,PSHNEG        ;[M80] NEGATE NUMBER AT END IF Y WAS ODD
5042 17C0 : CC 0B 15                 call    z,NEG           ;[M80] NEGATE THE NEGATIVE NUMBER
5043 17C3 : D5                       push    de              ;[M80] SAVE Y AGAIN
5044 17C4 : C5                       push    bc              ;
5045 17C5 : CD 85 13                 call    LOG             ;[M80] COMPUTE  EXP(Y*LOG(X))
5046 17C8 : C1                       pop     bc              ;
5047 17C9 : D1                       pop     de              ;[M80] IF X WAS NEGATIVE AND Y NOT AN INTEGER THEN
5048 17CA : CD CB 13                 call    FMULT           ;[M80]  LOG WILL BLOW HIM OUT OF THE WATER
5049 17CD
5050 17CD                  + ;[M80] THE FUNCTION EXP(X) CALCULATES e^X WHERE e=2.718282
5051 17CD                  | ;[M80]        THE TECHNIQUE USED IS TO EMPLOY A COUPLE
5052 17CD                  | ;[M80]        OF FUNDAMENTAL IDENTITIES THAT ALLOWS US TO
5053 17CD                  | ;[M80]        USE THE BASE 2 THROUGH THE DIFFICULT PORTIONS OF
5054 17CD                  | ;[M80]        THE CALCULATION:
5055 17CD                  | ;[M80]
5056 17CD                  | ;[M80]          (1)e^X=2^y  WHERE y=X*LOG2(e) [LOG2(e) IS
5057 17CD                  | ;[M80]                                          LOG BASE 2
5058 17CD                  | ;[M80]                                          OF e ]
5059 17CD                  | ;[M80]
5060 17CD                  | ;[M80]          (2) 2^y=2^[ INT(y)+(y-INT(y)]
5061 17CD                  | ;[M80]          (3) IF Ny=INT(y) THEN
5062 17CD                  | ;[M80]              2^(Ny+y-Ny)=[2^Ny]*[2^(y-Ny)]
5063 17CD                  | ;[M80]
5064 17CD                  | ;[M80]        NOW, SINCE 2^Ny IS EASY TO COMPUTE (AN EXPONENT
5065 17CD                  | ;[M80]        CALCULATION WITH MANTISSA BITS OF ZERO) THE DIFFICULT
5066 17CD                  | ;[M80]        PORTION IS TO COMPUTE 2^(Y-Ny) WHERE 0.LE.(Y-Ny).LT.1
5067 17CD                  | ;[M80]        THIS IS ACCOMPLISHED WITH A POLYNOMIAL APPROXIMATION
5068 17CD                  | ;[M80]        TO 2^Z WHERE 0.LE.Z.LT.1  . ONCE THIS IS COMPUTED WE
5069 17CD                  | ;[M80]        HAVE TO EFFECT THE MULTIPLY BY 2^Ny .
5070 17CD : 01 38 81   [M80] EXP:    ld      bc,$8138        ;[M65] LOG(e) BASE 2
5071 17D0 : 11 3B AA                 ld      de,$AA3B        ;[M80] GET LOG2(e)
5072 17D3 : CD CB 13                 call    FMULT           ;[M80] y=FAC*LOG2(e)
5073 17D6 : 3A E7 38                 ld      a,(FAC)         ;[M80] MUST SEE IF TOO LARGE
5074 17D9 : FE 88                    cp      $88             ;[M80] ABS .GT. 128?
5075 17DB : 30 22                    jr      nc,EXP100       ;[M80] IF SO OVERFLOW
5076 17DD : FE 68                    cp      $68             ;[M80] IF TOO SMALL ANSWER IS 1
5077 17DF : 38 30                    jr      c,EXP200        ;
5078 17E1 : CD 13 15                 call    PUSHF           ;[M80] SAVE y
5079 17E4 : CD B1 15                 call    INT             ;[M80] DETERMINE INTEGER POWER OF 2
5080 17E7 : C6 81                    add     a,$81          ;[M80] INTEGER WAS RETURNED IN A, BIAS IS 201
5081 17E9 : C1                       pop     bc              ;
5082 17EA : D1                       pop     de              ;[M80] RECALL y
5083 17EB : 28 15                    jr      z,EXP110        ;[M80] OVERFLOW
5084 17ED : F5                       push    af              ;[M80] SAVE EXPONENT
5085 17EE : CD 5E 12                 call    FSUB            ;[M80] FAC=y-INT(y)
5086 17F1 : 21 1A 18                 ld      hl,EXPBCN       ;[M80] WILL USE HART 1302 POLY. EVAL NOW
5087 17F4 : CD 46 18                 call    POLY            ;[M80] COMPUTE 2^[y-INT(y)]
5088 17F7 : C1                       pop     bc              ;[M80] INTEGER POWER OF 2 EXPONENT
5089 17F8 : 11 00 00                 ld      de,0            ;[M80] NOW HAVE FLOATING REPRESENTATION
5090 17FB : 4A                       ld      c,d             ;[M80] OF INT(y) IN (BCDE)
5091 17FC : C3 CB 13                 jp      FMULT           ;[M80] MULTIPLY BY 2^[y-INT(y)] AND RETURN
5092 17FD
5093 17FF : CD 13 15   (M80) EXP100: call    PUSHF           ;[M80] IF NEG. THEN JUMP TO ZERO
5094 1802 : 3A E6 38   (M80) EXP110: ld      a,(FACHO)       ;
5095 1805 : B7                       or      a               ;[M80] OVERFLOW IF PLUS
5096 1806 : F2 0E 18                 jp      p,EXP115        ;[M80] NEED STACK RIGHT
5097 1809 : F1                       pop     af              ;
5098 180A : F1                       pop     af              ;
5099 180B : C3 C3 12                 jp      ZERO            ;[M80] GO ZERO THE FAC
5100 180E : C3 D3 03   (M80) EXP115: jp      OVERR           ;[M80] OVERFLOW
5101 1811 : 01 00 81   (M80) EXP200: ld      bc,$8100        ;
5102 1814 : 11 00 00                 ld      de,$0000        ;1.
5103 1817 : C3 23 15                 jp      MOVFR           ;
5104 181A
5105 181A              [M80] ;*************************************************************
5106 181A              [M80] ;       Hart 1302 polynomial coefficients
5107 181A              [M80] ;*************************************************************
5108 181A : 07         [M80] EXPBCN  byte    7               ;[M80] DEGREE + 1
5109 181B : 7C 88 59 74              byte    $7C,$88,$59,$74 ;[M80] .00020745577403-
5110 181F : E0 97 26 77              byte    $E0,$97,$26,$77 ;[M80] .00127100574569-
5111 1823 : C4 1D 1E 7A              byte    $C4,$1D,$1E,$7A ;[M80] .00965065093202+
5112 1827 : 5E 50 63 7C              byte    $5E,$50,$63,$7C ;[M80] .05549656508324+
5113 182B : 1A FE 75 7E              byte    $1A,$FE,$75,$7E ;[M80] .24022713817633-
5114 182F : 18 72 31 80              byte    $18,$72,$31,$80 ;[M80] .69314717213716+
5115 1833 : 00 00 00 81              byte    $00,$00,$00,$81 ;[M80] 1.0
5116 1837
5117 1837                 +  ;[M80] POLYNOMIAL EVALUATOR AND THE RANDOM NUMBER GENERATOR
5118 1837                 |  ;[M80] EVALUATE P(X^2)*X
5119 1837                 |  ;[M80] POINTER TO DEGREE+1 IS IN (HL)
5120 1837                 |  ;[M80] THE CONSTANTS FOLLOW THE DEGREE
5121 1837                 |  ;[M80] CONSTANTS SHOULD BE STORED IN REVERSE ORDER, FAC HAS X
5122 1837                 |  ;[M80] WE COMPUTE:
5123 1837                 |  ;[M80]  C0*X+C1*X^3+C2*X^5+C3*X^7+...+C(N)*X^(2*N+1)
5124 1837
5125 1837 : CD 13 15   [M80] POLYX:  call    PUSHF           ;SAVE X
5126 183A : 11 C9 13                 ld      de,013C9H       ;PUT ADDRESS OF FMULTT ON STACK SO WHEN WE
5127 183D : D5                       push    de              ; RETURN WE WILL MULTIPLY BY X
5128 183E : E5         {M80} POLYX2: push    hl              ;SAVE CONSTANT POINTER
5129 183F : CD 2E 15                 call    MOVRF           ;SQUARE X
5130 1842 : CD CB 13                 call    FMULT           ;
5131 1845 : E1                       pop     hl              ;GET CONSTANT POINTER
5132 1846
5133 1846                  + ;[M80] POLYNOMIAL EVALUATOR
5134 1846                  | ;[M80] POINTER TO DEGREE+1 IS IN (HL), IT IS UPDATED
5135 1846                  | ;[M80] THE CONSTANTS FOLLOW THE DEGREE
5136 1846                  | ;[M80] CONSTANTS SHOULD BE STORED IN REVERSE ORDER, FAC HAS X
5137 1846                  | ;[M80] WE COMPUTE:
5138 1846                  | ;[M80]  C0+C1*X+C2*X^2+C3*X^3+...+C(N-1)*X^(N-1)+C(N)*X^N
5139 1846 : CD 13 15   [M80] POLY:   call    PUSHF           ;[M80] SAVE X
5140 1849 : 7E                       ld      a,(hl)          ;[M80] GET DEGREE
5141 184A : 23                       inc     hl              ;[M80] INCREMENT POINTER TO FIRST CONSTANT
5142 184B : CD 20 15                 call    MOVFM           ;[M80] MOVE FIRST CONSTANT TO FAC
5143 184E : 06                       byte    $06             ;[M80] "MVI	B" OVER NEXT BYTE
5144 184F : F1         (M80) POLY1:  pop     af              ;[M80] GET DEGREE
5145 1850 : C1                       pop     bc              ;
5146 1851 : D1                       pop     de              ;[M80] GET X
5147 1852 : 3D                       dec     a               ;[M80] ARE WE DONE?
5148 1853 : C8                       ret     z               ;[M80] YES, RETURN
5149 1854 : D5                       push    de              ;
5150 1855 : C5                       push    bc              ;[M80] NO, SAVE X
5151 1856 : F5                       push    af              ;[M80] SAVE DEGREE
5152 1857 : E5                       push    hl              ;[M80] SAVE CONSTANT POINTER
5153 1858 : CD CB 13                 call    FMULT           ;[M80] EVALUATE THE POLY, MULTIPLY BY X
5154 185B : E1                       pop     hl              ;[M80] GET LOCATION OF CONSTANTS
5155 185C : CD 31 15                 call    MOVRM           ;[M80] GET CONSTANT
5156 185F : E5                       push    hl              ;[M80] STORE LOCATION OF CONSTANTS SO FADD AND FMULT
5157 1860 : CD 61 12                 call    FADD            ;[M80]  WILL NOT SCREW THEM UP, ADD IN CONSTANT
5158 1863 : E1                       pop     hl              ;[M80] MOVE CONSTANT POINTER TO NEXT CONSTANT
5159 1864 : 18 E9                    jr      POLY1           ;[M80] SEE IF DONE
5160 1866
5161 1866                  | ;[M80] PSUEDO-RANDOM NUMBER GENERATOR
5162 1866                  | ;[M80] IF ARG=0, THE LAST RANDOM NUMBER GENERATED IS RETURNED
5163 1866                  | ;[M80] IF ARG .LT. 0, A NEW SEQUENCE OF RANDOM NUMBERS IS STARTED
5164 1866                  | ;[M80]  USING THE ARGUMENT
5165 1866                  | ;[M80] TO FORM THE NEXT RANDOM NUMBER IN THE SEQUENCE, WE MULTIPLY THE
5166 1866                  | ;[M80] PREVIOUS RANDOM NUMBER BY A RANDOM CONSTANT, AND ADD IN ANOTHER
5167 1866                  | ;[M80] RANDOM CONSTANT.  THEN THE HO AND LO BYTES ARE SWITCHED, THE
5168 1866                  | ;[M80] EXPONENT IS PUT WHERE IT WILL BE SHIFTED IN BY NORMAL, AND THE
5169 1866                  | ;[M80] EXPONENT IN THE FAC SET TO 200 SO THE RESULT WILL BE LESS THAN 1.
5170 1866                  | ;[M80] THIS IS THEN NORMALIZED AND SAVED FOR THE NEXT TIME.
5171 1866                  | ;[M80] THE HO AND LO BYTES WERE SWITCHED SO WE HAVE A RANDOM CHANCE OF
5172 1866                  | ;[M80] GETTING A NUMBER LESS THAN OR GREATER THAN .5
5173 1866                  | ;
5174 1866 : EF         [M80] RND:    rst     FSIGN           ;[M80] GET SIGN OF ARG
5175 1867 : 21 20 38                 ld      hl,RNDCNT+1         ;
5176 186A : FA C4 18                 jp      m,RNDSTR        ;[M80] START NEW SEQUENCE IF NEGATIVE
5177 186D : 21 41 38                 ld      hl,RNDX         ;[M80] GET LAST NUMBER GENERATED
5178 1870 : CD 20 15                 call    MOVFM           ;
5179 1873 : 21 20 38                 ld      hl,RNDCNT+1         ;
5180 1876 : C8                       ret     z               ;[M80] RETURN LAST NUMBER GENERATED IF ZERO
5181 1877 : 86                       add     a,(hl)          ;[M80] GET COUNTER INTO CONSTANTS AND ADD ONE
5182 1878 : E6 07                    and     7               ;
5183 187A : 06 00                    ld      b,0             ;
5184 187C : 77                       ld      (hl),a          ;
5185 187D : 23                       inc     hl              ;
5186 187E : 87                       add     a,a             ;
5187 187F : 87                       add     a,a             ;
5188 1880 : 4F                       ld      c,a             ;
5189 1881 : 09                       add     hl,bc           ;
5190 1882 : CD 31 15                 call    MOVRM           ;
5191 1885 : CD CB 13                 call    FMULT           ;
5192 1888 : 3A 1F 38                 ld      a,(RNDCNT)      ;
5193 188B : 3C                       inc     a               ;
5194 188C : E6 03                    and     3               ;
5195 188E : 06 00                    ld      b,0             ;
5196 1890 : FE 01                    cp      1               ;
5197 1892 : 88                       adc     a,b             ;
5198 1893 : 32 1F 38                 ld      (RNDCNT),a      ;
5199 1896 : 21 C7 18                 ld      hl,RNDTB2-4     ;
5200 1899 : 87                       add     a,a             ;
5201 189A : 87                       add     a,a             ;
5202 189B : 4F                       ld      c,a             ;
5203 189C : 09                       add     hl,bc           ;
5204 189D : CD 53 12                 call    FADDS           ;
5205 18A0 : CD 2E 15   [M80] RND1:   call    MOVRF           ;[M80] SWITCH HO AND LO BYTES,
5206 18A3 : 7B                       ld      a,e             ;[M80] GET LO
5207 18A4 : 59                       ld      e,c             ;[M80] PUT HO IN LO BYTE
5208 18A5 : EE 4F                    xor     $4F             ;
5209 18A7 : 4F                       ld      c,a             ;[M80] PUT LO IN HO BYTE
5210 18A8 : 36 80                    ld      (hl),128        ;[M80] MAKE RESULT POSITIVE
5211 18AA : 2B                       dec     hl              ;[M80] GET POINTER TO EXPONENT
5212 18AB : 46                       ld      b,(hl)          ;[M80] PUT EXPONENT IN OVERFLOW POSITION
5213 18AC : 36 80                    ld      (hl),128        ;[M80] SET EXP SO RESULT WILL BE BETWEEN 0 AND 1
5214 18AE : 21 1E 38                 ld      hl,RNDCNT-1     ;
5215 18B1 : 34                       inc     (hl)            ;[M80] INCREMENT THE PERTUBATION COUNT
5216 18B2 : 7E                       ld      a,(hl)          ;[M80] SEE IF ITS TIME
5217 18B3 : D6 AB                    sub     $AB             ;
5218 18B5 : 20 04                    jr      nz,NTPTRB       ;
5219 18B7 : 77                       ld      (hl),a          ;[M80] ZERO THE COUNTER
5220 18B8 : 0C                       inc     c               ;
5221 18B9 : 15                       dec     d               ;
5222 18BA : 1C                       inc     e               ;
5223 18BB : CD B0 12   (M80) NTPTRB: call    NORMAL          ;[M80] NORMALIZE THE RESULT
5224 18BE : 21 41 38                 ld      hl,RNDX         ;[M80] SAVE RANDOM NUMBER GENERATED FOR NEXT
5225 18C1 : C3 3A 15                 jp      MOVMF           ;[M80]  TIME
5226 18C4 : 77         (M80) RNDSTR: ld      (hl),a          ;[M80] ZERO THE COUNTERS
5227 18C5 : 2B                       dec     hl              ;
5228 18C6 : 77                       ld      (hl),a          ;
5229 18C7 : 2B                       dec     hl              ;
5230 18C8 : 77                       ld      (hl),a          ;
5231 18C9 : 18 D5                    jr      RND1            ;
5232 18CB
5233 18CB : 68 B1 46 68[M80] RNDTB2: byte    $68,$B1,$46,$68
5234 18CF : 99 E9 92 69              byte    $99,$E9,$92,$69
5235 18D3 : 10 D1 75 68              byte    $10,$D1,$75,$68
5236 18D7
5237 18D7                  + ;[M80] COSINE FUNCTION
5238 18D7                  | ;[M80] IDEA: USE COS(X)=SIN(X+PI/2)
5239 18D7 : 21 53 19   [M80] COS:    ld      hl,PI2          ;[M80] ADD PI/2 TO FAC
5240 18DA : CD 53 12                 call    FADDS           ;
5241 18DD
5242 18DD                  + ;[M80] SINE FUNCTION
5243 18DD                  | ;[M80] IDEA: USE IDENTITIES TO GET FAC IN QUADRANTS I OR IV
5244 18DD                  | ;[M80] THE FAC IS DIVIDED BY 2*PI AND THE INTEGER PART IS IGNORED BECAUSE
5245 18DD                  | ;[M80] SIN(X+2*PI)=SIN(X).  THEN THE ARGUMENT CAN BE COMPARED WITH PI/2 BY
5246 18DD                  | ;[M80] COMPARING THE RESULT OF THE DIVISION WITH PI/2/(2*PI)=1/4.
5247 18DD                  | ;[M80] IDENTITIES ARE THEN USED TO GET THE RESULT IN QUADRANTS I OR IV.
5248 18DD                  | ;[M80] AN APPROXIMATION POLYNOMIAL IS THEN USED TO COMPUTE SIN(X).
5249 18DD : 3A E7 38   [M80] SIN:    ld      a,(FAC)         ;[M80] WILL SEE IF .LT.2^-10
5250 18E0 : FE 77                    cp      $77             ;[M80] AND IF SO SIN(X)=X
5251 18E2 : D8                       ret     c               ;
5252 18E3 : 3A E6 38                 ld      a,(FACHO)       ;
5253 18E6 : B7                       or      a               ;
5254 18E7 : F2 F3 18                 jp      p,SIN1          ;[M65] FIRST QUADRANT
5255 18EA : E6 7F                    and     07FH            ;
5256 18EC : 32 E6 38                 ld      (FACHO),a       ;
5257 18EF : 11 0B 15                 ld      de,NEG          ;;Return to NEG
5258 18F2 : D5                       push    de              ;
5259 18F3 : 01 22 7E   [M65] SIN1:   ld      bc,$7E22        ;
5260 18F6 : 11 83 F9                 ld      de,$F983        ;[M80] WILL CALCULATE X=FAC/(2*PI)
5261 18F9 : CD CB 13                 call    FMULT           ;
5262 18FC : CD 13 15                 call    PUSHF           ;[M80] SAVE X
5263 18FF : CD B1 15                 call    INT             ;[M80] FAC=INT(X)
5264 1902 : C1                       pop     bc              ;
5265 1903 : D1                       pop     de              ;[M80] FETCH X TO REGISTERS
5266 1904 : CD 5E 12                 call    FSUB            ;[M80] FAC=X-INT(X)
5267 1907 : 01 00 7F                 ld      bc,$7F00        ;
5268 190A : 11 00 00                 ld      de,$0000        ;[M80] GET 1/4
5269 190D : CD 5B 15                 call    FCOMP           ;[M80] FAC=FAC-1/4
5270 1910 : FA 35 19                 jp      m,SIN2A         ;
5271 1913 : 01 80 7F                 ld      bc,$7F80        ;
5272 1916 : 11 00 00                 ld      de,$0000        ;[M80] -1/4
5273 1919 : CD 61 12                 call    FADD            ;
5274 191C : 01 80 80                 ld      bc,$8080        ;[M80] -1/2
5275 191F : 11 00 00                 ld      de,$0000        ;
5276 1922 : CD 61 12                 call    FADD            ;[M80] X=X-1/2
5277 1925 : EF                       rst     FSIGN           ;[M80] MAKE SURE IF QUADRANTS II,IV
5278 1926 : F4 0B 15                 call    p,NEG           ;[M80] WE WORK WITH 1/4-X
5279 1929 : 01 00 7F                 ld      bc,$7F00        ;
5280 192C : 11 00 00                 ld      de,$0000        ;[M80] 1/4
5281 192F : CD 61 12                 call    FADD            ;
5282 1932 : CD 0B 15                 call    NEG             ;
5283 1935 : 3A E6 38   [M80] SIN2A:  ld      a,(FACHO)       ;[M80] MUST REDUCE TO [0,1/4]
5284 1938 : B7                       or      a               ;[M80] SIGN IN PSW
5285 1939 : F5                       push    af              ;[M80] SAVE FOR POSSIBLE NEG. AFTER CALC
5286 193A : F2 42 19                 jp      p,SIN3          ;
5287 193D : EE 80                    xor     $80             ;
5288 193F : 32 E6 38                 ld      (FACHO),a       ;[M80] NOW IN [0,1/4]
5289 1942 : 21 5B 19   [M80] SIN3:   ld      hl,SINCON       ;[M80] POINT TO HART COEFFICIENTS
5290 1945 : CD 37 18                 call    POLYX           ;[M80] DO POLY EVAL
5291 1948 : F1                       pop     af              ;[M80] NOW TO DO SIGN
5292 1949 : F0                       ret     p               ;[M80] OK IF POS
5293 194A : 3A E6 38                 ld      a,(FACHO)       ;[M80] FETCH SIGN BYTE
5294 194D : EE 80                    xor     080H            ;[M80] MAKE NEG
5295 194F : 32 E6 38                 ld      (FACHO),a       ;[M80] REPLACE SIGN
5296 1952 : C9                       ret
5297 1953
5298 1953 : DB 0F 49 81[M80] PI2:    byte    $DB,$0F,$49,$81 ;[M80] PI/2
5299 1957 : 00 00 00 7F{M80} FR4:    byte    $00,$00,$00,$7F ;[M80] 1/4
5300 195B
5301 195B                  + ;[M80] HART ALGORITHM 3341 CONSTANTS
5302 195B                  | ;[M80] NOTE THAT HART CONSTANTS HAVE BEEN SCALED BY A POWER OF 2
5303 195B                  | ;[M80] THIS IS DUE TO RANGE REDUCTION AS A % OF 2*PI RATHER THAN PI/2
5304 195B                  | ;[M80] WOULD NEED TO MULTIPLY ARGUMENT BY 4 BUT INSTEAD WE FACTOR THIS
5305 195B                  | ;[M80] THRU THE CONSTANTS.
5306 195B : 05               SINCON: byte    5               ;[M80] DEGREE
5307 195C : FB D7 1E 86              byte    $FB,$D7,$1E,$86 ;[M80] .1514851E-3
5308 1960 : 65 26 99 87              byte    $65,$26,$99,$87 ;[M80] -.4673767E-2
5309 1964 : 58 34 23 87              byte    $58,$34,$23,$87 ;[M80] .7968968E-1
5310 1968 : E1 5D A5 86              byte    $E1,$5D,$A5,$86 ;[M80] -.6459637
5311 196C : DB 0F 49 83              byte    $DB,$0F,$49,$83 ;[M80] 1.570796
5312 1970
5313 1970                  + ;[M80] TANGENT FUNCTION
5314 1970                  | ;[M80] TAN(X)=SIN(X)/COS(X)
5315 1970 : CD 13 15   [M80] TAN:    call    PUSHF           ;[M80] SAVE ARG
5316 1973 : CD DD 18                 call    SIN             ;[M80]    TAN(X)=SIN(X)/COS(X)
5317 1976 : C1                       pop     bc              ;[M80] GET X OFF STACK
5318 1977 : E1                       pop     hl              ;[M80] PUSHF SMASHES (DE)
5319 1978 : CD 13 15                 call    PUSHF           ;
5320 197B : EB                       ex      de,hl           ;[M80] GET LO'S WHERE THEY BELONG
5321 197C : CD 23 15                 call    MOVFR           ;
5322 197F : CD D7 18                 call    COS             ;
5323 1982 : C3 2D 14                 jp      FDIVT           ;
5324 1985
5325 1985                  + ;ARCTANGENT FUNCTION
5326 1985                  | ;;Not Implemented
5327 1985 : F7         [M80] ATN:    rst     HOOKDO          ;;execute hook routine 15 (ATN)
5328 1986 : 0E         {~~~} HOOK14: byte    14              ;;if not implemented
5329 1988 : C3 C4 03                 jp      SNERR           ;;  generate SYNTAX error
5330 198A
5331 198A                    ;;RST OUTCHR jumps here
5332 198A : F7         [M80] OUTDO:  rst     HOOKDO          ;;execute hook routine 13 (OUTDOX)
5333 198B : 0D         {~~~} HOOK13: byte    13              ;
5334 198C : F5         {M80} OUTCON: push    af              ;
5335 198D : 3A 47 38   {M80} LPTCOD: ld      a,(PRTFLG)      ;[M80] SEE IF WE WANT TO TALK TO LPT
5336 1990 : B7                       or      a               ;[M80] TEST BITS
5337 1991 : CA D6 19                 jp      z,TTYPOP        ;[M80] IF ZERO THEN NOT
5338 1994                    ;;Print character in [A] to printer
5339 1994 : F1                       pop     af              ;
5340 1995 : F5                       push    af              ;
5341 1996 : FE 09                    cp      9               ;[M80] TAB
5342 1998 : 20 0C                    jr      nz,NOTABL       ;[M80] NO
5343 199A                    ;; Print spaces until next Tab Stop is reached
5344 199A : 3E 20      (M80) MORSPL: ld      a,' '           ;[M80] GET SPACE
5345 199C : DF                       rst     OUTCHR          ;[M80] SEND IT
5346 199D : 3A 46 38                 ld      a,(LPTPOS)      ;[M80] GET CURRENT PRINT POSIT
5347 19A0 : E6 07                    and     7               ;[M80] AT TAB STOP?
5348 19A2 : 20 F6                    jr      nz,MORSPL       ;[M80] GO BACK IF MORE TO PRINT
5349 19A4 : F1                       pop     af              ;[M80] POP OFF CHAR
5350 19A5 : C9                       ret                     ;[M80] RETURN
5351 19A6
5352 19A6 : F1         (M80) NOTABL: pop     af              ;[M80] GET CHAR BACK
5353 19A7 : F5                       push    af              ;[M80] SAVE AGAIN
5354 19A8 : D6 0D                    sub     13              ;[M80] IF FUNNY CONTROL CHAR, (LF) DO NOTHING
5355 19AA : 28 0B                    jr      z,ZERLP1        ;
5356 19AC : 38 0C                    jr      c,LPTPOP        ;[M80] JUST PRINT CHAR
5357 19AE : 3A 46 38                 ld      a,(LPTPOS)      ;[M80] GET POSIT
5358 19B1 : 3C                       inc     a               ;
5359 19B2 : FE 84                    cp      132             ;
5360 19B4 : CC C7 19                 call    z,PRINTW        ;
5361 19B7 : 32 46 38   (M80) ZERLP1: ld      (LPTPOS),a      ;;Save print pos
5362 19BA : F1         (~~~) LPTPOP: pop     af              ;;Print character on stack
5363 19BB : C3 E8 1A   (M80) LPTCHR: jp      LPTOUT          ;; Print raw character to printer
5364 
5365 19BE : AF         [M80] FINLPT: xor     a               ;[M80] RESET PRINT FLAG SO
5366 19BF : 32 47 38                 ld      (PRTFLG),a      ;[M80] OUTPUT GOES TO TERMINAL
5367 19C2 : 3A 46 38                 ld      a,(LPTPOS)      ;[M80] GET CURRENT LPT POSIT
5368 19C5 : B7                       or      a               ;[M80] ON LEFT HAND MARGIN ALREADY?
5369 19C6 : C8                       ret     z               ;[M80] YES, RETURN
5370 19C7
5371 19C7 : 3E 0D      (M80) PRINTW: ld      a,13            ;[M80] PUT OUT CRLF
5372 19C9 : CD BB 19                 call    LPTCHR          ;
5373 19CC : 3E 0A                    ld      a,10            ;
5374 19CE : CD BB 19                 call    LPTCHR          ;
5375 19D1 : AF                       xor     a               ;[M80] ZERO LPTPOS
5376 19D2 : 32 46 38                 ld      (LPTPOS),a      ;
5377 19D5 : C9                       ret                     ;[M80] DONE
5378 19D6
5379 19D6 : F1         [M80] TTYPOP: pop     af              ;Print character on stack to screen
5380 19D7 : C3 72 1D                 jp      TTYCHR          ;
5381 19DA
5382 19DA                    ;[M80] INCHR, TRYIN - CHARACTER INPUT ROUTINES
5383 19DA : CD 2F 1A   [M80] INCHR:  call    CQINCH          ;;Get Character from Keyboard
5384 19DD : C9                       ret                     ;
5385 19DE
5386 19DE                  + ; CRDONZ Only does a CR if TTYPOS is not Zero.
5387 19DE                  | ; In other words, only print a carriage return when not at left margin.
5388 19DE : 3A 00 38   [M80] CRDONZ: ld      a,(TTYPOS)      ;GET CURRENT TTYPOS
5389 19E1 : B7                       or      a               ;SET CC'S
5390 19E2 : C8                       ret     z               ;IF ALREADY ZERO, RETURN
5391 19E3 : 18 05                    jr      CRDO            ;DO CR
5392 19E5 : 36 00      [M80] FININL: ld      (hl),0          ;PUT A ZERO AT THE END OF BUF
5393 19E7 : 21 5F 38                 ld      hl,BUFMIN       ;SETUP POINTER
5394 19EA : 3E 0D      [M80] CRDO:   ld      a,13            ;
5395 19EC : DF                       rst     OUTCHR          ;
5396 19ED : 3E 0A                    ld      a,10            ;
5397 19EF : DF         {M80} CRFINO: rst     OUTCHR          ;
5398 19F0 : 3A 47 38   [M80] CRFIN:  ld      a,(PRTFLG)      ;[M80] SEE IF OUTPUTTING TO PRINTER
5399 19F3 : B7                       or      a               ;
5400 19F4 : 28 04                    jr      z,CRCONT        ;[M80] NOT PRINTER, CONTINUE
5401 19F6 : AF                       xor     a               ;[M80] CRFIN MUST ALWAYS RETURN WITH A=0
5402 19F7 : 32 46 38                 ld      (LPTPOS),a      ;;Set Print Head position to 0
5403 19FA : C9         (M80) CRCONT: ret                     ;
5404 19FB
5405 19FB                    ;;The INKEY$ function
5406 19FB : D7         [M80] INKEY:  rst     CHRGET          ;
5407 19FC : E5                       push    hl              ;[M80] SAVE THE TEXT POINTER
5408 19FD : CD 18 1A                 call    CHARCG          ;[M80] GET CHARC AND CLEAR IF SET
5409 1A00 : 28 09                    jr      z,NULRT         ;{M80} NO CHAR, RETURN NULL STRING
5410 1A02 : F5         {M80} BUFCIN: push    af              ;
5411 1A03 : CD 4E 0E                 call    STRIN1          ;[M80] MAKE ONE CHAR STRING
5412 1A06 : F1                       pop     af              ;
5413 1A07 : 5F                       ld      e,a             ;[M80] CHAR TO [D]
5414 1A08 : CD 19 10                 call    SETSTR          ;[M80] STUFF IN DESCRIPTOR AND GOTO PUTNEW
5415 1A0B : 21 6D 03   (M80) NULRT:  ld      hl,REDDY-1      ;
5416 1A0E : 22 E4 38                 ld      (FACLO),hl      ;
5417 1A11 : 3E 01                    ld      a,1             ;
5418 1A13 : 32 AB 38                 ld      (VALTYP),a      ;;Set Type to String
5419 1A16 : E1                       pop     hl              ;
5420 1A17 : C9                       ret                     ;
5421 1A18
5422 1A18 : E5         [M80] CHARCG: push    hl              ;
5423 1A19 : 21 0A 38                 ld      hl,CHARC        ;
5424 1A1C : 7E                       ld      a,(hl)          ;[M80] GET SAVED CHAR
5425 1A1D : 36 00                    ld      (hl),0          ;[M80] CLEAR IT
5426 1A1F : B7                       or      a               ;[M80] IS THERE ONE?
5427 1A20 : CC 39 1A                 call    z,CNTCCN        ;{M80} SEE IF ITS CONTROL-C
5428 1A23 : E1                       pop     hl              ;
5429 1A24 : C9                       ret                     ;
5430 1A25
5431 1A25 : CD 39 1A   [M80] ISCNTC: call    CNTCCN          ;{M80} SEE IF ITS CONTROL-C
5432 1A28 : C8                       ret     z               ;[M80] IF NONE, RETURN
5433 1A29 : 32 0A 38                 ld      (CHARC),a       ;{M80} SAVE CHAR
5434 1A2C : FE 13                    cp      $13             ;[M80] PAUSE? (^S)
5435 1A2E : C0                       ret     nz              ;{M80} IF PAUSE, READ NEXT CHAR
5436 1A2F
5437 1A2F : AF         [M65] CQINCH: xor     a               ;
5438 1A30 : 32 0A 38                 ld      (CHARC),a       ;{M80} CLEAR SAVED CHAR
5439 1A33 : CD 39 1A   (~~~) CQINC1: call    CNTCCN          ;
5440 1A36 : 28 FB                    jr      z,CQINC1        ;
5441 1A38 : C9                       ret                     ;
5442 1A39
5443 1A39 : CD 7E 1E   (~~~) CNTCCN: call    INCHRH          ;{M80} READ THE CHARACTER THAT WAS PRESSED
5444 1A3C : FE 03                    cp      3               ;[M80] ^C?
5445 1A3E : 20 0A                    jr      nz,CNTCCR       ;;No, set flags and return
5446 1A40 : 3A 5E 38         WRMCON: ld      a,(CLFLAG)       ;Get CLOAD Status
5447 1A43 : B7                       or      a               ;;Is it 0?
5448 1A44 : CC BE 0B                 call    z,SCRTCH        ;;Bad CLOAD, do a NEW
5449 1A47 : C3 CE 1F                 jp      WRMFIN          ;;Finish Warm Start
5450 1A4A : B7         (~~~) CNTCCR: or      a               ;;Set flags
5451 1A4B : C9                       ret                     ;
5452 1A4C
5453 1A4C : AF               PRESET: xor     a               ;[EUB] PRESET FLAG
5454 1A4D : 18 02                    jr      PPRSET          ;
5455 1A4F : 3E 01            PSET:   ld      a,1             ;[EUB] PSET FLAG
5456 1A51 : 08               PPRSET: ex      af,af'          ;;Save PSET/PRESET flag
5457 1A52 : CD 7F 1A                 call    SCAND           ;;Parse (X,Y)
5458 1A55 : CD 8E 1A         PPRSDO: call    SCALXY          ;;Convert X,Y
5459 1A58 : 28 02                    jr      z,RSETC         ;;Semigraphics at screen location?
5460 1A5A : 36 A0                    ld      (hl),$A0        ;;No, store base semigraphic`1
5461 1A5C : 08         (~~~) RSETC:  ex      af,af'          ;;Restore PSET/PRESET flag
5462 1A5D : B7                       or      a               ;;Set flags
5463 1A5E : 1A                       ld      a,(de)          ;;Get semigraphic offset
5464 1A5F : 20 03                    jr      nz,PSETC        ;;PRESET?
5465 1A61 : 2F                       cpl                     ;;Invert to create mask
5466 1A62 : A6                       and     (hl)            ;;and clear offset bit
5467 1A63 : 06                       byte    $06             ;;"LD B," around next instruction
5468 1A64 : B6         (~~~) PSETC:  or      (hl)            ;;If PRESET, set offset bit
5469 1A65 : 77                       ld      (hl),a          ;;Store at screen location
5470 1A66 : E1                       pop     hl              ;;Restore text pointer
5471 1A67 : C9                       ret                     ;
5472 1A68
5473 1A68                    ;;The PPOINT function
5474 1A68 : D7               POINT:  rst     CHRGET          ;;Eat character
5475 1A69 : CD 7F 1A                 call    SCAND           ;;Parse (X,Y)
5476 1A6C : CD 8E 1A                 call    SCALXY          ;;Convert X,Y
5477 1A6F : 20 06                    jr      nz,POINTZ       ;;Not semigraphics? Return 0
5478 1A71 : 1A                       ld      a,(de)          ;;Get bit offset
5479 1A72 : A6                       and     (hl)            ;;Mask with screen character
5480 1A73 : 16 01                    ld      d,1             ;
5481 1A75 : 20 02                    jr      nz,POINTR       ;;Bit set? Return 1
5482 1A77 : 16 00            POINTZ: ld      d,0             ;
5483 1A79 : AF               POINTR: xor     a               ;;Clear Accumulator
5484 1A7A : CD 23 0B                 call    FLOATD           ;
5485 1A7D : E1                       pop     hl              ;;Restore text pointer
5486 1A7E : C9                       ret                     ;
5487 1A7F
5488 1A7F                    ;;Get parameters for PSET, PRESET, POINT, and SOUND
5489 1A7F                    ;;Scans program text in the format (x-ooord,y-coord)
5490 1A7F                    ;;Returns x-ooord in BC, y-coord in DE
5491 1A7F : CF         [GWB] SCAND:  rst     SYNCHK
5492 1A80 : 28                       byte    '('             ;[GWB] SKIP OVER OPEN PAREN
5493 1A81 : CD D0 1A                 call    GETINT          ;[GWB] SCAN X INTO [D,E]
5494 1A84 : D5                       push    de              ;[GWB] SAVE WHILE SCANNING Y
5495 1A85 : CF                       rst     SYNCHK          ;
5496 1A86 : 2C                       byte    ','             ;[GWB] SCAN COMMA
5497 1A87 : CD D0 1A                 call    GETINT          ;[GWB] GET Y INTO [D,E]
5498 1A8A : CF                       rst     SYNCHK          ;
5499 1A8B : 29                       byte    ')'             ;{GWB} SKIP OVER CLOSE PAREN
5500 1A8C : C1                       pop     bc              ;[GWB] GET BACK X INTO [B,C]
5501 1A8D : C9                       ret                     ;
5502 1A8E
5503 1A8E                  + ;;Convert PSET Coordinates to Screen Position and Character Mask
5504 1A8E                  | ;;On entry: BC = X-Coordinate
5505 1A8E                  | ;;          DE = Y-Coordinate
5506 1A8E                  | ;;If BC > 71 or DE > 79, generates an FC error
5507 1A8E                  | ;;On exit: A = Masked Character at Screen Offset
5508 1A8E                  | ;;        DE = Address of Character Offset
5509 1A8E                  | ;;        HL = Offset into Screen
5510 1A8E : E3         [GWB] SCALXY: ex      (sp),hl         ;;Save Registers
5511 1A8F : E5                       push    hl
5512 1A90 : C5                       push    bc              ;;BC=X Coordinate
5513 1A91 : D5                       push    de              ;;DE=Y Coordinate
5514 1A92 : 21 47 00                 ld      hl,71
5515 1A95 : E7                       rst     COMPAR          ;;If Y greater than 71
5516 1A96 : DA 97 06   (~~~) FCERRP: jp      c,FCERR         ;;Function Call error
5517 1A99 : 21 4F 00                 ld      hl,79
5518 1A9C : C5                       push    bc
5519 1A9D : D1                       pop     de
5520 1A9E : E7                       rst     COMPAR          ;;If X greater than 79
5521 1A9F : 38 F5                    jr      c,FCERRP        ;;Function Call error
5522 1AA1 : D1                       pop     de
5523 1AA2 : C1                       pop     bc
5524 1AA3 : 21 28 30                 ld      hl,SCREEN+40    ;;Starting screen offset
5525 1AA6 : 7B                       ld      a,e             ;;A=Y Coordinate
5526 1AA7 : 11 28 00                 ld      de,40           ;;Screen width
5527 1AAA : FE 03            SCALPY: cp      3               ;;Less than 3?
5528 1AAC : 38 06                    jr      c,SCALEX        ;;Convert X
5529 1AAE : 19                       add     hl,de           ;;Add a line to offset
5530 1AAF : 3D                       dec     a               ;;Subtract 3
5531 1AB0 : 3D                       dec     a               ;
5532 1AB1 : 3D                       dec     a               ;
5533 1AB2 : 18 F6                    jr      SCALPY          ;;Repeat
5534 1AB4 : 07               SCALEX: rlca                    ;;Multiply remainder by 2
5535 1AB5 : CB 29                    sra     c               ;;Column = X-Coordinate / 2
5536 1AB7 : 30 01                    jr      nc,SCALES       ;;Was it odd?
5537 1AB9 : 3C                       inc     a               ;;Yes, add one to remainder
5538 1ABA : 09               SCALES: add     hl,bc           ;;Add column to screen offset
5539 1ABB : 11 CA 1A                 ld      de,BITTAB       ;
5540 1ABE : B7               SCALEB: or      a               ;;Check bit#
5541 1ABF : 28 04                    jr      z,SCALEC        ;;0? Mask screen character
5542 1AC1 : 13                       inc     de              ;;Bump table pointer
5543 1AC2 : 3D                       dec     a               ;;Decrement bit#
5544 1AC3 : 18 F9                    jr      SCALEB          ;;and repeat
5545 1AC5 : 7E               SCALEC: ld      a,(hl)          ;;Get character at screen offset
5546 1AC6 : F6 A0                    or      $A0             ;
5547 1AC8 : AE                       xor     (hl)            ;;Flip bits 5 and 7
5548 1AC9 : C9                       ret                     ;
5549 1ACA
5550 1ACA : 01 02 04 08      BITTAB: byte    $01,$02,$04,$08,$10,$40
5551 1ACE : 10 40
5552 1AD0
5553 1AD0                    ;;Parse an Integer
5554 1AD0 : CD 85 09         GETINT: call    FRMEVL          ;;Get a number
5555 1AD3 : C3 82 06                 jp      FRCINT          ;;Convert to an Integer
5556 1AD6
5557 1AD6 : D5               SOUND:  push    de
5558 1AD7 : CD 7F 1A                 call    SCAND
5559 1ADA : E5                       push    hl
5560 1ADB : CD 64 1E                 call    SOUNDS
5561 1ADE : E1                       pop     hl
5562 1ADF : D1                       pop     de
5563 1AE0 : C9                       ret
5564 1AE1
5565 1AE1                    ;;Print CR/LF to printer
5566 1AE1 : 3E 0D            LPCRLF: ld      a,13            ;;Send CR to printer
5567 1AE3 : CD E8 1A                 call    LPTOUT          ;
5568 1AE6 : 3E 0A                    ld      a,10            ;;Send LF to printer
5569 1AE8              [M80] LPTOUT: ;Primitive print character to printer routine
5570 1AE8 : F7                       rst     HOOKDO          ;;Call Extended ROM Hook Routine
5571 1AE9 : 11         {~~~} HOOK17: byte    17              ;
5572 1AEA : F5                       push    af              ;;Save character
5573 1AEB : F5                       push    af              ;;Save Registers
5574 1AEC : D9                       exx                     ;
5575 1AED : DB FE            LPTRDY: in      a,($FE)         ;;Wait for printer to be ready
5576 1AEF : E6 01                    and     1               ;
5577 1AF1 : 28 FA                    jr      z,LPTRDY        ;
5578 1AF3                    ;;Send framed byte to printer port
5579 1AF3 : CD 08 1B   {~~~} OUTBYT: call    OUTBIZ          ;;Send Start Bit
5580 1AF6 : 1E 08                    ld      e,8             ;;Send 8 bits to printer
5581 1AF8 : F1                       pop     af              ;;Restore character
5582 1AF9 : CD 0A 1B         OUTBTS: call    OUTBIT          ;;Send bit 0 to printer
5583 1AFC : 0F                       rrca                    ;;Rotate bits
5584 1AFD : 1D                       dec     e               ;;Decrement counter and loop
5585 1AFE : 20 F9                    jr      nz,OUTBTS       ;
5586 1B00 : 3E 01                    ld      a,1             ;;Send Stop Bit
5587 1B02 : CD 0A 1B                 call    OUTBIT          ;
5588 1B05 : D9                       exx                     ;;Restore Registers
5589 1B06 : F1                       pop     af              ;
5590 1B07 : C9                       ret                     ;
5591 1B08
5592 1B08                    ;;Send zero bit to printer port
5593 1B08 : 3E 00            OUTBIZ: ld      a,0              ;Write zero bit to printer port
5594 1B0A                    ;;Send bit 0 of A to printer port
5595 1B0A : D3 FE            OUTBIT: out     ($FE),a         ;;Write bit to printer port
5596 1B0C : 26 B1                    ld      h,177           ;;Wait 2,849 cycles (700 microseconds)
5597 1B0E : 25               OUTDLY: dec     h               ;;Wait [HL]*16+17 cycles
5598 1B0F : 20 FD                    jr      nz,OUTDLY       ;
5599 1B11 : 00                       nop                     ;
5600 1B12 : 00                       nop                     ;
5601 1B13 : 00                       nop                     ;
5602 1B14 : C9                       ret                     ;
5603 1B15
5604 1B15                    ;;Copy Screen Contents to Printer
5605 1B15                    ;;Assumes printer line width is 40
5606 1B15 : E5               COPY:   push    hl              ;;Save Text Pointer
5607 1B16 : D5                       push    de              ;
5608 1B17 : CD E1 1A                 call    LPCRLF          ;;Print CR/LF
5609 1B1A : 21 28 30                 ld      hl,SCREEN+40    ;;Row 1, Column 0
5610 1B1D : 11 E8 33                 ld      de,SCREEN+1000  ;;End of Screen
5611 1B20 : 7E         (~~~) COPY1:  ld      a,(hl)          ;;Get Screen Character
5612 1B21 : CD E8 1A                 call    LPTOUT          ;;Print it
5613 1B24 : 23                       inc     hl              ;;Bump pointer
5614 1B25 : E7                       rst     COMPAR          ;;Are we there yet?
5615 1B26 : 38 F8                    jr      c,COPY1         ;;No, do it again
5616 1B28 : CD E1 1A                 call    LPCRLF          ;;Print CR/LF
5617 1B2B : D1                       pop     de              ;
5618 1B2C : E1                       pop     hl              ;;Restore Text Pointer
5619 1B2D : C9                       ret                     ;
5620 182E
5621 1B2E                  + ;;Display Tape Control Messages
5622 1B2E                  | ;;Displays control messages, then waits for RETURN key
5623 1B2E                  | ;;PPLAY displays CLOAD message
5624 1B2E                  | ;;PRECRD displays CSAVE message
5625 1B2E                  | ;;Preserves all registers
5626 1B2E : E5               PPLAY:  push    hl              ;;Save all Registers
5627 1B2F : D5                       push    de              ;
5628 1B30 : C5                       push    bc              ;
5629 1B31 : 21 E8 1B                 ld      hl,PLAYT        ;;"Press <PLAY>"
5630 1B34 : F5               PRETRN: push    af              ;;Entry point for "Press <RECORD>"
5631 1B35 : CD 9D 0E                 call    STROUT          ;
5632 1B38 : 21 B5 00                 ld      hl,STARTT       ;
5633 1B3B : CD 9D 0E                 call    STROUT          ;;Print "Press RETURN key to start"
5634 1B3E : CD 7E 1E   (~~~) PRETRL: call    INCHRH          ;
5635 1B41 : FE 0D                    cp      13              ;
5636 1B43 : 20 F9                    jr      nz,PRETRL       ;;Wait for RETURN key
5637 1B45 : CD EA 19                 call    CRDO            ;Print CR/LF
5638 1B48 : F1                       pop     af              ;
5639 1B49 : C1                       pop     bc              ;
5640 1B4A : D1                       pop     de              ;
5641 1B4B : E1                       pop     hl              ;;Restore all Registers
5642 1B4C : C9                       ret                     ;
5643 1B4D
5644 1B4D                  + ;;Read Byte from Tape
5645 1B4D                  | ;;Returns Byte in A
5646 1B4D                  | ;;All other registers preserved
5647 1B4D : D9               RDBYTE: exx                     ;;Save index registers
5648 1B4E : 0E FC                    ld      c,252           ;;Tape I/O Port
5649 1B50 : CD 62 1B   (~~~) RDBYT2: call    RDBIT           ;;Wait for Start Bit (0)
5650 1B53 : 38 FB                    jr      c,RDBYT2        ;
5651 1B55 : 26 08                    ld      h,8             ;;Now read 8 bits
5652 1B57 : CD 62 1B         RDBYT3: call    RDBIT           ;;Read next bit
5653 1B5A : CB 15                    rl      l               ;;Rotate into L
5654 1B5C : 25                       dec     h               ;
5655 1B5D : 20 F8                    jr      nz,RDBYT3       ;;Loop until done
5656 1B5F : 7D                       ld      a,l             ;;Copy byte into A
5657 1B60 : D9                       exx                     ;;Restore index registers
5658 1B61 : C9                       ret                     ;
5659 1B62
5660 1B62                  + ;;Read Bit from Tape
5661 1B62                  | ;;Looks for a pulse train of two square waves with leading
5662 1B62                  | ;;negative halves, then measures the total length of the
5663 1B62                  | ;;square waves in cycles and compares it to as threshold
5664 1B62                  | ;;of 2633 cycles, which (at a clock speed of 3.579545 MHz)
5665 1B62                  | ;;equates to 1369 microseconds, about halfway between the
5666 1B62                  | ;;1723 and 868 microseconds for a mark and space, respectively.
5667 1B62                  | ;
5668 1B62                    ;;First wait for the leading negative half of the pulse train
5669 1B62 : ED 78            RDBIT:  in      a,(c)           ;;Read tape port
5670 1B64 : 1F                       rra                     ;;Rotate low bit into Carry
5671 1B65 : 38 FB                    jr      c,RDBIT         ;;If 1, do it again
5672 1B66                  + ;;Then wait for the start of the positive half of the square wave
5673 1B67                  | ;;Ends 15 cycles after detection
5674 1B67 : ED 78      (~~~) RDBIT2: in      a,(c)           ;;Read tape port
5675 1B69 : 1F                       rra                     ;;Rotate low bit into Carry
5676 1B6A : 30 FB                    jr      nc,RDBIT2       ;;If 0, do it again
5677 1B6C : AF                       xor     a               ;;Start counter at 0
5678 1B6D                  + ;;Now measure length of positive half
5679 1B6D                  | ;;Total cycles is iterations * 36 - 5
5680 1B6D : 3C         (~~~) RDBIT3: inc     a               ;;Increment counter
5681 1B6E : ED 40                    in      b,(c)           ;;Read tape port
5682 1B70 : CB 18                    rr      b               ;;Rotate low bit into Carry
5683 1B72 : 38 F9                    jr      c,RDBIT3        ;;If 1, do it again
5684 1B74                  + ;;Add length of negative half
5685 1B74                  | ;;Total cycles is iterations * 36 - 5
5686 1B74 : 3C         (~~~) RDBIT4: inc     a               ;;Increment counter
5687 1B75 : ED 40                    in      b,(c)           ;;Read tape port
5688 1B77 : CB 18                    rr      b               ;;Rotate low bit into Carry
5689 1B79 : 30 F9                    jr      nc,RDBIT4       ;;If 0, do it again
5690 1B7B                  + ;;Check Total Length
5691 1B7B                  | ;;Total length in cycles is A*36+5.
5692 1B7B : FE 49                    cp      73              ;;Set Carry if at least 2633 cycles
5693 1B7D : C9                       ret                     ;
5694 1B7E
5695 1B7E : C9         (~~~) RWARYR: ret                     ;;Return from RWARYD
5696 1B7F
5697 1B7F                    ;;CSAVE tape control
5698 1B7F : E5               PRECRD: push    hl              ;;Save Registers
5699 1B80 : D5                       push    de              ;
5700 1B81 : C5                       push    bc              ;
5701 1B82 : 21 F7 1B                 ld      hl,RECORT       ;;"Press <RECORD>"
5702 1B85 : 18 AD                    jr      PRETRN          ;;Wait for RETURN
5703 1B87
5704 1B87                    ;;Write byte to tape twice
5705 1B87 : CD 8A 1B         WRBYT2: call    WRBYTE          ;;Call WRBYTE, then drop into it
5706 1B8A
5707 1B8A                    ;;Write framed byte to tape
5708 1B8A                    ;;Writes a start bit (0) , the bits of the byte, then two stop bits (1)
5709 1B8A : F5               WRBYTE: push    af              ;;Save all registers
5710 1B8B : D9                       exx                     ;
5711 1B8C : 0E FC                    ld      c,252           ;;Tape I/O Port
5712 1B8E : F5                       push    af              ;;Save byte
5713 1B8F : AF                       xor     a               ;
5714 1B90 : 1E 01                    ld      e,1             ;
5715 1B92 : CD A5 1B                 call    WRBITS          ;;Write start bit ($00)
5716 1B95 : F1                       pop     af              ;;Restore byte
5717 1B96 : 1E 08                    ld      e,8             ;
5718 1B98 : CD A5 1B                 call    WRBITS          ;;Write 8 bits of byte
5719 1B9B : 3E FF                    ld      a,$FF           ;
5720 1B9D : 1E 02                    ld      e,2             ;
5721 1B9F : CD A5 1B                 call    WRBITS          ;;Write stop bits (2 x $FF)
5722 1BA2 : D9                       exx                     ;
5723 1BA3 : F1                       pop     af              ;;Restore all registers
5724 1BA4 : C9                       ret                     ;
5725 1BA5
5726 1BA5                  + ;;Write E most significant bits of A to Tape
5727 1BA5                  | ;;Each bit is written as two full square waves, negative half first
5728 1BA5                  | ;;The leading negative half and trailing positive half frame the
5729 1BA5                  | ;;(positive half first) square wave (that RDBITS looks for
5730 1BA5                  | ;;A mark (1) and space (0) have wave lengths of 2078 and 4126 cycles,
5731 1BA5                  | ;;respectively. At a clock speed of 3.579545 MHz, these equate to
5732 1BA5                  | ;;1723 and 868 microseconds, resulting in approximate frequencies
5733 1BA5                  | ;;of 1723 Hz for a mark and 868 Hz for a space.
5734 1BA5 : 17               WRBITS: rla                     ;;Rotate MSB into Carry
5735 1BA6 : 2E 40                    ld      l,64            ;;Preset Pulse Length 1,039 cycles for a 1
5736 1BA8 : 38 02                    jr      c,WRBIT2        ;;Was bit a 1?
5737 1BAA : 2E 80                    ld      l,128           ;;No, set Pulse Length 2,063 cycles for a 0
5738 1BAC                    ;;Write Bit with Pulse Length L ;
5739 1BAC : 06 04            WRBIT2: ld      b,4             ;;Countdown - + - +
5740 1BAE : ED 41            WRBIT3: out     (c),b           ;;Writing 0, 1, 0, 1
5741 1BB0 : 65                       ld      h,l             ;;Each pulse is L*16+15 cycles
5742 1BB1 : 25               WRBIT4: dec     h               ;                4
5743 1BB2 : 20 FD                    jr      nz,WRBIT4       ;
5744 1BB4 : 05                       dec     b               ;
5745 1BB5 : 20 F7                    jr      nz,WRBIT3       ;;Write next pulse
5746 1BB7 : 1D                       dec     e               ;
5747 1BB8 : 20 EB                    jr      nz,WRBITS       ;;Write next bit
5748 1BBA : C9                       ret                     ;
5749 1BBB : C9                       ret                     ;;Orphan instruction
5750 1BBC
5751 1BBC                  + ;;Write SYNC to tape
5752 1BBC                  | ;;Writes 12 $FF then a $00
5753 1BBC                  | ;;All registers preserved
5754 1BBC : F5               WRSYNC: push    af              ;;Save registers
5755 1BBD : C5                       push    bc              ;
5756 1BBE : 06 0C                    ld      b,12            ;
5757 1BC0 : 3E FF            WRSYN2: ld      a,$FF           ;
5758 1BC2 : CD 8A 1B                 call    WRBYTE          ;;Write $FF to tape
5759 1BC5 : 10 F9                    djnz    WRSYN2          ;;Do it 11 more times
5760 1BC7 : AF                       xor     a               ;
5761 1BC8 : CD 8A 1B                 call    WRBYTE          ;;Write $00 to tape
5762 1BCB : C1                       pop     bc              ;
5763 1BCC : F1                       pop     af              ;;Restore registers
5764 1BCD : C9                       ret                     ;
5765 1BCE
5766 1BCE                  + ;;Read SYNC from tape
5767 1BCE                  | ;;Reads bytes until it gets 6 $FF followed by a $00
5768 1BCE                  | ;;All registers preserved
5769 1BCE : F5               RDSYNC: push    af              ;;Save registers
5770 1BCF : C5                       push    bc              ;
5771 1BD0 : 06 06      (~~~) RDSYN1: ld      b,6             ;;Do 6 times
5772 1BD2 : CD 4D 1B   (~~~) RDSYN2: call    RDBYTE          ;
5773 1BD5 : 3C                       inc     a               ;
5774 1BD6 : 20 F8                    jr      nz,RDSYN1       ;;If not $FF, start all over
5775 1BD8 : 10 F8                    djnz    RDSYN2          ;;Repeat until 6 $FF read
5776 1BDA : CD 4D 1B   (~~~) RDSYN3: call    RDBYTE          ;
5777 1BDD : B7                       or      a               ;
5778 1BDE : 28 05                    jr      z,RDSYN4        ;;If $00, we are done
5779 1BE0 : 3C                       inc     a               ;
5780 1BE1 : 28 F7                    jr      z,RDSYN3        ;;If $FF, read another byte
5781 1BE3 : 18 EB                    jr      RDSYN1          ;;Otherwise, start all over
5782 1BE5 : C1         (~~~) RDSYN4: pop     bc              ;
5783 1BE6 : F1                       pop     af              ;;Restore registers
5784 1BE7 : C9                       ret                     ;
5785 1BE8
5786 1BE8 : 50 72 65 73      PLAYT:  byte    "Press <PLAY>",13,10,0          ;
5787 1BEC : 73 20 3C 50
5788 1BF0 : 4C 41 59 3E
5789 1BF4 : 0D 0A 00
5790 1BF7
5791 1BF7 : 50 72 65 73      RECORT: byte    "Press <RECORD>",13,10,0        ;
5792 1BFB : 73 20 3C 52
5793 1BFF : 45 43 4F 52
5794 1C03 : 44 3E 0D 0A
5795 1C07 : 00
5796 1C08
5797 1C08 : F7               CSAVE:  rst     HOOKDO          ;
5798 1C09 : 15         {~~~} HOOK21: byte    21              ;
5799 1C0A : FE AA                    cp      MULTK           ;;If * Token
5800 1C0C : CA 62 0C                 jp      z,CSARY        ;;Do CSAVE*
5801 1C0F : CD B8 1C                 call    NAMFIL          ;;Scan filename
5802 1C12 : E5                       push    hl              ;;Save text pointer
5803 1C13 : CD 25 1D                 call    WRHEAP           ;
5804 1C16 : 2A 4F 38                 ld      hl,(TXTTAB)     ;
5805 1C19 : CD 38 1D                 call    CSAVEP          ;
5806 1C1C : 06 0F            WRTAIL: ld      b,15            ;;Write 16 $00 to tape
5807 1C1E : AF                       xor     a               ;
5808 1C1F : CD 8A 1B         CSAVE3: call    WRBYTE          ;
5809 1C22 : 10 FB                    djnz    CSAVE3          ;
5810 1C24 : 01 40 1F                 ld      bc,8000         ;
5811 1C27 : CD 4B 1D                 call    SLEEP           ;;Delay 200,000 cycles ~ 50 milliseconds
5812 1C2A : E1                       pop     hl              ;;Restore Text Pointer
5813 1C2B : C9                       ret                     ;
5814 1C2C
5815 1C2C : F7               CLOAD:  rst     HOOKDO
5816 1C2D : 14         {~~~} HOOK20: byte    20
5817 1C2E : FE AA                    cp      MULTK           ;;Check for token after CLOAD
5818 1C30 : CA 63 0C                 jp      z,CLARY         ;;If *, CLOAD variable
5819 1C33 : D6 95                    sub     PRINTK          ;
5820 1C35 : 28 02                    jr      z,CLOADQ        ;;If ?, A will be $FF (verify)
5821 1C37 : AF                       xor     a               ;;otherwise it will be 0 (load)
5822 1C38 : 01                       byte    $01             ;;"LD BC," over two instructions
5823 1C39 : 2F               CLOADQ: cpl                     ;;A = $FF
5824 1C3A : 23                       inc     hl              ;;Bump text pointer
5825 1C3B : FE 01                    cp      1               ;;If A is 0, set C, else clear C
5826 1C3D : F5                       push    af              ;;Save A and C
5827 1C3E : 3E FF                    ld      a,$FF           ;
5828 1C40 : 32 5E 38                 ld      (CLFLAG),a      ;;Set Cload Flag to $FF
5829 1C43 : CD B1 1C                 call    NAMFIN          ;;Get FILNAM if present
5830 1C46                  + ;;Look for Filename
5831 1C46                  | ;;Reads tape until a file matching FILNAM is found
5832 1C46                  | ;;If first character of FILNAM is NUL, matches next file on tape
5833 1C46 : AF         (~~~) CLOADF: xor     a               ;
5834 1C47 : 32 5D 38                 ld      (INSYNC),a       ;;Clear SYNC flag
5835 1C4A : D5                       push    de              ;
5836 1C4B : CD 2E 1B                 call    PPLAY           ;;"Press <PLAY>", wait for RETURN
5837 1C4E : CD D9 1C                 call    RDHEAD          ;
5838 1C51 : 21 57 38                 ld      hl,FILNAF       ;;Filename found on tape
5839 1C54 : CD ED 1C                 call    CMPNAM          ;;Compare with FILNAM
5840 1C57 : D1                       pop     de              ;
5841 1C58 : 28 12                    jr      z,CLOADC        ;;If they match, continue CLOAD
5842 1C5A : 21 06 1D                 ld      hl,SKIPT        ;
5843 1C5D : CD 0D 1D                 call    OUTNAM          ;;"Skip: " + NAMFIL
5844 1C60 : 06 0A      (~~~) CLOADE: ld      b,10            ;;???Skip to end of file
5845 1C62 : CD 4D 1B   (~~~) CLOAD2: call    RDBYTE          ;
5846 1C65 : B7                       or      a               ;
5847 1C66 : 20 F8                    jr      nz,CLOADE       ;;Not $00, start over
5848 1C68 : 10 F8                    djnz    CLOAD2          ;;Loop until 10 in a row
5849 1C6A : 18 DA                    jr      CLOADF          ;;Check next file
5850 1C6C : 21 FE 1C   (~~~) CLOADC: ld      hl,FOUNDT       ;
5851 1C6F : CD 0D 1D                 call    OUTNAM          ;;"Found:" + NAMFIL
5852 1C72 : F1                       pop     af              ;;Restore mode
5853 1C73 : 32 E4 38                 ld      (FACLO),a       ;;and aave it
5854 1C76 : DC BE 0B                 call    c,SCRTCH        ;;If not CLOAD?, do a NEW
5855 1C79 : 3A E4 38                 ld      a,(FACLO)       ;;Get mode back
5856 1C7C : FE 01                    cp      1               ;;and check it
5857 1C7E : 32 5E 38                 ld      (CLFLAG),a      ;;Store in FlagE
5858 1C81 : 2A 4F 38                 ld      hl,(TXTTAB)     ;;Set pointer to BASIC program
5859 1C84 : CD 51 1D                 call    CLOADP          ;;Load/verify program
5860 1C87 : 20 11                    jr      nz,CLOADV       ;;Check CLOAD? status
5861 1C89 : 22 D6 38                 ld      (VARTAB),hl     ;;Set end of program
5862 1C8C : 21 6E 03   (~~~) CLOADR: ld      hl,REDDY        ;
5863 1C8F : CD 9D 0E                 call    STROUT          ;[M80] PRINT "OK" PREMATURELY
5864 1C92 : 3E FF                    ld      a,$FF           ;
5865 1C94 : 32 5E 38                 ld      (CLFLAG),a       ;;Set FlagE to $FF
5866 1C97 : C3 80 04                 jp      FINI            ;
5867 1C9A : 23         (~~~) CLOADV: inc     hl              ;
5868 1C9B : EB                       ex      de,hl           ;
5869 1C9C : 2A D6 38                 ld      hl,(VARTAB)     ;
5870 1C9F : E7                       rst     COMPAR          ;;Text pointer past end of program?
5871 1CA0 : 38 EA                    jr      c,CLOADR        ;;Yes, CLOAD? successful
5872 1CA2 : 21 AB 1C                 ld      hl,BADT         ;
5873 1CA5 : CD 9D 0E                 call    STROUT          ;;"Bad"
5874 1CA8 : C3 01 04                 jp      STPRDY          ;;Abort to direct mode
5875 1CAB
5876 1CAB : 42 61 64 0D      BADT:   byte    "Bad",13,10,0
5877 1CAF : 0A 00
5878 1CB1                    ;;Scan a Filename for CLOAD command
5879 1CB1 : AF               NAMFIN: xor     a               ;;Store 0
5880 1CB2 : 32 51 38                 ld      (FILNAM),a      ;;in first character of FILNAM
5881 1CB5 : 2B                       dec     hl              ;;Backup text pointer
5882 1CB6 : D7                       rst     CHRGET          ;;Check for terminator
5883 1CB7 : C8                       ret     z               ;;If found, return
5884 1CB8
5885 1CB8                    ;{GWB} Scan a Filename for CSAVE command
5886 1CB8 : CD 85 09   [GWB] NAMFIL: call    FRMEVL          ;[GWB] Evaluate string
5887 1CBB : E5                       push    hl              ;[GWB] save text pointer
5888 1CBC : CD 06 10                 call    ASC2            ;;DE = Pointer to File Name
5889 1CBF : 2B                       dec     hl              ;
5890 1CC0 : 2B                       dec     hl              ;
5891 1CC1 : 2B                       dec     hl              ;
5892 1CC2 : 46                       ld      b,(hl)          ;
5893 1CC3 : 0E 06                    ld      c,6             ;;Maximum File Name Length
5894 1CC5 : 21 51 38                 ld      hl,FILNAM       ;
5895 1CC8 : 1A         (~~~) NAMFL1: ld      a,(de)          ;;Copy String to FILNAM
5896 1CC9 : 77                       ld      (hl),a          ;
5897 1CCA : 23                       inc     hl              ;
5898 1CCB : 13                       inc     de              ;
5899 1CCC : 0D                       dec     c               ;
5900 1CCD : 28 08                    jr      z,NAMFL3        ;
5901 1CCF : 10 F7                    djnz    NAMFL1          ;
5902 1CD1 : 41                       ld      b,c             ;
5903 1CD2 : 36 00      (~~~) NAMFL2: ld      (hl),0          ;;Pad with NULs to length of 6
5904 1CD4 : 23                       inc     hl              ;
5905 1CD5 : 10 FB                    djnz    NAMFL2          ;
5906 1CD7 : E1         (~~~) NAMFL3: pop     hl              ;
5907 1CD8 : C9                       ret                     ;
5908 1CD9
5909 1CD9                    ;;Read File Header from Tape
5910 1CD9 : CD CE 1B         RDHEAD: call    RDSYNC          ;;Wait for SYNC
5911 1CDC : AF         {~~~} RDNAME: xor     a               ;
5912 1CDD : 32 5D 38                 ld      (INSYNC),a      ;;Clear SYNC flag
5913 1CE0 : 21 57 38                 ld      hl,FILNAF       ;
5914 1CE3 : 06 06                    ld      b,6             ;;Read 6 bytes into FINLAF
5915 1CE5 : CD 4D 1B   (~~~) RDNAML: call    RDBYTE          ;
5916 1CE8 : 77                       ld      (hl),a          ;
5917 1CE9 : 23                       inc     hl              ;
5918 1CEA : 10 F9                    djnz    RDNAML          ;
5919 1CEC : C9                       ret                     ;
5920 
5921 1CED                    ;;Compare Filename
5922 1CED                    ;;Compares the 6 bytes string to by HL to FILNAM
5923 1CED                    ;;Returns Z Set if the two are equal or FILNAM is an empty string
5924 1CED                    ;;Otherwise, return Z Clear
5925 1CED : 01 51 38         CMPNAM: ld      bc,FILNAM       ;
5926 1CED                    ;;Entry Point to Compare FILNAM to String pointed to by BC
5927 1CF0 : 1E 06      {---} CMPNAF: ld      e,6             ;;Check 6 characters
5928 1CF2 : 0A                       ld      a,(bc)          ;
5929 1CF3 : B7                       or      a               ;;First character of FILNAM
5930 1CF4 : C8                       ret     z               ;;If NUL return Equsl
5931 1CF5 : 0A         (~~~) CMPNAL: ld      a,(bc)          ;;Compare FILNAM character
5932 1CF6 : BE                       cp      (hl)            ;;with FILNAF character
5933 1CF7 : 23                       inc     hl              ;;Bump pointers
5934 1CF8 : 03                       inc     bc              ;
5935 1CF9 : C0                       ret     nz              ;;If different, return Not Equal
5936 1CFA : 1D                       dec     e               ;
5937 1CFB : 20 F8                    jr      nz,CMPNAL       ;;Decrememt counter and loop
5938 1CFD : C9                       ret                     ;
5939 1CFE
5940 1CFE : 46 6F 75 6E      FOUNDT: byte    "Found: ",0
5941 1D02 : 64 3A 20 00
5942 1D06 : 53 6B 69 70      SKIPT:  byte    "Skip: ",0
5943 1D0A : 3A 20 00
5944 1D0D                    ;;Print string then filename read from tape
5945 1D0D : D5               OUTNAM: push    de              ;;Save DE and AF
5946 1D0E : F5                       push    af              ;
5947 1D0F : CD 9D 0E                 call    STROUT          ;;Print string pointed to by HL
5948 1D12                    ;;Print filename read from tape
5949 1D12 : 21 57 38   {~~~} OUTNMF: ld      hl,FILNAF       ;;Pointer to filename
5950 1D15 : 06 06                    ld      b,6             ;;Filenames are 6 characters long
5951 1D17 : 7E               OUTNM1: ld      a,(hl)          ;
5952 1D18 : 23                       inc     hl              ;
5953 1D19 : B7                       or      a
5954 1D1A : 28 01                    jr      z,OUTNM2        ;;ASCII NUL?
5955 1D1C : DF                       rst     OUTCHR          ;;No, print character
5956 1D1D : 10 F8            OUTNM2: djnz    OUTNM1          ;;Countdown and loop
5957 1D1F : CD EA 19                 call    CRDO            ;;Print CR/LF
5958 1D22 : F1                       pop     af              ;
5959 1D23 : D1                       pop     de              ;;Restore AF and DE
5960 1D24 : C9                       ret                     ;
5961 1D25
5962 1D25                    ;;Prompt User, Wait for RETURN, and Write Header
5963 1D25 : CD 7F 1B         WRHEAP: call    PRECRD          ;;"Press <RECORD>", wait for RETURN
5964 1D28                    ;;Write File Header to Tape
5965 1D28 : CD BC 1B   {~~~} WRHEAD: call    WRSYNC          ;;Write SYNC to tape
5966 1D2B : 06 06      {~~~} WRNAME: ld      b,6
5967 1D2D : 21 51 38                 ld      hl,FILNAM       ;;Write Filename to tape
5968 1D30 : 7E         (~~~) WRNAML: ld      a,(hl)
5969 1D31 : 23                       inc     hl
5970 1D32 : CD 8A 1B                 call    WRBYTE
5971 1D35 : 10 F9                    djnz    WRNAML
5972 1D37 : C9                       ret
5973 1D38
5974 1D38                    ;;Save Program Text to tape
5975 1D38 : CD BC 1B         CSAVEP: call    WRSYNC          ;;Write SYNC to tape
5976 1D3B : EB                       ex      de,hl           ;;Save from TXTTAB
5977 1D3C : 2A D6 38                 ld      hl,(VARTAB)     ;;to VARTAB
5978 1D3F
5979 1D3F                    ;;Save RAM from DE to HL on tape
5980 1D3F : 1A               CSAVEB: ld      a,(de)          ;;Get byte from memory
5981 1D40 : 13                       inc     de              ;;Bump pointer
5982 1D41 : CD 8A 1B                 call    WRBYTE          ;;Write byte to text
5983 1D44 : E7                       rst     COMPAR          ;;Are we there yet?
5984 1D45 : 20 F8                    jr      nz,CSAVEB       ;;No, write another
5985 1D47 : C9                       ret                     ;
5986 1D48
5987 1D48                    ;;;Orphan code?
5988 1D48 : 01 00 00         SLEEPS: ld      bc,0            ;Sleep maximum amount
5989 1D4B
5990 1D4B                    ;;Pause program execution
5991 1D4B                    ;;Delays BC*25-5 cycles
5992 1D4B : 0B               SLEEP:  dec     bc              ;;Decrement Counter
5993 1D4C : 78                       ld      a,b             ;
5994 1D4D : B1                       or      c               ;;Is it 0?
5995 1D4E : 20 FB                    jr      nz,SLEEP        ;;If not, loop
5996 1D50 : C9                       ret                     ;
5997 1D51
5998 1D51                    ;;Load Program Text from tape
5999 1D51 : CD CE 1B         CLOADP: call    RDSYNC          ;;Wait for SYNC
6000 1D54 : 3E FF                    ld      a,$FF
6001 1D56 : 32 5D 38                 ld      (INSYNC),a      ;;Set SYNC flag
6002 1D59 : 9F                       sbc     a,a             ;;A = 0
6003 1D5A : 2F                       cpl                     ;;A = $FF ???WHY?
6004 1D5B : 57                       ld      d,a             ;;D = $FF
6005 1D5C : 06 0A      (~~~) CLOADB: ld      b,10            ;
6006 1D5E : CD 4D 1B   (~~~) CLOADN: call    RDBYTE          ;;Get Byte
6007 1D61 : 5F                       ld      e,a             ;;Save it
6008 1D62 : 96                       sub     (hl)            ;;Compare with byte in memory
6009 1D63 : A2                       and     d               ;;If CLOAD?
6010 1D64 : C0                       ret     nz              ;;and different, return with Zero cleared
6011 1D65 : 73                       ld      (hl),e          ;;Store byte in memory
6012 1D66 : CD A9 0B                 call    REASON          ;;If no space left, OM error
6013 1D69 : 7E                       ld      a,(hl)          ;;Get byte back
6014 1D6A : B7                       or      a               ;;Set flags
6015 1D6B : 23                       inc     hl              ;;Bump text pointer
6016 1D6C : 20 EE                    jr      nz,CLOADB       ;;Not 0, reset counter
6017 1D6E : 10 EE                    djnz    CLOADN          ;;Loop until 256 $00 are read
6018 1D70 : AF                       xor     a               ;;Return with Zero set
6019 1D71 : C9                       ret
6020                         ;
6021 1D72              [M80] TTYCHR: ;Print character to screen
6022 1D72 : F7                       rst     HOOKDO          ;;Call Extended BASIC Hook Routine
6023 1D73 : 13         {~~~} HOOK19: byte    19              ;
6024 1D74 : F5                       push    af              ;;Save character
6025 1D75 : FE 0A                    cp      10              ;[M80] LINE FEED?
6026 1D77 : 28 1A                    jr      z,ISLF          ;
6027 1D79 : 3A 00 38                 ld      a,(TTYPOS)      ;
6028 1D7C : B7                       or      a               ;;At beginning of line?
6029 1D7D : 20 14                    jr      nz,ISLF         ;;No, skip line counter check
6030 1D7F : 3A 08 38                 ld      a,(CNTOFL)      ;
6031 1D82 : B7                       or      a               ;;Is line Counter 0?
6032 1D83 : 28 0E                    jr      z,ISLF          ;;Then no pauses
6033 1D85 : 3D                       dec     a               ;
6034 1D86 : 32 08 38                 ld      (CNTOFL),a      ;;Decrement Line Counter
6035 1D89 : 20 08                    jr      nz,ISLF         ;;Not 0, don't pause
6036 1D8B : 3E 17                    ld      a,23            ;
6037 1D8D : 32 08 38                 ld      (CNTOFL),a      ;;Reset line counter
6038 1D90 : CD 2F 1A                 call    CQINCH          ;;Wait for character from keyboard
6039 1D93 : F1         (~~~) ISLF:   pop     af              ;;Retrieve Character
6040 1D94                    ;;Print Character, bypassing Extended Hook and Line Counter checks
6041 1D94 : F5               TTYOUT: push    af              ;
6042 1D95 : D9                       exx                     ;;Save HL on Stack
6043 1D96 : FE 07                    cp      7               ;;Is it BEL!
6044 1D98 : CA 14 1E                 jp      z,BEEP          ;;Make Beep Sound
6045 1D9B : FE 0B                    cp      11              ;;Is it CLS?
6046 1D9D : CA 45 1E                 jp      z,TTYCLR        ;;Clear the Screen
6047 1DA0 : 5F                       ld      e,a             ;;Save A
6048 1DA1 : 2A 01 38                 ld      hl,(CURRAM)     ;
6049 1DA4 : 3A 0D 38                 ld      a,(CURCHR)      ;;Get character under cursor
6050 1DA7 : 77                       ld      (hl),a          ;;Place at current screen position
6051 1DA8 : 7B                       ld      a,e             ;;Restore A
6052 1DA9 : FE 08                    cp      8               ;;Is it BS?
6053 1DAB : 28 30                    jr      z,BS            ;;Do Back Space
6054 1DAD : FE 0D                    cp      13              ;;Is it CR?
6055 1DAF : 28 0D                    jr      z,CR            ;;Do Carriage Return
6056 1DB1 : FE 0A                    cp      10              ;;Is it LF?
6057 1DB3 : 28 13                    jr      z,LF            ;;Do Line Feed
6058 1DB5 : 2A 01 38                 ld      hl,(CURRAM)     ;;Place character at
6059 1DB8 : 77                       ld      (hl),a          ;;current position on screen
6060 1DB9 : CD 1F 1E                 call    TTYMOV          ;;Move Cursor Right
6061 1DBC : 18 2C                    jr      TTYFIN          ;;Finish Up
6062 1DBE                    ;;Carriage Return: Move Cursor to Beginning of Current Line
6063 1DBE : ED 5B 00 38(~~~) CR:     ld      de,(TTYPOS)     ;
6064 1DC2 : AF                       xor     a               ;
6065 1DC3 : 57                       ld      d,a             ;;Subtract Cursor Column
6066 1DC4 : ED 52                    sbc     hl,de           ;;from Screen Position
6067 1DC6 : 18 1F                    jr      TTYFIS          ;
6068 1DC8                    ;;Line Feed: Move Cursor Down One Line
6069 1DC8 : 11 C0 33   (~~~) LF:     ld      de,SCREEN+960   ;
6070 1DCB : E7                       rst     COMPAR          ;;Cursor on Last Row?
6071 1DCC : D2 D8 1D                 jp      nc,LFS          ;;Yes, Scroll and Finish Up
6072 1DCF : 11 28 00                 ld      de,40           ;
6073 1DD2 : 19                       add     hl,de           ;;Add 40 to Move Down One Line
6074 1DD3 : 22 01 38                 ld      (CURRAM),hl     ;;Save New Screen Position
6075 1DD6 : 18 12                    jr      TTYFIN          ;
6076 1DD8 : CD FE 1D   (~~~) LFS:    call    SCROLL          ;;Scroll Up and Keep Screen Position
6077 1DDB : 18 0D                    jr      TTYFIN          ;
6078 1DDD                    ;;Back Space: Move Cursor Left and Delete Character
6079 1DDD : 3A 00 38   (~~~) BS:     ld      a,(TTYPOS)      ;
6080 1DE0 : B7                       or      a               ;;At First Column?
6081 1DE1 : 28 02                    jr      z,NOBS          ;
6082 1DE3 : 2B                       dec     hl              ;;No, Move One to the Left
6083 1DE4 : 3D                       dec     a               ;
6084 1DE5 : 36 20      (~~~) NOBS:   ld      (hl),' '        ;;Erase Character at Position
6085 1DE7 : CD 3E 1E   (~~~) TTYFIS: call    TTYSAV          ;;Save Column and Position
6086 1DEA : 2A 01 38   (~~~) TTYFIN: ld      hl,(CURRAM)     ;
6087 1DED : 7E                       ld      a,(hl)          ;;Get character at position
6088 1DEE : 32 0D 38                 ld      (CURCHR),a      ;;Save character under cursor
6089 1DF1 : 36 7F                    ld      (hl),$7F        ;Display Cursor
6090 1DF3 : D9         (~~~) TTYXPR: exx                     ;Restore [BC], [DE] and [HL]
6091 1DF4 : F1                       pop     af              ;Restore [AF]
6092 1DF5 : C9                       ret
6093 1DF6
6094 1DF6                    ;;Restore Character Under Cursor
6095 1DF6                    ;;*** Orphan Code?
6096 1DF6 : 2A 01 38                 ld      hl,(CURRAM)     ;;Get position
6097 1DF9 : 3A 0D 38                 ld      a,(CURCHR)      ;;Get character
6098 1DFC : 77                       ld      (hl),a          ;;Put character at position
6099 1DFD : C9                       ret                     ;
6100 1DFE
6101 1DFE                    ;;Scroll Screen Up one Line
6102 1DFE : 01 98 03         SCROLL: ld      bc,920          ;;Move 23 * 40 bytes
6103 1E01 : 11 28 30                 ld      de,SCREEN+40    ;;To Row 1 Column 0
6104 1E04 : 21 50 30                 ld      hl,SCREEN+80    ;;From Row 2 Column 1
6105 1E07 : ED B0                    ldir                    ;
6106 1E09 : 06 28                    ld      b,40            ;;Loop 40 Times
6107 1E0B : 21 C1 33                 ld      hl,SCREEN+961   ;;Starting at Row 23, Column 0
6108 1E0E : 36 20      (~~~) SCROLP: ld      (hl),' '        ;;Put Space
6109 1E10 : 23                       inc     hl              ;;Next Column
6110 1E11 : 10 FB                    djnz    SCROLP          ;;Do it again
6111 1E13 : C9                       ret                     ;
6112 1E14
6113 1E14                    ;;Make a Beep Sound
6114 1E14 : 01 C8 00   (~~~) BEEP:   ld      bc,200          ;
6115 1E17 : 11 32 00                 ld      de,50           ;
6116 1E1A : CD 64 1E                 call    SOUNDS          ;;Play freq 50, delay 300
6117 1E1D : 18 D4                    jr      TTYXPR          ;;Restore Registers and return
6118 1E1F
6119 1E1F                    ;;Move Cursor one character to the right
6120 1E1F : 2A 01 38         TTYMOV: ld      hl,(CURRAM)     ;
6121 1E22 : 3A 00 38                 ld      a,(TTYPOS)      ;
6122 1E25 : 23                       inc     hl              ;;Increment Position in Memory
6123 1E26 : 3C                       inc     a               ;;Increment Cursor Column
6124 1E27 : FE 26                    cp      38              ;;Less than 39?
6125 1E29 : 38 13                    jr      c,TTYSAV        ;;Save and Return
6126 1E2B : 23                       inc     hl              ;
6127 1E2C : 23                       inc     hl              ;;Skip border columns
6128 1E2D : 11 E8 33                 ld      de,SCREEN+1000  ;
6129 1E30 : E7                       rst     COMPAR          ;;Past End of Screen?
6130 1E31 : 3E 00                    ld      a,0             ;;Cursor Column = 0
6131 1E33 : 38 09                    jr      c,TTYSAV        ;;No, Save Position and Column
6132 1E35 : 21 C1 33                 ld      hl,033C1H       ;;Yes, Position = Row 24, Column 0
6133 1E38 : CD 3E 1E                 call    TTYSAV          ;Save Position and Column
6134 1E3B : C3 FE 1D                 jp      SCROLL          ;Scroll Screen
6135 1E3E
6136 1E3E                    ;;Update Current Screen Position and Cursor Column
6137 1E3E : 22 01 38         TTYSAV: ld      (CURRAM),hl     ;;Position in Screen RAM
6138 1E41 : 32 00 38                 ld      (TTYPOS),a      ;;Cursor Column
6139 1E44 : C9                       ret                     ;
6140 1E45
6141 1E45                    ;;Clear Screen
6142 1E45 : 06 20            TTYCLR: ld      b,' '           ;
6143 1E47 : 21 00 30                 ld      hl,SCREEN       ;
6144 1E4A : CD 59 1E                 call    FILLIT          ;;Write to Sreen RAM
6145 1E4D : 06 06                    ld      b,6             ;;Black on Light Cyan
6146 1E4F : CD 59 1E                 call    FILLIT          ;;Write to Color RAM
6147 1E52 : 21 29 30                 ld      hl,SCREEN+41    ;;Home Cursor
6148 1E55 : AF                       xor     a               ;;Column = 0
6149 1E56 : C3 E7 1D                 jp      TTYFIS          ;;Save and Finish
6150 1E59
6151 1E59                    ;;Fill 1024 bytes atarting at HL with A
6152 1E59 : 11 FF 03         FILLIT: ld      de,$3FF         ;;Count down from 1023
6153 1E5C                    ;;Fill BC bytes atartinf at HL with A
6154 1E5C : 70               FILLIP: ld      (hl),b          ;;Store byte
6155 1E5D : 23                       inc     hl              ;;Increment pointer
6156 1E5E : 1B                       dec     de              ;;Decrement Counter
6157 1E5F : 7A                       ld      a,d             ;
6158 1E60 : B3                       or      e               ;;Is it 0?
6159 1E61 : 20 F9                    jr      nz,FILLIP       ;;No, Loop
6160 1E63 : C9                       ret                     ;
6161 1e64
6162 1E64 : 78         [GWB] SOUNDS: ld      a,b             ;;Play frequency [DE] for duration [BC]
6163 1E65 : B1                       or      c               ;;If BC = 0 return
6164 1E66 : C8                       ret     z               ;
6165 1E67 : AF                       xor     a               ;
6166 1E68 : D3 FC                    out     ($FC),a         ;;Write 0 to port $FC
6167 1E6A : CD 76 1E                 call    SDELAY          ;
6168 1E6D : 3C                       inc     a               ;
6169 1E6E : D3 FC                    out     ($FC),a         ;;Write 1 to port $FC
6170 1E70 : CD 76 1E                 call    SDELAY          ;;Delay [DE]*31+44 cycles
6171 1E73 : 0B                       dec     bc              ;;Decrememt duration counter and loop
6172 1E74 : 18 EE                    jr      SOUNDS          ;
6173 1E76
6174 1E76 : D5               SDELAY: push    de              ;;Delay [DE]*31+27 cycles
6175 1E77 : E1                       pop     hl              ;;Copy freq delay to HL (+10)
6176 1E78 : 7C               SDELAL: ld      a,h             ;
6177 1E79 : B5                       or      l               ;
6178 1E7A : C8                       ret     z               ;;If 0, return
6179 1E7B : 2B                       dec     hl              ;
6180 1E7C : 18 FA                    jr      SDELAL          ;;Decrement and loop
6181 1E7E
6182 1E7E                  + ;;INCHRH, INCHRC, and INCHRI - Get Character from Keyboard
6183                       | ;;The Keyboard Matrix is 8 columns by 6 rows. The columns are wired to
6184                       | ;;to address lines A8 through A15 and the rows to I/O Port 255.
6185                       | ;;When the Z80 executes and IN instruction, it puts the contents of BC
6186                       | ;;on the address bus. So to read the keyboard, B is loaded with a column
6187                       | ;;mask, C is loaded with $FF, and OUT (C) reads the rows.
6188                       | ;;
6189                       | ;;        A8  A9  A10 A11 A12 A13 A14 A15
6190                       | ;;    D0   =   -   9   8   6   5   3   2
6191                       | ;;    D1  <--  /   O   I   Y   T   E   W
6192                       | ;;    D2   :   0   K   7   G   4   S   L
6193                       | ;;    D3  RTN  P   M   U   V   R   Z   Q
6194                       | ;;    D4   ;   L   N   H   C   D  SPC
6195                       | ;;    D5   .   ,   J   B   F   X   A
6196                       | ;;
6197                       | ;; Note: The RESET key is wired directly to the Z80 reset line.
6198 1E7E : F7               INCHRH: rst     HOOKDO
6199 1E7F : 12         {~~~} HOOK18: byte    18
6200 1E80 : D9               INCHRC: exx                     ;;Save Registers
6201 1E81 : 2A 0B 38         INCHRI: ld      hl,(RESPTR)
6202 1E84 : 7C                       ld      a,h
6203 1E85 : B7                       or      a
6204 1E86 : 28 1A                    jr      z,KEYSCN
6205 1E88 : EB                       ex      de,hl           ;;Save HL
6206 1E89 : 21 0F 38                 ld      hl,KCOUNT
6207 1E8C : 34                       inc     (hl)            ;;Increment debounce counter
6208 1E8D : 7E                       ld      a,(hl)          ;;Get Value
6209 1E8E : FE 0F                    cp      15              ;;Less than 15?
6210 1E90 : 38 3C                    jr      c,KEYFIN        ;;Yes, finish up
6211 1E92 : 36 05                    ld      (hl),5          ;;Set debounce counter to 5
6212 1E94 : EB                       ex      de,hl           ;;Restore HL
6213 1E95 : 23                       inc     hl
6214 1E96 : 7E                       ld      a,(hl)
6215 1E97 : 22 0B 38                 ld      (RESPTR),hl
6216 1E9A : B7                       or      a
6217 1E9B : F2 36 1F                 jp      p,KEYRET
6218 1E9E : AF                       xor     a
6219 1E9F : 32 0C 38                 ld      (RESPTR+1),a
6220 1EA2                    ;;Scan Keyboard
6221 1EA2 : 01 FF 00         KEYSCN: ld      bc,$FF          ;;B=0 to scan all columns
6222 1EA5 : ED 78                    in      a,(c)           ;;Read rows from I/O Port 255
6223 1EA7 : 2F                       cpl                     ;;and Invert
6224 1EA8 : E6 3F                    and     $3F             ;;Check all rows
6225 1EAA : 21 0E 38                 ld      hl,LSTX         ;;Pointer to last scan code
6226 1EAD : 28 16                    jr      z,NOKEYS        ;;No key pressed? ???do a thing
6227 1EAF                            ;;???Check for Shift and Control Keys
6228 1EAF : 06 7F                    ld      b,$7F           ;;Scanning column 7 - %01111111
6229 1EB1 : ED 78                    in      a,(c)           ;;Read rows and invert
6230 1EB3 : 2F                       cpl
6231 1EB4 : E6 0F                    and     $0F             ;;Check rows 0 through 3 - %00001111
6232 1EB6 : 20 1F                    jr      nz,KEYDN        ;;Key down? Process it
6233 1EB6                            ;;Scan the Rest of the Columns
6234 1EB8 : 06 BF                    ld      b,$BF           ;;Start with column 6 - %10111111
6235 1EBA : ED 78      (~~~) KEYSCL: in      a,(c)           ;;Read rows and invert
6236 1EBC : 2F                       cpl                     ;
6237 1EBD : E6 3F                    and     $3F             ;;Check rows 0 through 5 - %00111111
6238 1EBF : 20 16                    jr      nz,KEYDN        ;;Key down? Process it
6239 1EC1 : CB 08                    rrc     b               ;;Next column
6240 1EC3 : 38 F5                    jr      c,KEYSCL        ;;Loop if not out of columns
6241 1EC5 : 23               NOKEYS: inc     hl              ;;Point to KCOUNT
6242 1EC6 : 3E 46                    ld      a,70            ;
6243 1EC8 : BE                       cp      (hl)            ;
6244 1EC9 : 38 03                    jr      c,KEYFIN        ;;Less than 70? Clean up and return
6245 1ECB : 28 04                    jr      z,SCNINC        ;;0? Increment KCOUNT and return
6246 1ECD : 34                       inc     (hl)            ;
6247 1ECE : AF               KEYFIN: xor     a               ;;Clear A
6248 1ECF : D9                       exx                     ;;Restore Registers
6249 1ED0 : C9                       ret                     ;
6250 1ED1 : 34               SCNINC: inc     (hl)            ;;Increment KCOUNT
6251 1ED2 : 2B                       dec     hl              ;
6252 1ED3 : 36 00                    ld      (hl),0          ;;Clear LSTX
6253 1ED5 : 18 F7                    jr      KEYFIN          ;;Clean up and Return
6254 1ED7
6255 1ED7                    ;;Process Key Currently Pressed
6256 1ED7 : 11 00 00         KEYDN:  ld      de,0            ;
6257 1EDA : 1C               KEYROW: inc     e               ;;Get row number (1-5)
6258 1EDB : 1F                       rra                     ;
6259 1EDC : 30 FC                    jr      nc,KEYROW       ;
6260 1EDE : 7B                       ld      a,e             ;
6261 1EDF : CB 18            KEYCOL: rr      b               ;;Add column number times 6
6262 1EE1 : 30 04                    jr      nc,KEYCHK       ;
6263 1EE3 : C6 06                    add     a,6             ;
6264 1EE5 : 18 F8                    jr      KEYCOL          ;
6265 1EE7 : 5F               KEYCHK: ld      e,a             ;
6266 1EE8 : BE                       cp      (hl)            ;;Compare scan code to LSTX
6267 1EE9 : 77                       ld      (hl),a          ;;Update LSTX with scan code
6268 1EEA : 23                       inc     hl              ;;Point to KCOUNT
6269 1EEB : 20 0F                    jr      nz,KEYCLR       ;;Not the same? Clesr KCOUNT snd exit
6270 1EED : 3E 04                    ld      a,4
6271 1EEF : BE                       cp      (hl)            ;;Check KCOUNT
6272 1EF0 : 38 05                    jr      c,KEYFN6        ;;Greater than 4? Set to 6 and return
6273 1EF2 : 28 0C                    jr      z,KEYASC        ;;Equal to 4? Convert scan code
6274 1EF4 : 34                       inc     (hl)            ;;Increment KCOUNT
6275 1EF5 : 18 02                    jr      KEYFN2          ;;Clean up and exit
6276 1EF7 : 36 06            KEYFN6: ld      (hl),6          ;;Set KCOUNT to 6
6277 1EF9 : AF               KEYFN2: xor     a               ;;Clear A
6278 1EFA : D9                       exx                     ;;Restore registers
6279 1EFB : C9                       ret                     ;
6280 1EFC : 36 00            KEYCLR: ld      (hl),0          ;;Clear KCOUNT
6281 1EFE : 18 F9                    jr      KEYFN2          ;;Clean up and return
6282 1EFF                    ;;Convert Keyboard Scan Code to ASCII Character
6283 1F00 : 34               KEYASC: inc     (hl)            ;;Increment KCOUNT
6284 1F01 : 06 7F                    ld      b,$7F           ;;Read column 7
6285 1F03 : ED 78                    in      a,(c)           ;;Get row
6286 1F05 : CB 6F                    bit     5,a             ;;Check Control key
6287 1F07 : DD 21 93 1F              ld      ix,CTLTAB-1     ;;Point to control table
6288 1F0B : 28 0C                    jr      z,KEYLUP        ;;Control? Do lookup
6289 1F0D : CB 67                    bit     4,a             ;;Check Shift key
6290 1F0F : DD 21 65 1F              ld      ix,SHFTAB-1     ;;Point to shift table
6291 1F13 : 28 04                    jr      z,KEYLUP        ;;Shift? Do lookup
6292 1F15 : DD 21 37 1F              ld      ix,KEYTAB-1
6293 1F19 : DD 19            KEYLUP: add     ix,de           ;;Get pointer into table
6294 1F1B : DD 7E 00                 ld      a,(ix+0)        ;;Load ASCII value
6295 1F1E : B7                       or      a               ;;Reserved Word?
6296 1F1F : F2 36 1F                 jp      p,KEYRET        ;;No, return ASCII code
6297 1F22 : D6 7F                    sub     $7F             ;;Convert to Reserved Word Count
6298 1F24 : 4F                       ld      c,a             ;;and copy to C
6299 1F25 : 21 44 02                 ld      hl,RESLST-1     ;;Point to Reserved Word List
6300 1F28 : 23               KEYRES: inc     hl              ;;Bump pointer
6301 1F29 : 7E                       ld      a,(hl)          ;;Get next character
6302 1F2A : B7                       or      a               ;;First letter of reserved word?
6303 1F2B : F2 28 1F                 jp      p,KEYRES        ;;No, loop
6304 1F2E : 0D                       dec     c               ;;Decrement Count
6305 1F2F : 20 F7                    jr      nz,KEYRES       ;;Not 0? Find next word
6306 1F31 : 22 0B 38                 ld      (RESPTR),hl     ;;Save Keyword Address
6307 1F34 : E6 7F                    and     $7F             ;;Strip high bit from first character
6308 1F36 : D9               KEYRET: exx                     ;;Restore Registers
6309 1F37 : C9                       ret
6310 1F38
6311 1F38                    ;;Unmodified Key Lookup Table
6312 1F38 : 3D 08 3A 0D      KEYTAB: byte    '=',$08,':',$0D,';','.' ;;Backspace and Return
6313 1F3C : 3B 2E
6314 1F3E : 2D 2F 30 70              byte    '-','/','0','p','l',',' ;
6315 1F42 : 6C 2C
6316 1F44 : 39 6F 6B 6D              byte    '9','o','k','m','n','j' ;
6317 1F48 : 6E 6A
6318 1F4A : 38 69 37 75              byte    '8','i','7','u','h','b' ;
6319 1F4E : 68 62
6320 1F50 : 36 79 67 76              byte    '6','y','g','v','c','f' ;
6321 1F54 : 63 66
6322 1F56 : 35 74 34 72              byte    '5','t','4','r','d','x' ;
6323 1F5A : 64 78
6324 1F5C : 33 65 73 7A              byte    '3','e','s','z',' ','a' ;
6325 1F60 : 20 61
6326 1F62 : 32 77 31 71              byte    '2','w','1','q'         ;
6327                         ;;Shifted Key Lookup Table
6328 1F66 : 2B 5C 2A 0D      SHFTAB: byte    '+',$5C,'*',$0D,'@','>' ;;Backslash, Return
6329 1F6A : 40 3E
6330 1F6C : 5F 5E 3F 50              byte    '_','^','?','P','L','<' ;
6331 1F70 : 4C 3C
6332 1F72 : 29 4F 4B 4D              byte    ')','O','K','M','N','J' ;
6333 1F76 : 4E 4A
6334 1F78 : 28 49 27 55              byte    '(','I',$27,'U','H','B' ;;Apostrophe
6335 1F7C : 48 42
6336 1F7E : 26 59 47 56              byte    '&','Y','G','V','C','F' ;
6337 1F82 : 43 46
6338 1F84 : 25 54 24 52              byte    '%','T','$','R','D','X' ;
6339 1F88 : 44 58
6340 1F8A : 23 45 53 5A              byte    '#','E','S','Z',' ','A' ;
6341 1F8E : 20 41
6342 1F90 : 22 57 21 51              byte    $22,'W','!','Q'         ;;Quotation Mark
6343 1F94
6344 1F94                    ;;Control Key Lookup Table
6345 1F94 : 82 1C C1 0D      CTLTAB: byte    $82,$1C,$C1,$0D,$94,$C4 ;;NEXT ^\ PEEK Return POKE VAL
6346 1F98 : 94 C4                                                    ;;
6347 1F9A : 81 1E 30 10              byte    $81,$1E,$30,$10,$CA,$C3 ;;FOR ^^ 0 ^P POINT STR$
6348 1F9E : CA C3                                                    ;;
6349 1FA0 : 92 0F 9D 0D              byte    $92,$0F,$9D,$0D,$C8,$9C ;;COPY ^O PRESET ^M RIGHT$, SET
6350 1FA4 : C8 9C                                                    ;;
6351 1FA6 : 8D 09 8C 15              byte    $8D,$09,$8C,$15,$08,$C9 ;;RETURN ^I GOSUB ^U ^H MID$
6352 1FAA : 08 C9                                                    ;;
6353 1FAC : 90 19 07 C7              byte    $90,$19,$07,$C7,$03,$83 ;;ON ^Y ^G LEFT$ ^C DATA
6354 1FB0 : 03 83                                                    ;;
6355 1FB2 : 88 84 A5 12              byte    $88,$84,$A5,$12,$86,$18 ;;GOTO INPUT THEN ^R READ ^X
6356 1FB6 : 86 18                                                    ;;
6357 1FB8 : 8A 85 13 9A              byte    $8A,$85,$13,$9A,$C6,$9B ;;IF DIM ^S CLOAD CHR$ CSAVE
6358 1FBC : C6 9B                                                    ;;
6359 1FBE : 97 8E 89 11              byte    $97,$8E,$89,$11         ;;LIST REM RUN ^Q
6360 1FC2
6361 1FC2                    ;;Check for Ctrl-C, called from NEWSTT
6362 1FC2 : E5               INCNTC: push    hl                      ;;Save text pointer
6363 1FC3 : 21 04 00                 ld      hl,4                    ;
6364 1FC6 : 39                       add     hl,sp                   ;
6365 1FC7 : 22 F9 38                 ld      (SAVSTK),hl             ;;Save stack pointer less 2 entries
6366 1FCA : E1                       pop     hl                      ;;Restore text pointer
6367 1FCB : C3 25 1A                 jp      ISCNTC                  ;;Check for Ctrl-C
6368 1FCE
6369 1FCE                    ;;Finish up Warm Start
6370 1FCE : 2A F9 38         WRMFIN: ld      hl,(SAVSTK)             ;;Restore stack pointer
6371 1FD1 : F9                       ld      sp,hl                   ;
6372 1FD2 : 2A CE 38                 ld      hl,(SAVTXT)             ;;Restore text pointer
6373 1FD5 : CD 20 0C                 call    STOPC                   ;;Enter direct mode
6374 1FD8
6375 1FD8                  + ;;Save Stack Pointer
6376 1FD8                  | ;;Called from STKINI. Stores stack pointer in TEMPST
6377 1FD8                  | ;;;This code is inline in all the reference sources
6378 1FD8 : 2B               STKSAV: dec     hl              ;TAKE INTO ACCOUNT FNDFOR STOPPER
6379 1FD9 : 2B                       dec     hl              ;
6380 1FDA : 22 F9 38                 ld      (SAVSTK),hl     ;MAKE SURE SAVSTK OK JUST IN CASE
6381 1FDD : 21 B1 38                 ld      hl,TEMPST       ;INCREMENT BACK FOR SPHL
6382 1FE0 : C9                       ret                     ;
6383 1FE1
6384 1FE1                    ;;Power Up/Reset Routine: Jumped to from RST 0
6385 1FE1 : 3E FF      [M80] JMPINI: ld      a,$FF           ;;Turn off printer and Cold Start
6386 1FE3 : D3 FE                    out     ($FE),a         ;;Write $FF to Printer Port
6387 1FE5 : C3 41 00                 jp      INIT            ;[M80] INIT IS THE INTIALIZATION ROUTINE
6388 1FE8
6389 1FE8                    ;;Start Extended Basic
6390 1FE8 : 3E AA            XBASIC: ld      a,$AA           ;;
6391 1FEA : D3 FF                    out     ($FF),a         ;;Write Unlock Code to Port 255
6392 1FEC : 32 09 38                 ld      (LASTFF),a      ;;Save It
6393 1FEF : C3 10 20                 jp      XSTART          ;;Jump to Extended BASIC Startup
6394 1FF2
6395 1FF2                    ;;Called from COLDST to print BASIC startup message
6396 1FF2 : 21 5F 01   [GWB] PRNTIT: ld      hl,HEDING       ;Print copyright message and return
6397 1FF5 : C3 9D 0E                 jp      STROUT          ;
6398 1FF8
6399 1FF8                    ;;Pad rest of ROM space
6400 1FF8 : F5 F5 F5 F5              byte    $F5,$F5,$F5,$F5,$F5,$F5,$F5,$F5
6401 1FFC : F5 F5 F5 F5
6402 2000 :                          end                    ;End of Program!
Complete.
