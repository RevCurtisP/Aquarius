;;Mattel Aquarius Microsoft Basic ROM disassembly

;;
;;Annotated by Curtis F Kaylor
;;
;;Originally disassembled with dasmx, but modified to match TASM syntax

;;Listing format:
;;
;;  Lines beginning with ; are metacomments, i.e. not part of the source code
;;
;;  Lines beginning with : are temporary lines to allow progressive testing of 
;;  conversion to a source file and subsequent assembly. They will be added
;;  and removed as needed until the generated source code fully assembles.



;;Labels and comments are taken from the following:
;;  Original Source Code (Canonical Labels and Comments)
;;    [M80] Microsoft Basic-80 5.2 Source [198]
;;          winworldpc.com/product/microsoft-basic/80
;;    [M65] Microsoft BASIC for 6502 Original Source Code [1978]
;;          www.pagetable.com/?p=774
;;    [GWB] Microsoft GW-BASIC Interpreter Source Code [1983]
;;          https://github.com/microsoft/GW-BASIC
;;  Commented Disassemby Listings (Non-Canonical)
;;    [A4K] Altair BASIC 3.2 (4K) - Annotated Disassembly [1975]
;;          altairbasic.org/
;;    [A8K] Altair BASIC 84K - Disassembly [1978]
;;          www.autometer.de/unix4fun/z80pack/ftp/altair/basic8k78.orge
;;    [TR1] TRS-80 Model I Level II Basic ROM Disassembly
;;          http://www.trs-80.com/wordpress/zaps-patches-pokes-tips/rom-cpu-info-page/
;;  Third Party Reference Materials (Non-Canonical)
;;    [L2R] Level II ROM Reference Manual [1980]
;;          https://www.classic-computers.org.nz/system-80/manuals_Level%20II%20ROM%20Reference%20Manual.pdf
;;    [M64] COMPUTE!'s Mapping the C64
;;
;;Label sources are denoted to the left of the label and comment sources are denoted at the beginning of the comment.
;;
;;Comments taken from the above sources are preceded by a single semicolon, while unsourced comments
;;are preceded by two semicolons, and annotations are preceded by three semicolons.

                        ;;BASIC Constants
                        CLMWID  equ     14      ;[M80] MAKE COMMA COLUMNS FOURTEEN CHARACTERS
                        LPTSIZ  equ     132     ;{M80} WIDTH OF PRINTER

                        ;;System Variables
                        SCREEN  equ     $3000   ;;Screen Character Matrix
                        COLOR   equ     $3400   ;;Screen Color Matrix
                  [M80] TTYPOS  equ     $3800   ;[M80] STORE TERMINAL POSITION HERE
                        CURRAM  equ     $3801   ;;Position in CHARACTER RAM of cursor
                  [M65] USRPOK  equ     $3803   ;;JP instruction for USR() routine
                        USRADD  equ     $3804   ;;Address of USR routine
                        HOOK    equ     $3806   ;;Extended ROM Hook Vector
                  [M80] CNTOFL  equ     $3808   ;;Line Counter. If not 0,  
                        LASTFF  equ     $3809   ;;Last value last output to port #FF
                        CHARC   equ     $380A   ;[M80] ISCNTC STORES EATEN CHAR HERE WHEN NOT A ^C
                        RESPTR  equ     $380B   ;;Pointer to Ctrl-Key Reserved Word    
                        CURCHR  equ     $380D   ;;Character under Cursor
                  [M64] LSTX    equ     $380E   ;[M64] Matrix Coordinate of Last Key Pressed
                        KCOUNT  equ     $380F   ;;Keyboard debounce counter
                  [M80] FDIVC   equ     $3810   ;    
                  [M80] FDIVB   equ     $3814   ;    
                  [M80] FDIVA   equ     $3818   ;    
                  [M80] FDIVG   equ     $381B   ;    
                        ;               $381E   ;{M80} RND FUNCTION PERTUBATION COUNT
                  [M80] RNDCNT  equ     $381F   ; 
                  [M80] ;       equ     $3820   ; 
                  [M80] RNDTAB  equ     $3821   ;;Unused Random Number TABLE
                                                ;;;The exact same table exists in CP/M Basic where it is unused
                        RNDX    equ     $3841   ;[M80] LAST RANDOM NUMBER GENERATED, BETWEEN 0 AND 1
                  [M80] LPTPOS  equ     $3846   ;[M80] POSITION OF LPT PRINT HEAD
                  [M80] PRTFLG  equ     $3847   ;[M80] WHETHER OUTPUT GOES TO LPT
                        LINLEN  equ     $3848   ;;Length of a Screen Line
                        CLMLST  equ     $3849       
                  [M80] RUBSW   equ     $384A   ;[M80] RUBOUT SWITCH =1 INSIDE THE PROCESSING OF A RUBOUT (INLIN)
                  [M80] TOPMEM  equ     $384B   ;[M80] TOP LOCATION TO USE FOR THE STACK INITIALLY SET UP BY INIT 
                                                ;[M80] ACCORDING TO MEMORY SIZE TO ALLOW FOR 50 BYTES OF STRING SPACE.
                                                ;[M80] CHANGED BY A CLEAR COMMAND WITH AN ARGUMENT.
                  [M80] CURLIN  equ     $384D   ;[M80] CURRENT LINE #
                  [M80] TXTTAB  equ     $384F   ;[M80] POINTER TO BEGINNING OF TEXT
                                                ;[M80] DOESN'T CHANGE AFTER BEING SETUP BY INIT.
                  [GWB] FILNAM  equ     $3851   ;;File Name for CSAVE and CLOAD    
                        FILNAF  equ     $3857   ;;File Name Read from Cassette
                        INSYNC  equ     $385D   ;;Contains $FF between read of SYNC and data from tape         
                        CLFLAG  equ     $385E   ;;Flags whether doing CLOAD (0) or CLOAD? ($FF)
                        BUFMIN  equ     $385F   ;{M80} START OF BUFFER
                  [M80] BUF     equ     $3860   ;[M80] TYPE IN STORED HERE. DIRECT STATEMENTS EXECUTE OUT OF HERE. 
                                                ;[M80] REMEMBER "INPUT" SMASHES BUF. MUST BE AT A LOWER ADDRESS THAN DSCTMP 
                                                ;[M80] OR ASSIGNMENT OF STRING VALUES IN DIRECT STATEMENTS WON'T COPY INTO 
                                                ;[M80] STRING SPACE -- WHICH IT MUST ALLOW FOR SINGLE QUOTE IN BIG LINE
                  [M80] ENDBUF  equ     $38A9   ;[M80] PLACE TO STOP BIG LINES
                  [M80] BUFLEN  = ENDBUF-BUF-1  ;;Buffer Length
                  [M80] DIMFLG  equ     $38AA   ;[M80] IN GETTING A POINTER TO A VARIABLE IT IS IMPORTANT TO REMEMBER 
                                                ;[M80] WHETHER IT IS BEING DONE FOR "DIM" OR NOT
                  [M80] VALTYP  equ     $38AB   ;[M80] THE TYPE INDICATOR 0=NUMERIC 1=STRING
                  [M80] DORES   equ     $38AC   ;[M80] WHETHER CAN OR CAN'T CRUNCH RES'D WORDS TURNED ON WHEN "DATA"
                                                ;[M80] BEING SCANNED BY CRUNCH SO UNQUOTED STRINGS WON'T BE CRUNCHED.
                  [M80] MEMSIZ  equ     $38AD   ;[M80] HIGHEST LOCATION IN MEMORY
                  [M80] TEMPPT  equ     $38AF   ;[M80] POINTER AT FIRST FREE TEMP DESCRIPTOR. INITIALIZED TO POINT TO TEMPST
                  [M80] TEMPST  equ     $38B1   ;[M80] STORAGE FOR NUMTMP TEMP DESCRIPTORS
                  [M80] DSCTMP  equ     $38BD   ;[M80] STRING FUNCTIONS BUILD ANSWER DESCRIPTOR HERE
                  [M80] FRETOP  equ     $38C1   ;[M80] TOP OF STRING FREE SPACE
                  [M80] TENP3   equ     $38C3   ;[M80] USED MOMENTARILY BY FRMEVL. USED IN EXTENDED BY FOUT AND
                                                ;[M80] USER DEFINED FUNCTIONS ARRAY VARIABLE HANDLING TEMPORARY
                  [M80] TEMP8   equ     $38C5   ;[M80] USED TO STORE THE ADDRESS OF THE END OF STRING ARRAYS IN GARBAGE COLLECTION
                  [M80] ENDFOR  equ     $38C7   ;[M80] SAVED TEXT POINTER AT END OF "FOR" STATEMENT
                  [M80] DATLIN  equ     $38C9   ;[M80] DATA LINE # -- REMEMBER FOR ERRORS
                  [M80] SUBFLG  equ     $38CB   ;[M80] FLAG WHETHER SUBSCRIPTED VARIABLE ALLOWED "FOR" AND USER-DEFINED 
                                                ;[M80] FUNCTION POINTER FETCHING TURN THIS ON BEFORE CALLING PTRGET SO 
                                                ;[M80] ARRAYS WON'T BE DETECTED. STKINI AND PTRGET CLEAR IT.
                  [M80] USFLG   equ     $38CC   ;;Direct Mode Flag    
                  [M80] FLGINP  equ     $38CD   ;[M80] FLAGS WHETHER WE ARE DOING "INPUT" OR A READ
                  [M80] SAVTXT  equ     $38CE   ;[M80] PLACE WHERE NEWSTT SAVES TEXT POINTER
                  [M80] TENP2   equ     $38D0   ;[M80] FORMULA EVALUATOR TEMP MUST BE PRESERVED BY OPERATORS
                                                ;[M80] USED IN EXTENDED BY FOUT AND USER-DEFINED FUNCTIONS
                  [M80] OLDLIN  equ     $38D2   ;[M80] OLD LINE NUMBER (SETUP BY ^C,"STOP" OR "END" IN A PROGRAM)
                  [M80] OLDTXT  equ     $38D4   ;[M80] OLD TEXT POINTER
                  [M80] VARTAB  equ     $38D6   ;[M80] POINTER TO START OF SIMPLE VARIABLE SPACE. UPDATED WHENEVER 
                                                ;[M80] THE SIZE OF THE PROGRAM CHANGES, SET TO [TXTTAB] BY SCRATCH ("NEW").
                  [M80] ARYTAB  equ     $38D8   ;[M80] POINTER TO BEGINNING OF ARRAY TABLE. INCREMENTED BY 6 WHENEVER 
                                                ;[M80] A NEW SIMPLE VARIABLE IS FOUND, AND SET TO [VARTAB] BY CLEARC.
                  [M80] STREND  equ     $38DA   ;[M80] END OF STORAGE IN USE. INCREASED WHENEVER A NEW ARRAY 
                                                ;[M80] OR SIMPLE VARIABLE IS ENCOUNTERED SET TO [VARTAB] BY CLEARC.
                  [M80] DATPTR  equ     $38DC   ;[M80] POINTER TO DATA. INITIALIZED TO POINT AT THE ZERO IN FRONT OF [TXTTAB]
                                                ;[M80] BY "RESTORE" WHICH IS CALLED BY CLEARC. UPDATED BY EXECUTION OF A "READ"
                  [M65] VARNAM  equ     $38DE   ;;Variable Name
                  [M65] VARPNT  equ     $38E0   ;;Pointer to Variable
;                                       $38E2   ;;Used by Extended BASIC
;                                       $38E3   ;;Unused
                  [M80] FACLO   equ     $38E4   ;[M80] LOW ORDER OF MANTISSA
                  {M80} FACMO   equ     $38E5   ;[M80] MIDDLE ORDER OF MANTISSA
                  [M80] FACHO   equ     $38E6   ;[M80] HIGH ORDER OF MANTISSA
                  [M80] FAC     equ     $38E7   ;[M80] EXPONENT
                  [M80] FBUFFR  equ     $38E8   ;[M80[ BUFFER FOR FOUT
                  [M65] RESHO   equ     $38F6   ;[M65] RESULT OF MULTIPLIER AND DIVIDER    
                  [M65] RESMO   equ     $38F7   ;;RESMO and RESLO are loaded into and stored from HL 
                  {M65} RESLO   equ     $38F8   ;
                  [M80] SAVSTK  equ     $38F9   ;[M80] NEWSTT SAVES STACK HERE BEFORE SO THAT ERROR REVERY CAN
                                                ;[M80] CAN RESTORE THE STACK WHEN AN ERROR OCCURS
                        ;;              $3900   ;;This is always 0
                        BASTXT  equ     $3901   ;;Start of Basic Program 

                        ;;External Addresses
                        EXTBAS  equ     $2000   ;;Start of Extended Basic
                        XSTART  equ     $2010   ;;Extended BASIC Startup Routine
                        XINIT   equ     $E010   ;;ROM Cartridge Initialization Entry Point

                                .org    0       ;;Starting Address of ROM
                         
0000                  + ;;RST 0 - Startup
0000                  | ;;On power up or reset, the Z80 jumps to this RST
0000                  | ;;The instruction RST START is functionally equivalent to doing
0000                  | ;;a hardware reset.
0000 : C3 E1 1F   [M80] START:  jp      JMPINI          ;;Start Initialization
0003 : 82 06 22                 byte    $82,$06,$22     ;;Revision Date 1982-06-22
0006 : 0B                       byte    11              ;;Revision Number?
0007 : 00                       nop                     ;;Pad out the RST routine
0008
0008                  + ;;RST 1 - Syntax Check
0008                  | ;;Check for Matching Character
0008                  | ;[M65] "SYNCHK" LOOKS AT THE CURRENT CHARACTER TO MAKE SURE IT
0008                  | ;[M65] IS THE SPECIFIC THING IN THE BYTE IMMEDIATELY FOLLOWING
0008                  | ;[M65] "RST SYNCHK". IF NOT, IT CALLS THE "SYNTAX ERROR" ROUTINE.
0008                  | ;[M65] OTHERWISE IT GOBBLES THE NEXT CHAR AND RETURNS,
0008                  | ;
0008                  | ;[M65] [A]=NEW CHAR AND [H,L] IS ADVANCED BY "CHRGET".
0008                  | ;
0008                  | ;;;In Basic versions that don't use RST, this routine is named SYNCHR
0008 : 7E         [M80] SYNCHK: ld      a,(hl)
0009 : E3                       ex      (sp),hl
000A : BE                       cp      (hl)                    ;[M65] CHARACTERS EQUAL?
000B : 23                       inc     hl
000C : E3                       ex      (sp),hl
000D : C2 C4 03                 jp      nz,SNERR                ;[M65] "SYNTAX ERROR"
0010
0010                  + ;;RST 2 - Get Next Character
0010                  | ;[M80] CHRGET - THE NEXT CHARACTER SCAN ROUTINE
0010                  | ;[M65] "CHRGET" USES [H,L] AS THE CURRENT TEXT PNTR
0010                  | ;[M65] FETCHES A NEW CHARACTER INTO ACCA AFTER INCREMENTING [H,L]
0010                  | ;[M65] AND SETS CONDITION CODES ACCORDING TO WHAT'S IN ACCA.
0010                  | ;[M65]       NOT C=  NUMERIC   ("0" THRU "9")
0010                  | ;[M65]       Z=      ":" OR END-OF-LINE (A NULL)
0010                  | ;[M65]
0010                  | ;[M65] [ACCA] = NEW CHAR.
0010                  | ;[M65] [H,L]=[H,L]+1
0010                  | 
0010                  | ;;Since the text pointer is kept in HL, the 8080 versions of Basic
0010                  | ;;use LD A,HL to get the current character, rather than CHRGOT
0010                  |
0010                  | ;;;Basic versions that don't use RST use CALL CHRGTR instead
0010 : 23         [M65] CHRGET: inc     hl              ;[M65] INCREMENT THE TEXT PNTR
0011 : 7E         {M65} CHRGOT: ld      a,(hl)          ;;Entry point to get current character
0012 : FE 3A      {M65} QNUM:   cp      ':'             ;[M65] IS IT A ":"?
0014 : D0                       ret     nc              ;[M65] IT IS .GE. ":"
0015 : C3 70 06                 jp      CHRCON          ;;Continue in CHRGETR
0018
0018                  + ;;RST 3 - Output Character
0018                  | ;{M80}  RST OUTCHR prints char in [A] no registers affected
0018                  | ;{M80}    to either terminal or printer depending on flag:
0018                  | ;{M80}    PRTFLG if non-zero print to printer
0018                  | ;
0018                  | ;;;Basic versions that don't use RST use CALL OUTDO instead
0018 : C3 8A 19   [GWB] OUTCHR: jp      OUTDO           ;; Execute print character routine
001B : 00 00 00 00              byte    0,0,0,0,0       ;; Pad out the RST routine
001F : 00                                               ;;; (The hook call code from OUTDO could be moved here)
0020
0020                  + ;;RST 4 - Integer Compare
0020                  | ;[TR1] Compares HL with DE. After execution, 
0020                  | ;;If HL = DE, Z flag is set 
0020                  | ;;If HL <> DE, Z flag is reset
0020                  | ;;If HL < DE, C flag is set
0020                  | ;;If HL >= DE, C flag is reset
0020                  | ;;;In versions that don't use RST, this routine is named DCOMPR
0020 : 7C         [M80] COMPAR: ld      a,h             ;;Compare [DE] to [HL]
0021 : 92                       sub     d               ;;Sets Z flag if equal
0022 : C0                       ret     nz              ;;Sets Carry if [DE] > [HL]
0023 : 7D                       ld      a,l             ;;Destroys [A]
0024 : 93                       sub     e               ;
0025 : C9                       ret                     ;
0026 : 00 00                    byte    0,0             ;; Pad out the RST routine
0028
0028                  + ;;RST 5 - Get sign of Floating Point Argument
0028                  | ;[M80] PUT SIGN OF FAC IN A.
0028                  | ;[M80] ALTERS A ONLY
0028                  | ;[M80] LEAVES FAC ALONE
0028                  | ;
0028                  | ;;;Basic versions that don't use RST use CALL SIGN insteaoard
0028 : 3A E7 38   [M80] FSIGN:  ld      a,(FAC)         ;
002B : B7                       or      a               ;[M65] IF NUMBER IS ZERO, SO IS RESULT
002C : C2 EB 14                 jp      nz,SIGNC        ;;Check sign of mantissa if not 0
002F : C9                       ret                     ;
0030
0030                  + ;;RST 6 - Extended BASIC Hook Dispatch
0030                  | ;;The additional functionality of Extended Basic are invoked via this RST.
0030                  | ;;Each RST HOOK instruction is followed by a byte that indicates which hook
0030                  | ;;routine to execute. On startup, this routine jumps to NOHOOK, which skips
0030                  | ;;the hook number byte the does a RET.
0030                  | ;;
0030                  | ;;Extended Basic overwrites the address in HOOK, enabling hook dispatch.
0030                  | ;;
0030                  } ;;
0030                  | ;;*** TODO: List the hook routines.  
0030 : DD 2A 06 38      HOOKDO: ld      ix,(HOOK)       ;;Get hook routine address
0034 : DD E9                    jp      (ix)            ;;and jump to it
0036 : 00 00                    byte    0,0             ;;Pad out RST routine
0038
0038                  + ;;RST 7 - Execute USR Routine
0038                  | ;;The instruction RST USRFN executes user defined code at
0038                  | ;;the address in USR via the JP instruction in USRPOK.
0038                  | ;;
0038                  | ;;This is the same entry point used by the USR function.
0038                  | ;;***TODO: how to detect a USR() call
0038 : C3 03 38   [M80] USRFN:  jp      USRPOK          ;;Execute USR() routine
003B
003B                  + ;;Default Extended BASIC Hook Routine
003B                  | ;;The system variable HOOK is loaded with the address of this 
003B                  | ;;routine on startup, so that all RST HOOK instructions
003B                  | ;;are routed here. 
003B                  | ;;
003B                  | ;;This routine returns to the second byte after the RST 
003B                  | ;;RST instruction, preserving all registers.
003B : D9               NOHOOK: exx                     ;;Save BC, DE, and HL
003C : E1                       pop     hl              ;;Get return address off stack
003D : 23                       inc     hl              ;;Increment to skip byte after RST
003E : E5                       push    hl              ;;Put new return address on stack
003F : D9                       exx                     ;;Restore BC, DE, and HL 
0040 : C9                       ret                     ;;and Return
0041
0041 : 31 A0 38   [M80] INIT:   ld      sp,$38A0        ;[M80] SET UP TEMP STACK
0044 : 3E 0B                    ld      a,11            ;
0046 : CD 94 1D                 call    TTYOUT          ;;Print CLS to Clear Screen
0049 : 2A 01 38                 ld      hl,(CURRAM)     ;
004C : 36 20                    ld      (hl),' '        ;;Place Space on Screen
004E : 3E 07                    ld      a,7             ;
0050 : CD 94 1D                 call    TTYOUT          ;;Print BEL to Sound Beep 
0053 : AF                       xor     a               ;
0054 : D3 FF                    out     ($FF),a         ;;Output 0 to I/O Port 255;
0056 : 21 FF 2F                 ld      hl,$2FFF        ;
0059 : 22 5D 38                 ld      (INSYNC),hl     ;
005C
005C                    ;;Check for Catridge ROM at $E010
005C : 11 11 E0         CRTCHK: ld      de,$E011        ;
005F : 21 81 00                 ld      hl,CRTSIG-1     ;
0062 : 1B         (~~~) CRTCH1: dec     de              ;
0063 : 1B                       dec     de              ;
0064 : 23                       inc     hl              ;
0065 : 1A                       ld      a,(de)          ;
0066 : 0F                       rrca                    ;
0067 : 0F                       rrca                    ;
0068 : 83                       add     a,e             ;
0069 : BE                       cp      (hl)            ;
006A : 28 F6                    jr      z,CRTCH1        ;
006C : 7E                       ld      a,(hl)          ;
006D : B7                       or      a               ;
006E : 20 19                    jr      nz,RESET        ;;ROM not found, start Basic
0070 : EB                       ex      de,hl           ;
0071 : 06 0C                    ld      b,00CH          ;
0073 : 86         (~~~) CRTCH2: add     a,(hl)          ;
0074 : 23                       inc     hl              ;
0075 : 80                       add     a,b             ;
0076 : 05                       dec     b               ;
0077 : 20 FA                    jr      nz,CRTCH2       ;
0079 : AE                       xor     (hl)            ;
007A : D3 FF                    out     ($FF),a         ;
007C : 32 09 38                 ld      (LASTFF),a      ;
007F : C3 10 E0                 jp      XINIT           ;;Execute Catridge Code
0082
0082 : 2B 37 24 24      CRTSIG: byte    "+7$$3,",0      ;;$A000 Cartridge Signature
0086 : 33 2C 00
0089
0089                  + ;;Display Startup Screen
0089                  | ;;Copies the bytes at BASICT and STARTT directly to
0089                  | ;;specific positions in screen memory.
0089 : 11 A1 31         RESET:  ld      de,SCREEN+417           ;;Display "BASIC"
008C : 21 B0 00                 ld      hl,BASICT               ;;at line 10, column 17
008F : 01 05 00                 ld      bc,STARTT-BASICT        ;
0092 : ED B0                    ldir                            ;
0094 : 11 10 32                 ld      de,SCREEN+528           ;;Display Start Message
0097 : 21 B5 00                 ld      hl,STARTT               ;at line 13, column 8
009A : 01 19 00                 ld      bc,STARTE-STARTT        ;
009D : ED B0                    ldir                            ;
009F
009F                  + ;;Cycle Screen Colors
009F                  | ;;Cycles through backround colors by sequentially
009F                  | ;;calling the COLORS routine in a loop.
009F : 06 03            CYCLE:  ld      b,3             ;; Black on Yellow
00A1 : CD CF 00                 call    COLORS          ;
00A4 : 06 02                    ld      b,2             ;; Black on Green
00A6 : CD CF 00                 call    COLORS          ;
00A9 : 06 06                    ld      b,6             ;; Black on Light Cyan
00AB : CD CF 00                 call    COLORS          ;
00AE : 18 EF                    jr      CYCLE           ;
0080
0080                  + ;;Start Screen Text
0080                  | ;;Copied directly into Screen RAM by the RESET routine
00B0 : 42 41 53 49      BASICT: byte    "BASIC"                         ;
00B4 : 43
00B5 : 50 72 65 73      STARTT: byte    "Press RETURN key to start"     ;
00B9 : 73 20 52 45
00BD : 54 55 52 4E
00C1 : 20 6B 65 79
00C5 : 20 74 6F 20
00C9 : 73 74 61 72
00CD : 74       
00CE : 00               STARTE: byte    0               ;;End of String
00CF
00CF                  + ;;Set Screen Colors and Check for Keypress
00CF                  | ;;Fills color RAM with the foreground/backround colors
00CF                  | ;;pssed in the accumulator, then goes into a delay loop
00CF                  | ;;that checks for a keypress.
00CF                  | ;;
00CF                  | ;;If RETURN is pressed, execution passes to COLDST,
00CF                  | ;;initializing the Basic interpreter,
00CF                  | ;;
00CF                  | ;;If CTRL-C is pressed, execution passes to WARMST,
00CF                  | ;;preserving the Basic program and returning the user
00CF                  | ;;to the "Ok" prompt.
00CF : 21 00 34         COLORS: ld      hl,COLOR        ;;Store Accumulator in all bytes of Color
00D2 : 70         (~~~) COLOR1: ld      (hl),b          ;;memory, addresses $3400 through $3FFF
00D3 : 23                       inc     hl              ;;
00D4 : 7C                       ld      a,h             ;;NOTE: This wipes out $3B80 through $3FFF,
00D5 : FE 38                    cp      $38             ;;which are after the end of Color memory.
00D7 : 20 F9                    jr      nz,COLOR1       ;
00D9 : 21 00 40                 ld      hl,$4000        ;;Loop 12,288 times
00DC : CD 80 1E   (~~~) COLOR2: call    INCHRC          ;;Check for keypress
00DF : FE 0D                    cp      13              ;{M80} IS IT A CARRIAGE RETURN?
00E1 : 28 1A                    jr      z,COLDST        ;;Cold Start
00E3 : FE 03                    cp      3               ;;Is it CTRL-C?
00E5 : 28 06                    jr      z,WARMST        ;;Warm Start
00E7 : 2B                       dec     hl              ;;Decrement Counter
00E8 : 7C                       ld      a,h             ;
00E9 : B5                       or      l               ;
00EA : 20 F0                    jr      nz,COLOR2       ;;If not 0, loop
00EC : C9                       ret                     ;;Back to CYCLE
00ED
00ED                  + ;;Basic Interpreter Warm Start
00ED                  | ;;Clears the screen, resets I/O port $FF, initializes
00ED                  | ;;the hardware stack, 
00ED                  | ;;***then does other stuff.
00ED : 3E 0B            WARMST: ld      a,11            ;
00EF : CD 72 1D                 call    TTYCHR          ;;Clear Scree,
00F2 : 3A 09 38                 ld      a,(LASTFF)      ;
00F5 : D3 FF                    out     ($FF),a         ;;Reset I/O Port 255 
00F7 : CD E5 0B                 call    STKINI          ;;Initialize stack
00FA : CD 40 1A                 call    WRMCON          ;;Finish Up
00FD
00FD : 21 87 01         COLDST: ld      hl,DEFALT       ;Set System Variable Default Values
0100 : 01 51 00                 ld      bc,81           ;
0103 : 11 03 38                 ld      de,USRPOK       ;;Copy 80 bytes starting at DEFALT
0106 : ED B0                    ldir                    ;;to the first 80 bytes of System Variables
0108 : AF                       xor     a               ;
0109 : 32 A9 38                 ld      (ENDBUF),a      ;;Clear byte after end of BUF
010C : 32 00 39                 ld      (BASTXT-1),a    ;;Clear byte before start of basic program
010F                    ;;Test Memory to Find Top of RAM
010F : 21 64 39                 ld      hl,BASTXT+99    ;;Set RAM Test starting address
0112 : 23               MEMTST: inc     hl              ;;Bump pointer
0113 : 4E                       ld      c,(hl)          ;;Save contents of location
0114 : 7C                       ld      a,h             ;
0115 : B5                       or      l               ;;Wrapped around to $0000?
0116 : 28 0B                    jr      z,MEMCHK        ;;Yes, go on to check memory
0118 : A9                       xor     c               ;;Scramble bits into A 
0119 : 77                       ld      (hl),a          ;;and write to location
011A : 46                       ld      b,(hl)          ;;Read back into B
011B : 2F                       cpl                     ;;Invert scrambled bits
011C : 77                       ld      (hl),a          ;;Write to location
011D : 7E                       ld      a,(hl)          ;;read it back
011E : 2F                       cpl                     ;;and revert back
011F : 71                       ld      (hl),c          ;;Write original byte to location
0120 : B8                       cp      b               ;;Did reads match writes?
0121 : 28 EF                    jr      z,MEMTST        ;;Yes, check next location
0123                    ;;Check Memory Size             ;
0123 : 2B         (~~~) MEMCHK: dec     hl              ;;Back up to last good address
0124 : 11 2C 3A                 ld      de,BASTXT+299   ;
0127 : E7                       rst     COMPAR          ;;Is there enough RAM?
0128 : DA B7 0B                 jp      c,OMERR         ;;No, Out of Memory error
012B                    ;;Set Top of memory 
012B : 11 CE FF   {~~~} MEMSET: ld      de,$FFCE        
012E : 22 AD 38                 ld      (MEMSIZ),hl     ;;Set MEMSIZ to last RAM location
0131 : 19                       add     hl,de
0132 : 22 4B 38                 ld      (TOPMEM),hl     ;;Set TOPMEM t0 MEMSIZ-50
0135 : CD BE 0B                 call    SCRTCH          ;;Perform NEW
0138 : CD F2 1F                 call    PRNTIT          ;;Print copyright message
013B : 31 65 38                 ld      sp,$03865       ;;Top of of stack used to be here 
013E : CD E5 0B                 call    STKINI          ;;Set stack pointer to TOPMEM
0141                    ;;Check for Extended BASIC
0141 : 21 05 20                 ld      hl,EXTBAS+5     ;;End of signature in Extended BASIC
0144 : 11 82 00                 ld      de,CRTSIG       ;;Text to check signature against
0147 : 1A         (~~~) EXTCHK: ld      a,(de)          ;;Get byte from signature
0148 : B7                       or      a               ;;Did we reach a terminator?
0149 : CA E8 1F                 jp      z,XBASIC        ;;Yes, start Extended BASIC
014C : BE                       cp      (hl)            ;;Does it match byte in ROM?
014D : 20 04                    jr      nz,INITFF       ;;No, move on
014F : 2B                       dec     hl              ;;Move backward in Extended BASIC
0150 : 13                       inc     de              ;;and forward in test signature 
0151 : 18 F4                    jr      EXTCHK          ;;Compare next character
0153
0153                    ;;Initialize I/O Port 255
0153 : ED 5F      (~~~) INITFF: ld      a,r             ;;Read random number from Refresh Register
0155 : 17                       rla                     ;;Rotate left
0156 : 81                       add     a,c             ;;Copy in bit that was rotated out
0157 : D3 FF                    out     ($FF),a         ;;Write it to I/O Port 255
0159 : 32 09 38                 ld      (LASTFF),a      ;;and save it for later
015C : C3 02 04                 jp      READY           ;;Enter direct mode
015F
015F : 0B         [GWB] HEDING: byte    11
0160 : 43 6F 70 79              byte    "Copyright ",5," "
0164 : 72 69 67 68
0168 : 74 20 05 20
016C : 31 39 38 32              byte    "1982 by Microsoft Inc. S2",10,0
0170 : 20 62 79 20
0174 : 4D 69 63 72
0178 : 6F 73 6F 66
017C : 74 20 49 6E
0180 : 63 2E 20 53
0184 : 32 0A 00   
0187
0187                            ;;System Variable Default Values - 81 ($51) bytes
0187 : C3 97 06         DEFALT: jp      FCERR           ;;3803 USRPOK
018A : 3B 00                    word    NOHOOK          ;;3806 HOOK
018C : 00                       byte    0               ;;3808 CNTOFL
018D : A3                       byte    163             ;;3809 LASTFF
018E : 00                       byte    0               ;;380A CHARC 
018F : 00 00                    word    0               ;;380B RESPTR
0191 : 20                       byte    ' '             ;;380D CURCHR
0192 : 00                       byte    0               ;;380E LSTX  
0193 : 00                       byte    0               ;;380F KCOUNT
0194 : D6 00                    sub     $00             ;;3810 FDIVC 
0196 : 6F                       ld      l,a             ;;3812       
0197 : 7C                       ld      a,h             ;;3813       
0198 : DE 00                    sbc     a,00            ;;3814 FDIVB 
019A : 67                       ld      h,a             ;;3816       
019B : 78                       ld      a,b             ;;3817       
019C : DE 00                    sbc     a,00            ;;3818 FDIVA 
019E : 47                       ld      b,a             ;;381A       
019F : 3E 00                    ld      a,0             ;;381B FDIVG 
01A1 : C9                       ret                     ;;381D          
01A2 : 00                       byte    0               ;;381E          
01A3 : 00                       byte    0               ;;381F RNDCNT 
01A4 : 00                       byte    0               ;;3820
01A5 : 35 4A CA 99              byte    $35,$4A,$CA,$99 ;;3821 RNDTAB
01A9 : 39 1C 76 98              byte    $39,$1C,$76,$98 ;;3825
01AD : 22 95 B3 98              byte    $22,$95,$B3,$98 ;;3829
01B1 : 0A DD 47 98              byte    $0A,$DD,$47,$98 ;;383D
01B5 : 53 D1 99 99              byte    $53,$D1,$99,$99 ;;3831
01B9 : 0A 1A 9F 98              byte    $0A,$1A,$9F,$98 ;;3835
01BD : 65 BC CD 98              byte    $65,$BC,$CD,$98 ;;3839
01C1 : D6 77 3E 98              byte    $D6,$77,$3E,$98 ;;383D
01C5 : 52 C7 4F 80              byte    $52,$C7,$4F,$80 ;;3841 RNDX
01C9 : 00                       byte    $00             ;;3845
01CA : 00                       byte    $00             ;;3846 LPTPOS
01CB : 00                       byte    $00             ;;3847 PRTFLG
01CC : 28                       byte    $28             ;;3848 LINLEN
01CD : 0E                       byte    $0E             ;;3849 CLMLST
01CE : 00                       byte    $00             ;;384A RUBSW 
01CF : 64 39                    byte    $64,$39         ;;384B TOPMEM
01D1 : FE FF                    byte    $FE,$FF         ;;384D CURLIN
01D3 : 01 39                    byte    $01,$39         ;;384F TXTTAB
01D5
01D5                  + ;[M65] STATEMENT DISPATCH ADDRESSES
01D5                  | ;[M65] WHEN A STATEMENT IS TO BE EXECUTED, THE FIRST
01D5                  | ;[M65] CHARACTER OF THE STATEMENT IS EXAMINED
01D5                  | ;[M65] TO SEE IF IT IS LESS THAN THE RESERVED
01D5                  | ;[M65] WORD TOKEN FOR THE LOWEST NUMBERED STATEMENT NAME.
01D5                  | ;[M65] IF SO, THE "LET" CODE IS CALLED TO
01D5                  | ;[M65] TREAT THE STATEMENT AS AN ASSIGNMENT STATEMENT.
01D5                  | ;[M65] OTHERWISE A CHECK IS MADE TO MAKE SURE THE
01D5                  | ;[M65] RESERVED WORD NUMBER IS NOT TOO LARGE TO BE A
01D5                  | ;[M65] STATEMENT TYPE NUMBER. IF NOT THE ADDRESS
01D5                  | ;[M65] TO DISPATCH TO IS FETCHED FROM "STMDSP" (THE STATEMENT
01D5                  | ;[M65] DISPATCH LIST) USING THE RESERVED WORD
01D5                  | ;[M65] NUMBER FOR THE STATEMENT TO CALCULATE AN INDEX INTO
01D5                  | ;[M65] THE LIST.
01D5                  | ;
01D5              [M65] STMDSP: ;MARKS START OF STATEMENT LIST
01D5 : 21 0C                    word    ENDS            ;;$0C21
01D7 : BC 05                    word    FOR             ;;$05BC
01D9 : 13 0D                    word    NEXT            ;;$0D13
01DB : 1C 07                    word    DATA            ;;$071C
01DD : 93 08                    word    INPUT           ;;$0893
01DF : CC 10                    word    DIM             ;;$10CC
01E1 : BE 08                    word    READ            ;;$08BE
01E3 : 31 07                    word    LET             ;;$0731
01E5 : DC 06                    word    GOTO            ;;$06DC
01E7 : BE 06                    word    RUN             ;;$06BE
01E9 : 9C 07                    word    IFS             ;;$079C
01EB : 05 0C                    word    RESTOR          ;;$0C05
01ED : CB 06                    word    GOSUB           ;;$06CB
01EF : F8 06                    word    RETURN          ;;$06F8
01F1 : 1E 07                    word    REM             ;;$071E
01F3 : 1F 0C                    word    STOP            ;;$0C1F
01F5 : 80 07                    word    ONGOTO          ;;$0780
01F7 : B5 07                    word    LPRINT          ;;$07B5
01F9 : 15 1B                    word    COPY            ;;$1B15
01FB : 3B 0B                    word    DEF             ;;$0B3B
01FD : 6D 0B                    word    POKE            ;;$0B6D
01FF : BC 07                    word    PRINT           ;;$07BC
0201 : 4B 0C                    word    CONT            ;;$0C4B
0203 : 6C 05                    word    LIST            ;;$056C
0205 : 67 05                    word    LLIST           ;;$0567
0207 : CD 0C                    word    CLEAR           ;;$0CCD
0209 : 2c 1C                    word    CLOAD           ;;$1C2C
020B : 08 1C                    word    CSAVE           ;;$1C08
020D : 4F 1A                    word    PSET            ;;$1A4F
020F : 4C 1A                    word    PRESET          ;;$1A4C
0211 : D6 1A                    word    SOUND           ;;$1AD6
0213 : BD 0B                    word    SCRATH          ;;$0BBD NEW
0215 : F5 14      [M80] FUNDSP: word    SGN             ;;$14F5
0217 : B1 15                    word    INT             ;;$15B1
0219 : 09 15                    word    ABS             ;;$1509
021B : 03 38                    word    USRPOK          ;;$3803 USR()
021D : A8 10                    word    FRE             ;;$10A8
022F : 2E 0B                    word    LPOS            ;;$0B2E
0221 : 33 0B                    word    POS             ;;$0B33
0223 : 75 17                    word    SQR             ;;$1775
0225 : 66 18                    word    RND             ;;$1866
0227 : 85 13                    word    LOG             ;;$1385
0229 : CD 17                    word    EXP             ;;$17CD
022B : D7 18                    word    COS             ;;$18D7
022D : DD 18                    word    SIN             ;;$18DD
022F : 70 19                    word    TAN             ;;$1970
0231 : 85 19                    word    ATN             ;;$1985
0233 : 63 0B                    word    PEEK            ;;$0B63
0235 : F3 0F                    word    LEN             ;;$0FF3
0237 : 29 0E                    word    STR             ;;$0E29
0239 : 84 10                    word    VAL             ;;$1084
023B : 02 10                    word    ASC             ;;$1002
023D : 13 10                    word    CHR             ;;$1013
023F : 21 10                    word    LEFT            ;;$1021
0241 : 50 10                    word    RIGHT           ;;$1050
0243 : 59 10                    word    MID             ;;$1059
0245
0245                  + ;; Statement Tokens
0245                  | ;[M65] TOKENS FOR RESERVED WORDS ALWAYS HAVE THE MOST
0245                  | ;[M65] SIGNIFICANT BIT ON.
0245                  | ;;;The first (or only) character of each keyword has bit 7 set.
0245                  | ;;;In Altair and 6502 Basic, bit 7 was set in the last character
0245 :            [M65] RESLST: ;[M65] THE LIST OF RESERVED WORDS:
0245 :                  TK      =       $80             ;;Tokens start at $80
0245 :            [M65] ENDTK   equ     TK              ;
0245 : C5 4E 44                 byte    'E'+$80,"ND"    ;;$80
0248 :                  TK      =       TK+1            ;
0248 :            [M65] FORTK   equ     TK              ;
0248 : C6 4F 52                 byte    'F'+$80,"OR"    ;;$81
024B :                  TK      =       TK+1            ;
024B : CE 45 58 54              byte    'N'+$80,"EXT"   ;;$82
024F :                  TK      =       TK+1            ;
024F :            [M65] DATATK  equ     TK              ;
024F : C4 41 54 41              byte    'D'+$80,"ATA"   ;;$83
0253 :                  TK      =       TK+1            ;
0253 :                  INPUTK  equ     TK              ;
0253 : C9 4E 50 55              byte    'I'+$80,"NPUT"  ;;$84
0257 : 54
0258 :                  TK      =       TK+1            ;
0258 : C4 49 4D                 byte    'D'+$80,"IM"    ;;$85
025B :                  TK      =       TK+1            ;
025B : D2 45 41 44              byte    'R'+$80,"EAD"   ;;$86
025F :                  TK      =       TK+1            ;
025F : CC 45 54                 byte    'L'+$80,"ET"    ;;$87
0262 :                  TK      =       TK+1            ;
0262 :            [M65] GOTOTK  equ     TK              ;
0262 : C7 4F 54 4F              byte    'G'+$80,"OTO"   ;;$88
0266 :                  TK      =       TK+1            ;
0266 : D2 55 4E                 byte    'R'+$80,"UN"    ;;$89
0269 :                  TK      =       TK+1            ;
0269 : C9 46                    byte    'I'+$80,"F"     ;;$8A
026B :                  TK      =       TK+1            ;
026B : D2 45 53 54              byte    'R'+$80,"ESTORE";;$8B
026F : 4F 52 45
0272 :                  TK      =       TK+1            ;
0272 :            [M65] GOSUTK  equ     TK              ;
0272 : C7 4F 53 55              byte    'G'+$80,"OSUB"  ;;$8C
0276 : 42
0277 :                  TK      =       TK+1            ;
0277 : D2 45 54 55              byte    'R'+$80,"ETURN" ;;$8D
027B : 52 4E                                            ;
027D :                  TK      =       TK+1            ;
027D :            [M65] REMTK   equ     TK              ;
027D : D2 45 4D                 byte    'R'+$80,"EM"    ;;$8E
0280 :                  TK      =       TK+1            ;
0280 : D3 54 4F 50              byte    'S'+$80,"TOP"   ;;$8F
0282 :                  TK      =       TK+1            ;
0284 : CF 4E                    byte    'O'+$80,"N"     ;;$90
0286 :                  TK      =       TK+1            ;
0286 : CC 50 52 49              byte    'L'+$80,"PRINT" ;;$91
028A : 4E 54                                            ;
028C :                  TK      =       TK+1            ;
028C : C3 4F 50 59              byte    'C'+$80,"OPY"   ;;$92
0290 :                  TK      =       TK+1            ;
0290 : C4 45 46                 byte    'D'+$80,"EF"    ;;$93
0293 :                  TK      =       TK+1            ;
0293 : D0 4F 4B 45              byte    'P'+$80,"OKE"   ;;$94
0297 :                  TK      =       TK+1            ;
0297 :            [M65] PRINTK  equ     TK              ;
0297 : D0 52 49 4E              byte    'P'+$80,"RINT"  ;;$95
029B : 54
029C :                  TK      =       TK+1            ;
029C : C3 4F 4E 54              byte    'C'+$80,"ONT"   ;;$96
02A0 :                  TK      =       TK+1            ;
02A0 : CC 49 53 54              byte    'L'+$80,"IST"   ;;$97
02A4 :                  TK      =       TK+1            ;
02A4 : CC 4C 49 53              byte    'L'+$80,"LIST"  ;;$98
02A8 : 54
02A9 :                  TK      =       TK+1            ;
02A9 : C3 4C 45 41              byte    'C'+$80,"LEAR"  ;;$99
02AD : 52
02AE :                  TK      =       TK+1            ;
02AE : C3 4C 4F 41              byte    'C'+$80,"LOAD"  ;;$9A
02B2 : 44
02B3 :                  TK      =       TK+1            ;
02B3 : C3 53 41 56              byte    'C'+$80,"SAVE"  ;;$9B
02B7 : 45
02B8 :                  TK      =       TK+1            ;
02B8 :                  PSETTK  equ     TK              ;;For Extended BASIC
02B8 : D0 53 45 54              byte    'P'+$80,"SET"   ;;$9C
02BC :                  TK      =       TK+1            ;
02B8 :                  PRESTK  equ     TK              ;;For Extended BASIC
02BC : D0 52 45 53              byte    'P'+$80,"RESET" ;;$9D
02C0 : 45 54                                            ;
02C2 :                  TK      =       TK+1            ;
02C2 : D3 4F 55 4E              byte    'S'+$80,"OUND"  ;;$9E
02C6 : 44
02C7 :                  TK      =       TK+1            ;
02C7 :            [M65] SCRATK  equ     TK              ;
02C7 : CE 45 57                 byte    'N'+$80,"EW"    ;;$9F
02CA :                  TK      =       TK+1            ;
02CA :                  ;[M65] END OF COMMAND LIST      ;
02CA :                  TABTK   equ     TK              ;
02CA : D4 41 42 28              byte    'T'+$80,"AB("   ;;$A0
02CE :                  TK      =       TK+1            ;
02CE :            [M80] TOTK    equ     TK              ;
02CE : D4 4F                    byte    'T'+$80,"O"     ;;$A1
02D0 :                  TK      =       TK+1            ;
02D0 :            [M80] FNTK    equ     TK              ;
02D0 : C6 4E                    byte    'F'+$80,"N"     ;;$A2
02D2 :                  TK      =       TK+1            ;
02D2 :                  SPCTK   equ     TK              ;
02D2 : D3 50 43 28              byte    'S'+$80,"PC("   ;;$A3
02D6 :                  TK      =       TK+1            ;
02D6 :                  INKETK  equ     TK              ;
02D6 : C9 4E 4B 45              byte    'I'+$80,"NKEY$" ;;$A4
02DA : 59 24
02DC :                  TK      =       TK+1            ;
02DC :            [M65] THENTK  equ     TK              ;
02DC : D4 48 45 4E              byte    'T'+$80,"HEN"   ;;$A5
02E0 :                  TK      =       TK+1            ;
02E0 :            [M80] NOTTK   equ     TK              ;
02E0 : CE 4F 54                 byte    'N'+$80,"OT"    ;;$A6
02E3 :                  TK      =       TK+1            ;
02E3 :            [M65] STEPTK  equ     TK              ;
02E3 : D3 54 45 50              byte    'S'+$80,"TEP"   ;;$A7
02E7 :                  TK      =       TK+1            ;
02E7
02E7 :                  ;;Operators                         
02E7 :            [M80] PLUSTK  equ     TK              ;
02E7 : AB                       byte    '+'+$80         ;;$A8 plus
02E8 :                  TK      =       TK+1            ;
02E8 :            [M80] MINUTK  equ     TK              ;
02E8 : AD                       byte    '-'+$80         ;;$A9 minus
02E9 :                  TK      =       TK+1            ;
02E9 :            [M80] MULTK   equ     TK              ;
02E9 : AA                       byte    '*'+$80         ;;$AA times
02EA :                  TK      =       TK+1            ;
02EA :            [M80] DIVTK   equ     TK              ;
02EA : AF                       byte    '/'+$80         ;;$AB divide
02EB :                  TK      =       TK+1            ;
02EB :            [M80] EXPTK   equ     TK              ;
02EB : DE                       byte    '^'+$80         ;;$AC
02EC :                  TK      =       TK+1            ;
02EC :                  ANDTK   equ     TK              ;;For Extended BASIC
02EC : C1 4E 44                 byte    'A'+$80,"ND"    ;;$AD
02EF :                  TK      =       TK+1            ;
02EF :                  ORTK    equ     TK              ;;For Extended BASIC
02EF : CF 52                    byte    'O'+$80,"R"     ;;$AE
02F1 :                  TK      =       TK+1            ;
02F1 :            [M80] GREATK  equ     TK              ;
02F1 : BE                       byte    '>'+$80         ;;$BE greater than
02F2 :                  TK      =       TK+1            ;
02F2 :            [M80] EQUATK  equ     TK              ;
02F2 : BD                       byte    '='+$80         ;;$BD equals
02F3 :                  TK      =       TK+1            ;
02F3 :            [M80] LESSTK  equ     TK              ;
02F3 : BC                       byte    '<'+$80         ;;$BC less than
02F3 :                  TK      =       TK+1            ;
02F4
02F4 :                + ;;Functions
02F4 :                | ;[M65] NOTE DANGER OF ONE RESERVED WORD BEING A PART
02F4 :                | ;[M65] OF ANOTHER:
02F4 :                | ;[M65] IE . . IF 2 GREATER THAN F OR T=5 THEN...
02F4 :                | ;[M65] WILL NOT WORK!!! SINCE "FOR" WILL BE CRUNCHED!!
02F4 :                | ;[M65] IN ANY CASE MAKE SURE THE SMALLER WORD APPEARS
02F4 :                | ;[M65] SECOND IN THE RESERVED WORD TABLE ("INP" AND "INPUT")
02F4 :                | ;[M65] ANOTHER EXAMPLE: IF T OR Q THEN ... "TO" IS CRUNCHED
02F4 :            [M65] ONEFUN  equ     TK              ;;*** This might go after SGN
02F4 : D3 47 4E                 byte    'S'+$80,"GN"    ;;$B2
02F7                    TK      =       TK+1            ;
02F7 : C9 4E 54                 byte    'I'+$80,"NT"    ;;$B3
02FA                    TK      =       TK+1            ;
02FA : C1 42 53                 byte    'A'+$80,"BS"    ;;$B4
02FD                    TK      =       TK+1            ;
02FD : D5 53 52                 byte    'U'+$80,"SR"    ;;$B5
0300                    TK      =       TK+1            ;
0300 : C6 52 45                 byte    'F'+$80,"RE"    ;;$B6
0303                    TK      =       TK+1            ;
0303 : CC 50 4F 53              byte    'L'+$80,"POS"   ;;$B7
0307                    TK      =       TK+1            ;
0307 : D0 4F 53                 byte    'P'+$80,"OS"    ;;$B8
030A                    TK      =       TK+1            ;
030A : D3 51 52                 byte    'S'+$80,"QR"    ;;$B9
030D                    TK      =       TK+1            ;
030D : D2 4E 44                 byte    'R'+$80,"ND"    ;;$BA
0310                    TK      =       TK+1            ;
0310 : CC 4F 47                 byte    'L'+$80,"OG"    ;;$BB
0313                    TK      =       TK+1            ;
0313 : C5 58 50                 byte    'E'+$80,"XP"    ;;$BC
0316                    TK      =       TK+1            ;
0316 : C3 4F 53                 byte    'C'+$80,"OS"    ;;$BD
0319                    TK      =       TK+1            ;
0319 : D3 49 4E                 byte    'S'+$80,"IN"    ;;$BE
031C                    TK      =       TK+1            ;
031C : D4 41 4E                 byte    'T'+$80,"AN"    ;;$BF
031F                    TK      =       TK+1            ;
031F : C1 54 4E                 byte    'A'+$80,"TN"    ;;$C0
0322                    TK      =       TK+1            ;
0322 : D0 45 45 4B              byte    'P'+$80,"EEK"   ;;$C1
0326                    TK      =       TK+1            ;
0326 : CC 45 4E                 byte    'L'+$80,"EN"    ;;$C2
0329                    TK      =       TK+1            
0329 : D3 54 52 24              byte    'S'+$80,"TR$"   ;;$C3
032D                    TK      =       TK+1            ;
032D : D6 41 4C                 byte    'V'+$80,"AL"    ;;$C4
0330                    TK      =       TK+1            ;
0330 : C1 53 43                 byte    'A'+$80,"SC"    ;;$C5
0333                    TK      =       TK+1            ;
0333                    CHRTK   equ     TK
0333 : C3 48 52 24              byte    'C'+$80,"HR$"   ;;$C6
0337                    TK      =       TK+1            ;
0337 : CC 45 46 54              byte    'L'+$80,"EFT$"  ;;$C7
033B : 24
033C                    TK      =       TK+1            ;
033C : D2 49 47 48              byte    'R'+$80,"IGHT$" ;;$C8
0340 : 54 24
0342                    TK      =       TK+1            ;
0342 : CD 49 44 24              byte    'M'+$80,"ID$"   ;;$C9
0346                    TK      =       TK+1            ;
0346                    POINTK  equ     TK
0346 : D0 4F 49 4E              byte    'P'+$80,"OINT"  ;;$CA
034A : 54
034B
;;The token crunching routine stops here, but the token expansion routine does not
;;so any 'tokens' above $CA will produce strange results when LISTed
034B : 80                       byte    $80             ;;End of List Marker
034C
034C                    ;OPERATOR TABLE CONTAINS PRECEDENCE FOLLOWED BY THE ROUTINE ADDRESS
034C : 79         [M80] OPTAB:  byte    121             ;ADD
034D : 5C 16                    word    FADDT           ;
034F : 79                       byte    121             ;SUBTRACT
0350 : 5C 12                    word    FSUBT           ;
0352 : 7C                       byte    124             ;MULTIPLY
0353 : C9 13                    word    FMULTT          ;
0355 : 7C                       byte    124             ;DIVIDE
0356 : 2D 14                    word    FDIVT           ;
0358 : 7F                       byte    127             ;POWER
0359 : 7E 17                    word    FPWRT           ;
035B : 50                       byte    80              ;AND
035C : A9 0A                    word    ANDOP           ;
035E : 46                       byte    70              ;OR
035F : A8 0A                    word    OROP            ;    
0361
0361                    ;{M80} NEEDED FOR MESSAGES
0361
0361 : 20 45 72 72[M65] ERR:    byte    " Error",7,0    
0365 : 6F 72 07 00
0369
0369 : 20 69 6E 20[M65] INTXT:  byte    " in ",0        
036C : 00
036E
036E : 4F 6B 0D 0A[M80] REDDY:  byte    "Ok",13,10,0    ;;FINZER relies on REDDY-1 being a 0!
0372 : 00
0373
0373 : 42 72 65 61[M80] BRKTXT: byte    "Break",0
0377 : 6B 00
0379
0379                  + ; [M65] ERROR MESSAGES
0379                  | ; [M65] WHEN AN ERROR CONDITION IS DETECTED,
0379                  | ; [M65] [ACCX] MUST BE SET UP TO INDICATE WHICH ERROR
0379                  | ; [M65] MESSAGE IS APPROPRIATE AND A BRANCH MUST BE MADE
0379                  | ; [M65] TO "ERROR". THE STACK WILL BE RESET AND ALL
0379                  | ; [M65] PROGRAM CONTEXT WILL BE LOST. VARIABLES
0379                  | ; [M65] VALUES AND THE ACTUAL PROGRAM REMAIN INTACT.
0379                  | ; [M65] ONLY THE VALUE OF [ACCX] IS IMPORTANT WHEN
0379                  | ; [M65] THE BRANCH IS MADE TO ERROR. [ACCX] IS USED AS AN
0379                  | ; [M65] INDEX INTO "ERRTAB" WHICH GIVES THE TWO
0379                  | ; [M65] CHARACTER ERROR MESSAGE THAT WILL BE PRINTED ON THE
0379                  | ; [M65] USER'S TERMINAL.
0379                  | ;
0379 :            [M80] ERRTAB: ;;List OF Error Messages
0379 :            [M80] ERRNF   equ     *-ERRTAB        ;;$00
0379 : 4E 46                    byte    "NF"            ;[M80] NEXT without FOR
037B :            [M80] ERRSN   equ     *-ERRTAB        ;;$02
037B : 53 4E                    byte    "SN"            ;[M80] Syntax error
037D :            [M80] ERRRG   equ     *-ERRTAB        ;;$04
037D : 52 47                    byte    "RG"            ;[M80] RETURN without GOSUB
037F :            [M80] ERROD   equ     *-ERRTAB        ;;$06
037F : 4F 44                    byte    "OD"            ;[M80] Out of DATA
0381 :            [M80] ERRFC   equ     *-ERRTAB        ;;$08
0381 : 46 43                    byte    "FC"            ;[M80] Illegal function call
0383 :            [M80] ERROV   equ     *-ERRTAB        ;;$0A
0383 : 4F 56                    byte    "OV"            ;[M80] Overflow
0385 :            [M80] ERROM   equ     *-ERRTAB        ;;$0C
0385 : 4F 4D                    byte    "OM"            ;[M80] Out of memory
0387 :            [M80] ERRUS   equ     *-ERRTAB        ;;$0E
0387 : 55 4C                    byte    "UL"            ;[M80] Undefined line number
0389              [M80] ERRBS   equ     *-ERRTAB        ;;$10
0389 : 42 53                    byte    "BS"            ;[M80] Subscript out of range
038B              [M80] ERRDDS  equ     *-ERRTAB        ;;$12
038B : 44 44                    byte    "DD"            ;[M80] Duplicate Definition
038D              [M80] ERRDV0  equ     *-ERRTAB        ;;$14
038D : 2F 30                    byte    "/0"            ;[M80] Division by zero
038F              [M80] ERRID   equ     *-ERRTAB        ;;$16
038F : 49 44                    byte    "ID"            ;[M80] Illegal direct
0391              [M80] ERRTM   equ     *-ERRTAB        ;;$18
0391 : 54 4D                    byte    "TM"            ;[M80] Type mismatch
0393              [M80] ERRSO   equ     *-ERRTAB        ;;$1A
0393 : 4F 53                    byte    "OS"            ;[M80] Out of string space
0395              [M80] ERRLS   equ     *-ERRTAB        ;;$1C
0395 : 4C 53                    byte    "LS"            ;[M80] String too long
0397              [M80] ERRST   equ     *-ERRTAB        ;;$1E
0397 : 53 54                    byte    "ST"            ;[M80] String formula too complex
0399              [M80] ERRCN   equ     *-ERRTAB        ;;$20
0399 : 43 4E                    byte    "CN"            ;[M80] Can't continue
039B              [M80] ERRUF   equ     *-ERRTAB        ;;$22
039B : 55 46                    byte    "UF"            ;[M80] Undefined user function
039D              [M80] ERRMO   equ     *-ERRTAB        ;;$24
039D : 4D 4F                    byte    "MO"            ;[M80] Missing operand
039F
039F                  + ;[M80] FIND A "FOR" ENTRY ON THE STACK WITH THE VARIABLE POINTER PASSED IN [D,E]
039F                  | ;[M65] MOST SMALL ROUTINES ARE FAIRLY SIMPLE
039F                  | ;[M65] AND ARE DOCUMENTED IN PLACE. "FNDFOR" IS
039F                  | ;[M65] USED FOR FINDING "FOR" ENTRIES ON
039F                  | ;[M65] THE STACK. WHENEVER A "FOR" IS EXECUTED, A
039F                  | ;[M65] 16-BYTE ENTRY IS PUSHED ONTO THE STACK.
039F                  | ;[M65] BEFORE THIS IS DONE, HOWEVER, A CHECK
039F                  | ;[M65] MUST BE MADE TO SEE IF THERE
039F                  | ;[M65] ARE ANY "FOR" ENTRIES ALREADY ON THE STACK
039F                  | ;[M65] FOR THE SAME LOOP VARIABLE. IF SO, THAT "FOR" ENTRY
039F                  | ;[M65] AND ALL OTHER "FOR" ENTRIES THAT WERE MADE AFTER IT
039F                  | ;[M65] ARE ELIMINATED FROM THE STACK. THIS IS SO A
039F                  | ;[M65] PROGRAM THAT JUMPS OUT OF THE MIDDLE
039F                  | ;[M65] OF A "FOR" LOOP AND THEN RESTARTS THE LOOP AGAIN
039F                  | ;[M65] AND AGAIN WON'T USE UP 18 BYTES OF STACK
039F                  | ;[M65] SPACE EVERY TIME. THE "NEXT" CODE ALSO
039F                  | ;[M65] CALLS "FNDFOR" TO SEARCH FOR A "FOR" ENTRY WITH
039F                  | ;[M65] THE LOOP VARIABLE IN
039F                  | ;[M65] THE "NEXT". AT WHATEVER POINT A MATCH IS FOUND
039F                  | ;[M65] THE STACK IS RESET. IF NO MATCH IS FOUND A
039F                  | ;[M65] "NEXT WITHOUT FOR"  ERROR OCCURS. GOSUB EXECUTION
039F                  | ;[M65] ALSO PUTS A 5-BYTE ENTRY ON STACK.
039F                  | ;[M65] WHEN A RETURN IS EXECUTED "FNDFOR" IS
039F                  | ;[M65] CALLED WITH A VARIABLE POINTER THAT CAN'T
039F                  | ;[M65] BE MATCHED. WHEN "FNDFOR" HAS RUN
039F                  | ;[M65] THROUGH ALL THE "FOR" ENTRIES ON THE STACK  
039F                  | ;[M65] IT RETURNS AND THE RETURN CODE MAKES
039F                  | ;[M65] SURE THE ENTRY THAT WAS STOPPED
039F                  | ;[M65] ON IS A GOSUB ENTRY. THIS ASSURES THAT
039F                  | ;[M65] IF YOU GOSUB TO A SECTION OF CODE
039F                  | ;[M65] IN WHICH A FOR LOOP IS ENTERED BUT NEVER
039F                  | ;[M65] EXITED THE RETURN WILL STILL BE
039F                  | ;[M65] ABLE TO FIND THE MOST RECENT
039F                  | ;[M65] GOSUB ENTRY. THE "RETURN" CODE ELIMINATES THE
039F                  | ;[M65] "GOSUB" ENTRY AND ALL "FOR" ENTRIES MADE AFTER
039F                  | ;[M65] THE GOSUB ENTRY.
039F                  | ;
039F :            [M80] FORSIZ  equ     13              ;;Size of a FOR entry on the stack
039F
039F : 21 04 00   [M80] FNDFOR: ld      hl,4+0          ;[M80] IGNORING THE RETURN ADDRESS OF
03A2 : 39                       add     hl,sp           ;[M80] THIS SUBROUTINE, SET [H,L]=SP
03A3 : 7E         [M80] LOOPER: ld      a,(hl)          ;[M80] SEE WHAT TYPE OF THING IS ON THE STACK
03A4 : 23                       inc     hl              ;
03A5 : FE 81                    cp      FORTK           ;[M80] IS THIS STACK ENTRY A "FOR"?
03A7 : C0                       ret     nz              ;[M80] NO SO OK
03A8 : 4E                       ld      c,(hl)          ;[M80] DO EQUIVALENT OF PUSHM / XTHL
03A9 : 23                       inc     hl              ;
03AA : 46                       ld      b,(hl)          ;
03AB : 23                       inc     hl              ;
03AC : E5                       push    hl              ;[M80] PUT H  ON
03AD : 60                       ld      h,b             ;[M80] PUSH B / XTHL IS SLOWER
03AE : 69                       ld      l,c             ;
03AF : 7A                       ld      a,d             ;[M80] FOR THE "NEXT" STATMENT WITHOUT AN ARGUMENT
03B0 : B3                       or      e               ;[M80] WE MATCH ON ANYTHING
03B1 : EB                       ex      de,hl           ;[M80] MAKE SURE WE RETURN [D,E]
03B2 : 28 02                    jr      z,POPGOF        ;[M80] POINTING TO THE VARIABLE
03B4 : EB                       ex      de,hl           ;
03B5 : E7                       rst     COMPAR          ;
03B6 : 01 0D 00   [M80] POPGOF: ld      bc,FORSIZ       ;[M80] TO WIPE OUT A "FOR" ENTRY
03B9 : E1                       pop     hl              ;[M80] IF VARIABLE IN THIS ENTRY MATCHES RETURN
03BA : C8                       ret     z               ;[M80] WITH [H,L] POINTING THE BOTTOM ;OF THE ENTRY
03BB : 09                       add     hl,bc           ;[M80] NOW POINTING TO THE START OF THE NEXT ENTRY.
03BC : 18 E5                    jr      LOOPER          ;[M80] SEE IF ITS A "FOR" ENTRY AND IF THE VARIABLE MATCHES
03BE
03BE : 2A C9 38   [M80] DATSNE: ld      hl,(DATLIN)     ;[M80] GET DATA LINE
03C1 : 22 4D 38                 ld      (CURLIN),hl     ;[M80] MAKE IT CURRENT LINE
03C4 : 1E 02      [M80] SNERR:  ld      e,ERRSN         ;[M80] "SYNTAX ERROR"
03C6 : 01                       byte    $01             ;[M80] "LD BC," OVER THE NEXT 2
03C7 : 1E 14      [M80] DV0ERR: ld      e,ERRDV0        ;[M80] DIVISION BY ZERO
03C9 : 01                       byte    $01             ;[M80] "LD BC," OVER THE NEXT 2
03CA : 1E 00      [M80] NFERR:  ld      e,ERRNF         ;[M80] "NEXT WITHOUT FOR" ERROR
03CC : 01                       byte    $01             ;[M80] "LD BC," OVER THE NEXT 2
03CD : 1E 12      [M80] DDERR:  ld      e,ERRDDS        ;[M80] "REDIMENSIONED VARIABLE"
03CF : 01                       byte    $01             ;[M80] "LD BC," OVER THE NEXT 2
03D0 : 1E 22      [M80] UFERR:  ld      e,ERRUF         ;[M80] "UNDEFINED FUNCTION" ERROR
03D2 : 01                       byte    $01             ;[M80] "LD BC," OVER THE NEXT 2
03D3 : 1E 0A      [M80] OVERR:  ld      e,ERROV         ;;      Overflow Error
03D5 : 01                       byte    $01             ;[M80] "LD BC," OVER THE NEXT 2
03D6 : 1E 24      [M80] MOERR:  ld      e,ERRMO         ;;     Missing Operand
03D8 : 01                       byte    $01             ;[M80] "LD BC," OVER THE NEXT 2
03D9 : 1E 18      [M80] TMERR:  ld      e,ERRTM         ;[M80] TYPE MISMATCH ERROR
03DB
03DB : CD E5 0B   [M80] ERROR:  call    STKINI          ;
03DE : F7                       rst     HOOKDO          ;;call Hook Service Routine
03DF : 00         {~~~} HOOK0:  byte    0               ;
03E0 : CD DE 19   (M65) ERRCRD: call    CRDONZ          ;
03E3 : 21 79 03                 ld      hl,ERRTAB       ;
03E6 : F7                       rst     HOOKDO          ;;call Hook Service Routine
03E7 : 01         {~~~} HOOK1:  byte    1               ;
03E8 : 57                       ld      d,a             ;;Add Error Offset
03E9 : 19                       add     hl,de           ;
03EA : 3E 3F                    ld      a,'?'           ;[M65] PRINT A QUESTION MARK
03EC : DF                       rst     OUTCHR          ;
03ED : 7E         (M80) ERRFIN: ld      a,(hl)          ;[M65] GET FIRST CHR OF ERR MSG.
03EE : DF                       rst     OUTCHR          ;[M65] OUTPUT IT.
03EF : D7                       rst     CHRGET          ;[M65] GET SECOND CHR.
03F0 : DF                       rst     OUTCHR          ;[M65] OUTPUT IT.
03F1 : 21 61 03                 ld      hl,ERR          ;;" Error"
03F4 : CD 9D 0E   [M80] ERRFN1: call    STROUT          ;[M80] PRINT MESSAGE
03F7 : 2A 4D 38                 ld      hl,(CURLIN)     ;[M80] RESTORE LINE NUMBER
03FA : 7C                       ld      a,h             ;[M80] SEE IF IN DIRECT MODE
03FB : A5                       and     l               ;
03FC : 3C                       inc     a               ;[M80] ZERO SAYS DIRECT MODE
03FD : C4 6D 16                 call    nz,INPRT        ;[M80] PRINT LINE NUMBER IN [H,L]
0400 : 3E                       byte    $3E             ;[M80] SKIP THE NEXT BYTE WITH "MVI A,0"
0401
0401                  - ;[M80] FOR "LIST" COMMAND STOPPING
0401 : C1         [M80] STPRDY: pop     bc                      
0402
0402 : F7         [M80] READY:  rst     HOOKDO          ;;Call hook routine
0403 : 02         {~~~} HOOK2:  byte    2               ;
0404 : CD BE 19                 call    FINLPT          ;[M80] PRINT ANY LEFT OVERS
0407 : AF                       xor     a               ;
0408 : 32 08 38                 ld      (CNTOFL),a      ;[M80] FORCE OUTPUT
040B : CD DE 19                 call    CRDONZ          ;[M80] IF NOT ALREADY AT LEFT, SEND CRLF
040E : 21 6E 03                 ld      hl,REDDY        ;[M80] "OK" CRLF CRLF
0411 : CD 9D 0E                 call    STROUT          ;
0414                                                        ;
0414 : 21 FF FF   [M80] MAIN:   ld      hl,$FFFF        ;
0417 : 22 4D 38                 ld      (CURLIN),hl     ;[M80] SETUP CURLIN FOR DIRECT MODE
;;;GW-BASIC and CP/M Basic have Automatic Line Numbering Logic here
041A : CD 85 0D   {M80} NTAUTO: call    INLIN           ;[M80] GET A LINE FROM TTY
041D : 38 F5                    jr      c,MAIN          ;[M80] IGNORE ^C S
041F : D7                       rst     CHRGET          ;[M80] GET THE FIRST
0420 : 3C                       inc     a               ;[M80] SEE IF 0 SAVING THE CARRY FLAG
0421 : 3D                       dec     a               ;
0422 : 28 F0                    jr      z,MAIN          ;[M80] IF SO, A BLANK LINE WAS INPUT
0424 : F5                       push    af              ;[M80] SAVE STATUS INDICATOR FOR 1ST CHARACTER
0425 : CD 9C 06   {M65} MAIN1:  call    SCNLIN          ;[M80] READ IN A LINE #
;;;GW-BASIC snd CP/M Basic have extra logic here         ;
0428 : D5         [M80] EDENT:  push    de              ;[M80] SAVE LINE #
0429 : CD BC 04                 call    CRUNCH          ;[M80] CRUNCH THE LINE DOWN
042C : 47                       ld      b,a             ;[M65] RETAIN CHARACTER COUNT.
042D : D1                       pop     de              ;[M80] RESTORE LINE #
042E : F1                       pop     af              ;[M80] WAS THERE A LINE #?
042F : F7                       rst     HOOKDO          ;;Call Hook Dispatch Routine
0430 : 03         {~~~} HOOK3:  byte    3               ;
0431 : D2 4B 06                 jp      nc,GONE         ;
0434 : D5                       push    de              ;
0435 : C5                       push    bc              ;[M80] SAVE LINE # AND CHARACTER COUNT
0436 : AF                       xor     a               ;
0437 : 32 CC 38                 ld      (USFLG),a       ;{M80} RESET THE FLAG
043A : D7                       rst     CHRGET          ;[M80] REMEMBER IF THIS LINE IS
043B : B7                       or      a               ;[M80] SET THE ZERO FLAG ON ZERO
043C : F5                       push    af              ;[M80] BLANK SO WE DON'T INSERT IT
043D : CD 9F 04                 call    FNDLIN          ;[M80] GET A POINTER TO THE LINE
0440 : 38 06                    jr      c,LEXIST        ;[M80] LINE EXISTS, DELETE IT
0442 : F1                       pop     af              ;[M80] GET FLAG SAYS WHETHER LINE BLANK
0443 : F5                       push    af              ;[M80] SAVE BACK
0444 : CA F3 06                 jp      z,USERR         ;[M80] SAVE BACK
0447 : B7                       or      a               ;[M80] TRYING TO DELETE NON-EXISTANT LINE, ERROR
0448 : C5         (M80) LEXIST: push    bc              ;[M80] SAVE THE POINTER
0449 : 30 10                    jr      nc,NODEL        ;
0FFB                    ;[M80] DELETE THE LINE
044B : EB         {M80} DEL:    ex      de,hl           ;[M80] [D,E] NOW HAVE THE POINTER TO NEXT LINE
044C : 2A D6 38                 ld      hl,(VARTAB)     ;[M80] COMPACTIFYING TO VARTAB
044F : 1A         (M80) MLOOP:  ld      a,(de)          ;
0450 : 02                       ld      (bc),a          ;[M80] SHOVING DOWN TO ELIMINATE A LINE
0451 : 03                       inc     bc              ;
0452 : 13                       inc     de              ;
0453 : E7                       rst     COMPAR          ;
0454 : 20 F9                    jr      nz,MLOOP        ;[M80] DONE COMPACTIFYING?
0456 : 60                       ld      h,b             ;
0457 : 69                       ld      l,c             ;;HL = new end of program
0458 : 22 D6 38                 ld      (VARTAB),hl     ;[M65] SETUP [VARTAB]
045B : D1         (M80) NODEL:  pop     de              ;[M80] POP POINTER AT PLACE TO INSERT
045C : F1                       pop     af              ;[M80] SEE IF THIS LINE HAD ANYTHING ON IT
045D : 28 21                    jr      z,FINI          ;[M80] IF NOT DON'T INSERT
045F : 2A D6 38   (M80) LEVFRE: ld      hl,(VARTAB)     ;[M80] CURRENT END
0462 : E3                       ex      (sp),hl         ;[M80] [H,L]=CHARACTER COUNT. VARTAB ONTO STACK
0463 : C1                       pop     bc              ;[M80] [B,C]=OLD VARTAB
0464 : 09                       add     hl,bc           ;
0465 : E5                       push    hl              ;[M80] SAVE NEW VARTAB
0466 : CD 92 0B                 call    BLTU            ;;Create space for new line
0469 : E1                       pop     hl              ;[M80] POP OFF VARTAB
046A : 22 D6 38                 ld      (VARTAB),hl     ;[M80] UPDATE VARTAB
046D : EB                       ex      de,hl           ;
046E : 74                       ld      (hl),h          ;[M80] FOOL CHEAD WITH NON-ZERO LINK
046F : D1                       pop     de              ;[M80] GET LINE # OFF STACK
0470 : 23                       inc     hl              ;[M80] SO IT DOESN'T THINK THIS LINK
0471 : 23                       inc     hl              ;[M80] IS THE END OF THE PROGRAM
0472 : 73                       ld      (hl),e          ;
0473 : 23                       inc     hl              ;[M80] PUT DOWN LINE #
0474 : 72                       ld      (hl),d          ;
0475 : 23                       inc     hl              ;
0476 : 11 60 38                 ld      de,BUF          ;[M80] MOVE LINE FRM BUF TO PROGRAM AREA
0479 : 1A         (M80) MLOOPR: ld      a,(de)          ;[M80] NOW TRANSFERING LINE IN FROM BUF
047A : 77                       ld      (hl),a          ;
047B : 23                       inc     hl              ;
047C : 13                       inc     de              ;
047D : B7                       or      a               ;;If not line terminator, keep going
047E : 20 F9                    jr      nz,MLOOPR       ;
0480
0480 : F7         [M80] FINI:   rst     HOOKDO          ;
0481 : 04         {~~~} HOOK4:  byte    4               ;
0482 : CD CB 0B                 call    RUNC            ;[M80] DO CLEAR & SET UP STACK 
0485 : F7                       rst     HOOKDO          ;
0486 : 05         {~~~} HOOK5:  byte    5               ;
0487 : 23                       inc     hl              ;;HL=TXTTAB
0488 : EB         {M80} LINKER: ex      de,hl           ;;DE=TXTTAB
0489
0489                  + ;;Fix Basic Line Links 
0489                  | ;[M80] CHEAD GOES THROUGH PROGRAM STORAGE AND FIXES
0489                  | ;[M80] UP ALL THE LINKS. THE END OF EACH
0489                  | ;[M80] LINE IS FOUND BY SEARCHING FOR THE ZERO AT THE END.
0489                  | ;[M80] THE DOUBLE ZERO LINK IS USED TO DETECT THE END OF THE PROGRAM
0489                  | ;
0489 : 62         [M80] CHEAD:  ld      h,d             ;[H,L]=[D,E]
048A : 6B                       ld      l,e             ;
048B : 7E                       ld      a,(hl)          ;[M80] SEE IF END OF CHAIN
048C : 23                       inc     hl              ;[M80] BUMP POINTER
048D : B6                       or      (hl)            ;[M80] 2ND BYTE
048E : CA 14 04                 jp      z,MAIN          ;
0491 : 23                       inc     hl              ;[M80] FIX HL TO START OF TEXT
0492 : 23                       inc     hl              ;
0493 : 23                       inc     hl              ;
0494 : AF                       xor     a               ;SET CC'S
0495 : BE         (M80) CZLOOP: cp      (hl)            ;;Skip to end of Basic line
0496 : 23                       inc     hl              ;
0497 : 20 FC                    jr      nz,CZLOOP       ;
0499 : EB                       ex      de,hl           ;SWITCH TEMP
049A : 73                       ld      (hl),e          ;DO FIRST BYTE OF FIXUP
049B : 23                       inc     hl              ;ADVANCE POINTER
049C : 72                       ld      (hl),d          ;2ND BYTE OF FIXUP
049D : 18 EA                    jr      CHEAD           ;KEEP CHAINING TIL DONE
049F
049F                  + ;;Find Basic Line
049F                  | ;[M80] FNDLIN SEARCHES THE PROGRAM TEXT FOR THE LINE
049F                  | ;[M80] WHOSE LINE # IS PASSED IN [D,E]. [D,E] IS PRESERVED.
049F                  | ;[M80] THERE ARE THREE POSSIBLE RETURNS:
049F                  | ;[M80]
049F                  | ;[M80]  1) ZERO FLAG SET. CARRY NOT SET.  LINE NOT FOUND.
049F                  | ;[M80]     NO LINE IN PROGRAM GREATER THAN ONE SOUGHT.
049F                  | ;[M80]     [B,C] POINTS TO TWO ZERO BYTES AT END OF PROGRAM.
049F                  | ;[M80]     [H,L]=[B,C]
049F                  | ;[M80]
049F                  | ;[M80]  2) ZERO, CARRY SET.
049F                  | ;[M80]     [B,C] POINTS TO THE LINK FIELD IN THE LINE
049F                  | ;[M80]     WHICH IS THE LINE SEARCHED FOR.
049F                  | ;[M80]     [H,L] POINTS TO THE LINK FIELD IN THE NEXT LINE.
049F                  | ;[M80]
049F                  | ;[M80]  3) NON-ZERO, CARRY NOT SET.
049F                  | ;[M80]     LINE NOT FOUND, [B,C]  POINTS TO LINE IN PROGRAM
049F                  | ;[M80]     GREATER THAN ONE SEARCHED FOR.
049F                  | ;[M80]     [H,L] POINTS TO THE LINK FIELD IN THE NEXT LINE.
049F : 2A 4F 38         FNDLIN: ld      hl,(TXTTAB)     ;[M80] GET POINTER TO START OF TEXT
04A2 : 44               LOOP:   ld      b,h             ;[M80] IF EXITING BECAUSE OF END OF PROGRAM,
04A3 : 4D                       ld      c,l             ;[M80] SET [B,C] TO POINT TO DOUBLE ZEROES.
04A4 : 7E                       ld      a,(hl)          ;[M80] GET WORD POINTER TO
04A5 : 23                       inc     hl              ;[M80] BUMP POINTER
04A6 : B6                       or      (hl)            ;[M80] GET 2ND BYTE
04A7 : 2B                       dec     hl              ;[M80] GO BACK
04A8 : C8                       ret     z               ;[M80] IF ZERO THEN DONE
04A9 : 23                       inc     hl              ;[M80] SKIP PAST AND GET THE LINE #
04AA : 23                       inc     hl              ;
04AB : 7E                       ld      a,(hl)          ;[M80] INTO [H,L] FOR COMPARISON WITH
04AC : 23                       inc     hl              ;[M80] THE LINE # BEING SEARCHED FOR
04AD : 66                       ld      h,(hl)          ;[M80] WHICH IS IN [D,E]
04AE : 6F                       ld      l,a             ;
04AF : E7                       rst     COMPAR          ;[M80] SEE IF IT MATCHES OR IF WE'VE GONE TOO FAR
04B0 : 60                       ld      h,b             ;[M80] MAKE [H,L] POINT TO THE START OF THE
04B1 : 69                       ld      l,c             ;[M80] LINE BEYOND THIS ONE, BY PICKING
04B2 : 7E                       ld      a,(hl)          ;[M80] UP THE LINK THAT [B,C] POINTS AT
04B3 : 23                       inc     hl              ;
04B4 : 66                       ld      h,(hl)          ;
04B5 : 6F                       ld      l,a             ;
04B6 : 3F                       ccf                     ;[M80] TURN CARRY OFF
04B7 : C8                       ret     z               ;[M80] EQUAL RETURN
04B8 : 3F                       ccf                     ;[M80] MAKE CARRY ZERO
04B9 : D0                       ret     nc              ;[M80] NO MATCH RETURN (GREATER)
04BA : 18 E6                    jr      LOOP            ;[M80] KEEP LOOPING
04BC
04BC                  + ;;Convert Keyword to Token
04BC                  | ;[M80] ALL "RESERVED" WORDS ARE TRANSLATED INTO SINGLE
04BC                  | ;[M80] ONE OR TWO (IF TWO, FIRST IS ALWAYS 377 OCTAL)
04BC                  | ;[M80] BYTES WITH THE MSB ON. THIS SAVES SPACE AND TIME
04BC                  | ;[M80] BY ALLOWING FOR TABLE DISPATCH DURING EXECUTION.
04BC                  | ;[M80] THEREFORE ALL STATEMENTS APPEAR TOGETHER IN THE
04BC                  | ;[M80] RESERVED WORD LIST IN THE SAME
04BC                  | ;[M80] ORDER THEY APPEAR IN IN STMDSP.
04BC : AF         [M80] CRUNCH: xor     a               ;SAY EXPECTING FLOATING NUMBERS
04BD : 32 AC 38                 ld      (DORES),a       ;ALLOW CRUNCHING
04C0 : 0E 05                    ld      c,5             ;LENGTH OF KRUNCH BUFFER
04C2 : 11 60 38                 ld      de,BUF          ;SETUP DESTINATION POINTER
04C5 : 7E         [M80] KLOOP:  ld      a,(hl)          ;GET CHARACTER FROM BUF
04C6 : FE 20                    cp      ' '             ;SPACE?
04C8 : CA 3C 05                 jp      z,STUFFH        ;JUST STUFF AWAY
04CB : 47                       ld      b,a             ;SETUP B WITH A QUOTE IF IT IS A STRING
04CC : FE 22                    cp      '"'             ;QUOTE SIGN?
04CE : CA 58 05                 jp      z,STRNG         ;YES, GO TO SPECIAL STRING HANDLING
04D1 : B7                       or      a               ;END OF LINE?
04D2 : CA 5E 05                 jp      z,CRDONE        ;YES, DONE CRUNCHING
04D5 : 3A AC 38                 ld      a,(DORES)       ;IN DATA STATEMENT AND NO CRUNCH?
04D8 : B7                       or      a
04D9 : 7E                       ld      a,(hl)          ;GET THE CHARACTER AGAIN
04DA : C2 3C 05                 jp      nz,STUFFH       ;IF NO CRUNCHING JUST STORE THE CHARACTER
04DD : FE 3F                    cp      '?'             ;A QMARK?
04DF : 3E 95                    ld      a,PRINTK        ;
04E1 : CA 3C 05                 jp      z,STUFFH        ;THEN USE A "PRINT" TOKEN
04E4 : 7E                       ld      a,(hl)          ;
04E5 : FE 30                    cp      '0'             ;[M65] SKIP NUMERICS.
04E7 : 38 05                    jr      c,MUSTCR        ;
04E9 : FE 3C                    cp      '<'             ;[M65] ":" AND ";" ARE ENTERED STRAIGHTAWAY.
04EB : DA 3C 05                 jp      c,STUFFH        ;
04EE : D5         [M65] MUSTCR: push    de              ;[M65] SAVE BUFFER POINTER.
04EF : 11 44 02                 ld      de,RESLST-1     ;[M65] LOAD RESLST POINTER.
04F2 : C5                       push    bc              ;[M65] SAVE TEXT POINTER FOR LATER USE.
04F3 : 01 36 05                 ld      bc,NOTGOS       ;[M80] PLACE TO RETURN IF NOT FUNNY GO
04F6 : C5                       push    bc              ;
04F7 : 06 7F                    ld      b,$7F           ;
04F9 : 7E       *       CRUNCX: ld      a,(hl)          ;[M80] GET CHAR FROM MEMORY
04FA : FE 61                    cp      'a'             ;[M80] IS IT LOWER CASE RANGE
04FC : 38 07                    jr      c,RESCON        ;[M80] LESS
04FE : FE 7B                    cp      '{'             ;[M80] GREATER
0500 : 30 03                    jr      nc,RESCON       ;[M80] TEST
0502 : E6 5F                    and     $5F             ;[M80] MAKE UPPER CASE
0504 : 77                       ld      (hl),a          ;;and put it back
0505 : 4E         [N65] RESCON: ld      c,(hl)          ;[M80 SAVE CHAR IN [C]
0506                    ;;Find next Reserved Word that starts with this character
0506 : EB                       ex      de,hl           ;;HL=RESLST Pointer, DE=Text Pointer
0507 : 23         (M80) LOPPSI: inc     hl              ;[M80] BUMP RESLST POINTER
0508 : B6                       or      (hl)            ;[M80] SET CC'S
0509 : F2 07 05                 jp      p,LOPPSI        ;[M80] SEE IF REST OF CHARS MATCH
050C : 04                       inc     b               ;
050D : 7E                       ld      a,(hl)          ;[M80] GET BYTE FROM RESERVED WORD LIST
050E : E6 7F                    and     $7F             ;[M80] GET RID OF HIGH BIT
0510 : C8                       ret     z               ;[M80] IF=0 THEN END OF THIS CHARS RESLT
0511 : B9                       cp      c               ;[M80] COMPARE TO CHAR FROM SOURCE LINE
0512 : 20 F3                    jr      nz,LOPPSI       ;[M80] IF NO MATCH, SEARCH FOR NEXT RESWRD
0514 : EB                       ex      de,hl           ;;DE=RESLST Pointer, HL=Text Pointer
0515 : E5                       push    hl              ;;Save Text Pointer
0516 : 13         (M80) LOPSKP: inc     de              ;[M80] POINT AFTER TOKEN
0517 : 1A                       ld      a,(de)          ;[M80] GET A BYTE FROM RESWRD LIST
0518 : B7                       or      a               ;[M80] BUMP RESLST POINTER
0519 : FA 32 05                 jp      m,NOTFNT        ;[M80] SET CC'S
051C : 4F                       ld      c,a             ;[M80] NOT END OF RESWRD, KEEP SKIPPING
051D : 78                       ld      a,b             ;
051E : FE 88                    cp      GOTOTK          ;
0520 : 20 02                    jr      nz,MAKUPL       ;
0522 : D7                       rst     CHRGET          ;
0523 : 2B                       dec     hl              ;[M80] FIX TEXT POINTER
0524 : 23         (M80) MAKUPL: inc     hl              ;
0525 : 7E                       ld      a,(hl)          ;
0526 : FE 61                    cp      'a'             ;[M80] IS IT LOWER CASE RANGE
0528 : 38 02                    jr      c,MAKUPS        ;[M80] LESS
052A : E6 5F                    and     $5F             ;[M80] MAKE UPPER CASE
052C : B9         (M80) MAKUPS: cp      c               ;[M80] COMPARE TO CHAR FROM SOURCE LINE
052D : 28 E7                    jr      z,LOPSKP        ;[M80] IF NO MATCH, SEARCH FOR NEXT RESWRD
052F : E1                       pop     hl              ;
0530 : 18 D3                    jr      RESCON          ;
0532 : 48         (M80) NOTFNT: ld      c,b             ;
0533 : F1                       pop     af              ;
0534 : EB                       ex      de,hl           ;
0535 : C9                       ret                     ;
0536 : F7         [M80] NOTGOS: rst     HOOKDO          ;
0537 : 0A         {~~~} HOOK10: byte    10              ;
0538 : EB                       ex      de,hl           ;;HL=text pointer, DE=krunch pointer 
0539 : 79                       ld      a,c             ;;Get token
053A : C1                       pop     bc              ;
053B : D1                       pop     de              ;
053C
053C                    ;;Copy character to crunch buffer
053C : 23         [M80] STUFFH: inc     hl              ;[M80] ENTRY TO BUMP [H,L]
053D : 12         {M80} KRNSAV: ld      (de),a          ;[M80] SAVE BYTE IN KRUNCH BUFFER
053E : 13                       inc     de              ;[M80] BUMP POINTER
053F : 0C                       inc     c               ;;Increment buffer count
0540 : D6 3A                    sub     ':'             ;[M65] IS IT A ":"?"
0542 : 28 04                    jr      z,COLIS         ;[M65] YES, ALLOW CRUNCHING AGAIN.
0544 : FE 49                    cp      DATATK-':'      ;[M65] IS IT A DATATK?
0546 : 20 03                    jr      nz,NODATT       ;[M65] NO, SEE IF IT IS REM TOKEN.
0548
0548 : 32 AC 38   (M80) COLIS:  ld      (DORES),a       ;[M65] SETUP FLAG.
054B : D6 54      (M80) NODATT: sub     REMTK-':'       ;[M65] REM ONLY STOPS ON NULL.
054D : C2 C5 04                 jp      nz,KLOOP        ;[M65] NO, CONTINUE CRUNCHING.
0550 : 47                       ld      b,a             ;{M80} SAVE TERMINATOR IN [B]
0551 : 7E         (M80) STR1:   ld      a,(hl)          ;[M80] GET A CHAR
0552 : B7                       or      a               ;[M80] SET CONDITION CODES
0553 : 28 09                    jr      z,CRDONE        ;[M80] IF END OF LINE THEN DONE
0555 : B8                       cp      b               ;[M80] COMPARE CHAR WITH THIS TERMINATOR
0556 : 28 E4                    jr      z,STUFFH        ;[M80] IF YES, DONE WITH STRING
0558
0558 : 23         (M80) STRNG:  inc     hl              ;[M80] INCREMENT TEXT POINTER
0559 : 12                       ld      (de),a          ;[M80] SAVE CHAR IN KRUNCH BUFFER
055A : 0C                       inc     c               ;;Increment buffer count
055B : 13                       inc     de              ;[M65] INCREMENT BUFFER POINTER.
055C : 18 F3                    jr      STR1            ;[M80] KEEP LOOPING
055E
055E : 21 5F 38   (M80) CRDONE: ld      hl,BUF-1        ;[M80] GET POINTER TO CHAR BEFORE BUF AS "GONE" DOES A CHRGET
0561 : 12                       ld      (de),a          ;[M80] NEED THREE 0'S ON THE END
0562 : 13                       inc     de              ;[M80] ONE FOR END-OF-LINE
0563 : 12                       ld      (de),a          ;[M80] AND 2 FOR A ZERO LINK
0564 : 13                       inc     de              ;[M80] SINCE IF THIS IS A DIRECT STATEMENT
0565 : 12                       ld      (de),a          ;[M80] ITS END MUST LOOK LIKE THE END OF A PROGRAM
0566 : C9                       ret                     ;[M80] END OF CRUNCHING
0567
0567                    ;;The LLIST and LIST commands
0567 : 3E 01      [M80] LLIST:  ld      a,1             ;[M80] PRTFLG=1 FOR REGULAR LIST
0569 : 32 47 38                 ld      (PRTFLG),a      ;[M80] SAVE IN I/O FLAG (END OF LPT)
056C : 3E 17      [M80] LIST:   ld      a,23            ;;Set line count to 23
056E : 32 08 38                 ld      (CNTOFL),a      ;
0571 : CD 9C 06                 call    SCNLIN          ;[M80] SCAN LINE RANGE
0574 : C0                       ret     nz              ;
0575 : C1                       pop     bc              ;[M80] GET RID OF NEWSTT RETURN ADDR
0576 : CD 9F 04                 call    FNDLIN          ;[M80] DONT EVEN LIST LINE #
0579 : C5                       push    bc              ;[M80] SAVE POINTER TO 1ST LINE
057A : E1         (M80) LIST4:  pop     hl              ;[M80] GET POINTER TO LINE
057B : 4E                       ld      c,(hl)          ;[M80] [B,C]=THE LINK POINTING TO THE NEXT
057C : 23                       inc     hl              ;
057D : 46                       ld      b,(hl)          ;
057E : 23                       inc     hl              ;
057F : 78                       ld      a,b             ;[M80] SEE IF END OF CHAIN
0580 : B1                       or      c               ;
0581 : CA 02 04                 jp      z,READY         ;[M80] LAST LINE, STOP.
0584 : CD 25 1A                 call    ISCNTC          ;[M80] CHECK FOR CONTROL-C
0587 : C5                       push    bc              ;[M80] SAVE LINK
0588 : CD EA 19                 call    CRDO            ;
058B : 5E                       ld      e,(hl)          ;[M80] [B,C]=THE LINK POINTING TO THE NEXT LINE
058C : 23                       inc     hl              ;
058D : 56                       ld      d,(hl)          ;
058E : 23                       inc     hl              ;
058F : E5                       push    hl              ;[M80] DON'T ALLOW ^C
0590 : EB                       ex      de,hl           ;[M80] GET LINE # IN [H,L]
0591 : CD 75 16                 call    LINPRT          ;[M80] PRINT AS INT WITHOUT LEADING SPACE
0594 : 3E 20                    ld      a,' '           ;
0596 : E1                       pop     hl              ;
0597 : DF         (M65) PLOOP:  rst     OUTCHR          ;[M80] PRINT A SPACE AFTER THE LINE #
0598 : 7E       * [M80] LISPRT: ld      a,(hl)          ;
0599 : 23                       inc     hl              ;[M80] INCR POINTER
059A : B7                       or      a               ;[M80] SET CC
059B : 28 DD                    jr      z,LIST4         ;[M80] IF =0 THEN END OF LINE
059D : F2 97 05                 jp      p,PLOOP         ;
05A0 : F7                       rst     HOOKDO          ;;Handle Extended BASIC Tokens
05A1 : 16         {~~~} HOOK22: byte    22              ;
05A2 : D6 7F                    sub     $7F             ;
05A4 : 4F                       ld      c,a             ;
05A5 : 11 45 02                 ld      de,RESLST       ;[M80] GET PTR TO START OF RESERVED WORD LIST
05A8 : 1A         (M80) RESSRC: ld      a,(de)          ;[M80] GET CHAR FROM RESLST
05A9 : 13                       inc     de              ;[M80] BUMP SOURCE PTR
05AA : B7                       or      a               ;[M80] SET CC'S
05AB : F2 A8 05                 jp      p,RESSRC        ;[M80] IF NOT END OF THIS RESWRD, THEN KEEP LOOKING
05AE : 0D                       dec     c               ;
05AF : 20 F7                    jr      nz,RESSRC       ;
05B1 : E6 7F      [m80] MORLNP: and     $7F             ;[M80] AND OFF HIGH ORDER BIT
05B3 : DF                       rst     OUTCHR          ;[M80] STORE THIS CHAR
05B4 : 1A         {M80} MORPUR: ld      a,(de)          ;[M80] GET BYTE FROM RESWRD
05B5 : 13                       inc     de              ;[M80] BUMP POINTER
05B6 : B7                       or      a               ;[M80] SET CC'S
05B7 : F2 B1 05                 jp      p,MORLNP        ;[M80] END OF RESWRD?
05BA : 18 DC                    jr      LISPRT          ;[M80] PRINT NEXT CHAR
05BC
05BC                  + ;[M80] "FOR" STATEMENT
05BC                  | ;[M80] A "FOR" ENTRY ON THE STACK HAS THE FOLLOWING FORMAT:
05BC                  | ;[M80]
05BC                  | ;[M80] LOW ADDRESS
05BC                  | ;[M80]  TOKEN ($FOR IN HIGH BYTE)  1 BYTE
05BC                  | ;[M80]  A POINTER TO THE LOOP VARIABLE  2 BYTES
05BC                  | ;[M80]  A BYTE REFLECTING THE SIGN OF THE INCREMENT 1 BYTE
05BC                  | ;[M80]  THE STEP 4 BYTES
05BC                  | ;[M80]  THE UPPER VALUE 4 BYTES
05BC                  | ;[M80]  THE LINE # OF THE "FOR" STATEMENT 2 BYTES
05BC                  | ;[M80]  A TEXT POINTER INTO THE "FOR" STATEMENT 2 BYTES
05BC                  | ;[M80] HIGH ADDRESS
05BC                  | ;[M80]
05BC                  | ;[M80] TOTAL 16 BYTES
05BC                  | ;;;*** On the Aquarius, the entry is only 13 bytes
05BC : 3E 64      [M80] FOR:    ld      a,100
05BE : 32 CB 38                 ld      (SUBFLG),a      ;[M80] DONT RECOGNIZE SUBSCRIPTED VARIABLES
05C1 : CD 31 07                 call    LET             ;[M65] READ VARIABLE AND ASSIGN INITIAL VALUE
05C4 : C1                       pop     bc              ;
05C5 : E5                       push    hl              ;[M80] SAVE THE TEXT POINTER
05C6 : CD 1C 07                 call    DATA            ;[M80] SET [H,L]=END OF STATEMENT
05C9 : 22 C7 38                 ld      (ENDFOR),hl     ;[M80] SAVE FOR COMPARISON
05CC : 21 02 00                 ld      hl,2            ;[M80] SET UP POINTER INTO STACK
05CF : 39                       add     hl,sp           ;
05D0 : CD A3 03   (M80) LPFORM: call    LOOPER          ;[M80] MUST HAVE VARIABLE POINTER IN [D,E]
05D3 : 20 14                    jr      nz,NOTOL        ;[M80] NO MATCHING ENTRY, DON'T ELIMINATE ANYTHING
05D5 : 09                       add     hl,bc           ;[M80] ELIMINATE THE MATCHING ENTRY
05D6 : D5                       push    de              ;[M80] SAVE THE TEXT POINTER
05D7 : 2B                       dec     hl              ;[M80] SEE IF END TEXT POINTER OF MATCHING ENTRY
05D8 : 56                       ld      d,(hl)          ;[M80] MATCHES THE FOR WE ARE HANDLING
05D9 : 2B                       dec     hl              ;[M80] PICK UP THE END OF THE "FOR" TEXT POINTER
05DA : 5E                       ld      e,(hl)          ;[M80] FOR THE ENTRY ON THE STACK
05DB : 23                       inc     hl              ;[M80] WITHOUT CHANGING [H,L]
05DC : 23                       inc     hl              ;
05DD : E5                       push    hl              ;[M80] SAVE THE STACK POINTER FOR THE COMPARISON
05DE : 2A C7 38                 ld      hl,(ENDFOR)     ;[M80] GET ENDING TEXT POINTER FOR THIS "FOR"
05E1 : E7                       rst     COMPAR          ;[M80] SEE IF THEY MATCH
05E2 : E1                       pop     hl              ;[M80] GET BACK THE STACK POINTER
05E3 : D1                       pop     de              ;
05E4 : 20 EA                    jr      nz,LPFORM       ;;[M80] KEEP SEARCHING IF NO MATCH
05E6 : D1                       pop     de              ;[M80] GET BACK THE TEXT POINTER
05E7 : F9                       ld      sp,hl           ;[M80] DO THE ELIMINATION
05E8 : 0C                       inc     c               ;
05E9 : D1         (M80) NOTOL:  pop     de              ;
05EA : EB                       ex      de,hl           ;[M80] [H,L]=TEXT POINTER
05EB : 0E 08                    ld      c,8             ;[M80] MAKE SURE 16 BYTES ARE AVAILABLE
05ED : CD A0 0B                 call    GETSTK          ;[M80] OFF OF THE STACK
05F0 : E5                       push    hl              ;[M80] REALLY SAVE THE TEXT POINTER
05F1 : 2A C7 38                 ld      hl,(ENDFOR)     ;[M80] PICK UP POINTER AT END OF "FOR"
05F4 : E3                       ex      (sp),hl         ;[M80] PUT POINTER ON STACK AND RESTORE TEXT POINTER
05F5 : E5                       push    hl              ;[M80] PUSH POINTER TO VARIABLE ONTO THE STACK
05F6 : 2A 4D 38                 ld      hl,(CURLIN)     ;[M80] [H,L] GET THE CURRENT LINE #
05F9 : E3                       ex      (sp),hl         ;[M80] LINE # ON THE STACK AND [H,L] IS THE TEXT POINTER
05FA : CD 75 09                 call    CHKNUM          ;
05FD : CF                       rst     SYNCHK          ;
05FE : A1                       byte    TOTK            ;[M80] "TO" IS NECESSARY
05FF : CD 72 09                 call    FRMNUM          ;[M65] VALUE MUST BE A NUMBER
0602 : E5                       push    hl              ;
0603 : CD 2E 15                 call    MOVRF           ;[M80] GET THE STUFF
0606 : E1                       pop     hl              ;[M80] REGAIN TEXT POINTER
0607 : C5                       push    bc              ;[M80] OPPOSITE OF PUSHR
0608 : D5                       push    de              ;[M80] SAVE THE SIGN OF THE INCREMENT
0609 : 01 00 81                 ld      bc,$8100        ;[M80] DEFAULT THE STEP TO BE 1
060C : 51                       ld      d,c             ;
060D : 5A                       ld      e,d             ;[M80] GET 1.0 IN THE REGISTERS
060E : 7E                       ld      a,(hl)          ;[M80] GET TERMINATING CHARACTER
060F : FE A7                    cp      STEPTK          ;[M80] DO WE HAVE "STEP" ?
0611 : 3E 01                    ld      a,1             ;[M80] SETUP DEFAULT SIGN
0613 : 20 0A                    jr      nz,ONEON        ;[M65] NO. ASSUME 1.0.
0615 : D7                       rst     CHRGET          ;[M65] YES. ADVANCE POINTER
0616 : CD 72 09                 call    FRMNUM          ;
0619 : E5                       push    hl              ;
061A : CD 2E 15                 call    MOVRF           ;[M80] SET UP THE REGISTERS
061D : EF                       rst     FSIGN           ;[M80] GET THE SIGN OF THE INCREMENT
061E : E1         {M80} STPSGN: pop     hl              ;[M80] POP OFF THE TEXT POINTER
061F : C5         (M80) ONEON:  push    bc              ;[M80] PUT VALUE ON BACKWARDS
0620 : D5                       push    de              ;[M80] OPPOSITE OF PUSHR
0621 : F5                       push    af              ;
0622 : 33                       inc     sp              ;
0623 : E5                       push    hl              ;
0624 : 2A CE 38                 ld      hl,(SAVTXT)     ;
0627 : E3                       ex      (sp),hl         ;
0628 : 06 81      [M80] NXTCON: ld      b,FORTK         ;[M80] PUT A 'FOR' TOKEN ONTO THE STACK
062A : C5                       push    bc              ;
062B : 33                       inc     sp              ;[M80] THE "TOKEN" ONLY TAKES ONE BYTE OF STACK SPACE
062C                                                    
062C                  + ;[M80] NEW STATEMENT FETCHER
062C                  | ;[M80] BACK HERE FOR NEW STATEMENT. CHARACTER POINTED TO BY [H,L]
062C                  | ;[M80] ":" OR END-OF-LINE. THE ADDRESS OF THIS LOCATION IS
062C                  | ;[M80] LEFT ON THE STACK WHEN A STATEMENT IS EXECUTED SO
062C                  | ;[M80] IT CAN MERELY DO A RETURN WHEN IT IS DONE.
062C : 22 CE 38   [M80] NEWSTT: ld      (SAVTXT),hl     ;USED BY CONTINUE AND INPUT AND CLEAR AND PRINT USING
062F : CD C2 1F                 call    INCNTC           ;;*** might be [M65] ISCNTC
0632 : 7E                       ld      a,(hl)          ;;Get Terminator
0633 : FE 3A                    cp      ':'             ;[M80] IS IT A COLON?
0635 : 28 14                    jr      z,GONE          ;
0637 : B7                       or      a               ;
0638 : C2 C4 03                 jp      nz,SNERR        ;[M80] MUST BE A ZERO
063B : 23                       inc     hl              ;
063C : 7E         [M80] GONE4:  ld      a,(hl)          ;[M80] IF POINTER IS ZERO, END OF PROGRAM
063D : 23                       inc     hl              ;
063E : B6                       or      (hl)            ;[M80] OR IN HIGH PART
063F : CA 29 0C                 jp      z,ENDCON        ;[M80] FIX SYNTAX ERROR IN UNENDED ERROR ROUTINE
0642 : 23                       inc     hl              ;
0643 : 5E                       ld      e,(hl)          ;
0644 : 23                       inc     hl              ;
0645 : 56                       ld      d,(hl)          ;[M80] GET LINE # IN [D,E]
0646 : EB                       ex      de,hl           ;[M80] [H,L]=LINE #
0647 : 22 4D 38                 ld      (CURLIN),hl     ;[M80] SETUP CURLIN WITH THE CURRENT LINE #
064A : EB                       ex      de,hl           ;;DE=Line#, HL=Text Pointer
064B
064B : D7         [M80] GONE:   rst     CHRGET          ;[M80] GET THE STATEMENT TYPE
064C : 11 2C 06                 ld      de,NEWSTT       ;[M80] PUSH ON A RETURN ADDRESS OF NEWSTT
064F : D5                       push    de              ;[M80] STATEMENT
0650 : C8         [M80] GONE3:  ret     z               ;[M80] IF A TERMINATOR TRY AGAIN
0651                    ;[M80] "IF" COMES HERE
0651 : D6 80      [M80] GONE2:  sub     $80             ;[M80] "ON ... GOTO" AND "ON ... GOSUB" COME HERE
0653 : DA 31 07                 jp      c,LET           ;[M80] MUST BE A LET
0656 : FE 20                    cp      TABTK-$80       ;;End of Statement Tokens
0658 : F7                       rst     HOOKDO          ;;Handle Extended BASIC Statement Tokens
0659 : 17         {~~~} HOOK23: byte    23              ;
065A : D2 C4 03                 jp      nc,SNERR        ;;Not a Statement Token
065D : 07                       rlca                    ;[M80] MULTIPLY BY 2
065E : 4F                       ld      c,a             ;
065F : 06 00                    ld      b,0             ;;Offset = (Token - 128) * 2 
0661 : EB                       ex      de,hl           ;
0662 : 21 D5 01                 ld      hl,STMDSP       ;[M80] STATEMENT DISPATCH TABLE
0665 : 09         [~~~] GONE5:  add     hl,bc           ;[M80] ADD ON OFFSET
0666 : 4E                       ld      c,(hl)          ;[M80] PUSH THE ADDRESS TO GO TO ONTO
0667 : 23                       inc     hl              ;[M80] THE STACK
0668 : 46                       ld      b,(hl)          ;[M80] PUSHM SAVES BYTES BUT NOT SPEED
0669 : C5                       push    bc              ;
066A : EB                       ex      de,hl           ;[M80] RESTORE THE TEXT POINTER
066B                  + ;;Execute Statement
066B                  | ;[M80] NEWSTT FALLS INTO CHRGET. THIS FETCHES THE FIRST CHAR AFTER
066B                  | ;[M80] THE STATEMENT TOKEN AND THE CHRGET'S "RET" DISPATCHES TO STATEMENT
066B : 23         [M80] CHRGTR: inc     hl              ;[M80] DUPLICATION OF CHRGET RST FOR SPEED
066C : 7E         {M80} CHRGT2: ld      a,(hl)          ;
066D : FE 3A                    cp      ':'             ;[M80] SEE CHRGET RST FOR EXPLANATION
066F : D0                       ret     nc              ;
0670                    ;[M80] CHRCON IS THE CONTINUATION OF THE CHRGET RST                  
0670 : FE 20      [M80] CHRCON: cp      ' '             ;MUST SKIP SPACES
0672 : 28 F7                    jr      z,CHRGTR        ;GET ANOTHER CHARACTER
0674 : FE 30                    cp      '0'             ;ALL CHARS .GT. "9" HAVE RET'D SO
0676 : 3F                       ccf                     ;TURN CARRY ON IF NUMERIC.
0677 : 3C                       inc     a               ;ALSO, SETZ IF NULL.
0678 : 3D                       dec     a               ;
0679 : C9         {M80} CHRRTS: ret                     ;RETURN TO CALLER.
067A
067A                  + ;[M80] INTIDX READS A FORMULA FROM THE CURRENT POSITION AND
067A                  | ;[M80] TURNS IT INTO A POSITIVE INTEGER
067A                  | ;[M80] LEAVING THE RESULT IN [D,E].  NEGATIVE ARGUMENTS
067A                  | ;[M80] ARE NOT ALLOWED. [H,L] POINTS TO THE TERMINATING
067A                  | ;[M80] CHARACTER OF THE FORMULA ON RETURN.
067A                  | ;
067A : D7               INTIDX: rst     CHRGET          ;
067B : CD 72 09         INTID2: call    FRMNUM          ;{M80} READ FORMULA AND GET RESULT AS INTEGER IN [D,E]
067E : EF               INTFR2: rst     FSIGN           ;[M80] DON'T ALLOW NEGATIVE NUMBERS
067F : FA 97 06                 jp      m,FCERR         ;[M80] TOO BIG. FUNCTION CALL ERROR
0682
0682 : 3A E7 38   [M80] FRCINT: ld      a,(FAC)         ;
0685 : FE 90                    cp      144             ;[M65] FAC .GT. 32767?
0687 : DA 86 15                 jp      c,QINT          ;[M65] GO TO QINT AND SHOVE IT
068A : 01 80 90                 ld      bc,$9080        ;
068D : 11 00 00                 ld      de,$0000        ;[M65] -32768
0690 : E5                       push    hl              ;
0691 : CD 5B 15                 call    FCOMP           ;[M65] SEE IF FAC=[B,C,D,E]
0694 : E1                       pop     hl              ;
0695 : 51                       ld      d,c             ;
0696 : C8                       ret     z               ;[M65] NO, FAC IS TOO BIG.
0697
0697 : 1E 08      [M80] FCERR:  ld      e,ERRFC         ;[M65] "FUNCTION CALL" ERROR
0699 : C3 DB 03                 jp      ERROR           ;
069C
069C                    ;[M80]  LINGET READS A LINE # FROM THE CURRENT TEXT POSITION
069C                    ;[M80] 
069C                    ;[M80]  LINE NUMBERS RANGE FROM 0 TO 65529
069C                    ;[M80] 
069C                    ;[M80]  THE ANSWER IS RETURNED IN [D,E].
069C                    ;[M80]  [H,L] IS UPDATED TO POINT TO THE TERMINATING CHARACTER
069C                    ;[M80]  AND [A] CONTAINS THE TERMINATING CHARACTER WITH CONDITION
069C                    ;[M80]  CODES SET UP TO REFLECT ITS VALUE.
069C                    ;
069C : 2B         [M80] SCNLIN: dec     hl              
069D : 11 00 00   [M80] LINGET: ld      de,0            ;[M80] ASSUME START LIST AT ZERO
06A0 : D7         (M80) MORLIN: rst     CHRGET          ;;Get next character
06A1 : D0                       ret     nc              ;[M80] WAS IT A DIGIT
06A2 : E5                       push    hl              ;
06A3 : F5                       push    af              ;
06A4 : 21 98 19                 ld      hl,0+6552       ;[M80] SEE IF THE LINE # IS TOO BIG
06A7 : E7                       rst     COMPAR          ;
06A8 : 38 11                    jr      c,POPHSR        ;[M80] YES, DON'T SCAN ANY MORE DIGITS AND GIVE SYNTAX ERROR
06AA : 62                       ld      h,d             ;[M80] SAVE [D,E]
06AB : 6B                       ld      l,e             ;
06AC : 19                       add     hl,de           ;
06AD : 29                       add     hl,hl           ;
06AE : 19                       add     hl,de           ;
06AF : 29                       add     hl,hl           ;[M80] PUTTING [D,E]*10 INTO [H,L]
06B0 : F1                       pop     af              ;
06B1 : D6 30                    sub     '0'             ;
06B3 : 5F                       ld      e,a             ;
06B4 : 16 00                    ld      d,0             ;
06B6 : 19                       add     hl,de           ;[M80] ADD THE NEW DIGIT
06B7 : EB                       ex      de,hl           ;
06B8 : E1                       pop     hl              ;[M80] GET BACK TEXT POINTER
06B9 : 18 E5                    jr      MORLIN          ;
06BB : F1         (M80) POPHSR: pop     af              ;[M80] GET OFF TERMINATING DIGIT
06BC : E1                       pop     hl              ;[M80] GET BACK OLD TEXT POINTER
06BD : C9                       ret                     ;
06BE
06BE : F7         [M80] RUN:    rst     HOOKDO          ;Call Hook Routine
06BF : 18         {~~~} HOOK24: byte    24              ;
06C0 : CA CB 0B                 jp      z,RUNC          ;[M80] NO LINE # ARGUMENT
06C3 : CD CF 0B   {M80} CONRUN: call    CLEARC          ;RESET THE STACK,DATPTR,VARIABLES ...
06C6 : 01 2C 06                 ld      bc,NEWSTT       ;
06C9 : 18 10                    jr      RUNC2           ;[M80] PUT "NEWSTT" ON AND FALL INTO "GOTO"
06CB
06CB                  + ;[M80] GOSUB STATEMENT
06CB                  | ;[M80] A "GOSUB" ENTRY ON THE STACK HAS THE FOLLOWING FORMAT
06CB                  | ;[M80]
06CB                  | ;[M80] LOW ADDRESS
06CB                  | ;[M80]
06CB                  | ;[M80]  A TOKEN EQUAL TO $GOSUB 1 BYTE
06CB                  | ;[M80]  THE LINE # OF THE THE "GOSUB" STATEMENT 2 BYTES
06CB                  | ;[M80]  A POINTER INTO THE TEXT OF THE "GOSUB" 2 BYTES
06CB                  | ;[M80]
06CB                  | ;[M80] HIGH ADDRESS
06CB                  | ;[M80]
06CB                  | ;[M80] TOTAL 5 BYTES
06CB : 0E 03      [M80] GOSUB:  ld      c,3             ;[M80] "GOSUB" ENTRIES ARE 5 BYTES LONG
06CD : CD A0 0B                 call    GETSTK          ;[M80] MAKE SURE THERE IS ROOM
06D0 : C1                       pop     bc              ;[M80] POP OFF RETURN ADDRESS OF "NEWSTT"
06D1 : E5                       push    hl              ;[M80] REALLY PUSH THE TEXT POINTER
06D2 : E5                       push    hl              ;[M80] SAVE TEXT POINTER
06D3 : 2A 4D 38                 ld      hl,(CURLIN)     ;[M80] GET THE CURRENT LINE #
06D6 : E3                       ex      (sp),hl         ;[M80] PUT CURLIN ON THE STACK AND [H,L]=TEXT PTR
06D7 : 3E 8C                    ld      a,GOSUTK        ;
06D9 : F5                       push    af              ;[M80] PUT GOSUB TOKEN ON THE STACK
06DA : 33                       inc     sp              ;[M80] THE GOSUB TOKEN TAKES ONLY ONE BYTE
06DB
06DB : C5         [M80] RUNC2:  push    bc              ;[M80] RESTORE RETURN ADDRESS OF "NEWSTT"
06DC
06DC : CD 9C 06   [M80] GOTO:   call    SCNLIN          ;[M80] PICK UP THE LINE # AND PUT IT IN [D,E]
06DF : CD 1E 07                 call    REM             ;[M80] SKIP TO THE END OF THIS LINE
06E2 : 23                       inc     hl              ;[M80] POINT AT THE LINK BEYOND IT
06E3 : E5                       push    hl              ;[M80] SAVE THE POINTER
06E4 : 2A 4D 38                 ld      hl,(CURLIN)     ;[M80] GET THE CURRENT LINE #
06E7 : E7                       rst     COMPAR          ;;Is target line less than current line
06E8 : E1                       pop     hl              ;[M80] [H,L]=CURRENT POINTER
06E9 : DC A2 04                 call    c,LOOP          ;[M80] SEARCH FROM THIS POINT
06EC : D4 9F 04                 call    nc,FNDLIN       ;[M80] SEARCH FROM THE BEGINNING -- ACTUALLY
06EF : 60                       ld      h,b             ;[M80] [H,L]= POINTER TO THE START OF THE MATCHED LINE
06F0 : 69                       ld      l,c             ;
06F1 : 2B                       dec     hl              ;
06F2 : D8                       ret     c               ;[M80] GO TO NEWSTT
06F3 : 1E 0E      [M80] USERR:  ld      e,ERRUS         ;[M80] C=MATCH, SO IF NO MATCH WE
06F5 : C3 DB 03                 jp      ERROR           ;[M80] GIVE A "US" ERROR
06F8
06F8                  + ;[M80] RETURN STATEMENT
06F8                  | ;[M80] SEE "GOSUB" FOR THE FORMAT OF THE STACK ENTRY
06F8                  | ;[M80] "RETURN" RESTORES THE LINE NUMBER AND TEXT POINTER ON THE STACK
06F8                  | ;[M80] AFTER ELIMINATING ALL THE "FOR" ENTRIES IN FRONT OF THE "GOSUB"
06F8                  | ;[M80] ENTRY
06F8 : C0         [M80] RETURN: ret     nz              ;[M80] BLOW HIM UP IF THERE ISN'T A TERMINATOR
06F9 : 16 FF                    ld      d,255           ;[M80] MAKE SURE VARIABLE POINTER IN [D,E] NEVER GETS MATCHED
06FB : CD 9F 03                 call    FNDFOR          ;[M80] GO PAST ALL THE "FOR" ENTRIES
06FE : F9                       ld      sp,hl           ;[M80] UPDATE THE STACK
06FF : FE 8C                    cp      GOSUTK          ;
0701 : 1E 04                    ld      e,ERRRG         ;[M80] ERROR ERRRG IS "RETURN WITHOUT GOSUB"
0703 : C2 DB 03                 jp      nz,ERROR        ;
0706 : E1                       pop     hl              ;GET LINE # "GOSUB" WAS FROM
0707 : 22 4D 38                 ld      (CURLIN),hl     ;PUT IT INTO CURLIN
070A : 23                       inc     hl              ;
070B : 7C                       ld      a,h             ;
070C : B5                       or      l               ;;Is line number $FFFF
070D : 20 07                    jr      nz,RETU1        ;;No, carry on
070F : 3A CC 38                 ld      a,(USFLG)       ;
0712 : B7                       or      a               ;;Is flag set?
0713 : C2 01 04                 jp      nz,STPRDY       ;;Yes, abort to direct mode
0716 : 21 2C 06   (M65) RETU1:  ld      hl,NEWSTT       ;[M80] PUT RETURN ADDRESS OF "NEWSTT" BACK ON STACK
0719 : E3                       ex      (sp),hl         ;[M80] GET TEXT POINTER FROM "GOSUB"
071A : 3E                       byte    $3E             ;{M80} "LD A," AROUND POP HL
071B : E1         [M80] DATAH:  pop     hl              ;[M80] GET TEXT POINTER OFF STACK
071C : 01         [M80] DATA:   byte    $01             ;[M80] "LD BC," TO PICK UP ":" INTO C AND SKIP
071D : 3A                       byte    ':'             ;{M80} ":" ONLY APPLIES IF QUOTES HAVE MATCHED UP
071E : 0E         [M80] REM:    byte    $0E             ;[M80] "LD C,"   THE ONLY TERMINATOR IS ZERO
071F : 00                       byte    0               ;[M80] NO-OPERATION "DATA" ACTUALLY EXECUTES THIS 0
0720 : 06 00                    ld      b,0             ;[M80] INSIDE QUOTES THE ONLY TERMINATOR IS ZERO
0722 : 79         (M80) EXCHQT: ld      a,c             ;[M80] WHEN A QUOTE IS SEEN THE SECOND
0723 : 48                       ld      c,b             ;[M80] TERMINATOR IS TRADED, SO IN "DATA"
0724 : 47                       ld      b,a             ;[M80] COLONS INSIDE QUOTATIONS WILL HAVE NO EFFECT
0725 : 7E         (M80) REMER:  ld      a,(hl)          ;[M80] GET A CHAR
0726 : B7                       or      a               ;[M80] ZERO IS ALWAYS A TERMINATOR
0727 : C8                       ret     z               ;
0728 : B8                       cp      b               ;[M80] TEST FOR THE OTHER TERMINATOR
0729 : C8                       ret     z               ;
072A : 23                       inc     hl              ;
072B : FE 22                    cp      '"'             ;[M80] IS IT A QUOTE?
072D : 28 F3                    jr      z,EXCHQT        ;[M80] IF SO TIME TO TRADE
072F : 18 F4                    jr      REMER           ;
0731
0731 : CD D1 10   [M80] LET:    call    PTRGET          ;[M80] GET POINTER TO VARIABLE INTO [D,E]
0734 : CF                       rst     SYNCHK          ;[M80] 
0735 : B0                       byte    EQUATK          ;[M80] CHECK FOR "="
0736 : D5                       push    de              ;[M80] SAVE THE VARIABLE POINTER
0737 : 3A AB 38                 ld      a,(VALTYP)      ;{M80} REMEMBER THE VARIABLE TYPE
073A : F5                       push    af              ;
073B : CD 85 09                 call    FRMEVL          ;[M80] GET THE VALUE OF THE FORMULA
073E : F1                       pop     af              ;[M80] GET THE VALTYP OF THE VARIABLE INTO [A] INTO FAC
073F : E3                       ex      (sp),hl         ;[M80] [H,L]=POINTER TO VARIABLE, TEXT POINTER ON TOP OF STACK
0740 : 22 CE 38                 ld      (SAVTXT),hl     ;[???] PLACE TO SAVE THE VALUE
0743 : 1F                       rra                     ;
0744 : CD 77 09                 call    CHKVAL          ;[M65] MAKE SURE "VALTYP" MATCHES CARRY AND SET ZERO FLAG FOR NUMERIC
0747 : CA 79 07                 jp      z,COPNUM        ;[M80] NUMERIC, SO FORCE IT AND COPY
074A                    
074A : E5         [M80] INPCOM: push    hl              ;
074B : 2A E4 38                 ld      hl,(FACLO)      ;[M80] GET POINTER TO THE DESCRIPTOR OF THE RESULT
074E : E5                       push    hl              ;[M80] SAVE THE POINTER AT THE DESCRIPTOR
074F : 23                       inc     hl              ;
0750 : 23                       inc     hl              ;
0751 : 5E                       ld      e,(hl)          ;
0752 : 23                       inc     hl              ;
0753 : 56                       ld      d,(hl)          ;
0754 : 2A 4F 38                 ld      hl,(TXTTAB)     ;[M80] IF THE DATA IS IN BUF, COPY
0757 : E7                       rst     COMPAR          ;[M80] SINCE BUF CHANGES ALL THE TIME
0758 : 30 0E                    jr      nc,INBUFC       ;[M80] GO COPY, IF DATA REALLY IS IN BUF
075A : 2A DA 38                 ld      hl,(STREND)     ;[M80] SEE IF IT POINTS INTO STRING SPACE
075D : E7                       rst     COMPAR          ;[M80] IF NOT DON'T COPY
075E : D1                       pop     de              ;[M80] GET BACK THE POINTER AT THE DESCRIPTOR
075F : 30 0F                    jr      nc,DNTCPY       ;[M80] DON'T COPY LITERALS
0761 : 21 BD 38                 ld      hl,DSCTMP       ;[M80] NOW, SEE IF ITS A VARIABLE BY SEEING IF THE DESCRIPTOR
0764 : E7                       rst     COMPAR          ;[M80] IS IN THE TEMPORARY STORAGE AREA (BELOW DSCTMP)
0765 : 30 09                    jr      nc,DNTCPY       ;[M80] DON'T COPY IF ITS NOT A VARIABLE
0767 : 3E                       byte    $3E             ;[M80] SKIP THE NEXT BYTE WITH A "MVI A,"
0768 : D1         [M80] INBUFC: pop     de              ;[M80] GET THE POINTER TO THE DESCRIPTOR IN [D,E]
0769 : CD E4 0F                 call    FRETMS          ;[M80] FREE UP A TEMORARY POINTING INTO BUF
076C : EB                       ex      de,hl           ;[M80] STRCPY COPIES [H,L]
076D : CD 39 0E                 call    STRCPY          ;[M80] COPY VARIABLES IN STRING SPACE OR STRINGS WITH DATA IN BUF
0770 : CD E4 0F   (M80) DNTCPY: call    FRETMS          ;[M80] FREE UP TEMPORARY WITHOUT FREEING UP ANY STRING SPACE
0773 : E1                       pop     hl              ;[M80] 
0774 : CD 3D 15                 call    MOVE            ;[M80] COPY A DESCRIPTOR OR A VALUE
0777 : E1                       pop     hl              ;[M80] GET THE TEXT POINTER BACK
0778 : C9                       ret                     ;
0779                    
0779 : E5         [M80] COPNUM: push    hl
077A : CD 3A 15                 call    MOVMF           ;COPY A DESCRIPTOR OR A VALUE
077D : D1                       pop     de              ;FOR "FOR" POP OFF POINTER AT LOOP VARIABLE INTO [D,E]
077E : E1                       pop     hl              ;GET THE TEXT POINTER BACK
077F : C9                       ret
0780
0780                    ;{M80} ON..GOTO, ON GOSUB CODE
0780 : F7         [M80] ONGOTO: rst     HOOKDO          ;
0781 : 19         {~~~} HOOK25: byte    25              ;
0782 : CD 54 0B   {M80] NTOERR: call    GETBYT          ;[M80] GET VALUE INTO [E]
0785 : 7E               OMGOTO  ld      a,(hl)          ;[M80] GET THE TERMINATOR BACK
0786 : 47                       ld      b,a             ;[M80] SAVE THIS CHARACTER FOR LATER
0787 : FE 8C                    cp      GOSUTK          ;[M80] AN "ON ... GOSUB" PERHAPS?
0789 : 28 03                    jr      z,ISGOSU        ;[M80] YES, SOME FEATURE USE
078B : CF                       rst     SYNCHK          ;
078C : 88                       byte    GOTOTK          ;[M80] OTHERWISE MUST BE "GOTO"
078D : 2B                       dec     hl              ;[M80] BACK UP CHARACTER POINTER
078E : 4B         (M80) ISGOSU: ld      c,e             ;[M80] GET COUNT INTO [C]
078F : 0D         (M80) LOOPON: dec     c               ;[M80] SEE IF ENOUGH SKIPS
0790 : 78                       ld      a,b             ;[M80] PUT DISPATCH CHARACTER IN PLACE
0791 : CA 51 06                 jp      z,GONE2         ;[M80] IF DONE, GO OFF
0794 : CD 9D 06                 call    LINGET          ;[M80] SKIP OVER A LINE #
0797 : FE 2C                    cp      ','             ;[M80] IS IT A COMMA?
0799 : C0                       ret     nz              ;{M80} NO COMMA MUST BE THE END OF THE LINE
079A : 18 F3                    jr      LOOPON          ;[M80] CONTINUE GOBBLING LINE #S
079C
079C                    ;[M80] IF ... THEN CODE
079C : CD 85 09   [M80] IFS:    call    FRMEVL          ;[M80] EVALUATE A FORMULA
079F : 7E                       ld      a,(hl)          ;[M80] GET TERMINATING CHARACTER OF FORMULA
07A0 : FE 88                    cp      GOTOTK          ;[M80] ALLOW "GOTO" AS WELL
07A2 : 28 03                    jr      z,OKGOTO        ;
07A4 : CF                       rst     SYNCHK          ;
07A5 : A5                       byte    THENTK          ;[M80] MUST HAVE A THEN
07A6 : 2B                       dec     hl              ;
07A7 : CD 75 09   [M80] OKGOTO: call    CHKNUM          ;[M65] 0=FALSE. ALL OTHERS TRUE
07AA : EF                       rst     FSIGN           ;
07AB : CA 1E 07                 jp      z,REM           ;[M65] SKIP REST OF STATEMENT
07AE : D7         {M80} DOCOND: rst     CHRGET          ;[M80] PICK UP THE FIRST LINE # CHARACTER
07AF : DA DC 06                 jp      c,GOTO          ;[M80] DO A "GOTO"
07B2 : C3 50 06                 jp      GONE3           ;[M80] EXECUTE STATEMENT, NOT GOTO
                        ;
07B5 : 3E 01      [M80] LPRINT: ld      a,1             ;SAY NON ZERO
07B7 : 32 47 38                 ld      (PRTFLG),a      ;SAVE AWAY
07BA : 2B         [M80] NEWCHR: dec     hl              ;
07BB : D7                       rst     CHRGET          ;[M80] GET ANOTHER CHARACTER
07BC : F7         [M80] PRINT:  rst     HOOKDO          ;
07BD : 06         {~~~} HOOK6:  byte    6               ;
07BE : CC EA 19                 call    z,CRDO          ;[M80] PRINT CRLF IF END WITHOUT PUNCTUATION
07C1 : CA 66 08   (M80) PRINTC: jp      z,FINPRT        ;{M80} FINISH BY RESETTING FLAGS, TERMINATOR SHOULD NOY CRLF
07C4 : FE A0                    cp      TABTK           ;
07C6 : CA 3A 08                 jp      z,TABER         ;[M80] THE TAB FUNCTION?
07C9 : FE A3                    cp      SPCTK           ;
07CB : CA 3A 08                 jp      z,TABER         ;[M80] THE SPC FUNCTION?
07CE : E5                       push    hl              ;{M80} SAVE THE TEXT POINTER
07CF : FE 2C                    cp      ','             ;
07D1 : 28 44                    jr      z,COMPRT        ;[M80] IS IT A COMMA?
07D3 : FE 3B                    cp      $3B             ;{M80} IS IT A ";"
07D5 : CA 61 08                 jp      z,NOTABR        ;
07D8 : C1                       pop     bc              ;[M80] GET RID OF OLD TEXT POINTER
07D9 : CD 85 09                 call    FRMEVL          ;[M80] EVALUATE THE FORMULA
07DC : E5                       push    hl              ;[M80] SAVE TEXT POINTER
07DD : 3A AB 38                 ld      a,(VALTYP)      ;[M80] SEE IF WE HAVE A STRING
07E0 : B7                       or      a               ;
07E1 : C2 11 08                 jp      nz,STRDON       ;[M80] IF SO, PRINT SPECIALY
07E4 : CD 80 16                 call    FOUT            ;[M80] MAKE A NUMBER INTO A STRING
07E7 : CD 5F 0E                 call    STRLIT          ;[M80] MAKE IT  A STRING
07EA : 36 20                    ld      (hl),' '        ;[M80] PUT A SPACE AT THE END
07EC : 2A E4 38                 ld      hl,(FACLO)      ;[M80] SIZE BYTE IS FIRST IN DESCRIPTOR
07EF : 3A 47 38                 ld      a,(PRTFLG)      ;
07F2 : B7                       or      a               ;
07F3 : 28 08                    jr      z,ISTTY         ;[M80] LPT OR TTY?
07F5 : 3A 46 38                 ld      a,(LPTPOS)      ;
07F8 : 86                       add     a,(hl)          ;
07F9 : FE 84                    cp      LPTSIZ          ;[M80] CHECK FOR OVERLAP
07FB : 18 0D                    jr      LINCHK          ;[M80] START ON A NEW LINE
07FD : 3A 48 38   (M80) ISTTY:  ld      a,(LINLEN)      ;
0800 : 47                       ld      b,a             ;
0801 : 3C                       inc     a               ;[M80] NO OVERFLOW LINE WIDTH?
0802 : 28 09                    jr      z,LINCH2        ;[M80] YES
0804 : 3A 00 38                 ld      a,(TTYPOS)      ;[M80] SEE WHERE WE ARE
0807 : 86                       add     a,(hl)          ;
0808 : 3D                       dec     a               ;[M80] ACTUALLY EQUAL TO LINE LENGTH IS OK
0809 : B8                       cp      b               ;
080A : D4 EA 19   (M80) LINCHK: call    nc,CRDO         ;[M80] IF SO CRLF
080D : CD A0 0E   (M80) LINCH2: call    STRPRT          ;[M80] PRINT THE NUMBER
0810 : AF                       xor     a               ;
0811 : C4 A0 0E   (M80) STRDON: call    nz,STRPRT       ;[M80] PRINT THE NUMBER
0814 : E1                       pop     hl              ;
0815 : 18 A3                    jr      NEWCHR          ;[M80[ PRINT SOME MORE
0817 : 3A 47 38   (M80) COMPRT: ld      a,(PRTFLG)      ;[M80[ OUTPUT TO THE LINE PRINTER?
081A : B7                       or      a               ;[M80[ NON-ZERO MEANS YES
081B : 28 08                    jr      z,ISCTTY        ;[M80[ NO, DO TELETYPE COMMA
081D : 3A 46 38                 ld      a,(LPTPOS)      ;[M80[ ARE WE USING INFINITE WIDTH?
0820 : FE 70                    cp      112             ;[M80[ CHECK IF NO MORE COMMA FIELDS
0822 : C3 2D 08                 jp      CHKCOM          ;[M80[ USE TELETYPE CHECK
0825 : 3A 49 38   (M80) ISCTTY: ld      a,(CLMLST)      ;[M80] POSITION OF LAST COMMA COLUMN
0828 : 47                       ld      b,a             ;
0829 : 3A 00 38                 ld      a,(TTYPOS)      ;[M80] GET TELETYPE POSITION
082C : B8                       cp      b               ;
082D : D4 EA 19   (M80) CHKCOM: call    nc,CRDO         ;[M80] TYPE CRLF
0830 : D2 61 08                 jp      nc,NOTABR       ;[M80] AND QUIT IF BEYOND THE LAST COMMA FIELD
0833 : D6 0E      (M80) MORCOM: sub     CLMWID          ;[M80] GET [A] MODULUS CLMWID
0835 : 30 FC                    jr      nc,MORCOM       ;
0837 : 2F                       cpl                     ;[M80] FILL OUT TO AN EVEN CLMWID: CLMWID-[A] MOD CLMWID SPACES
0838 : 18 20                    jr      ASPA2           ;[M80] GO PRINT [A]+1 SPACES
083A : F5         (M80) TABER:  push    af              ;[M80] REMEMBER IF [A]=SPCTK OR TABTK
083B : CD 53 0B                 call    GTBYTC          ;[M80] EVALUATE THE ARGUMENT
083E : CF                       rst     SYNCHK          ;
083F : 29                       byte    ')'             ;
0840 : 2B                       dec     hl              ;
0841 : F1                       pop     af              ;[M80] GET BACK SPCTK OR TABTK
0842 : D6 A3                    sub     SPCTK           ;[M80] WAS IT SPCTK?
0844 : E5                       push    hl              ;[M80] SAVE THE TEXT POINTER
0845 : 28 0F                    jr      z,DOSIZT        ;[M80] VALUE IN [A]
0847 : 3A 47 38                 ld      a,(PRTFLG)      ;[M80] LINE PRINTER OR TTY?
084A : B7                       or      a               ;[M80] NON-ZERO MEANS LPT
084B : CA 53 08                 jp      z,TTYIST        ;
084E : 3A 46 38                 ld      a,(LPTPOS)      ;[M80] GET LINE PRINTER POSITION
0851 : 18 03                    jr      DOSIZT          ;
0853 : 3A 00 38   (M80) TTYIST: ld      a,(TTYPOS)      ;[M80] GET TELETYPE PRINT POSITION
0856 : 2F         (M80) DOSIZT: cpl                     ;[M80] PRINT [E]-[A] SPACES
0857 : 83                       add     a,e             ;
0858 : 30 07                    jr      nc,NOTABR       ;[M80] PRINT IF PAST CURRENT
085A : 3C         (M80) ASPA2:  inc     a               ;
085B : 47                       ld      b,a             ;[M80] [B]=NUMBER OF SPACES TO PRINT
085C : 3E 20                    ld      a,' '           ;[M80] [A]=SPACE
085E : DF         (M80) REPOUT: rst     OUTCHR          ;[M80] PRINT [A]
085F : 10 FD                    djnz    REPOUT          ;[M80] DECREMENT THE COUNT
0861 : E1         (M80) NOTABR: pop     hl              ;[M80] PICK UP TEXT POINTER
0862 : D7                       rst     CHRGET          ;[M80] AND THE NEXT CHARACTER
0863 : C3 C1 07                 jp      PRINTC          ;{M80} WE JUST PRINTED SPACES, DON'T CALL CRDO IF END OF THE LINE
0866 : F7         (M80) FINPRT: rst     HOOKDO          ;
0867 : 07         {~~~} HOOK7:  byte    7               ;
0868 : AF                       xor     a               ;
0869 : 32 47 38                 ld      (PRTFLG),a      ;[M80] ZERO OUT PTRFIL
086C : C9                       ret                     ;
086D                    
086D : 3F 52 65 64      TRYAGN: byte    "?Redo from start",13,10,0
0871 : 6F 20 66 72                
0875 : 6F 6D 20 73             
0879 : 74 61 72 74                
087D : 0D 0A 00                
0880                    
0880                  + ;[M80]  HERE WHEN THE DATA THAT WAS TYPED IN OR IN "DATA" STATEMENTS
0880                  | ;[M80]  IS IMPROPERLY FORMATTED. FOR "INPUT" WE START AGAIN.
0880                  | ;[M80]  FOR "READ" WE GIVE A SYNTAX ERROR AT THE DATA LINE.
0880                  | ;
0880 : F7               TRMNOK: rst     HOOKDO          ;
0881 : 08         {~~~} HOOK8:  byte    8               ;
0882 : 3A CD 38                 ld      a,(FLGINP)      ;[M80] WAS IT READ OR INPUT?
0885 : B7                       or      a               ;[M80] ZERO=INPUT
0886 : C2 BE 03                 jp      nz,DATSNE       ;[M80] GIVE ERROR AT DATA LINE
0889 : C1                       pop     bc              ;[M80] GET RID OF THE POINTER INTO THE VARIABLE LIST
088A : 21 6D 08                 ld      hl,TRYAGN       ;[M80] PRINT "?REDO FROM START"
088D : CD 9D 0E                 call    STROUT          ;
0890 : C3 01 0C                 jp      GTMPRT          ;          
0893
0893 : F7         [M80] INPUT:  rst     HOOKDO          ;
0894 : 1A         {~~~} HOOK26: byte    26              ;
0895 : CD 45 0B                 call    ERRDIR          ;[M65] DIRECT IS NOT OK 
0898 : 7E                       ld      a,(hl)          ;
0899 : FE 22      {M80} QTINP:  cp      '"'             ;[M80] IS IT A QUOTE?
089B : 3E 00                    ld      a,0             ;[M80] BE TALKATIVE
089D : C2 AA 08                 jp      nz,NOTQTI       ;[M65] NO MESSAGE
08A0 : CD 60 0E                 call    STRLTI          ;[M65] LITERALIZE THE STRING IN TEXT
08A3 : CF         {M80} NTICMA: rst     SYNCHK          ;
08A4 : 3B                       byte    ';'             ;[M80] MUST END WITH SEMICOLON
08A5 : E5         {M80} INPCMA: push    hl              ;[M80] REMEMBER WHERE IT ENDED
08A6 : CD A0 0E                 call    STRPRT          ;[M80] PRINT IT OUT
08A9 : 3E                       byte    $3E             ;;[LD A,] over next instruction
08AA : E5         (M80) NOTQTI: push    hl              ;{M80} SAVE TEXT POINTER
08AB : CD 5B 0D                 call    QINLIN          ;[M65] TYPE "?" AND INPUT A LINE OF TEXT.
08AE : C1                       pop     bc              ;{M80} GET BACK THE TEXT POINTER
08AF : DA 26 0C                 jp      c,STPEND        ;{M80} IF CONTROL-C, STOP
08B2 : 23                       inc     hl              ;
08B3 : 7E                       ld      a,(hl)          ;
08B4 : B7                       or      a               ;
08B5 : 2B                       dec     hl              ;
08B6 : C5                       push    bc              ;
08B7 : CA 1B 07                 jp      z,DATAH         ;
08BA : 36 2C      {M80} INPCN3: ld      (hl),','        ;[M80] SETUP COMMA AT BUFMIN
08BC : 18 05                    jr      INPCON          ;
08BE
08BE                  + ;[M80] READ STATEMENT
08BE                  | ;[M80] IN THE PROCESSING OF DATA AND READ STATEMENTS:
08BE                  | ;[M80] ONE POINTER POINTS TO THE DATA (IE THE NUMBERS BEING FETCHED)
08BE                  | ;[M80] AND ANOTHER POINTS TO THE LIST OF VARIABLES
08BE                  | ;[M80]
08BE                  | ;[M80] THE POINTER INTO THE DATA ALWAYS STARTS POINTING TO A
08BE                  | ;[M80] TERMINATOR -- A , : OR END-OF-LINE
08BE : E5         [M80] READ:   push    hl              ;[M80] SAVE THE TEXT POINTER
08BF : 2A DC 38                 ld      hl,(DATPTR)     ;[M80] GET LAST DATA LOCATION
08C2 : F6                       byte    $F6             ;[M80] "ORI" TO SET [A] NON-ZERO
08C3 : AF         (M80) INPCON: xor     a               ;[M80] SET FLAG THAT THIS IS AN INPUT
08C4 : 32 CD 38                 ld      (FLGINP),a      ;[M80] STORE THE FLAG
08C7 : E3                       ex      (sp),hl         ;[M80] [H,L]=VARIABLE LIST POINTER
08C8 : 01                       byte    $01             ;[M80] "LD BC," OVER THE NEXT 2
08C9 : CF         [M80] LOPDT2: rst     SYNCHK          
0BCA : 2C                       byte    ','             ;[M80] MAKE SURE THERE IS A ","
08CB : CD D1 10   {M80} LOPDAT: call    PTRGET          ;[M80] GET THE POINTER TO A VARIABLE INTO [D,E]
08CE : E3                       ex      (sp),hl         ;;Swap with Data List Pointer
08CF                    ;[M80] NOTE AT THIS POINT WE HAVE A VARIABLE WHICH WANTS DATA
08CF                    ;[M80] AND SO WE MUST GET DATA OR COMPLAIN
08CF : D5                       push    de              ;[M80] SAVE THE POINTER TO THE VARIABLE
08D0 : 7E                       ld      a,(hl)          ;[M80] READ DATA LIST TERMINATOR
08D1 : FE 2C                    cp      ','             ;
08D3 : 28 1B                    jr      z,DATBK         ;[M80] A COMMA SO A VALUE MUST FOLLOW
08D5 : 3A CD 38                 ld      a,(FLGINP)      ;[M80] SEE WHAT TYPE OF STATEMENT THIS WAS
08D8 : B7                       or      a               ;;???ZERO FOR INPUT, OTHERWISE READ
08D9 : C2 53 09                 jp      nz,DATLOP       ;[M80] SEARCH FOR ANOTHER DATA STATEMENT
08DC
08DC : 3E 3F      {M80} GETAGN: ld      a,'?'           ;[M80] TYPE "?" AND INPUT A LINE OF TEXT
08DE : DF                       rst     OUTCHR          ;
08DF : CD 5B 0D                 call    QINLIN          ;
08E2 : D1                       pop     de              ;
08E3 : C1                       pop     bc              ;[M80] TAKE OFF SINCE MAYBE LEAVING
08E4 : DA 26 0C                 jp      c,STPEND        ;[M80] IF EMPTY LEAVE
08E7 : 23                       inc     hl              ;
08E8 : 7E                       ld      a,(hl)          ;
08E9 : 2B                       dec     hl              ;
08EA : B7                       or      a               ;
08EB : C5                       push    bc              ;[M80] PUT BACK  SINCE DIDN'T LEAVE
08EC : CA 1B 07                 jp      z,DATAH
08EF : D5                       push    de              ;{M80} SAVE THE POINTER TO THE VARIABLE
08F0                    
08F0 : F7         [M80] DATBK:  rst     HOOKDO          ;;Call Extended Hook 28
08F1 : 1C         {~~~} HOOK28: byte    28              ;
08F2 : 3A AB 38                 ld      a,(VALTYP)      ;[M80] IS IT A STRING?
08F5 : B7                       or      a               ;
08F6 : 28 1F                    jr      z,NUMINS        ;[M80] IF NUMERIC, USE FIN TO GET IT
08F8 : D7                       rst     CHRGET          ;
08F9 : 57                       ld      d,a             ;[M80] ASSUME QUOTED STRING
08FA : 47                       ld      b,a             ;[M80] SETUP TERMINATORS
08FB : FE 22                    cp      '"'             ;[M80] QUOTE ?
08FD : 28 0C                    jr      z,NOWGET        ;[M80] TERMINATORS OK
08FF : 3A CD 38                 ld      a,(FLGINP)      ;[M80] INPUT SHOULDN'T TERMINATE ON ":"      
0902 : B7                       or      a               ;[M80] SEE IF READ OR INPUT
0903 : 57                       ld      d,a             ;[M80] SET D TO ZERO FOR INPUT
0904 : 28 02                    jr      z,NCOLST        ;
0906 : 16 3A                    ld      d,':'           ;[M80] UNQUOTED STRING TERMINATORS
0908 : 06 2C      (M80) NCOLST: ld      b,','           ;[M80] ARE COLON AND COMMA
090A : 2B                       dec     hl              ;[M80] START CHARACTER MUST BE INCLUDED IN THE QUOTED STRING
090B : CD 63 0E   (M80) NOWGET: call    STRLT2          ;[M80] MAKE STRING DESCRIPTOR FOR VALUE AND COPY IF NECESSARY
090E : EB                       ex      de,hl           ;
090F : 21 20 09                 ld      hl,STRDN2       ;[M80] RETURN LOC
0912 : E3                       ex      (sp),hl         ;[M80] [H,L]=PLACE TO STORE VARIABLE VALUE
0913 : D5                       push    de              ;[M80] TEXT POINTER GOES ON
0914 : C3 4A 07                 jp      INPCOM          ;[M80] DO ASSIGNMENT
0917 : D7         (M80) NUMINS: rst     CHRGET          ;
0918 : CD E5 15                 call    FIN             ;[M80] CALL # INPUTTER
091B : E3                       ex      (sp),hl         ;*** tail end of [M80] FIN?
091C : CD 3A 15                 call    MOVMF           ;
091F : E1                       pop     hl              ;
0920 : 2B         (M80) STRDN2: dec     hl              ;
0921 : D7                       rst     CHRGET          ;
0922 : 28 05                    jr      z,TRMOK         ;
0924 : FE 2C                    cp      ','             ;
0926 : C2 80 08                 jp      nz,TRMNOK       ;[M80] ENDED PROPERLY?
0929 : E3         [M80] TRMOK:  ex      (sp),hl         ;
092A : 2B                       dec     hl              ;[M80] LOOK AT TERMINATOR
092B : D7                       rst     CHRGET          ;[M80] AND SET UP CONDITION CODES
092C : C2 C9 08                 jp      nz,LOPDT2       ;[M80] NOT ENDING, CHECK FOR COMMA AND GET ANOTHER VARIABLE
092F : D1                       pop     de              ;[M80] POP OFF THE POINTER INTO DATA
0930 : 3A CD 38                 ld      a,(FLGINP)      ;[M80] FETCH THE STATEMENT TYPE FLAG
0933 : B7                       or      a               ;
0934 : EB                       ex      de,hl           ;[M80] INPUT STATEMENT
0935 : C2 1A 0C                 jp      nz,RESFIN       ;[M80] UPDATE DATPTR
0938 : D5                       push    de              ;[M80] SAVE THE TEXT POINTER
0939 : B6                       or      (hl)            ;
093A : 21 42 09                 ld      hl,EXIGNT       ;
093D : C4 9D 0E                 call    nz,STROUT       ;[M65] TYPE "?EXTRA IGNORED"
0940 : E1                       pop     hl              ;
0941 : C9                       ret                     ;[M65[ DO NEXT STATEMENT
0942
0942 : 3F 45 78 74[M65] EXIGNT: byte    "?Extra ignored",13,10,0
0946 : 72 61 20 69
094A : 67 6E 6F 72
094E : 65 64 0D 0A
0952 : 00
0953                    
0953                  + ;[M80] THE SEARCH FOR DATA STATMENTS IS MADE BY USING THE EXECUTION CODE
0953                  | ;[M80] FOR DATA TO SKIP OVER STATEMENTS. THE START WORD OF EACH STATEMENT
0953                  | ;[M80] IS COMPARED WITH $DATA. EACH NEW LINE NUMBER
0953                  | ;[M80] IS STORED IN DATLIN SO THAT IF AN ERROR OCCURS WHILE READING
0953                  | ;[M80] DATA THE ERROR MESSAGE WILL GIVE THE LINE NUMBER OF THE 
0953                  | ;[M80] ILL-FORMATTED DATA
0953                  | ;
0953 : CD 1C 07   [M80] DATLOP: call    DATA            ;
0956 : B7                       or      a               ;
0957 : 20 11                    jr      nz,NOWLIN       ;
0959 : 23                       inc     hl              ;
095A : 7E                       ld      a,(hl)          ;
095B : 23                       inc     hl              ;
095C : B6                       or      (hl)            ;
095D : 1E 06                    ld      e,ERROD         ;[M80] NO DATA IS ERROR ERROD
095F : CA DB 03                 jp      z,ERROR         ;[M80] IF SO COMPLAIN
0962 : 23                       inc     hl              ;[M80] SKIP PAST LINE #
0963 : 5E                       ld      e,(hl)          ;[M80] GET DATA LINE #
0964 : 23                       inc     hl              ;
0965 : 56                       ld      d,(hl)          ;
0966 : ED 53 C9 38              ld      (DATLIN),de     ;
096A : D7               NOWLIN: rst     CHRGET          ;[M80] GET THE STATEMENT TYPE
096B : FE 83                    cp      DATATK          ;[M80] IS IS "DATA"?
096D : 20 E4                    jr      nz,DATLOP       ;[M80] NOT DATA SO LOOK SOME MORE
096F : C3 F0 08                 jp      DATBK           ;[M80] CONTINUE READING
0972                                                    
0972                 +  ;[M65] THESE ROUTINES CHECK FOR CERTAIN "VALTYP".
0972                 |  ;[M65] [C] IS NOT PRESERVED.
0972                 |  ;                                
0972 : CD 85 09   [M65] FRMNUM: call    FRMEVL          ;{M80} EVALUATE A FORMULA
0975 : F6         [M65] CHKNUM: byte    $F6             ;;"OR $37" to skip next instruction
0976 : 37         [M65] CHKSTR: scf                     ;;Set Carry to match strings
0977 : 3A AB 38   [M65] CHKVAL: ld      a,(VALTYP)      ;
097A : 8F                       adc     a,a             ;;Shift Left and Copy in Cary
097B : B7                       or      a               ;;Set Flags
097C : E8                       ret     pe              ;;Return if Overflow
097D : C3 D9 03   [M65] CHKERR: jp      TMERR           ;;Else TYPE MISMATCH Error
0980
0980                  + ;[M80] THE FORMULA EVALUATOR STARTS WITH
0980                  | ;[M80] [H,L] POINTING TO THE FIRST CHARACTER OF THE FORMULA.
0980                  | ;[M80] AT THE END [H,L] POINTS TO THE TERMINATOR.
0980                  | ;[M80] THE RESULT IS LEFT IN THE FAC.
0980                  | ;[M80] ON RETURN [A] DOES NOT REFLECT THE TERMINATING CHARACTER
0980                  | ;[M80]
0980                  | ;[M80] THE FORMULA EVALUATOR USES THE OPERATOR TABLE (OPTAB)
0980                  | ;[M80] TO DETERMINE PRECEDENCE AND DISPATCH ADDRESSES FOR
0980                  | ;[M80] EACH OPERATOR.
0980                  | ;[M80] A TEMPORARY RESULT ON THE STACK HAS THE FOLLOWING FORMAT
0980                  | ;[M80]
0980                  | ;[M80] THE ADDRESS OF 'RETAOP' -- THE PLACE TO RETURN ON COMPLETION
0980                  | ;[M80] OF OPERATOR APPLICATION
0980                  | ;[M80]
0980                  | ;[M80] THE FLOATING POINT TEMPORARY RESULT
0980                  | ;[M80]
0980                  | ;[M80] THE ADDRESS OF THE OPERATOR ROUNTINE
0980                  | ;[M80]
0980                  | ;[M80] THE PRECEDENCE OF THE OPERATOR
0980                  | ;[M80]
0980                  | ;[M80] TOTAL 10 BYTES
0980                  | ;
0980 : CF         [M80] FRMEQL: rst     SYNCHK          ;
0981 : B0                       byte    EQUATK          ;[M80] CHECK FOR EQUAL SIGN
0982 : 01                       byte    $01             ;[M80] "LD BC," OVER THE NEXT 2
0983 : CF         [M80] FRMPRN: rst     SYNCHK          ;[M80] GET PAREN BEFORE FORMULA
0984 : 28                       byte    '('             ;
0975
0985                  + ;;Evaluate Formula
0985                  | ;[M65] THE FORMULA EVALUATOR STARTS WITH
0985                  | ;[M65] [H,L] POINTING TO THE FIRST CHARACTER OF THE FORMULA.
0985                  | ;[M65] AT THE END [H,L] POINTS TO THE TERMINATOR.
0985                  | ;[M65] THE RESULT IS LEFT IN THE FAC.
0985                  | ;[M65] ON RETURN [A] DOES NOT REFLECT THE TERMINATOR.
0985                  | ;
0985                  | ;[M65] THE FORMULA EVALUATOR USES THE OPERATOR LIST (OPTAB)
0985                  | ;[M65] TO DETERMINE PRECEDENCE AND DISPATCH ADDRESSES FOR
0985                  | ;[M65] EACH OPERATOR.
0985                  | ;[M65] A TEMPORARY RESULT ON THE STACK HAS THE FOLLOWING FORMAT.
0985                  | ;[M65]       THE ADDRESS OF THE OPERATOR ROUTINE.
0985                  | ;[M65]       THE FLOATING POINT TEMPORARY RESULT.
0985                  | ;[M65]       THE PRECEDENCE OF THE OPERATOR.
0985                  | ;
0985 : 2B         [M80] FRMEVL: dec     hl              ;[M80] BACK UP CHARACTER POINTER
0986 : 16 00      [M80] FRMCHK: ld      d,0             ;[M80] INITIAL DUMMY PRECEDENCE IS 0
0988 : D5         [M80] LPOPER: push    de              ;[M80] SAVE PRECEDENCE
0989 : 0E 01                    ld      c,1             ;[M80] EXTRA SPACE NEEDED FOR RETURN ADDRESS
098B : CD A0 0B                 call    GETSTK          ;[M80] MAKE SURE THERE IS ROOM FOR RECURSIVE CALLS
098E : CD FD 09                 call    EVAL            ;[M80] EVALUATE SOMETHING
0991 : 22 D0 38   [N80] TSTOP:  ld      (TENP2),hl      ;[M80] SAVE TEXT POINTER
0994 : 2A D0 38   [M80] RETAOP: ld      hl,(TENP2)      ;[M80] RESTORE TEXT PTR
0997 : C1                       pop     bc              ;[M80] POP OFF THE PRECEDENCE OF OLDOP
0998 : 78                       ld      a,b             ;
0999 : FE 78                    cp      $78             ;
099B : D4 75 09                 call    nc,CHKNUM       ;
099E : 7E         {M80} NOTSTV  ld      a,(hl)          ;[M80] GET NEXT CHARACTER
099F : 22 C3 38                 ld      (TENP3),hl      ;[M80] SAVE UPDATED CHARACTER POINTER
09A2 : FE A8                    cp      PLUSTK          ;[M80] IS IT AN OPERATOR?
09A4 : D8                       ret     c               ;
09A5 : FE B2                    cp      LESSTK+1        ;
09A7 : D0                       ret     nc              ;[M80] NO, ALL DONE
09A8 : FE AF                    cp      GREATK          ;[M80] SOME KIND OF RELATIONAL?
09AA : D2 E2 09                 jp      nc,DORELS       ;[M80] YES, DO IT
09AD : D6 A8                    sub     PLUSTK          ;[M80] SUBTRACT OFFSET FOR FIRST ARITHMETIC
09AF : 5F                       ld      e,a             ;[M80] MUST MULTIPLY BY 3
09B0 : 20 08                    jr      nz,NTPLUS       ;[M80] NOT ADDITION OP
09B2 : 3A AB 38                 ld      a,(VALTYP)      ;[M80] SEE IF LEFT PART IS STRING
09B5 : 3D                       dec     a               ;[M80] SEE IF LEFT PART IS STRING
09B6 : 7B                       ld      a,e             ;[M80] REFETCH OP-VALUE
09B7 : CA 7C 0F                 jp      z,CAT           ;[M80] MUST BE CAT
09BA : 07         (M80) NTPLUS: rlca                    ;[M65] MULTIPLY BY 2
09BB : 83                       add     a,e             ;[M65] BY THREE.
09BC : 5F                       ld      e,a             ;[M65] SET UP FOR LATER
09BD : 21 4C 03   {M65} QPREC1: ld      hl,OPTAB        ;[M80] CREATE INDEX INTO OPTAB
09C0 : 16 00                    ld      d,0             ;[M80] MAKE HIGH BYTE OF OFFSET=0
09C2 : 19                       add     hl,de           ;[M80] ADD IN CALCULATED OFFSET
09C3 : 78                       ld      a,b             ;[M80] [A] GETS OLD PRECEDENCE
09C4 : 56                       ld      d,(hl)          ;[M80] REMEMBER NEW PRECEDENCE
09C5 : BA                       cp      d               ;[M80] OLD-NEW
09C6 : D0                       ret     nc              ;[M80] APPLY OLD OP IF >= PRECEDENCE
09C7 : 23                       inc     hl              ;
09C8 : CD 75 09                 call    CHKNUM          ;
09CB                    
09CB : C5         [M80] FINTMP: push    bc              ;[M80] SAVE THESE THINGS FOR RETAOP
09CC : 01 94 09                 ld      bc,RETAOP       ;[M80] GENERAL OPERATOR APPLICATION ROUTINE -- DOES TYPE CONVERSIONS
09CF : C5                       push    bc              ;[M80] SAVE PLACE TO GO
09D0 : 43                       ld      b,e             ;;Save dispatch offset and precedence
09D1 : 4A                       ld      c,d             ;
09D2 : CD 13 15                 call    PUSHF           ;[M80] PUT FAC ON STACK
09D5 : 58                       ld      e,b             ;
09D6 : 51                       ld      d,c             ;;Restore dispatch offset and precedence
09D7 : 4E                       ld      c,(hl)          ;;Load FINRE2 address from FINREA into BC
09D8 : 23                       inc     hl              ;
09D9 : 46                       ld      b,(hl)          ;
09DA : 23                       inc     hl              ;;Now HL contains FINRE2 address
09DB : C5                       push    bc              ;;Push FINRE2 address
09DC : 2A C3 38                 ld      hl,(TENP3)      ;REGET THE TEXT POINTER
09DF : C3 88 09                 jp      LPOPER          ;PUSH ON THE PRECEDENCE AND READ MORE FORMULA
09E2
09E2                    ;;Evaluate Logical Operators
09E2 : 16 00      [M80] DORELS: ld      d,0             ;{M80} ASSUME NO RELATION OPS, SETUP HIGH ORDER OF INDEX INTO OPTAB
09E4 : D6 AF      (M80) LOPREL: sub     GREATK          ;[M80] IS THIS ONE RELATION?
09E6 : DA D0 0A                 jp      c,FINREL        ;[M80] RELATIONS ALL THROUGH
09E9 : FE 03                    cp      LESSTK-GREATK+1 ;[M80] IS IT REALLY RELATIONAL?
09EB : D2 D0 0A                 jp      nc,FINREL       ;[M80] NO JUST BIG
09EE : FE 01                    cp      1               ;[M80] SET UP BITS BY MAPPING
09F0 : 17                       rla                     ;[M80] 0 TO 1 1 TO 2 AND 2 TO 4
09F1 : AA                       xor     d               ;[M80] BRING IN THE OLD BITS
09F2 : BA                       cp      d               ;[M80] MAKE SURE RESULT IS BIGGER
09F3 : 57                       ld      d,a             ;[M80] SAVE THE MASK
09F4 : DA C4 03                 jp      c,SNERR         ;[M80] DON'T ALLOW TWO OF THE SAME
09F7 : 22 C3 38                 ld      (TENP3),hl      ;[M80] SAVE CHARACTER POINTER
09FA : D7                       rst     CHRGET          ;[M80] GET THE NEXT CANDIDATE
09FB : 18 E7                    jr      LOPREL          ;
09FD
09FD                    ;[M80] EVALUATE VARIABLE, CONSTANT, FUNCTION CALL
09FD : F7         [M80] EVAL:   rst     HOOKDO          ;
09FE : 09         {~~~} HOOK9:  byte    9               ;
09FF : AF                       xor     a               ;
0A00 : 32 AB 38                 ld      (VALTYP),a      ;[M65] ASSUME VALUE WILL BE NUMERIC
0A03 : D7                       rst     CHRGET          ;
0A04 : CA D6 03                 jp      z,MOERR         ;[M80] TEST FOR MISSING OPERAND - IF NONE GIVE ERROR
0A07 : DA E5 15                 jp      c,FIN           ;[M80] IF NUMERIC, INTERPRET CONSTANT
0A0A : CD C6 0C                 call    ISLETC          ;[M80] VARIABLE NAME?
0A0D : D2 4E 0A                 jp      nc,ISVAR        ;[M80] AN ALPHABETIC CHARACTER MEANS YES
0A10 : FE A8                    cp      PLUSTK          ;[M80] IGNORE "+"
0A12 : 28 E9                    jr      z,EVAL          ;
0A14 : FE 2E      {M65} QDOT:   cp      '.'             ;[M65] LEADING CHARACTER OF CONSTANT?
0A16 : CA E5 15                 jp      z,FIN           ;
0A19 : FE A9                    cp      MINUTK          ;[M80] NEGATION?
0A1B : CA 3D 0A                 jp      z,DOMIN         ;[M65] SHO IS.
0A1E : FE 22                    cp      '"'             ;[M80] STRING CONSTANT?
0A20 : CA 60 0E                 jp      z,STRLTI        ;[M80] IF SO BUILD A TEMPORARY DESCRIPTOR
0A23 : FE A6                    cp      NOTTK           ;[M80] CHECK FOR "NOT" OPERATOR
0A25 : CA 05 0B                 jp      z,NOTER         ;
0A28 : FE A4                    cp      INKETK          ;[M80] INKEY$ FUNCTION?
0A2A : CA FB 19                 jp      z,INKEY         ;
0A2D : FE A2                    cp      FNTK            ;
0A2F : CA 40 0B                 jp      z,FNDOER        ;
0A32 : D6 B2                    sub     ONEFUN          ;[M80] IS IT A FUNCTION CALL
0A34 : D2 5F 0A                 jp      nc,ISFUN        ;[M80] YES, DO IT
0A37                    ;[M80] ONLY POSSIBILITY LEFT IS A FORMULA IN PARENTHESES
0A37 : CD 83 09   [M80] PARCHK: call    FRMPRN          ;[M80] RECURSIVELY EVALUATE THE FORMULA
0A3A : CF                       rst     SYNCHK          ;
0A3B : 29                       byte    ')'             ;
0A3C : C9                       ret                     ;
0A3D                    
0A3D : 16 7D      [M80] DOMIN:  ld      d,125           ;[M80] A PRECEDENCE BELOW ^ BUT ABOVE ALL ELSE
0A3F : CD 88 09                 call    LPOPER          ;[M80] SO ^ GREATER THAN UNARY MINUS
0A42 : 2A D0 38                 ld      hl,(TENP2)      ;[M80] GET TEXT POINTER
0A45 : E5                       push    hl              ;
0A46 : CD 0B 15                 call    NEG             ;
0A49 : CD 75 09   [M80] LABBCK: call    CHKNUM          ;[M80] FUNCTIONS THAT DON'T RETURN
0A4C : E1                       pop     hl              ;[M80] STRING VALUES COME BACK HERE
0A4D : C9                       ret                     ;
0A4E                    
0A4E : CD D1 10   [M80] ISVAR:  call    PTRGET          ;[M80] GET A POINTER TO THE VARIABLE IN [D,E]
0A51 : E5         [M80] RETVAR: push    hl              ;[M80] SAVE THE TEXT POINTER
0A52 : EB                       ex      de,hl           ;{M80} PUT THE POINTER TO THE VARIABLE OR STRING DESCRIPTOR
0A53 : 22 E4 38                 ld      (FACLO),hl      ;[M80]IN CASE IT'S STRING STORE POINTER TO THE DESCRIPTOR IN FACLO.
0A56 : 3A AB 38                 ld      a,(VALTYP)      ;[M80]FOR STRINGS WE JUST LEAVE
0A59 : B7                       or      a               ;[M80]A POINTER IN THE FAC
0A5A : CC 20 15                 call    z,MOVFM         ;[M80]THE FAC USING [H,L] AS THE POINTER.
0A5D : E1                       pop     hl              ;[M80]RESTORE THE TEXT POINTER
0A5E : C9                       ret                     ;
0A5F                    
0A5F                    ;[M80] MOST FUNCTIONS TAKE A SINGLE ARGUMENT.
0A5F                    ;[M80] THE RETURN ADDRESS OF THESE FUNCTIONS IS A SMALL ROUTINE
0A5F                    ;[M80] THAT CHECKS TO MAKE SURE VALTYP IS 0 (NUMERIC) AND POPS OFF
0A5F                    ;[M80] THE TEXT POINTER. SO NORMAL FUNCTIONS THAT RETURN STRING RESULTS (I.E. CHR$)
0A5F                    ;[M80] MUST POP OFF THE RETURN ADDRESS OF LABBCK, AND POP OFF THE
0A5F                    ;[M80] TEXT POINTER AND THEN RETURN TO FRMEVL.
0A5F                    ;[M80]
0A5F                    ;[M80] THE SO CALLED "FUNNY" FUNCTIONS CAN TAKE MORE THAN ONE ARGUMENT.
0A5F                    ;[M80] THE FIRST OF WHICH MUST BE STRING AND THE SECOND OF WHICH
0A5F                    ;[M80] MUST BE A NUMBER BETWEEN 0 AND 256. THE TEXT POINTER IS
0A5F                    ;[M80] PASSED TO THESE FUNCTIONS SO ADDITIONAL ARGUMENTS
0A5F                    ;[M80] CAN BE READ. THE TEXT POINTER IS PASSED IN [D,E].
0A5F                    ;[M80] THE CLOSE PARENTHESIS MUST BE CHECKED AND RETURN IS DIRECTLY
0A5F                    ;[M80] TO FRMEVL WITH [H,L] SETUP AS THE TEXT POINTER POINTING BEYOND THE ")".
0A5F                    ;[M80] THE POINTER TO THE DESCRIPTOR OF THE STRING ARGUMENT
0A5F                    ;[M80] IS STORED ON THE STACK UNDERNEATH THE VALUE OF THE INTEGER
0A5F                    ;[M80] ARGUMENT (2 BYTES)
0A5F                    ;
0A5F              [M80] NUMGFN  =       (CHRTK-ONEFUN)*2+1
0A5F : F7         [M80] ISFUN:  rst     HOOKDO          ;
0A60 : 1B         {~~~} HOOK27  byte    27              ;
0A61 : FE 18                    cp      POINTK-ONEFUN   ;;Is it POINT()
0A63 : CA 68 1A                 jp      z,POINT         ;;Yes, go do it
0A66 : 06 00      {M80} NTMRND: ld      b,0             ;
0A68 : 07                       rlca                    ;[M80] MULTIPLY BY 2
0A69 : 4F                       ld      c,a             ;
0A6A : C5                       push    bc              ;[M80] SAVE THE FUNCTION # ON THE STACK
0A6B : D7                       rst     CHRGET          ;
0A6C : 79                       ld      a,c             ;[M80] LOOK AT FUNCTION #
0A6D : FE 29                    cp      NUMGFN          ;[M80] IS IT PAST LASNUM?
0A6F : 38 16                    jr      c,OKNORM        ;[M80] NO, MUST BE A NORMAL FUNCTION
0A71 : CD 83 09                 call    FRMPRN          ;[M80] EAT OPEN PAREN AND FIRST ARG
0A74 : CF                       rst     SYNCHK          ;
0A75 : 2C                       byte    ','             ;[M80] TWO ARGS SO COMMA MUST DELIMIT
0A76 : CD 76 09                 call    CHKSTR          ;[M80] MAKE SURE THE FIRST ONE WAS STRING
0A79 : EB                       ex      de,hl           ;[M80] [D,E]=TXTPTR
0A7A : 2A E4 38                 ld      hl,(FACLO)      ;[M80] GET PTR AT STRING DESCRIPTOR
0A7D : E3                       ex      (sp),hl         ;[M80] GET FUNCTION #, SAVE THE STRING PTR
0A7E : E5                       push    hl              ;[M80] PUT THE FUNCTION # ON
0A7F : EB                       ex      de,hl           ;[M80] [H,L]=TXTPTR
0A80 : CD 54 0B                 call    GETBYT          ;[M80] [E]=VALUE OF FORMULA
0A83 : EB                       ex      de,hl           ;[M80] TEXT POINTER INTO [D,E], [H,L]=INT VALUE OF SECOND ARGUMENT
0A84 : E3                       ex      (sp),hl         ;[M80] SAVE INT VALUE OF SECOND ARG. [H,L]=FUNCTION NUMBER
0A85 : 18 08                    jr      FINGO           ;[M80] DISPATCH TO FUNCTION
0A87 : CD 37 0A   [M80] OKNORM: call    PARCHK          ;[M80] CHECK OUT THE ARGUMEN AND MAKE SURE ITS FOLLOWED BY ")"
0A8A : E3                       ex      (sp),hl         ;[M80] [H,L]=FUNCTION # AND SAVE TEXT POINTER
0A8B : 11 49 0A                 ld      de,LABBCK       ;[M80] RETURN ADDRESS
0A8E : D5                       push    de              ;[M80] MAKE THEM REALLY COME BACK
0A8F : 01 15 02   (M80) FINGO:  ld      bc,FUNDSP       ;[M80] FUNCTION DISPATCH TABLE       
0A92 : 09                       add     hl,bc           ;[M80] ADD ON THE OFFSET
0A93 : 4E                       ld      c,(hl)          ;{M80} FASTER THAN "PUSH HL"
0A94 : 23                       inc     hl              ;
0A95 : 66                       ld      h,(hl)          ;
0A96 : 69                       ld      l,c             ;
0A97 : E9                       jp      (hl)            ;[M80] GO PERFORM THE FUNCTION
0A98
0A98                    ;[M80] THE FOLOWING ROUTINE IS CALLED FROM FIN
0A98                    ;[M80] TO SCAN LEADING SIGNS FOR NUMBERS. 
0A98 : 15         [M80] MINPLS: dec     d               ;[M80] SET SIGN OF EXPONENT FLAG
0A99 : FE A9                    cp      MINUTK          ;[M80] NEGATIVE EXPONENT?
0A9B : C8                       ret     z               ;
0A9C : FE 2D                    cp      '-'             ;[M80] NO, RESET FLAG
0A9E : C8                       ret     z               ;
0A9F : 14                       inc     d               ;
0AA0 : FE 2B                    cp      '+'             ;
0AA2 : C8                       ret     z               ;
0AA3 : FE A8                    cp      PLUSTK          ;[M80] IGNORE "+"
0AA5 : C8                       ret     z               ;
0AA6 : 2B                       dec     hl              ;[M80] CHECK IF LAST CHARACTER WAS A DIGIT
0AA7 : C9                       ret                     ;[M80] RETURN WITH NON-ZERO SET
0AA8
0AA8                  + ;;AND and OR Operators
0AA8                  | ;
0AA8                  | ;[M80] DANDOR APPLIES THE "AND" AND "OR" OPERATOR
0AA8                  | ;[M80] AND SHOULD BE USED TO IMPLEMENT ALL LOGICAL OPERATORS.
0AA8                  | ;[M80] WHENEVER AN OPERATOR IS APPLIED, ITS PRECEDENCE IS IN [B].
0AA8                  | ;[M80] THIS FACT IS USED TO DISTINGUISH BETWEEN "AND" AND "OR".
0AA8                  | ;[M80] THE RIGHT HAND ARGUMENT IS COERCED TO INTEGER, JUST AS
0AA8                  | ;[M80] THE LEFT HAND ONE WAS WHEN IT WAS PUSHED ON THE STACK.
0AA8 : F6         [M65] OROP:   byte    $F6             ;[M80] OR $AF" TO SET THE PRECEDENCE "OR"=70
0AA9 : AF         [M65] ANDOP:  xor     a               ;;leave 0 in A for AND
0AAA : F5         [M80] DANDOR: push    af              ;[M80] SAVE THE PRECEDENCE or Operator...
0AAB : CD 75 09                 call    CHKNUM          ;[M65] MUST BE NUMBER
0AAE : CD 82 06                 call    FRCINT          ;COERCE RIGHT HAND ARGUMENT TO INTEGER
0AB1 : F1                       pop     af              ;GET BACK THE PRECEDENCE TO DISTINGUISH "AND" AND "OR"
0AB2 : EB                       ex      de,hl           ;
0AB3 : C1                       pop     bc              ;
0AB4 : E3                       ex      (sp),hl         ;
0AB5 : EB                       ex      de,hl           ;
0AB6 : CD 23 15                 call    MOVFR           ;
0AB9 : F5                       push    af              ;
0ABA : CD 82 06                 call    FRCINT          ;
0ABD : F1                       pop     af              ;
0ABE : C1                       pop     bc              ;
0ABF : 79                       ld      a,c             ;
0AC0 : 21 21 0B                 ld      hl,GIVINT       ;{M80} PLACE TO JUMP WHEN DONE
0AC3 : C2 CB 0A                 jp      nz,NOTAND       ;
0AC6 : A3                       and     e               ;
0AC7 : 4F                       ld      c,a             ;
0AC8 : 78                       ld      a,b             ;
0AC9 : A2                       and     d               ;
0ACA : E9                       jp      (hl)            ;[M80] RETURN THE INTEGER [A,L]
0ACB : B3         [M80] NOTAND: or      e               ;
0ACC : 4F                       ld      c,a             ;
0ACD : 78                       ld      a,b             ;
0ACE : B2                       or      d               ;
0ACF : E9                       jp      (hl)            ;[M80] RETURN THE INTEGER [A,L]
0AD0                    
0AD0                  + ;[M80] HERE TO BUILD AN ENTRY FOR A RELATIONAL OPERATOR
0AD0                  | ;[M80] STRINGS ARE TREATED SPECIALLY. NUMERIC COMPARES ARE DIFFERENT
0AD0                  | ;[M80] FROM MOST OPERATOR ENTRIES ONLY IN THE FACT THAT AT THE
0AD0                  | ;[M80] BOTTOM INSTEAD OF HAVING RETAOP, DOCMP AND THE RELATIONAL
0AD0                  | ;[M80] BITS ARE STORED. STRINGS HAVE STRCMP,THE POINTER AT THE STRING DESCRIPTOR,
0AD0                  | ;[M80] DOCMP AND THE RELATIONAL BITS.
0AD0                  | ;                   
0AD0 : 21 E2 0A   [M80] FINREL: ld      hl,FINREA       
0AD3 : 3A AB 38                 ld      a,(VALTYP)      ;[M80] SEE IF WE HAVE A NUMERIC COMPARE
0AD6 : 1F                       rra                     ;{M65} GET VALUE TYPE INTO CARRY
0AD7 : 7A                       ld      a,d             ;
0AD8 : 17                       rla                     ;{M65} PUT VALTYP INTO LOW ORDER BIT OF MASK
0AD9 : 5F                       ld      e,a             ;[M80] DISPATCH OFFSET FOR COMPARES IN APPLOP
0ADA : 16 64                    ld      d,100           ;{MM80] [A]=OLD PRECEDENCE
0ADC : 78                       ld      a,b             ;
0ADD : BA                       cp      d               ;[M80] RELATIONALS HAVE PRECEDENCE 100
0ADE : D0                       ret     nc              ;[M80] APPLY EARLIER OPERATOR IF IT HAS HIGHER PRECEDENCE
0ADF : C3 CB 09                 jp      FINTMP          ;
0AE2
0AE2 : E4 0A            FINREA: word    FINRE2
0AE4 : 79         (M65) FINRE2: ld      a,c
0AE5 : B7                       or      a
0AE6 : 1F                       rra
0AE7 : C1                       pop     bc
0AE8 : D1                       pop     de
0AE9 : F5                       push    af
0AEA : CD 77 09                 call    CHKVAL          ;[M80] SEE IF WE HAVE A NUMERIC COMPARE
0AED : 21 FB 0A                 ld      hl,DOCMP        ;[M80] ROUTINE TO TAKE COMPARE ROUTINE RESULTAND RELATIONAL BITS AND RETURN THE ANSWER
0AF0 : E5                       push    hl
0AF1 : CA 5B 15                 jp      z,FCOMP         ;{M89} COMPARE NUMBERS RETURNING $7F IF FAC IS LESS THAN THE REGISTERS
0AF4 : AF                       xor     a
0AF5 : 32 AB 38                 ld      (VALTYP),a
0AF8 : C3 FC 0D                 jp      STRCMP
0AFB
0AFB : 3C         [M80] DOCMP:  inc     a               ;[M80] SETUP BITS
0AFC : 8F                       adc     a,a             ;[M80] 4=LESS 2=EQUAL 1=GREATER
0AFD : C1                       pop     bc              ;[M80] WHAT DID HE WANT?
0AFE : A0                       and     b               ;[M80] ANY BITS MATCH?
0AFF : C6 FF                    add     a,$FF           ;[M80] MAP 0 TO 0
0B01 : 9F                       sbc     a,a             ;[M80] AND ALL OTHERS TO 377
0B02 : C3 F6 14                 jp      FLOAT           ;[M80] CONVERT [A] TO AN INTEGER SIGNED
0B05
0B05 : 16 5A      [M80] NOTER:  ld      d,90            ;[M80] "NOT" HAS PRECEDENCE 90, SO FORMULA EVALUATION
0B07 : CD 88 09                 call    LPOPER          ;[M80] IS ENTERED WITH A DUMMY ENTRY OF 90 ON THE STACK
0B0A : CD 75 09                 call    CHKNUM          ;[M65] MUST BE NUMBER
0B0D : CD 82 06                 call    FRCINT          ;[M80] COERCE THE ARGUMENT TO INTEGER
0B10 : 7B                       ld      a,e             ;[M80] COMPLEMENT [D,E]
0B11 : 2F                       cpl                     ;
0B12 : 4F                       ld      c,a             ;
0B13 : 7A                       ld      a,d             ;
0B14 : 2F                       cpl                     ;
0B15 : CD 21 0B                 call    GIVINT          ;[M80] UPDATE THE FAC
0B18                            ;[M80] FRMEVL, AFTER SEEING THE PRECEDENCE OF 90 THINKS IT IS APPLYING AN OPERATOR
0B18                            ;[M80] SO IT HAS THE TEXT POINTER IN TEMP2 SO RETURN TO REFETCH IT
0B18 : C1                       pop     bc              ;
0B19 : C3 94 09                 jp      RETAOP          ; 
0B1C                            
0B1C                    ;{M80} SUBTRACTS [D,E] FROM [H,L] AND FLOAT THE RESULT LEAVING IT IN FAC
0B1C                    ;;;Named GIVDBL in [M80] and [GWB] but Aquarius only supports floats
0B1C : 7D               GIVFLT: ld      a,l             ;[M80] [H,L]=[H,L]-[D,E]
0B1D : 93                       sub     e               ;
0B1E : 4F                       ld      c,a             ;
0B1F : 7C                       ld      a,h             ;[M80] SAVE HIGH BYTE IN [H]
0B20 : 9A                       sbc     a,d             ;
0B21 : 41         [M80] GIVINT: ld      b,c             ;;Float [C,D], entered from NOTER
0B22 : 50               FLOATB: ld      d,b             ;;Float [B], entered from SNGFLT
0B23 : 1E 00            FLOATD: ld      e,0             ;;Float [D], entered from POINT
0B25 : 21 AB 38                 ld      hl,VALTYP       ;
0B28 : 73                       ld      (hl),e          ;[M80] SET VALTYP TO "FLOATING POINT"
0B29 : 06 90      {M80} INEGAD: ld      b,144           ;{M80} SET EXPONENT
0B2B : C3 FB 14                 jp      FLOATR          ;[M80] GO FLOAT THE NUMBER
02BE
0B2E : 3A 46 38   [M80] LPOS:   ld      a,(LPTPOS)      ;{M80} GET PRINT HEAD POSITION
0B31 : 18 03                    jr      SNGFLT          ;
0B33
0B33 : 3A 00 38   [M80] POS:    ld      a,(TTYPOS)      ;[M80] GET TELETYPE POSITION
0B36                    
0B36 : 47         [M80] SNGFLT: ld      b,a             ;[M80] MAKE [A] AN UNSIGNED INTEGER          
0B37 : AF                       xor     a               ;
0B38 : C3 22 0B                 jp      FLOATB          ;
0B3B
0B3B                  + ;{M80} SIMPLE USER DEFINED FUNCTION CODE
0B3B                  | ;[M80] NOTE ONLY SINGLE ARGUMENTS ARE ALLOWED TO FUNCTIONS
0B3B                  | ;[M80] AND FUNCTIONS MUST BE OF THE SINGLE LINE FORM:
0B3B                  | ;[M80] DEF FNA(X)=X^2+X-2
0B3B                  | ;[M80] NO STRINGS CAN BE INVOLVED WITH THESE FUNCTIONS
0B3B                  | ;[M80]
0B3B                  | ;[M80] IDEA: CREATE A FUNNY SIMPLE VARIABLE ENTRY
0B3B                  | ;[M80] WHOSE FIRST CHARACTER (SECOND WORD IN MEMORY)
0B3B                  | ;[M80] HAS THE 200 BIT SET.
0B3B                  | ;[M80] THE VALUE WILL BE:
0B3B                  | ;[M80]
0B3B                  | ;[M80]       A TXTPTR TO THE FORMULA
0B3B                  | ;[M80]       THE NAME OF THE PARAMETER VARIABLE
0B3B                  | ;[M80]
0B3B                  | ;[M80] FUNCTION NAMES CAN BE LIKE "FNA4"
0B3B                  | ;[M80]
0B3B                    ;;Not Implemented in 8K BASIC
0B3B : F7         [M80] DEF:    rst     HOOKDO          ;;If not hooked
0B3C : 0F         {~~~} HOOK15: byte    15
0B3D : C3 C4 03                 jp      SNERR           ;;Syntax Error
0B40                    ;                    
0B40 : F7         [M80] FNDOER: rst     HOOKDO          ;;If not hooked
0B41 : 10         {~~~} HOOK16: byte    16              
0B42 : C3 C4 03                 jp      SNERR           ;;Syntax Error
0B45
0B45                    ;[M65] SUBROUTINE TO SEE IF WE ARE IN DIRECT MODE AND COMPLAIN IF SO.
0B45 : E5               ERRDIR: push    hl              ;
0B46 : 2A 4D 38                 ld      hl,(CURLIN)     ;[M65] DIR MODE HAS [CURLIN]=$FFFF
0B49 : 23                       inc     hl              ;[M65] SO NOW, IS RESULT ZERO?
0B4A : 7C                       ld      a,h             ;
0B4B : B5                       or      l               ;
0B4C : E1                       pop     hl              ;
0B4D : C0                       ret     nz              ;[M65] YES
0B4E : 1E 16                    ld      e,ERRID         ;[M65] INPUT DIRECT ERROR CODE
0B50 : C3 DB 03                 jp      ERROR           ;
0B53                    
0B53 : D7         [M80] GTBYTC: rst     CHRGET          ;
0B54 : CD 72 09   [M80] GETBYT: call    FRMNUM          ;[M80] EVALUATE A FORMULA
0B57 : CD 7E 06   [M80] CONINT: call    INTFR2          ;[M80] CONVERT THE FAC TO AN INTEGER IN [D,E]
0B5A : 7A                       ld      a,d             ;[M80] SET THE CONDITION CODES BASED ON THE HIGH ORDER
0B5B : B7                       or      a               ;
0B5C : C2 97 06                 jp      nz,FCERR        ;[M80] WASN'T ERROR
0B5F : 2B                       dec     hl              ;[M80] fUNCTIONS CAN GET HERE WITH BAD [H,L] BUT NOT SERIOUS
0B60 : D7                       rst     CHRGET          ;[M80] SET CONDITION CODES ON TERMINATOR
0B61 : 7B                       ld      a,e             ;[M80] RETURN THE RESULT IN [A] AND [E]
0B62 : C9                       ret                     ;
0B63
0B63 : CD 82 06   [M80] PEEK:   call    FRCINT          ;[M80] GET AN INTEGER IN [D,E]
0B66 : CD 88 0B                 call    PROMEM          ;{M80} DONT ALLOW IF PROTECTED MEMORY
0B69 : 1A                       ld      a,(de)          ;[M80] GET THE VALUE TO RETURN
0B6A : C3 36 0B                 jp      SNGFLT          ;[M80] AND FLOAT IT
0B6D                                
0B6D : CD 72 09   [M80] POKE:   call    FRMNUM          ;[M80] READ A FORMULA
0B70 : CD 82 06                 call    FRCINT          ;{M80} FORCE VALUE INTO INT IN [D,E]
0B73 : CD 88 0B                 call    PROMEM          ;{M80} DONT ALLOW IF PROTECTED MEMORY
0B76 : D5                       push    de              ;[M80] PUT VALUE ON STACK
0B77 : CF                       rst     SYNCHK          ;
0B78 : 2C                       byte    ','             ;[M80] CHECK FOR A COMMA
0B79 : CD 54 0B                 call    GETBYT
0B7C : D1                       pop     de              ;[M80] GET THE ADDRESS BACK
0B7D : 12                       ld      (de),a          ;[M80] STORE IT AWAY
0B7E : C9                       ret                     ;[M80] SCANNED EVERYTHING
0B7F
0B7F : CD 85 09   {~~~} FRMINT: call    FRMEVL          ;;*** More Orphan Code?
0B82 : E5                       push    hl
0B83 : CD 82 06                 call    FRCINT
0B86 : E1                       pop     hl
0B87 : C9                       ret
0B88                            
0B88                  + ;;Check for illegal Address in PEEK and POKE
0B88                  | ;;;Label based on {M80] PRODIR
0B88 : E5               PROMEM: push    hl              ;
0B89 : 21 FF 2F                 ld      hl,$2FFF        ;   
0B8C : E7                       rst     COMPAR          ;{M80} IS [D.E] LESS THAN 3000H?
0B8D : E1                       pop     hl              ;
0B8E : D2 97 06                 jp      nc,FCERR        ;{M80} YES, BLOW HIM UP NOW
0B91 : C9                       ret                     ;
0B92
0B92                  + ;[M80] THIS IS THE BLOCK TRANSFER ROUTINE
0B92                  | ;[M80] IT MAKES SPACE BY SHOVING EVERYTHING FORWARD
0B92                  | ;[M80]
0B92                  | ;[M80] [H,L] = DESTINATION OF HIGH ADDRESS
0B92                  | ;[M80] [D,E] = LOW ADDRESS TO BE TRANSFERRED
0B92                  | ;[M80] [B,C] = HIGH ADDRESS TO BE TRANSFERRED
0B92                  | ;[M80]
0B92                  | ;[M80] A CHECK IS MADE TO MAKE SURE A REASONABLE AMOUNT
0B92                  | ;[M80] OF SPACE REMAINS BETWEEN THE TOP OF THE STACK AND
0B92                  | ;[M80] THE HIGHEST LOCATION TRANSFERRED INTO
0B92                  | ;[M80]
0B92                  | ;[M80] ON EXIT [H,L]=[D,E]=LOW [B,C]=LOCATION LOW WAS MOVED INTO
0B92                  | ;
0B92 : CD A9 0B   [M80] BLTU:   call    REASON          ;[M80] CHECK DESTINATION TO MAKE SURE STACK WON'T BE OVERRUN
0B95 : C5         [M80] BLTUC:  push    bc              ;[M80] EXCHANGE [B,C] AND [H,L]
0B96 : E3                       ex      (sp),hl         ;
0B97 : C1                       pop     bc              ;
0B98 : E7         (M80) BLTLOP: rst     COMPAR          ;[M80] SEE IF WE ARE DONE
0B99 : 7E                       ld      a,(hl)          ;[M80] GET THE WORD TO TRANSFER
0B9A : 02                       ld      (bc),a          ;[M80] TRANSFER IT
0B9B : C8                       ret     z               ;
0B9C : 0B                       dec     bc              ;
0B9D : 2B                       dec     hl              ;[M80] BACKUP FOR NEXT GUY
0B9E : 18 F8                    jr      BLTLOP          ;
0BA0
0BA0                  + ;;Check Stack Size
0BA0                  | ;[M80] THIS ROUTINE IS USED TO MAKE SURE A CERTAIN NUMBER
0BA0                  | ;[M80] OF LOCATIONS REMAIN AVAILABLE FOR THE
0BA0                  | ;[M80] STACK. THE CALL IS :
0BA0                  | ;[M80]       LD      C,number of 2 byte entries necessary
0BA0                  | ;[M80]       CALL    GETSTK
0BA0                  | ;
0BA0                  | ;[M80] THIS ROUTINE MUST BE CALLED BY ANY ROUTINE WHICH PUTS
0BA0                  | ;[M80] AN ARBITRARY AMOUNT OF STUFF ON THE STACK
0BA0                  | ;[M80] (I.E. ANY RECURSIVE ROUTINE LIKE FRMEVL)
0BA0                  | ;[M80] IT IS ALSO CALLED BY ROUTINES SUCH AS "GOSUB" AND "FOR"
0BA0                  | ;[M80] WHICH MAKE PERMANENT ENTRIES ON THE STACK
0BA0                  | ;[M80] ROUTINES WHICH MERELY USE AND FREE UP THE GUARANTEED
0BA0                  | ;[M80] NUMLEV STACK LOCATIONS NEED NOT CALL THIS
0BA0                  | ;
0BA0 : E5               GETSTK: push    hl              ;[M80] SAVE [H,L]
0BA1 : 2A DA 38                 ld      hl,(STREND)     ;
0BA4 : 06 00                    ld      b,0             ;
0BA6 : 09                       add     hl,bc           ;
0BA7 : 09                       add     hl,bc           ;[M80] SEE IF WE CAN HAVE THIS MANY
0BA8 : 3E                       byte    $3E             ;;"LD A," over next instruction
0BA9 : E5               REASON: push    hl              ;;Save text pointer
0BAA : 3E D0                    ld      a,208           ;[M80]  EXAMINE [H,L] TO MAKE SURE
0BAC : 95                       sub     l               ;[M80]  AT LEAST 104 LOCATIONS
0BAD : 6F                       ld      l,a             ;[M80]  REMAIN BETWEEN IT AND THE
0BAE : 3E FF                    ld      a,$FF           ;[M80]  TOP OF THE STACK
0BB0 : 9C                       sbc     a,h             ;
0BB1 : 67                       ld      h,a             ;[M80] NOW SEE IF [SP] IS LARGER
0BB2 : 38 03                    jr      c,OMERR         ;[M80] IN CASE [H,L] WAS TOO BIG
0BB4 : 39                       add     hl,sp           ;[M80] IF SO, CARRY WILL BE SET
0BB5 : E1                       pop     hl              ;[M80] GET BACK ORIGINAL [H,L]
0BB6 : D8                       ret     c               ;[M80] WAS OK?
0BB7                    
0BB7 : 11 0C 00   [M80] OMERR:  ld      de,ERROM        ;;"OUT OF MEMORY"
0BBA : C3 DB 03                 jp      ERROR           ;
0BBD
0BBD                    ;[M80] THE "NEW" COMMAND CLEARS THE PROGRAM TEXT AS WELL AS VARIABLE SPACE                                
0BBD                    ;;SCRATH is the entry point from the Statement Dispatch Table for the NEW command
0BBD                    ;;SCRTCH is the entry point from an aborted CLOAD command
0BBD : C0         [M80] SCRATH: ret     nz              ;[M80] MAKE SURE THERE IS A TERMINATOR
0BBE : F7         [M80] SCRTCH: rst     HOOKDO          ;Call Hook Dispatch Routine        
0BBF : 0C         {~~~} HOOK12: byte    12              ;
0BC0 : 2A 4F 38                 ld      hl,(TXTTAB)     ;[M80] GET POINTER TO START OF TEXT
0BC3 : AF                       xor     a               ;[M80] SET [A]=0
0BC4 : 77                       ld      (hl),a          ;[M80] SAVE AT END OFF TEXT
0BC5 : 23                       inc     hl              ;[M80] BUMP POINTER
0BC6 : 77                       ld      (hl),a          ;[M80] SAVE ZERO
0BC7 : 23                       inc     hl              ;[M80] BUMP POINTER
0BC8 : 22 D6 38                 ld      (VARTAB),hl     ;[M80] NEW START OF VARIABLES
0BC8
0BC8                  + ;;Clear Variablea, Reset Stack, and Reset Text Pointer
0BC8                  | ;;Leaves BASIC program intact
0BC8                  | ;;Entry Point from RUN and FINI
0BCB : 2A 4F 38   [M80] RUNC:   ld      hl,(TXTTAB)     ;[M80] POINT AT THE START OF TEXT
0BCE : 2B                       dec     hl              ;
0BCF
0BCF                  + ;[M80] CLEARC IS A SUBROUTINE WHICH INITIALIZES THE VARIABLE AND
0BCF                  | ;[M80] ARRAY SPACE BY RESETING ARYTAB [THE END OF SIMPLE VARIABLE SPACE]
0BCF                  | ;[M80] AND STREND [THE END OF ARRAY STORAGE]. IT FALLS INTO STKINI
0BCF                  | ;[M80] WHICH RESETS THE STACK. [H,L] IS PRESERVED.
0BCF                  | ;
0BCF : 22 CE 38   [M80] CLEARC: ld      (SAVTXT),hl     ;
0BD2 : 2A AD 38                 ld      hl,(MEMSIZ)     ;[M65] FREE UP STRING SPACE
0BD5 : 22 C1 38                 ld      (FRETOP),hl     ;
0BD8 : AF         {M80} GODFRE: xor     a               ;
0BD9 : CD 05 0C                 call    RESTOR          ;[M65] RESTOR DATA
0BDC : 2A D6 38                 ld      hl,(VARTAB)     ;[M65] LIBERATE THE
0BDF : 22 D8 38                 ld      (ARYTAB),hl     ;[M65] VARIABLES AND
0BE2 : 22 DA 38                 ld      (STREND),hl     ;[M65] ARRAYS
0BE5
0BE5                  + ;[M80] STKINI RESETS THE STACK POINTER ELIMINATING
0BE5                  | ;[M80] GOSUB & FOR CONTEXT.  STRING TEMPORARIES ARE FREED
0BE5                  | ;[M80] UP, SUBFLG IS RESET, CONTINUING IS DISALLOWED,
0BE5                  | ;[M80] AND A DUMMY ENTRY IS PUT ON THE STACK. THIS IS SO
0BE5                  | ;[M80] FNDFOR WILL ALWAYS FIND A NON-"FOR" ENTRY AT THE BOTTOM
0BE5                  | ;[M80] OF THE STACK. [A]=0 AND [D,E] IS PRESERVED.
0BE5                  | ;
0BE5 : C1         [M80] STKINI: pop     bc              ;[M80] GET RETURN ADDRESS HERE
0BE6 : 2A 4B 38                 ld      hl,(TOPMEM)     ;
0BE9 : F9                       ld      sp,hl           ;[M80] INITIALIZE STACK
0BEA : CD D8 1F                 call    STKSAV          ;[M80] MAKE SURE SAVSTK OK JUST IN CASE.
0BED : 22 AF 38   {M80} STKERR: ld      (TEMPPT),hl     ;
0BF0 : CD BE 19                 call    FINLPT          ;{M80] BACK TO NORMAL PRINT MODE
0BF3 : AF                       xor     a               ;[M80] ZERO OUT A
0BF4 : 6F                       ld      l,a             ;[M80] ZERO OUT H
0BF5 : 67                       ld      h,a             ;[M80] ZERO OUT L
0BF6 : 22 D4 38                 ld      (OLDTXT),hl     ;
0BF9 : 32 CB 38                 ld      (SUBFLG),a      ;[M80] ALLOW SUBSCRIPTS
0BFC : 22 DE 38                 ld      (VARNAM),hl      ;
0BFF : E5                       push    hl              ;[M80] PUT ZERO (NON $FOR,$GOSUB) ON THE STACK
0C00 : C5                       push    bc              ;[M80] PUT RETURN ADDRESS BACK ON
0C01 : 2A CE 38   [M80] GTMPRT: ld      hl,(SAVTXT)     ;[M80] GET SAVED [H,L]
0C04 : C9                       ret
0C05
0C05                    ;;The RESTORE Command
0C05 : EB         [M80] RESTOR: ex      de,hl           ;[M80] SAVE [H,L] IN [D,E]
0C06 : 2A 4F 38                 ld      hl,(TXTTAB)     ;
0C09 : 28 0E                    jr      z,BGNRST        ;[M80] RESTORE DATA POINTER TO BEGINNING OF PROGRAM
0C0B : EB                       ex      de,hl           ;[M80] TEXT POINTER BACK TO [H,L]
0C0C : CD 9C 06                 call    SCNLIN          ;[M80] GET THE FOLLOWING LINE NUMBER
0C0F : E5                       push    hl              ;[M80] SAVE TEXT POINTER
0C10 : CD 9F 04                 call    FNDLIN          ;[M80] FIND THE LINE NUMBER
0C13 : 60                       ld      h,b             ;[M80] GET POINTER TO LINE IN [H,L]
0C14 : 69                       ld      l,c             ;
0C15 : D1                       pop     de              ;[M80] TEXT POINTER BACK TO [D,E]
0C16 : D2 F3 06                 jp      nc,USERR        ;[M80] SHOULD HAVE FOUND LINE
0C19 : 2B         (M80) BGNRST: dec     hl              ;[M80] INITIALIZE DATPTR TO [TXTTAB]-1
0C1A : 22 DC 38   [M80] RESFIN: ld      (DATPTR),hl     ;[M80] READ FINISHES COME TO RESFIN
0C1D : EB                       ex      de,hl           ;[M80] GET THE TEXT POINTER BACK
0C1E : C9                       ret
0C1F                    ;;The STOP and END Statements
0C1F                    ;;STOPC is entry point to END from WARMST
0C1F : C0         [M80] STOP:   ret     nz              ;[M80] MAKE SURE "STOP" STATEMENTS HAVE A TERMINATOR
0C20 : F6         [M65] STOPC:  byte    $F6             ;;"OR" to skip next instruction
0C21 : C0         [M80] ENDS:   ret     nz              ;[M80] MAKE SURE "END" STATEMENTS HAVE A TERMINATOR
0C22 : 22 CE 38   {M80} CONSTP: ld      (SAVTXT),hl     ;
0C25 : 21                       byte    $21             ;{M80} SKIP OVER OR USING "LD H,"
0C26 : F6 FF      [M80] STPEND: or      $FF             ;[M80] SET NON-ZERO TO FORCE PRINTING OF BREAK MESSAGE
0C28 : C1                       pop     bc              ;[M80] POP OFF NEWSTT ADDRESS
0C29 : 2A 4D 38   [M80] ENDCON: ld      hl,(CURLIN)     ;[M80] SAVE CURLIN
0C2C : F5                       push    af              ;{M80} SAVE MESSAGE FLAG, ZERO MEANS DON'T PRINT "BREAK"
0C2D : 7D                       ld      a,l             ;
0C2E : A4                       and     h               ;[M80] SEE IF DIRECT
0C2F : 3C                       inc     a               ;
0C30 : 28 09                    jr      z,DIRIS         ;[M80] IF NOT SET UP FOR CONTINUE
0C32 : 22 D2 38                 ld      (OLDLIN),hl     ;[M80] SAVE OLD LINE #
0C35 : 2A CE 38                 ld      hl,(SAVTXT)     ;[M80] GET POINTER TO START OF STATEMENT
0C38 : 22 D4 38                 ld      (OLDTXT),hl     ;[M80] SAVE IT
0C3B : CD BE 19   [M80] DIRIS:  call    FINLPT          ;{M80} BACK TO NORMAL PRINT MODE
0C3E : CD DE 19                 call    CRDONZ          ;[M80] PRINT CR IF TTYPOS .NE. 0
0C41 : F1                       pop     af              ;[M80] GET BACK ^C FLAG
0C42 : 21 73 03                 ld      hl,BRKTXT       ;[M80] "BREAK"
0C45 : C2 F4 03                 jp      nz,ERRFN1       ;[M80] CALL STROUT AND FALL INTO READY
0C48 : C3 02 04                 jp      READY           ;
0C4B
0C4B                    ;;The CONT Command
0C4B : 2A D4 38   [M80] CONT:   ld      hl,(OLDTXT)     ;[M80] ZERO INDICATES THERE IS NOTHING TO CONTINUE
0C4E : 7C                       ld      a,h             ;[M80] "STOP","END",TYPING CRLF
0C4F : B5                       or      l               ;[M80] TO "INPUT" AND ^C SETUP OLDTXT
0C50 : 11 20 00   {M80} RESERR: ld      de,ERRCN        ;[M80] "CAN'T CONTINUE"
0C53 : CA DB 03                 jp      z,ERROR         ;
0C56 : ED 5B D2 38              ld      de,(OLDLIN)     ;
0C5A : ED 53 4D 38              ld      (CURLIN),de     ;[M80] SET UP OLD LINE # AS CURRENT LINE #
0C5E : C9                       ret                     ;
0C5F
0C5F                    ;;This looks like orphan code
0C5F : C3 97 06                 jp      FCERR
0C62
0C62                    ;;CSAVE* and CLOAD*
0C62   3E               CSARY:  byte    $3E             ;;"LD A," sets A = 62 for CSAVE*
0C63 : AF               CLARY:  xor     a               ;;Set A = 0 for CLOAD*
0C64 : B7                       or      a               ;;Set flags
0C65 : F5                       push    af              ;;and save them
0C66 : D7                       rst     CHRGET          ;;Skip '*'
0C67 : 3E 01                    ld      a,1             ;
0C69 : 32 CB 38                 ld      (SUBFLG),a      ;;Don't look for '(' after variable name
0C6C : CD D1 10                 call    PTRGET          ;;Get pointer to variable
0C6F : C2 97 06                 jp      nz,FCERR        ;;Doesn't exist? FC Error
0C72 : 32 CB 38                 ld      (SUBFLG),a      ;;Turn subscripts back on
0C75 : CD 75 09                 call    CHKNUM          ;;Must be numeric variable or TM Error
0C78 : F1                       pop     af              ;
0C79 : E5                       push    hl              ;;Text Pointer
0C7A : F5                       push    af              ;;CSAVE/CLOAD flag
0C7B : C5                       push    bc              ;;Pointer to Number of Dimensions
0C7C : 06 23                    ld      b,'#'           ;
0C7E : 28 12                    jr      z,CLARYP        ;;If flag is 0, do CLOAD
0C80                    ;;Write Array Header to Tape
0C80 : CD 7F 1B   {~~~} CSARYH: call    PRECRD          ;;"Press <RECORD>" and wait for RETURN
0C83 : CD BC 1B                 call    WRSYNC          ;;Write SYNC to tape
0C86 : 78                       ld      a,b             ;;Write filename "######"
0C87 : CD 87 1B                 call    WRBYT2          ;
0C8A : CD 87 1B                 call    WRBYT2          ;
0C8D : CD 87 1B                 call    WRBYT2          ;
0C90 : 18 11                    jr      RWARY           ;;Write Array 
0C92                    ;;Read Array Header from Tape
0C92 : CD 2E 1B   (~~~) CLARYP: call    PPLAY           ;;"Press <PLAY>", wait for RETURN
0C95 : CD CE 1B   {~~~} CLARYH: call    RDSYNC          ;;Wait for SYNC
0C98 : 0E 06      (~~~) CLARYF: ld      c,6             ;;Look for filename "@@@@@@"
0C9A : CD 4D 1B   (~~~) CLARYL: call    RDBYTE
0C9D : B8                       cp      b
0C9E : 20 F8                    jr      nz,CLARYF
0CA0 : 0D                       dec     c
0CA1 : 20 F7                    jr      nz,CLARYL
0CA3                    ;;Read Array from or Write Array to Tape
0CA3                    ;;DE=End of Array+1, Stack: Array Pointer, CSAVE Flag, Text Pointer
0CA3 : E1               RWARY:  pop     hl              ;;Restore Array Pointer
0CA4 : EB                       ex      de,hl           ;;DE = Array Pointer, HL = Array Length
0CA5 : 19                       add     hl,de           ;;HL = End of Array plus 1
0CA6 : EB                       ex      de,hl           ;;HL = Array Pointer, DE = End of Array
0CA7 : 4E                       ld      c,(hl)          ;
0CA8 : 06 00                    ld      b,0             ;;BC = Number of Dimensions
0CAA : 09                       add     hl,bc           ;;Each dimension size is two bytes
0CAB : 09                       add     hl,bc           ;;So add twice
0CAC : 23                       inc     hl              ;;Add one more for Number of Dimensions
0CAD                    ;;HL=Start Address, DE=End Address+1, Stack: CSAVE Flag Z, Text Pointer
0CAD : E7         (~~~) RWMEM:  rst     COMPAR          ;;Are we there yet?
0CAE : 28 0D                    jr      z,RWARYD        ;;Yes, you can get out
0CB0 : F1                       pop     af              ;;Get CSAVE/CLOAD flag
0CB1 : F5                       push    af              ;;And save it again
0CB2 : 7E                       ld      a,(hl)          ;;Read byte from array
0CB3 : C4 8A 1B                 call    nz,WRBYTE       ;;If CSAVE* write to tape
0CB6 : CC 4D 1B                 call    z,RDBYTE        ;;If CLOAD* read from tape
0CB9 : 77                       ld      (hl),a          ;;Write byte into array
0CBA : 23                       inc     hl              ;;Bump pointer
0CBB : 18 F0                    jr      RWMEM           ;;and do next byte
0CBD : F1               RWARYD: pop     af              ;;Get CSAVE/CLOAD flag
0CBE : C2 1C 1C                 jp      nz,WRTAIL       ;;If CSAVE* write trailer and return
0CC1 : E1                       pop     hl              ;;Restore text pointer
0CC2 : C3 7E 1B                 jp      RWARYR          ;;and Return
0CC5                    ;
0CC5                  + ;[M80] TEST FOR A LETTER / CARRY ON=NOT A LETTER
0CC5                  | ;[M80]               CARRY OFF=A LETTER
0CC5                  | ;
0CC5 : 7E         [M80] ISLET:  ld      a,(hl)
0CC6 : FE 41      [M65] ISLETC: cp      'A'
0CC8 : D8                       ret     c               ;[M80] IF LESS THAN "A", RETURN EARLY
0CC9 : FE 5B                    cp      'Z'+1
0CCB : 3F                       ccf
0CCC : C9                       ret
0CCD                    ;
0CCD                  + ;[M80] THIS CODE IS FOR THE "CLEAR" COMMAND WITH AN ARGUMENT
0CCD                  | ;[M80] TO CHANGE THE AMOUNT OF STRING SPACE ALLOCATED.
0CCD                  | ;[M80] IF NO FORMULA IS GIVEN THE AMOUNT OF STRING SPACE
0CCD                  | ;[M80] REMAINS UNCHANGED.
0CCD                  | ;
0CCD                  | ;;Second Parameter is End of Basic Memory
0CCD : F7         (M80) CLEAR:  rst     HOOKDO          ;;Call Hook Dispatch Routine
0CCE : 0B         {~~~} HOOK11: byte    11              ;
0CCF : CA CF 0B                 jp      z,CLEARC        ;[M80] IF NO FORMULA JUST CLEAR
0CD2 : CD 7B 06                 call    INTID2          ;[M80] GET AN INTEGER INTO [D,E] 
0CD5 : 2B                       dec     hl              ;
0CD6 : D7                       rst     CHRGET          ;[M80] SEE IF ITS THE END
0CD7 : E5                       push    hl              ;
0CD8 : 2A AD 38                 ld      hl,(MEMSIZ)     ;[M80] GET HIGHEST ADDRESS
0CDB : 28 0E                    jr      z,CLEARS        ;[M80] SHOULD FINISH THERE
0CDD : E1                       pop     hl              ;
0CDE : CF                       rst     SYNCHK          ;
0CDF : 2C                       byte    ','             ;
0CE0 : D5                       push    de              ;;Save First Parameter
0CE1 : CD 7B 06                 call    INTID2          ;;Get Second Parameter
0CE4 : 2B                       dec     hl              ;
0CE5 : D7                       rst     CHRGET          ;
0CE6 : C2 C4 03                 jp      nz,SNERR        ;{M80} IF NOT TERMINATOR, GOOD BYE        
0CE9 : E3                       ex      (sp),hl         ;
0CEA : EB                       ex      de,hl           ;
0CEB                    ;;Set VARTAB, TOPMEM, and MEMSIZ
0CEB                    ;;On Entry HL = top of memory, from MEMSIZ or second parameter 
0CEB                    ;;         DE = string space, from the first parameter
0CEB : 7D         (M80) CLEARS: ld      a,l             ;[M80] SUBTRACT [H,L]-[D,E] INTO [D,E]
0CEC : 93                       sub     e               ;
0CED : 5F                       ld      e,a             ;;Leaving start of String Space in [D,E]
0CEE : 7C                       ld      a,h             ;
0CEF : 9A                       sbc     a,d             ;
0CF0 : 57                       ld      d,a             ;
0CF1 : DA B7 0B                 jp      c,OMERR         ;[M80] WANTED MORE THAN TOTAL!
0CF4 : E5                       push    hl              ;[M80] SAVE MEMSIZ
0CF5 : 2A D6 38                 ld      hl,(VARTAB)     ;[M80] TOP LOCATION IN USE
0CF8 : 01 28 00                 ld      bc,40           ;[M80] TOP LOCATION IN USE
0CFB : 09                       add     hl,bc           ;[M80] LEAVE BREATHING ROOM
0CFC : E7                       rst     COMPAR          ;[M80] ROOM?
0CFD : D2 B7 0B                 jp      nc,OMERR        ;[M80] NO, DON'T EVEN CLEAR
0D00 : EB                       ex      de,hl           ;[M80] NEW STACK LOCATION [H,L]
0D01 : 22 4B 38                 ld      (TOPMEM),hl     ;[M80] SET UP NEW STACK LOCATION
0D04 : E1                       pop     hl              ;[M80] GET BACK MEMSIZ
0D05 : 22 AD 38                 ld      (MEMSIZ),hl     ;[M80] SET IT UP, MUST BE OK
0D08 : E1                       pop     hl              ;[M80] REGAIN THE TEXT POINTER
0D09 : C3 CF 0B                 jp      CLEARC          ;[M80] GO CLEAR
0D0C
0D0C                    ;;DE = HL - DE  *** Orphan Code?                    
0D0C : 7D                       ld      a,l 
0D0D : 93                       sub     e
0D0E : 5F                       ld      e,a
0D0F : 7C                       ld      a,h
0D10 : 9A                       sbc     a,d
0D11 : 57                       ld      d,a
0D12 : C9                       ret
0D13
0D13                    ;;The NEXT STATEMENT
0D13                    ;;See FOR for description of the stack entry
0D13 : 11 00 00   [M80] NEXT:   ld      de,0            ;{M80} FOR "NEXT" WITHOUT ARGS CALL FNDFOR WITH [D,E]=0
0D16 : C4 D1 10   (M80) NEXTC:  call    nz,PTRGET       ;{M80} GET POINTER TO LOOP VARIABLE INTO [D,E]
0D19 : 22 CE 38                 ld      (SAVTXT),hl     ;{M80} SAVE TEXT POINTER IN CASE LOOP TERMINATES
0D1C : CD 9F 03                 call    FNDFOR          ;{M80} LOOK FOR ENTRY WHOSE VARIABLE NAME MATCHES THIS ONES    
0D1F : C2 CA 03                 jp      nz,NFERR        ;[M80] "NEXT WITHOUT FOR"
0D22 : F9                       ld      sp,hl           ;[M80] SETUP STACK POINTER BY CHOPPING AT THIS POINT
0D23 : D5                       push    de              ;[M80] PUT THE VARIABLE PTR BACK ON
0D24 : 7E                       ld      a,(hl)          ;
0D25 : F5                       push    af              ;
0D26 : 23                       inc     hl              ;
0D27 : D5                       push    de              ;{M80} PUT POINTER TO LOOP VARIABLE ONTO STACK
0D28 : CD 20 15                 call    MOVFM           ;[M80] STEP VALUE INTO THE FAC
0D2B : E3                       ex      (sp),hl         ;{M80} PUT POINTER INTO FOR ENTRY ONTO STACK
0D2C : E5                       push    hl              ;{M80} PUT POINTER TO LOOP VARIABLE BACK ONTO STACK
0D2D : CD 53 12   {M80} NXTDO:  call    FADDS           ;
0D30 : E1                       pop     hl              ;{M80} POP OFF POINTER TO LOOP VARIABLE
0D31 : CD 3A 15                 call    MOVMF           ;[M80] MOV FAC INTO LOOP VARIABLE
0D34 : E1                       pop     hl              ;[M80] GET THE ENTRY POINTER
0D35 : CD 31 15                 call    MOVRM           ;[M80] GET THE FINAL INTO THE REGISTERS
0D38 : E5                       push    hl              ;[M80] SAVE THE ENTRY POINTER
0D39 : CD 5B 15                 call    FCOMP           ;{M80} RETURN 255 IF FAC < REGISTERS, 0 IF =, 1 IF >
0D3C : E1         {M80} FINNXT: pop     hl              ;{M80} POP OFF "FOR" POINTER NOW POINTING PAST FINAL VALUE
0D3D : C1                       pop     bc              ;[M80] GET THE SIGN OF THE INCREMENT
0D3E : 90                       sub     b               ;{M80} SUBTRACT SIGN FROM (CURRENT VALUE-FINAL VALUE)
0D3F : CD 31 15                 call    MOVRM           ;{M80} "FOR" LINE # INTO [D,E], TEXT POINTER INTO [B,C]
0D42 : 28 09                    jr      z,LOOPDN        ;{M80} IF ZERO THEN THE LOOP IS FINISHED
0D44 : EB                       ex      de,hl           ;
0D45 : 22 4D 38                 ld      (CURLIN),hl     ;[M80] STORE THE LINE #
0D48 : 69                       ld      l,c             ;[M80] SETUP THE TEXT POINTER
0D49 : 60                       ld      h,b             ;
0D4A : C3 28 06                 jp      NXTCON          ;
0D4D              
0D4D : F9         (M80) LOOPDN: ld      sp,hl           ;{M80} ELIMINATE FOR ENTRY SINCE [H,L] MOVED ALL THE WAY THE ENTRY
0D4E : 2A CE 38                 ld      hl,(SAVTXT)     ;UPDATE SAVED STACK
0D51 : 7E                       ld      a,(hl)          ;IS THERE A COMMA AT THE END
0D52 : FE 2C                    cp      ','             ;IF SO LOOK AT ANOTHER
0D54 : C2 2C 06                 jp      nz,NEWSTT       ;VARIABLE NAME TO "NEXT"
0D57 : D7                       rst     CHRGET          ;READ FIRST CHARCTER
0D58 : CD 16 0D                 call    NEXTC           ;DO NEXT, BUT DON'T ALLOW BLANK VARIABLE NAME
0D5B
0D5B                  + ;;Input Line
0D5B                  | ;[M80] THIS IS THE LINE INPUT ROUTINE IT READS CHARACTERS INTO BUF
0D5B                  | ;[M80] THE ROUTINE IS ENTERED AT INLIN, AT QINLIN TO TYPE A QUESTION MARK
0D5B                  | ;[M80] AND A SPACE FIRST
0D5B : 3E 3F      [M80] QINLIN: ld      a,'?'           ;
0D5D : DF                       rst     OUTCHR          ;
0D5E : 3E 20                    ld      a,' '           ;
0D60 : DF                       rst     OUTCHR          ;
0D61 : C3 85 0D   {M65} GINLIN: jp      INLIN           ;;;For relative jumps
0D64
0D64 : 3A 4A 38   [M80] RUBOUT: ld      a,(RUBSW)       ;[M80] ARE WE ALREADY RUBBING OUT?
0D67 : B7                       or      a               ;[M80] SET CC'S
0D68 : 3E 5C                    ld      a,'\'           ;[M80] GET READY TO TYPE BACKSLASH
0D6A : 32 4A 38                 ld      (RUBSW),a       ;[M80] MAKE RUBSW NON-ZERO IF NOT ALREADY
0D6D : 20 05                    jr      nz,NOTBEG       ;[M80] NOT RUBBING BACK TO BEGGINING
0D6F : 05                       dec     b               ;[M80] AT BEGINNING OF LINE?
0D70 : 28 13                    jr      z,INLIN         ;[M80] SET FIRST BYTE IN BUF TO ZERO
0D72 : DF                       rst     OUTCHR          ;[M80] SEND BACKSLASH
0D73 : 04                       inc     b               ;[M80] EFFECTIVELY SKIP NEXT INSTRUCTION
0D74 : 05         (M80) NOTBEG: dec     b               ;[M80] BACK UP CHAR COUNT BY 1
0D75 : 2B                       dec     hl              ;[M80] AND LINE POSIT
0D76 : 28 09                    jr      z,INLINN        ;[M80] AND RE-SET UP INPUT
0D78 : 7E                       ld      a,(hl)          ;[M80] OTHERWISE GET CHAR TO ECHO
0D79 : DF                       rst     OUTCHR          ;[M80] SEND IT
0D7A : 18 12                    jr      INLINC          ;[M80] AND GET NEXT CHAR
0D7C
0D7C : 05         [M65] LINLIN: dec     b               ;[M80] AT START OF LINE?
0D7D : 2B         {M80} LINLN2: dec     hl              ;[M65] BACKARROW SO BACKUP PNTR AND
0D7E : DF                       rst     OUTCHR          ;[M80] SEND BACKSPACE
0D7F : 20 0D                    jr      nz,INLINC       ;
0D81 : DF         (M80) INLINN: rst     OUTCHR          ;
0D82
0D82 : CD EA 19   [M80] INLINU: call    CRDO            ;[M80] TYPE A CRLF
0D85 : 21 60 38   [M80] INLIN:  ld      hl,BUF          ;
0D88 : 06 01                    ld      b,1             ;[M80] CHARACTER COUNT
0D8A : AF                       xor     a               ;[M80] CLEAR TYPE AHEAD CHAR
0D8B : 32 4A 38                 ld      (RUBSW),a       ;[M80] LIKE SO
0D8E : CD DA 19   [M80] INLINC: call    INCHR           ;[M80] GET A CHAR
0D91 : 4F         {M80} INLNC1: ld      c,a             ;[M80] SAVE CURRENT CHAR IN [C]
0D92 : FE 7F                    cp      127             ;[M80] CHARACTER DELETE?
0D94 : 28 CE                    jr      z,RUBOUT        ;[M80] DO IT
0D96 : 3A 4A 38                 ld      a,(RUBSW)       ;[M80] BEEN DOING A RUBOUT?
0D99 : B7                       or      a               ;[M80] SET CC'S
0D9A : 28 07                    jr      z,NOTRUB        ;[M80] NOPE.
0D9C : 3E 5C                    ld      a,'\'           ;[M80] GET READY TO TYPE SLASH
0D9E : DF                       rst     OUTCHR          ;[M80] SEND IT
0D9F : AF                       xor     a               ;[M80] CLEAR RUBSW
0DA0 : 32 4A 38                 ld      (RUBSW),a       ;[M80] LIKE SO
0DA3 : 79         (M80) NOTRUB: ld      a,c             ;[M80] GET BACK CURRENT CHAR
;;;The following comment is in both [M65] and [M80], so it likely ended up in the Aquarius
;;;source code as well. Bob Albrecht is a key figure in the early history of microcomputers.
;;;He founded the People's Computer Company, a newsletter that operated with a walk-in
;;;storefront to teach children "about having fun with computers" and later became
;;;Dr. Dobb's Journal of Computer Calisthenics and Orthodontia.  He brought the first
;;;Altair 8800 to the Homebrew Computer Club and was one of the main supporters
;;;of the effort to make Tiny BASIC a standard on many early machines.
0DA4 : FE 07      {M80} CHKFUN: cp      7               ;[M80] IS IT BOB ALBRECHT RINGING THE BELL
0DA6 : 28 41                    jr      z,GOODCH        ;[M80] FOR SCHOOL KIDS?
0DA8 : FE 03                    cp      3               ;[M80] CONTROL-C?
0DAA : CC EA 19                 call    z,CRDO          ;[M80] TYPE CHAR, AND CRLFT
0DAD : 37                       scf                     ;[M80] RETURN WITH CARRY ON
0DAE : C8                       ret     z               ;[M80] IF IT WAS CONTROL-C
0DAF : FE 0D                    cp      13              ;
0DB1 : CA E5 19                 jp      z,FININL        ;[M80] IS IT A CARRIAGE RETURN?
0DB4 : FE 15                    cp      21              ;[M80] ;LINE DELETE? (CONTROL-U)
0DB6 : CA 82 0D                 jp      z,INLINU        ;[M80] GO DO IT
0DB9 : 00                       nop                     ;;;Whatever was removed isn't in the
0DBA : 00                       nop                     ;;;available source codes
0DBB : 00                       nop                     ;
0DBC : 00                       nop                     ;
0DBD : 00                       nop                     ;
0DBE : FE 08                    cp      8               ;[M80] BACKSPACE? (CONTROL-H)?
0DC0 : CA 7C 0D                 jp      z,LINLIN        ;[M65] YES
0DC3 : FE 18                    cp      24              ;[M80] AT START OF LINE?
0DC5 : 20 05                    jr      nz,NTCTLX       ;[M80] IS IT CONTROL-X (LINE DELETE)
0DC7 : 3E 23                    ld      a,'#'           ;[M80] SEND NUMBER SIGN
0DC9 : C3 81 0D                 jp      INLINN          ;[M80] SEND # SIGN AND ECHO
0DCC                    
0DCC : FE 12      (M80) NTCTLX: cp      18              ;[M80] CONTROL-R?
0DCE : 20 14                    jr      nz,NTCTLR       ;[M80] NO
0DD0 : C5                       push    bc              ;[M80] SAVE [B,C]
0DD1 : D5                       push    de              ;[M80] SAVE [D,E]
0DD2 : E5                       push    hl              ;[M80] SAVE [H,L]
0DD3 : 36 00                    ld      (hl),0          ;[M80] STORE TERMINATOR
0DD5 : CD EA 19                 call    CRDO            ;[M80] DO CRLF
0DD8 : 21 60 38                 ld      hl,BUF          ;[M80] POINT TO START OF BUFFER
0DDB : CD 9D 0E                 call    STROUT          ;;Print It
0DDE : E1                       pop     hl              ;[M80] RESTORE [H,L]
0DDF : D1                       pop     de              ;[M80] RESTORE [D,E]
0DE0 : C1                       pop     bc              ;[M80] RESTORE [B,C]
0DE1 : C3 8E 0D                 jp      INLINC          ;[M80] GET NEXT CHAR
0DE4                    
0DE4 : FE 20      (M80) NTCTLR: cp      ' '             ;[M80] CHECK FOR FUNNY CHARACTERS
0DE6 : DA 8E 0D                 jp      c,INLINC        ;
0DE9                    
0DE9 : 78         (M80) GOODCH: ld      a,b             ;[M80] GET CURRENT LENGTH
0DEA : FE 49                    cp      ENDBUF-BUF      ;[M80] ;Set Carry if longer than Buffer
0DEC : 3E 07                    ld      a,7             ;[M80] GET BELL CHAR
0DEE : D2 F8 0D                 jp      nc,OUTBEL       ;[M80] NO CAUSE FOR BELL
0DF1 : 79         {M80} OUTBND: ld      a,c             ;[M80] RESTORE  CURRENT CHARACTER INTO [A]
0DF2 : 71                       ld      (hl),c          ;[M80] STORE THIS CHARACTER
0DF3 : 32 CC 38                 ld      (USFLG),a       ;[M80] FLAG THAT VALUE HAS BEEN PRINTED
0DF6 : 23                       inc     hl              ;[M80] INCREMENT CHARACTER COUNT
0DF7 : 04                       inc     b               ;[M80] BUMP POINTER INTO BUF
0DF8 : DF         (M80) OUTBEL: rst     OUTCHR          ;[M80] SEND THE CHAR
0DF9 : C3 8E 0D                 jp      INLINC          ;{M80} GET NEXT CHAR
0DFC 
0DFC                  + ;[M80] THE FOLLOWING ROUTINE COMPARES TWO STRINGS
0DFC                  | ;[M80] ONE WITH DESC IN [D,E] OTHER WITH DESC. IN [FACLO, FACLO+1]
0DFC                  | ;[M80] A=0 IF STRINGS EQUAL
0DFC                  | ;{M80} A=127 IF B,C,D,E .GT. FACLO
0DFC                  | ;{M80} A=1 IF B,C,D,E .LT. FACLO
0DFC                  | ;
0DFC : D5         [M80] STRCMP: push    de              
0DFD : CD C9 0F                 call    FREFAC          ;[M80] FREE UP FAC STRING, GET POINTER TO DESCRIPTOR IN [H,L]
0E00 : 7E                       ld      a,(hl)          ;[M80] SAVE THE LENGTH OF THE FAC STRING IN [A]
0E01 : 23                       inc     hl              ;
0E02 : 23                       inc     hl              ;
0E03 : 4E                       ld      c,(hl)          ;[M80] SAVE THE POINTER AT THE FAC STRING DATA IN [B,C]
0E04 : 23                       inc     hl              ;
0E05 : 46                       ld      b,(hl)          ;
0E06 : D1                       pop     de              ;[M80] GET THE STACK STRING POINTER
0E07 : C5                       push    bc              ;[M80] SAVE THE POINTER AT THE FAC STRING DATA
0E08 : F5                       push    af              ;[M80] SAVE THE FAC STRING LENGTH
0E09 : CD CD 0F                 call    FRETMP          ;[M80] FREE UP STACK STRING, RETURN POINTER TO DESCRIPTOR IN [H,L]
0E0C : CD 31 15                 call    MOVRM           ;
0E0F : F1                       pop     af              ;
0E10 : 57                       ld      d,a             ;
0E11 : E1                       pop     hl              ;[M80] GET BACK 2ND CHARACTER POINTER
0E12 : 7B         (M80) CSLOOP: ld      a,e             ;[M80] BOTH STRINGS ENDED
0E13 : B2                       or      d               ;[M80] TEST BY OR'ING THE LENGTHS TOGETHER
0E14 : C8                       ret     z               ;[M80] IF SO, RETURN WITH A ZERO
0E15 : 7A                       ld      a,d             ;[M80] GET FACLO STRING LENGTH
0E16 : D6 01                    sub     1               ;[M80] SET CARRY AND MAKE [A]=255 IF [D]=0
0E18 : D8                       ret     c               ;[M80] RETURN IF THAT STRING ENDED
0E19 : AF                       xor     a               ;[M80] MUST NOT HAVE BEEN ZERO, TEST CASE
0E1A : BB                       cp      e               ;[M80] OF B,C,D,E STRING HAVING ENDED FIRST
0E1B : 3C                       inc     a               ;[M80] RETURN WITH A=1
0E1C : D0                       ret     nc              ;[M80] TEST THE CONDITION
0E1D                    ;[M80] HERE WHEN NEITHER STRING ENDED
0E1D : 15                       dec     d               ;[M80] DECREMENT BOTH CHARACTER COUNTS
0E1E : 1D                       dec     e               ;
0E1F : 0A                       ld      a,(bc)          ;[M80] GET CHARACTER FROM B,C,D,E STRING
0E20 : 03                       inc     bc              ;
0E21 : BE                       cp      (hl)            ;[M80] COMPARE WITH FACLO STRING
0E22 : 23                       inc     hl              ;[M80] BUMP POINTERS (INX DOESNT CLOBBER CC'S)
0E23 : 28 ED                    jr      z,CSLOOP        ;[M80] IF BOTH THE SAME, MUST BE MORE TO STRINGS
0E25 : 3F                       ccf                     ;[M80] HERE WHEN STRINGS DIFFER
0E26 : C3 F1 14                 jp      SIGNS           ;[M80] SET [A] ACCORDING TO CARRY
0E29
0E29                  + ;;CONVERT NUMBER TO STRING
0E29                  | ;[M80] THE STR$ FUNCTION TAKES A NUMBER AND GIVES A STRING WITH
0E29                  | ;[M80] THE CHARACTERS THE OUTPUT OF THE NUMBER WOULD HAVE GIVEN
0E29 : CD 75 09   [M65] STR:    call    CHKNUM          ;[M80] IS A NUMERIC
0E2C : CD 80 16                 call    FOUT            ;[M80] DO ITS OUTPUT
0E2F : CD 5F 0E                 call    STRLIT          ;[M80] SCAN IT AND TURN IT INTO A STRING
0E32 : CD C9 0F                 call    FREFAC          ;[M80] FREE UP THE TEMP
0E35 : 01 1D 10                 ld      bc,FINBCK       ;
0E38 : C5                       push    bc              ;[M80] SET UP ANSWER IN NEW TEMP
0E39
0E39                  + ;;COPY A STRING
0E39                  | ;[M80] STRCPY CREATES A COPY OF THE STRING
0E39                  | ;[M80] WHOSE DESCRIPTOR IS POINTED TO BY [H,L].
0E39                  | ;[M80] ON RETURN [D,E] POINTS TO DSCTMP
0E39                  | ;[M80] WHICH HAS THE STRING INFO (LENGTH,WHERE COPIED TO)
0E39                  | ;
0E39 : 7E         [M80] STRCPY: ld      a,(hl)          ;[M80] GET LENGTH
0E3A : 23                       inc     hl              ;[M80] MOVE UP TO THE POINTER
0E3B : 23                       inc     hl              ;[M80] GET POINTER TO POINTER OF ARG
0E3C : E5                       push    hl              ;[M80] GET THE SPACE
0E3D : CD B3 0E                 call    GETSPA          ;[M80] FIND OUT WHERE STRING TO COPY
0E40 : E1                       pop     hl              ;
0E41 : 4E                       ld      c,(hl)          ;
0E42 : 23                       inc     hl              ;
0E43 : 46                       ld      b,(hl)          ;
0E44 : CD 53 0E                 call    STRAD2          ;[M80] SETUP DSCTMP
0E47 : E5                       push    hl              ;[M80] SAVE POINTER TO DSCTMP
0E48 : 6F                       ld      l,a             ;[M80] GET CHARACTER COUNT INTO [L]
0E49 : CD BD 0F                 call    MOVSTR          ;[M80] MOVE THE CHARS IN
0E4C : D1                       pop     de              ;[M80] RESTORE POINTER TO DSCTMP
0E4D : C9                       ret                     ;[M80] RETURN
0E4E
0E4E : 3E 01      [M80] STRIN1: ld      a,1             ;[M80] MAKE ONE CHAR STRING (CHR$, INKEY$)
0E50 : CD B3 0E   [M80] STRINI: call    GETSPA          ;[M80] GET SOME STRING SPACE ([A] CHARS)
0E53 : 21 BD 38   [M80] STRAD2: ld      hl,DSCTMP       ;[M80] GET DESC. TEMP
0E56 : E5         {M80} STRADI: push    hl              ;[M80] SAVE DESC. POINTER
0E57 : 77                       ld      (hl),a          ;[M80] SAVE CHARACTER COUNT
0E58 : 23                       inc     hl              ;[M80] STORE [D,E]=POINTER TO FREE SPACE
0E59 : 23               STRADX: inc     hl              ;
0E5A : 73                       ld      (hl),e          ;
0E5B : 23                       inc     hl              ;
0E5C : 72                       ld      (hl),d          ;
0E5D : E1                       pop     hl              ;[M80] AND RESTORE [H,L] AS THE DESCRIPTOR POINTER
0E5E : C9                       ret                     ;
0E5F     
0E5F                  + ;;Build Descriptor for String Litersl
0E5F                  | ;[M80] STRLT2 TAKES THE STRING LITERAL WHOSE FIRST CHARACTER
0E5F                  | ;[M80] IS POINTED BY [H,L]+1 AND BUILDS A DESCRIPTOR FOR IT.
0E5F                  | ;[M80] THE DESCRIPTOR IS INITIALLY BUILT IN DSCTMP, BUT PUTNEW
0E5F                  | ;[M80] TRANSFERS IT INTO A TEMPORARY AND LEAVES A POINTER
0E5F                  | ;[M80] AT THE TEMPORARY IN FACLO. THE CHARACTERS OTHER THAN
0E5F                  | ;[M80] ZERO THAT TERMINATE THE STRING SHOULD BE SET UP IN [B]
0E5F                  | ;[M80] AND [D]. IT THE TERMINATOR IS A QUOTE, THE QUOTE IS SKIPPED
0E5F                  | ;[M80] OVER. LEADING QUOTES SHOULD BE SKIPPED BEFORE CALL. ON RETURN
0E5F                  | ;[M80] THE CHARACTER AFTER THE STRING LITERAL IS POINTED TO
0E5F                  | ;[M80] BY [H,L] AND IS IN [A], BUT THE CONDITION CODES ARE
0E5F                  | ;[M80] NOT SET UP.
0E5F                  | ;
0E5F : 2B         [M80] STRLIT: dec     hl              ;;Back up to '"'
0E60 : 06 22      [M80] STRLTI: ld      b,'"'           ;[M80] ASSUME STR ENDS ON QUOTE
0E62 : 50         {M80} STRLT3: ld      d,b             ;
0E63 : E5         [M80] STRLT2: push    hl              ;[M80] SAVE POINTER TO START OF LITERAL
0E64 : 0E FF                    ld      c,255           ;[M80] INITIALIZE CHARACTER COUNT
0E66 : 23         (M80) STRGET: inc     hl              ;;Move past '"'
0E67 : 7E                       ld      a,(hl)          ;[M80] GET CHAR
0E68 : 0C                       inc     c               ;[M80] BUMP CHARACTER COUNT
0E69 : B7                       or      a               ;[M80] IF 0, (END OF LINE) DONE
0E6A : 28 06                    jr      z,STRFIN        ;[M80] TEST
0E6C : BA                       cp      d               ;
0E6D : 28 03                    jr      z,STRFIN        ;
0E6F : B8                       cp      b               ;[M80] CLOSING QUOTE
0E70 : 20 F4                    jr      nz,STRGET       ;[M80] NO, GO BACK FOR MORE
0E72 : FE 22      (M80) STRFIN: cp      '"'             ;[M80] IF QUOTE TERMINATES THE STRING
0E74 : CC 6B 06                 call    z,CHRGTR        ;[M80] SKIP OVER THE QUOTE
0E77 : E3                       ex      (sp),hl         ;[M80] SAVE POINTER AT END OF STRING
0E78 : 23                       inc     hl              ;
0E79 : EB                       ex      de,hl           ;[M80] GET POINTER TO TEMP
0E7A : 79                       ld      a,c             ;[M80] GET CHARACTER COUNT IN A
0E7B : CD 53 0E                 call    STRAD2          ;[M80] SAVE STR INFO
0E7E                    
0E7E                  + ;;Set Pointer to Temporary String Descriptor
0E7E                  | ;[M80] SOME STRING FUNCTION IS RETURNING A RESULT IN DSCTMP
0E7E                  | ;[M80] WE WANT TO SETUP A TEMP DESCRIPTOR WITH DCSTMP IN IT
0E7E                  | ;[M80] PUT A POINTER TO THE DESCRIPTOR IN FACLO AND FLAG THE
0E7E                  | ;[M80] RESULT AS TYPE STRING
0E7E                  |
0E7E : 11 BD 38   [M80] PUTNEW: ld      de,DSCTMP       ;[M80] [D,E] POINT AT RESULT DESCRIPTOR
0E81 : 2A AF 38                 ld      hl,(TEMPPT)     ;[M80] [H,L]=POINTER TO FIRST FREE TEMP
0E84 : 22 E4 38                 ld      (FACLO),hl      ;[M80] POINTER AT WHERE RESULT DESCRIPTOR WILL BE
0E87 : 3E 01                    ld      a,1             ;
0E89 : 32 AB 38                 ld      (VALTYP),a      ;[M80] FLAG THIS AS A STRING
0E8C : CD 3D 15                 call    MOVE            ;[M80] AND MOVE THE VALUE INTO A TEMPORARY
0E8F : E7                       rst     COMPAR          ;;IF TEMPPT POINTS TO DSCTMP, THERE ARE NO FREE TEMPS
0E90 : 22 AF 38                 ld      (TEMPPT),hl     ;[M80] SAVE NEW TEMPORARY POINTER
0E93 : E1                       pop     hl              ;[M80] GET THE TEXT POINTER
0E94 : 7E                       ld      a,(hl)          ;[M80] GET CURRENT CHARACTER INTO [A]
0E95 : C0                       ret     nz              ;
0E96 : 11 1E 00                 ld      de,ERRST        ;[M80] "STRING TEMPORARY" ERROR
0E99 : C3 DB 03                 jp      ERROR           ;[M80] GO TELL HIM
0E9C
0E9C                  + ;;Output String
0E9C                  | ;[M80] PRINT THE STRING POINTED TO BY [H,L] WHICH ENDS WITH A ZERO
0E9C                  | ;[M80] IF THE STRING IS BELOW DSCTMP IT WILL BE COPIED INTO STRING SPACE
0E9C                  | ;
0E9C : 23               STROUI: inc     hl              ;[M80] POINT AT NEXT CHARACTER
0E9D : CD 5F 0E   [M80] STROUT: call    STRLIT          ;[M80] GET A STRING LITERAL
0EA0                    ; PRINT THE STRING WHOSE DESCRIPTOR IS POINTED TO BY FACLO.
0EA0 : CD C9 0F   [M80] STRPRT: call    FREFAC          ;[M80] RETURN TEMP POINTER BY FACLO
0EA3 : CD 31 15                 call    MOVRM           ;[M80] [D]=LENGTH [B,C]=POINTER AT DATA
0EA6 : 1C                       inc     e               ;[M80] CHECK FOR NULL STRING
0EA7 : 1D         [M80' STRPR2: dec     e               ;[M80] DECREMENT THE LENGTH
0EA8 : C8                       ret     z               ;[M80] ALL DONE
0EA9 : 0A                       ld      a,(bc)          ;[M80] GET CHARACTER TO PRINT
0EAA : DF                       rst     OUTCHR          ;
0EAB : FE 0D                    cp      13              ;
0EAD : CC F0 19                 call    z,CRFIN         ;[M65] TYPE REST OF CARRIAGE RETURN
0EB0 : 03                       inc     bc              ;[M80] POINT TO THE NEXT CHARACTER
0EB1 : 18 F4                    jr      STRPR2          ;[M80] AND PRINT IT...
0EB3
0EB3                  + ;[M80] GETSPA - GET SPACE FOR CHARACTER STRING
0EB3                  | ;[M80] MAY FORCE GARBAGE COLLECTION.
0EB3                  | ;[M80]
0EB3                  | ;[M80] # OF CHARS (BYTES) IN [A]
0EB3                  | ;[M80] RETURNS WITH POINTER IN [D,E] OTHERWISE IF CANT GET SPACE
0EB3                  | ;[M80] BLOWS OFF TO "OUT OF STRING SPACE" TYPE ERROR.
0EB3                  | ;
0EB3 : B7         [M80] GETSPA: or      a               ;[M80] MUST BE NON ZERO. SIGNAL NO GARBAG YET
0EB4 : 0E                       byte    $0E             ;[M80] "MVI C" AROUND THE NEXT BYTE 
0EB5 : F1         [M80] TRYGI2: pop     af              ;[M80] IN CASE COLLECTED WHAT WAS LENGTH?                         
0EB6 : F5                       push    af              ;[M80] SAVE IT BACK
0EB7 : 2A 4B 38                 ld      hl,(TOPMEM)     ;
0EBA : EB                       ex      de,hl           ;[M80] IN [D,E]        
0EBB : 2A C1 38                 ld      hl,(FRETOP)     ;[M80] GET TOP OF FREE SPACE IN [H,L]
0EBE : 2F                       cpl                     ;[M80] -# OF CHARS
0EBF : 4F                       ld      c,a             ;[M80] IN [B,C]
0EC0 : 06 FF                    ld      b,$FF           ;
0EC2 : 09                       add     hl,bc           ;[M80] SUBTRACT FROM TOP OF FREE
0EC3 : 23                       inc     hl              ;
0EC4 : E7                       rst     COMPAR          ;[M80] COMPARE THE TWO
0EC5 : 38 07                    jr      c,GARBAG        ;[M80] NOT ENOUGH ROOM FOR STRING, OFFAL TIME
0EC7 : 22 C1 38                 ld      (FRETOP),hl     ;[M80] SAVE NEW BOTTOM OF MEMORY
0ECA : 23                       inc     hl              ;[M80] MOVE BACK TO POINT TO STRING
0ECB : EB                       ex      de,hl           ;[M80] RETURN WITH POINTER IN [D,E]
0ECC : F1                       pop     af              ;
0ECD : C9                       ret                     ;
0ECE
0ECE                    ;Garbage Collector - Removes Orphaned Strings
0ECE : F1         [M80] GARBAG: pop     af              ;[M80] HAVE WE COLLECTED BEFORE?
0ECF : 11 1A 00                 ld      de,ERRSO        ;[M80] GET READY FOR OUT OF STRING SPACE ERROR
0ED2 : CA DB 03                 jp      z,ERROR         ;[M80] GO TELL USER HE LOST
0ED5 : BF                       cp      a               ;[M80] SET ZERO FLAG TO SAY WEVE GARBAGED
0ED6 : F5                       push    af              ;[M80] SAVE FLAG BACK ON STACK
0ED7 : 01 B5 0E                 ld      bc,TRYGI2       ;[M80] PLACE FOR GARBAG TO RETURN TO.
0EDA : C5                       push    bc              ;[M80] SAVE ON STACK
0EDB : 2A AD 38   [M80] GARBA2: ld      hl,(MEMSIZ)     ;[M80] START FROM TOP DOWN
0EDE : 22 C1 38   (M80) FNDVAR: ld      (FRETOP),hl     ;[M80] LIKE SO
0EE1 : 21 00 00                 ld      hl,0            ;[M80] GET DOUBLE ZERO
0EE4 : E5                       push    hl              ;[M80] SAY DIDNT SEE VARS THIS PASS
0EE5 : 2A DA 38                 ld      hl,(STREND)     ;[M80] FORCE DVARS TO IGNORE STRINGS IN PROGRAM TEXT
0EE8 : E5                       push    hl              ;[M80] FORCE FIND HIGH ADDRESS
0EE9 : 21 B1 38                 ld      hl,TEMPST       ;[M80] GET START OF STRING TEMPS
0EEC : ED 5B AF 38(M80) TVAR:   ld      de,(TEMPPT)     ;[M80] SEE IF DONE
0EF0 : E7                       rst     COMPAR          ;[M80] TEST
0EF1 : 01 EC 0E                 ld      bc,TVAR         ;[M80] FORCE JUMP TO TVAR
0EF4 : C2 32 0F                 jp      nz,DVAR2        ;[M80] DO TEMP VAR GARBAGE COLLECT
0EF7 : 2A D6 38                 ld      hl,(VARTAB)     ;[M80] GET STARTING POINT IN [H,L]
0EFA                    
0EFA : ED 5B D8 38(M80) SVAR:   ld      de,(ARYTAB)     ;[M80] GET STOPPING LOCATION
0EFE : E7                       rst     COMPAR          ;[M80] SEE IF AT END OF SIMPS
0EFF : 28 0A                    jr      z,ARYVA4        ;
0F01 : 23                       inc     hl              ;{M80} BUMP POINTER
0F02 : 7E                       ld      a,(hl)          ;[M80] GET VALTYP
0F03 : 23                       inc     hl              ;[M80] POINT AT THE VALUE
0F04 : B7                       or      a               ;
0F05 : CD 35 0F                 call    DVARS           ;
0F08 : 18 F0                    jr      SVAR            ;
0F0A                    ;;;Subsection of [M80] ARYVAR
0F0A : C1         (M80) ARYVA2: pop     bc              ;[M80] GET RID OF STACK GARBAGE
0F0B : ED 5B DA 38(M80) ARYVA4: ld      de,(STREND)     ;[M80] GET RID OF STACK GARBAGE
0F0F : E7                       rst     COMPAR          ;[M80] SEE IF DONE WITH ARRAYS
0F10 : CA 57 0F                 jp      z,GRBPAS        ;[M80] YES, SEE IF DONE COLLECTING
0F13 : CD 31 15                 call    MOVRM           ;
0F16 : 7A                       ld      a,d             ;
0F17 : E5                       push    hl              ;
0F18 : 09                       add     hl,bc           ;[M80] ADDING BASE TO LENGTH
0F19 : B7                       or      a               ;[M80] 
0F1A : F2 0A 0F                 jp      p,ARYVA2        ;;Loop
0F1D : 22 C5 38                 ld      (TEMP8),hl      ;[M80] SAVE END OF ARRAY 
0F20 : E1                       pop     hl              ;[M80] GET BACK CURRENT POSITION
0F21 : 4E                       ld      c,(hl)          ;[M80] PICK UP NUMBER OF DIMS
0F22 : 06 00                    ld      b,0             ;[M80] MAKE DOUBLE WITH HIGH ZERO
0F24 : 09                       add     hl,bc           ;[M80] GO PAST DIMS
0F25 : 09                       add     hl,bc           ;[M80] BY ADDING ON TWICE #DIMS (2 BYTE GUYS)
0F26 : 23                       inc     hl              ;[M80] ONE MORE TO ACCOUNT FOR #DIMS.
0F27 : EB         (M80) ARYSTR: ex      de,hl           ;[M80] SAVE CURRENT POSIT IN [D,E]
0F28 : 2A C5 38                 ld      hl,(TEMP8)      ;[M80] GET END OF ARRAY
0F2B : EB                       ex      de,hl           ;[M80] FIX [H,L] BACK TO CURRENT
0F2C : E7                       rst     COMPAR          ;[M80] SEE IF AT END OF ARRAY
0F2D : 28 DC                    jr      z,ARYVA4        ;[M80] END OF ARRAY, TRY NEXT ARRAY
0F2F : 01 27 0F                 ld      bc,ARYSTR       ;[M80] ADDR OF WHERE TO RETURN TO
0F32 : C5         (M80) DVAR2:  push    bc              ;[M80] GOES ON STACK
0F33 : F6 80                    or      $80             ;;Set Flags
0F35 : 7E         [M80] DVARS:  ld      a,(hl)          ;[M80] GET VALTYP
0F36 : 23                       inc     hl              ;[M80] BUMP POINTER TWICE
0F37 : 23                       inc     hl              ;
0F38 : 5E                       ld      e,(hl)          ;[M80] [D,E]=AMOUNT TO SKIP
0F39 : 23                       inc     hl              ;
0F3A : 56                       ld      d,(hl)          ;
0F3B : 23                       inc     hl              ;
0F3C : F0                       ret     p               ;
0F3D : B7                       or      a               ;
0F3E : C8                       ret     z               ;[M80] NULL STRING, RETURN
0F3F : 44                       ld      b,h             ;[M80] MOVE [B,C] BACK TO [H,L]
0F40 : 4D                       ld      c,l             ;
0F41 : 2A C1 38                 ld      hl,(FRETOP)     ;[M80] GET POINTER TO TOP OF STRING FREE SPACE
0F44 : E7                       rst     COMPAR          ;[M80] IS THIS STRINGS POINTER .LT. FRETOP
0F45 : 60                       ld      h,b             ;[M80] MOVE [B,C] BACK TO [H,L]
0F46 : 69                       ld      l,c             ;
0F47 : D8                       ret     c               ;[M80] IF NOT, NO NEED TO MESS WITH IT FURTHUR
0F48 : E1                       pop     hl              ;[M80] GET RETURN ADDRESS OFF STACK
0F49 : E3                       ex      (sp),hl         ;[M80] GET MAX SEEN SO FAR & SAVE RETURN ADDRESS
0F4A : E7                       rst     COMPAR          ;[M80] LETS SEE
0F4B : E3                       ex      (sp),hl         ;[M80] SAVE MAX SEEN & GET RETURN ADDRESS OFF STACK
0F4C : E5                       push    hl              ;[M80] SAVE RETURN ADDRESS BACK
0F4D : 60                       ld      h,b             ;[M80] MOVE [B,C] BACK TO [H,L]
0F4E : 69                       ld      l,c             ;[
0F4F : D0                       ret     nc              ;[M80] IF NOT, LETS LOOK AT NEXT VAR
0F50 : C1                       pop     bc              ;[M80] GET RETURN ADDR OFF STACK
0F51 : F1                       pop     af              ;[M80] POP OFF MAX SEEN
0F52 : F1                       pop     af              ;[M80] AND VARIABLE POINTER
0F53 : E5                       push    hl              ;[M80] SAVE NEW VARIABLE POINTER
0F54 : D5                       push    de              ;[M80] AND NEW MAX POINTER
0F55 : C5                       push    bc              ;[M80] SAVE RETURN ADDRESS BACK
0F56 : C9                       ret                     ;[M80] AND RETURN
0F57                  
0F57                    ;[M80] HERE WHEN MADE ONE COMPLETE PASS THRU STRING VARS
0F57 : D1         [M80] GRBPAS: pop     de              ;[M80] POP OFF MAX POINTER
0F58 : E1                       pop     hl              ;[M80] AND GET VARIABLE POINTER
0F59 : 7C                       ld      a,h             ;[M80] GET LOW IN
0F5A : B5                       or      l               ;[M80] SEE IF ZERO POINTER
0F5B : C8                       ret     z               ;[M80] IF END OF COLLECTION, THEN MAYBE RETURN TO GETSPA
0F5C : 2B                       dec     hl              ;[M80] CURRENTLY JUST PAST THE DESCRIPTOR
0F5D : 46                       ld      b,(hl)          ;[M80] [B]=HIGH BYTE OF DATA POINTER
0F5E : 2B                       dec     hl              ;
0F5F : 4E                       ld      c,(hl)          ;[M80] [B,C]=POINTER AT STRING DATA
0F60 : E5                       push    hl              ;[M80] SAVE LOCATION TO UPDTE POINTER AFTER STRING IS MOVED
0F61 : 2B                       dec     hl              ;
0F62 : 2B                       dec     hl              ;
0F63 : 6E                       ld      l,(hl)          ;[M80] [L]=STRING LENGTH
0F64 : 26 00                    ld      h,0             ;[M80] [H,L] GET CHARACTER COUNT
0F66 : 09                       add     hl,bc           ;[M80] [H,L]=POINTER BEYOND STRING
0F67 : 50                       ld      d,b             ;
0F68 : 59                       ld      e,c             ;[M80] [D,E]=ORIGINAL POINTER
0F69 : 2B                       dec     hl              ;[M80] DON'T MOVE ONE BEYOND STRING
0F6A : 44                       ld      b,h             ;[M80] GET TOP OF STRING IN [B,C]
0F6B : 4D                       ld      c,l             ;
0F6C : 2A C1 38                 ld      hl,(FRETOP)     ;[M80] GET TOP OF FREE SPACE
0F6F : CD 95 0B                 call    BLTUC           ;[M80] MOVE STRING
0F72 : E1                       pop     hl              ;[M80] GET BACK POINTER TO DESC.
0F73 : 71                       ld      (hl),c          ;[M80] SAVE FIXED ADDR
0F74 : 23                       inc     hl              ;[M80] MOVE POINTER
0F75 : 70                       ld      (hl),b          ;[M80] HIGH PART
0F76 : 60                       ld      h,b             ;
0F77 : 69                       ld      l,c             ;[M80] [H,L]=NEW POINTER
0F78 : 2B                       dec     hl              ;[M80] FIX UP FRETOP
0F79 : C3 DE 0E                 jp      FNDVAR          ;[M80] AND TRY TO FIND HIGH AGAIN
0FC7                    ;
0FC7                    ;[M80] STRING CONCATENATION
0FC7                    ;[M80] THE FOLLOWING ROUTINE CONCATENATES TWO STRINGS
0FC7                    ;[M80] THE FACLO CONTAINS THE FIRST ONE AT THIS POINT,
0FC7                    ;[M80] [H,L] POINTS BEYOND THE + SIGN AFTER IT
0FC7                    ;
0F7C : C5         [M80] CAT:    push    bc              ;[M80] PUT OLD PRECEDENCE BACK ON
0F7D : E5                       push    hl              ;[M80] SAVE TEXT POINTER
0F7E : 2A E4 38                 ld      hl,(FACLO)      ;[M80] GET POINTER TO STRING DESC.
0F81 : E3                       ex      (sp),hl         ;[M80] SAVE ON STACK & GET TEXT POINTER BACK
0F82 : CD FD 09                 call    EVAL            ;[M80] EVALUATE REST OF FORMULA
0F85 : E3                       ex      (sp),hl         ;[M80] SAVE TEXT POINTER, GET BACK DESC.
0F86 : CD 76 09                 call    CHKSTR          ;
0F89 : 7E                       ld      a,(hl)          ;
0F8A : E5                       push    hl              ;[M80] SAVE DESC. POINTER.
0F8B : 2A E4 38                 ld      hl,(FACLO)      ;[M80] GET POINTER TO 2ND DESC.
0F8E : E5                       push    hl              ;[M80] SAVE IT
0F8F : 86                       add     a,(hl)          ;[M80] ADD TWO LENGTHS TOGETHER
0F90 : 11 1C 00                 ld      de,ERRLS        ;[M80] SEE IF RESULT .LT. 256
0F93 : DA DB 03                 jp      c,ERROR         ;[M80] ERROR "LONG STRING"
0F96 : CD 50 0E                 call    STRINI          ;[M80] GET INITIAL STRING
0F99 : D1                       pop     de              ;[M80] GET 2ND DESC.
0F9A : CD CD 0F                 call    FRETMP          ;
0F9D : E3                       ex      (sp),hl         ;[M80] SAVE POINTER TO IT
0F9E : CD CC 0F                 call    FRETM2          ;[M80] FREE UP 1ST TEMP
0FA1 : E5                       push    hl              ;[M80] SAVE DESC. POINTER (FIRST)
0FA2 : 2A BF 38                 ld      hl,(DSCTMP+2)   ;[M80] GET POINTER TO FIRST
0FA5 : EB                       ex      de,hl           ;[M80] IN [D,E]
0FA6 : CD B4 0F                 call    MOVINS          ;[M80] MOVE IN THE FIRST STRING
0FA9 : CD B4 0F                 call    MOVINS          ;[M80] AND THE SECOND
0FAC : 21 91 09                 ld      hl,TSTOP        ;[M80] CAT REENTERS FORMULA EVALUATION AT TSTOP
0FAF : E3                       ex      (sp),hl         ;
0FB0 : E5                       push    hl              ;[M80] TEXT POINTER OFF FIRST
0FB1 : C3 7E 0E                 jp      PUTNEW          ;[M80] THEN RETURN ADDRESS OF TSTOP
0FB4
0FB4 : E1         [M80] MOVINS: pop     hl              ;[M80] GET RETURN ADDR
0FB5 : E3                       ex      (sp),hl         ;[M80] PUT BACK, BUT GET DESC.
0FB6 : 7E                       ld      a,(hl)          ;[M80] [A]=STRING LENGTH
0FB7 : 23                       inc     hl              ;
0FB8 : 23                       inc     hl              ;
0FB9 : 4E                       ld      c,(hl)          ;[M80] [B,C]=POINTER AT STRING DATA
0FBA : 23                       inc     hl              ;
0FBB : 46                       ld      b,(hl)          ;
0FBC : 6F                       ld      l,a             ;[M80] [L]=STRING LENGTH
0FBD : 2C         [M80] MOVSTR: inc     l               ;
0FBE : 2D         (M80) MOVLP:  dec     l               ;[M80] SET CC'S
0FBF : C8                       ret     z               ;[M80] 0, NO BYTE TO MOVE
0FC0 : 0A                       ld      a,(bc)          ;[M80] GET CHAR
0FC1 : 12                       ld      (de),a          ;[M80] SAVE IT
0FC2 : 03                       inc     bc              ;[M80] MOVE POINTERS
0FC3 : 13                       inc     de              ;
0FC4 : 18 F8                    jr      MOVLP           ;[M80] KEEP DOING IT
0FC6   
0FC6                  + ;[M80] FREE UP STRING TEMPORARY - FRESTR, FREFAC, FRETMP, FRETMS
0FC6                  | ;[M80] FRETMP IS PASSED A POINTER TO A STRING DESCRIPTOR IN [D,E]
0FC6                  | ;[M80] THIS VALUE IS RETURNED IN [H,L]. ALL THE OTHER REGISTERS ARE MODIFIED.
0FC6                  | ;[M80] A CHECK TO IS MADE TO SEE IF THE STRING DESCRIPTOR [D,E] POINTS
0FC6                  | ;[M80] TO IS THE LAST TEMPORARY DESCRIPTOR ALLOCATED BY PUTNEW.
0FC6                  | ;[M80] IF SO, THE TEMPORARY IS FREED UP BY THE UPDATING OF TEMPPT.
0FC6                  | ;[M80] IF A TEMPORARY IS FREED UP, A FURTHER CHECK IS MADE TO SEE IF THE
0FC6                  | ;[M80] STRING DATA THAT THAT STRING TEMPORARY POINTED TO IS THE
0FC6                  | ;[M80] THE LOWEST PART OF STRING SPACE IN USE.
0FC6                  | ;[M80] IF SO, FRETMP IS UPDATED TO REFLECT THE FACT THAT THAT SPACE IS NO
0FC6                  | ;[M80] LONGER IN USE.
0FC6                  | ;
0FC6 : CD 76 09   [M80] FRESTR: call    CHKSTR          ;[M80] MAKE SURE ITS A STRING
0FC9 : 2A E4 38   [M80] FREFAC: ld      hl,(FACLO)      ;
0FCC : EB         [M80] FRETM2: ex      de,hl           ;[M80] FREE UP THE TEMP IN THE FACLO
0FCD : CD E4 0F   [M80] FRETMP: call    FRETMS          ;[M80] FREE UP THE TEMPORARY
0FD0 : EB                       ex      de,hl           ;[M80] PUT THE STRING POINTER INTO [H,L]
0FD1 : C0                       ret     nz              ;
0FD2 : D5                       push    de              ;[M80] SAVE [D,E] TO RETURN IN [H,L]
0FD3 : 50                       ld      d,b             ;[M80] [D,E]=POINTER AT STRING
0FD4 : 59                       ld      e,c             ;
0FD5 : 1B                       dec     de              ;[M80] SUBTRACT ONE
0FD6 : 4E                       ld      c,(hl)          ;[M80] [C]=LENGTH OF THE STRING FREED UP
0FD7 : 2A C1 38                 ld      hl,(FRETOP)     ;[M80] SEE IF ITS THE FIRST ONE IN STRING SPACE
0FDA : E7                       rst     COMPAR          ;
0FDB : 20 05                    jr      nz,NOTLST       ;[M80] NO SO DON'T ADD
0FDD : 47                       ld      b,a             ;[M80] MAKE [B]=0
0FDE : 09                       add     hl,bc           ;[M80] ADD
0FDF : 22 C1 38                 ld      (FRETOP),hl     ;[M80] AND UPDATE FRETOP
0FE2 : E1         (M80) NOTLST: pop     hl              ;[M80] GET POINTER AT CURRENT DESCRIPTOR
0FE3 : C9                       ret
0FE4
0FE4 : 2A AF 38   [M80] FRETMS: ld      hl,(TEMPPT)     ;[M80] GET TEMP POINTER
0FE7 : 2B                       dec     hl              ;[M80] LOOK AT WHAT IS IN THE LAST TEMP
0FE8 : 46                       ld      b,(hl)          ;[M80] [B,C]=POINTER AT STRING
0FE9 : 2B                       dec     hl              ;[M80] DECREMENT TEMPPT BY STRSIZ
0FEA : 4E                       ld      c,(hl)          ;
0FEB : 2B                       dec     hl              ;
0FEC : 2B                       dec     hl              ;
0FED : E7                       rst     COMPAR          ;[M80] SEE IF [D,E] POINT AT THE LAST
0FEE : C0                       ret     nz              ;[M80] RETURN NOW IF NOW FREEING DONE
0FEF : 22 AF 38                 ld      (TEMPPT),hl     ;[M80] UPDATE THE TEMP POINTER SINCE
0FF2 : C9                       ret                     ;
0FF3                    
0FF3                  + ;[M80] THE FUNCTION LEN($) 
0FF3                  | ;[M80] RETURNS THE LENGTH OF THE STRING PASSED AS AN ARGUMENT
0FF3 : 01 36 0B   [M80] LEN:    ld      bc,SNGFLT       ;[M80] CALL SNGFLT WHEN DONE
0FF6 : C5                       push    bc              ;[M80] LIKE SO
0FF7 : CD C6 0F   [M80] LEN1:   call    FRESTR          ;[M80] FREE UP TEMP POINTED TO BY FACLO
0FFA : AF                       xor     a               ;[M80] FORCE NUMERIC FLAG
0FFB : 57                       ld      d,a             ;[M80] SET HIGH OF [D,E] TO ZERO FOR VAL
0FFC : 32 AB 38                 ld      (VALTYP),a      ;
0FFF : 7E                       ld      a,(hl)          ;
1000 : B7                       or      a               ;[M80] SET CONDITION CODES ON LENGTH
1001 : C9                       ret                     ;[M80] RETURN
1002
1002                    ;[M80] THE FOLLOWING IS THE ASC($) FUNCTION. 
1002                    ;[M80] IT RETURNS AN INTEGER WHICH IS THE DECIMAL ASCII EQUIVALENT
1002 : 01 36 0B   [M80] ASC:    ld      bc,SNGFLT       ;[M80] WHERE TO GO WHEN DONE
1005 : C5                       push    bc              ;[M80] SAVE RETURN ADDR ON STACK
1006 : CD F7 0F   [M80] ASC2:   call    LEN1            ;[M80] SET UP ORIGINAL STR
1009 : CA 97 06                 jp      z,FCERR         ;[M80] NULL STR, BAD ARG.
100C : 23                       inc     hl              ;[M80] BUMP POINTER
100D : 23                       inc     hl              ;
100E : 5E                       ld      e,(hl)          ;[M80] [D,E]=POINTER AT STRING DATA
100F : 23                       inc     hl              ;
1010 : 56                       ld      d,(hl)          ;
1011 : 1A                       ld      a,(de)          ;[M80] [A]=FIRST CHARACTER
1012 : C9                       ret                     ;
1013                    
1013                  + ;;CHR$ Function
1013                  | ;[M80] CHR$(#) CREATES A STRING WHICH CONTAINS AS ITS ONLY
1013                  | ;[M80] CHARACTER THE ASCII EQUIVALENT OF THE INTEGER ARG (#)
1013                  | ;[M80] WHICH MUST BE .LE. 255.
1013 : CD 4E 0E   [M65] CHR:    call    STRIN1          ;[M80] GET STRING IN DSCTMP
1016 : CD 57 0B                 call    CONINT          ;[M80] GET INTEGER IN RANGE
1019 : 2A BF 38   [M80] SETSTR: ld      hl,(DSCTMP+2)   ;[M80] GET ADDR OF STR
101C : 73                       ld      (hl),e          ;[M80] SAVE ASCII BYTE
101D : C1         [M80] FINBCK: pop     bc              ;[M80] RETURN TO HIGHER LEVEL & SKIP THE CHKNUM CALL
101E : C3 7E 0E                 jp      PUTNEW          ;[M80] GO CALL PUTNEW
1021                    
1021                  + ;[M80] THE FOLLOWING IS THE LEFT$($,#) FUNCTION.
1021                  | ;[M80] IT TAKES THE LEFTMOST # CHARS OF THE STR.
1021                  | ;[M80] IF # IS .GT. THAN THE LEN OF THE STR, IT RETURNS THE WHOLE STR.
1021 : CD A0 10   [M65] LEFT:   call    PREAM           ;[M80] TEST THE PARAMETERS
1024 : AF                       xor     a               ;[M80] LEFT NEVER CHANGES STRING POINTER
1025 : E3         [M80] LEFT3:  ex      (sp),hl         ;[M80] SAVE TEXT POINTER
1026 : 4F                       ld      c,a             ;[M80] OFFSET NOW IN [C]
1027 : E5         [M80] LEFT2:  push    hl              ;[M80] SAVE DESC. FOR  FRETMP
1028 : 7E                       ld      a,(hl)          ;[M80] GET STRING LENGTH
1029 : B8                       cp      b               ;[M80] ENTIRE STRING WANTED?
102A : 38 02                    jr      c,ALLSTR        ;[M80] IF #CHARS ASKED FOR.GE.LENGTH,YES
102C : 78                       ld      a,b             ;[M80] GET TRUNCATED LENGTH OF STRING
102D : 11                       byte    $11             ;[M80] SKIP OVER MVI USING "LD D,"
102E : 0E 00      [M80] ALLSTR: ld      c,0             ;[M80] MAKE OFFSET ZERO
1030 : C5                       push    bc              ;[M80] SAVE OFFSET ON STACK
1031 : CD B3 0E                 call    GETSPA          ;[M80] GET SPACE FOR NEW STRING
1034 : C1                       pop     bc              ;[M80] GET BACK OFFSET
1035 : E1                       pop     hl              ;[M80] GET BACK DESC POINTER.
1036 : E5                       push    hl              ;[M80] BUT KEEP ON STACK
1037 : 23                       inc     hl              ;[M80] MOVE TO STRING POINTER FIELD
1038 : 23                       inc     hl              ;
1039 : 46                       ld      b,(hl)          ;[M80] GET POINTER LOW
103A : 23                       inc     hl              ;
103B : 66                       ld      h,(hl)          ;[M80] POINTER HIGH
103C : 68                       ld      l,b             ;[M80] GET LOW IN  L
103D : 06 00                    ld      b,000H          ;[M80] GET READY TO ADD OFFSET TO POINTER
103F : 09                       add     hl,bc           ;[M80] ADD  IT
1040 : 44                       ld      b,h             ;[M80] GET OFFSET POINTER IN [B,C]
1041 : 4D                       ld      c,l             ;
1042 : CD 53 0E                 call    STRAD2          ;[M80] SAVE INFO IN DSCTMP
1045 : 6F                       ld      l,a             ;[M80] GET#  OF CHARS TO  MOVE IN L
1046 : CD BD 0F                 call    MOVSTR          ;[M80] MOVE THEM IN
1049 : D1                       pop     de              ;[M80] GET BACK DESC. POINTER
104A : CD CD 0F                 call    FRETMP          ;[M80] FREE IT UP.
104D : C3 7E 0E                 jp      PUTNEW          ;[M80] PUT TEMP IN TEMP LIST
1050
1050 : CD A0 10   [M80] RIGHT:  call    PREAM           ;[M80] CHECK ARG
1053 : D1                       pop     de              ;[M80] GET DESC. POINTER
1054 : D5                       push    de              ;[M80] SAVE BACK FOR LEFT
1055 : 1A                       ld      a,(de)          ;[M80] GET PRESENT LEN OF STR
1056 : 90                       sub     b               ;[M80] SUBTRACT 2ND PARM
1057 : 18 CC                    jr      LEFT3           ;[M80] CONTINUE WITH LEFT CODE
1059                            
1059                  + ;[M80] MID ($,#) RETURNS STR WITH CHARS FROM # POSITION ONWARD.
1059                  | ;[M80] IF # IS GT LEN($) THEN RETURN NULL STRING.
1059                  | ;[M80] MID ($,#,#) RETURNS STR WITH CHARS FROM # POSITION
1059                  | ;[M80] FOR #2 CHARS. IF #2 GOES PAST END OF STRING, RETURN
1059                  | ;[M80] AS MUCH AS POSSIBLE.
1059 : EB         [M80] MID:    ex      de,hl           ;[M80] PUT THE TEXT POINTER IN [H,L]
105A : 7E                       ld      a,(hl)          ;[M80] GET THE FIRST CHARACTER
105B : CD A3 10                 call    PREAM2          ;[M80] GET OFFSET OFF STACK AND MAKE
105E : 04                       inc     b               ;
105F : 05                       dec     b               ;[M80] SEE IF EQUAL TO ZERO
1060 : CA 97 06                 jp      z,FCERR         ;[M80] IT MUST NOT BE 0
1063 : C5                       push    bc              ;
1064 : 1E FF      [M80] MIDRST: ld      e,$FF           ;[M80] IF TWO ARG GUY, TRUNCATE
1066 : FE 29                    cp      ')'             ;[M80] [E] SAYS USE ALL CHARS
1068 : 28 05                    jr      z,MID2          ;[M80] IF ONE ARGUMENT THIS IS CORRECT
106A : CF                       rst     SYNCHK          ;
106B : 2C                       byte    ','             ;[M80] COMMA? MUST DELINEATE 3RD ARG
106C : CD 54 0B                 call    GETBYT          ;[M80] GET ARGUMENT  IN  [E]
106F : CF         [M80] MID2:   rst     SYNCHK          ;
1070 : 29                       byte    ')'             ;[M80] MUST BE FOLLOWED BY )
1071 : F1                       pop     af              ;[M80] GET OFFSET BACK IN A
1072 : E3                       ex      (sp),hl         ;[M80] SAVE TEXT POINTER, GET DESC.
1073 : 01 27 10                 ld      bc,LEFT2        ;[M80] WHERE TO RETURN TO.
1076 : C5                       push    bc              ;[M80] GOES ON STACK
1077 : 3D                       dec     a               ;[M80] SUB ONE FROM OFFSET
1078 : BE                       cp      (hl)            ;[M80] POINTER PAST END OF STR?
1079 : 06 00                    ld      b,0             ;[M80] ASSUME NULL LENGTH STR
107B : D0                       ret     nc              ;[M80] YES, JUST USE NULL STR
107C : 4F                       ld      c,a             ;[M80] SAVE OFFSET OF CHARACTER POINTER
107D : 7E                       ld      a,(hl)          ;[M80] GET PRESENT LEN OF STR
107E : 91                       sub     c               ;[M80] SUBTRACT INDEX (2ND ARG)
107F : BB                       cp      e               ;[M80] IS IT TRUNCATION
1080 : 47                       ld      b,a             ;[M80] GET CALCED LENGTH IN B
1081 : D8                       ret     c               ;[M80] IF NOT USE PARTIAL STR
1082 : 43                       ld      b,e             ;[M80] USE TRUNCATED LENGTH
1083 : C9                       ret                     ;[M80] RETURN TO LEFT2
1084
1084                  + ;[M80] THE VAL FUNCTION TAKES A STRING AND TURN IT INTO A NUMBER
1084                  | ;[M80] BY INTERPRETING THE ASCII DIGITS. ETC..
1084                  | ;[M80] EXCEPT FOR THE PROBLEM THAT A TERMINATOR MUST BE SUPPLIED
1084                  | ;[M80] BY REPLACING THE CHARACTER BEYOND THE STRING, VAL
1084                  | ;[M80] IS MERELY A CALL TO FLOATING INPUT (FIN).
1084                  | ;
1084                  | ;[M80] IF STRING IS HIGHEST IN STRING SPACE WE ARE MODIFYING [MEMSIZ]
1084                  | ;[M80] AND THIS IS WHY [MEMSIZ] CAN'T BE USED TO STORE STRING DATA 
1084                  | ;[M80] BECAUSE WHAT IF THE USER TOOK VAL OFF THAT HIGH STRING
1084 : CD F7 0F   [M80] VAL:    call    LEN1            ;[M80] DO SETUP, SET RESULT=REAL
1087 : CA C3 12                 jp      z,ZERO          ;[M80] MAKE SURE TYPE SET UP OK IN EXTENDED
108A : 5F                       ld      e,a             ;[M80] GET LENGTH OF STR
108B : 23                       inc     hl              ;[M80] TO HANDLE THE FACT THE IF
108C : 23                       inc     hl              ;
108D : 7E                       ld      a,(hl)          ;
108E : 23                       inc     hl              ;
108F : 66                       ld      h,(hl)          ;[M80] TWO STRINGS "1" AND "2"
1090 : 6F                       ld      l,a             ;[M80] ARE STORED NEXT TO EACH OTHER
1091 : E5                       push    hl              ;[M80] AND FIN IS CALLED POINTING TO
1092 : 19                       add     hl,de           ;[M80] THE FIRST TWELVE WILL BE RETURNED
1093 : 46                       ld      b,(hl)          ;[M80] THE IDEA IS TO STORE 0 IN THE
1094 : 72                       ld      (hl),d          ;[M80] STRING BEYOND THE ONE VAL
1095 : E3                       ex      (sp),hl         ;[M80] IS BEING CALLED ON
1096 : C5                       push    bc              ;[M80] THE FIRST CHARACTER OF THE NEXT STRING
1097 : 2B                       dec     hl              ;[M80] ***CALL CHRGET TO MAKE SURE
1098 : D7                       rst     CHRGET          ;[M80] VAL(" -3")=-3
1099 : CD E5 15                 call    FIN             ;[M80] IN EXTENDED, GET ALL THE PRECISION WE CAN
109C : C1                       pop     bc              ;[M80] GET THE MODIFIED CHARACTER OF THE NEXT STRING INTO [B]
109D : E1                       pop     hl              ;[M80] GET THE POINTER TO THE MODIFIED CHARACTER
109E : 70                       ld      (hl),b          ;[M80] RESTORE THE CHARACTER
109F : C9                       ret                     ;
10A0
10A0                    ;[M80] USED BY RIGHT$ AND LEFT$ FOR PARAMETER CHECKING AND SETUP
10A0 : EB         [M80] PREAM:  ex      de,hl           ;[M80] PUT THE TEXT POINTER IN [H,L]
10A1 : CF                       rst     SYNCHK          ;
10A2 : 29                       byte    ')'             ;[M80] PARAM LIST SHOULD END
10A3                    ;[M80] USED BY MID$ FOR PARAMETER CHECKING AND SETUP
10A3 : C1         [M80] PREAM2: pop     bc              ;[M80] GET RETURN ADDR OFF STACK
10A4 : D1                       pop     de              ;[M80] GET LENGTH OF ARG OFF STACK
10A5 : C5                       push    bc              ;[M80] SAVE RETURN ADDR BACK ON
10A6 : 43                       ld      b,e             ;[M80] SAVE INIT LENGTH
10A7 : C9                       ret
10A8
10A8 :                  ;[M65] FRE FUNCTION AND INTEGER TO FLOATING ROUTINES
10A8 : 2A DA 38   [M80] FRE:    ld      hl,(STREND)     ;    
10AB : EB                       ex      de,hl           ;
10AC : 21 00 00                 ld      hl,0            ;
10AF : 39                       add     hl,sp           ;
10B0 : 3A AB 38                 ld      a,(VALTYP)      ;
10B3 : B7                       or      a               ;
10B4 : CA 1C 0B                 jp      z,GIVFLT        ;
10B7 : CD C9 0F                 call    FREFAC          ;[M80] FREE UP ARGUMENT AND SETUP TO GIVE FREE STRING SPACE
10BA : CD DB 0E                 call    GARBA2          ;[M80] DO GARBAGE COLLECTION
10BD : ED 5B 4B 38              ld      de,(TOPMEM)     ;
10C1 : 2A C1 38                 ld      hl,(FRETOP)     ;[M80] TOP OF FREE AREA
10C4 : C3 1C 0B                 jp      GIVFLT          ;[M80] RETURN [H,L]-[D,E]
10C7
10C7 : 2B         [M80] DIMCON: dec     hl              ;[M80] SEE IF COMMA ENDED THIS VARIABLE
10C8 : D7                       rst     CHRGET          ;
10C9 : C8                       ret     z               ;[M80] IF TERMINATOR, GOOD BYE
10CA : CF                       rst     SYNCHK          ;
10CB : 2C                       byte    ','             ;[M80] MUST BE COMMA
10CC  
10CC                  + ;{M80} DIMENSION
10CC                  | ;[M80] THE "DIM" CODE SETS DIMFLG AND THEN FALLS INTO THE VARIABLE
10CC                  | ;[M80] SEARCH ROUTINE. THE VARIABLE SEARCH ROUTINE LOOKS AT
10CC                  | ;[M80] DIMFLG AT THREE DIFFERENT POINTS:
10CC                  | ;[M80]
10CC                  | ;[M80]  1) IF AN ENTRY IS FOUND, DIMFLG BEING ON INDICATES
10CC                  | ;[M80]          A "DOUBLY DIMENSIONED" VARIABLE
10CC                  | ;[M80]  2) WHEN A NEW ENTRY IS BEING BUILT DIMFLG'S BEING ON
10CC                  | ;[M80]          INDICATES THE INDICES SHOULD BE USED FOR
10CC                  | ;[M80]          THE SIZE OF EACH INDICE. OTHERWISE THE DEFAULT
10CC                  | ;[M80]          OF TEN IS USED.
10CC                  | ;[M80]  3) WHEN THE BUILD ENTRY CODE FINISHES, ONLY IF DIMFLG IS
10CC                  | ;[M80]          OFF WILL INDEXING BE DONE
10CC                  | ;
10CC : 01 C7 10   [M80] DIM:    ld      bc,DIMCON       ;[M80] PLACE TO COME BACK TO
10CF : C5                       push    bc              ;
10D0 : F6                       byte    $F6             ;;"OR" to skip next instruction
10D1
10D1                  + ;{M80} VARIABLE SEARCHING
10D1                  | ;[M80] ROUTINE TO READ THE VARIABLE NAME AT THE CURRENT TEXT POSITION
10D1                  | ;[M80] AND PUT A POINTER TO ITS VALUE IN [D,E]. [H,L] IS UPDATED
10D1                  | ;[M80] TO POINT TO THE CHARACTER AFTER THE VARIABLE NAME.
10D1                  | ;[M80] VALTYP IS SETUP. NOTE THAT EVALUATING SUBSCRIPTS IN
10D1                  | ;[M80] A VARIABLE NAME CAN CAUSE RECURSIVE CALLS TO PTRGET SO AT
10D1                  | ;[M80] THAT POINT ALL VALUES MUST BE STORED ON THE STACK.
10D1                  | ;[M80] ON RETURN, [A] DOES NOT REFLECT THE VALUE OF THE TERMINATING CHARACTER
10D1                  | ;;VALTYP is set to 1f a '$' follows the variable name, or 0 if one doesn't.
10D1                  | ;;  A pointer to the variable contents is returned in DE. The contents are a
10D1                  | ;;  four byte floating point numbwe for numeric variables and a two byte
10D1                  | ;;  pointer to the string data for a string variable.
10D1                  | ;;If SUBFLG = 0 and a '(' follows the variable name, the array table is searched.
10D1                  | ;;  If the array is found, the indexes are evaluated and a pointer to the array
10D1                  | ;;  element is returned in DE.
10D1                  | ;;If SUBFLG = 1, the array table is searched for the variable name.
10D1                  | ;;  If found, the pointer to the next array entry is returned in DE, and
10D1                  | ;;  a pointer to the number of dimensions is returned in BC.
10D1 : AF         [M80] PTRGET: xor      a              ;[M80] MAKE [A]=0
10D2 : 32 AA 38                 ld      (DIMFLG),a      ;[M80] FLAG IT AS SUCH
10D5 : 4E                       ld      c,(hl)          ;[M80] GET FIRST CHARACTER IN [C]
10D6 : CD C5 0C   {M80} PTRGT2: call    ISLET           ;[M80] CHECK FOR LETTER
10D9 : DA C4 03                 jp      c,SNERR         ;[M80] MUST HAVE A LETTER
10DC : AF                       xor     a               ;
10DD : 47                       ld      b,a             ;[M80] ASSUME NO SECOND CHARACTER
10DE : 32 AB 38                 ld      (VALTYP),a      ;[M80] ZERO NAMCNT
10E1 : D7                       rst     CHRGET          ;[M80] GET CHAR
10E2 : 38 05                    jr      c,ISSEC         ;[M80] YES, WAS NUMERIC
10E4 : CD C6 0C                 call    ISLETC          ;[M80] SET CARRY IF NOT ALPHABETIC
10E7 : 38 09                    jr      c,NOSEC         ;[M80] ALLOW ALPHABETICS
10E9 : 47         (M80) ISSEC:  ld      b,a             ;[M80] IT IS A NUMBER--SAVE IN B
10EA : D7         (M80) EATEM:  rst     CHRGET          ;[M80] GET CHAR
10EB : 38 FD                    jr      c,EATEM         ;[M65] SKIP NUMERICS
10ED : CD C6 0C   {M80} VMORC1: call    ISLETC          ;
10F0 : 30 F8                    jr      nc,EATEM        ;[M65] SKIP ALPHABETICS
10F2 : D6 24      (M80) NOSEC:  sub     '$'             ;[M65] IS IT A STRING?
10F4 : 20 08                    jr      nz,NOTSTR       ;[M65] IF NOT, [VALTYP]=0.
10F6 : 3C                       inc     a               ;[M65] SET [VALTYP]=1 (STRING !)
10F7 : 32 AB 38                 ld      (VALTYP),a      ;
10FA : 0F                       rrca                    ;
10FB : 80                       add     a,b             ;
10FC : 47                       ld      b,a             ;
10FD : D7                       rst     CHRGET          ;[M80] READ PAST TYPE MARKER
10FE : 3A CB 38   (M65) NOTSTR: ld      a,(SUBFLG)      ;[M80] GET FLAG WHETHER TO ALLOW ARRAYS
1101 : 3D                       dec     a               ;[M80] IF SUBFLG=1, "ERASE" HAS CALLED
1102 : CA A0 11                 jp      z,ERSFIN        ;[M80] PTRGET, AND SPECIAL HANDLING MUST BE DONE
1105 : F2 0E 11                 jp      p,NOARYS        ;[M80] NO ARRAYS ALLOWED
1108 : 7E                       ld      a,(hl)          ;[M80] GET CHAR BACK
1109 : D6 28                    sub     '('             ;[M80] (CHECK FOR "(") WON'T MATCH IF SUBFLG SET
110B : CA 7A 11                 jp      z,ISARY         ;[M80] IT IS!
110E    
110E : AF         (M80) NOARYS: xor     a               ;[M80]ALLOW PARENS AGAIN
110F : 32 CB 38                 ld      (SUBFLG),a      ;[M80]SAVE IN FLAG LOCATION
1112 : E5                       push    hl              ;[M80] SAVE THE TEXT POINTER
1113 : 50                       ld      d,b             ;;???Variable Name
1114 : 59                       ld      e,c             
1115 : 2A DE 38                 ld      hl,(VARNAM)
1118 : E7                       rst     COMPAR
1119 : 11 E0 38                 ld      de,VARPNT
111C : CA 1A 14                 jp      z,POPHRT
111F : 2A D8 38                 ld      hl,(ARYTAB)
1122 : EB                       ex      de,hl           ;{M80} [D,E]=POINTER INTO ARRAYS
1123 : 2A D6 38                 ld      hl,(VARTAB)     ;{M80} [H,L]=POINTER INTO SIMPLE VARIABLES
1126 : E7         (M80) LOPFND: rst     COMPAR          ;
1127 : CA 3D 11                 jp      z,SMKVAR        ;[M80] IF SO, CREATE VARIABLE
112A : 79                       ld      a,c             ;[M80] ARE LOW BYTES DIFFERENT
112B : 96                       sub     (hl)            ;[M80] TEST
112C : 23                       inc     hl              ;
112D : C2 32 11                 jp      nz,LOPFN2       ;{M80} NO
1130 : 78                       ld      a,b             ;[M80] ARE HIGH BYTES DIFFERENT
1131 : 96                       sub     (hl)            ;[M80] THE SAME?
1132 : 23         (~~~) LOPFN2: inc     hl              ;
1133 : CA 6C 11                 jp      z,NTFPRT        ;{M80} YES
1136 : 23                       inc     hl              ;
1137 : 23                       inc     hl              ;
1138 : 23                       inc     hl              ;
1139 : 23                       inc     hl              ;;Skip past variable
113A : C3 26 11                 jp      LOPFND          ;
                                ;
113D                    
113D : E1         (M80) SMKVAR: pop     hl              ;
113E : E3                       ex      (sp),hl         ;
113F : D5                       push    de              ;
1140 : 11 51 0A                 ld      de,RETVAR       ;[M80] DID EVAL CALL US?
1143 : E7                       rst     COMPAR          ;[M80] IF SO, DON'T MAKE A NEW VARIABLE
1144 : D1                       pop     de              ;[M80] RESTORE THE POSITION
1145 : CA 6F 11                 jp      z,FINZER        ;[M80] MAKE FAC ZERO (ALL TYPES) AND SKIP RETURN
1148 : E3                       ex      (sp),hl         ;[M80] PUT RETURN ADDRESS BACK
1149 : E5                       push    hl              ;[M80] PUT THE TEXT POINTER BACK
114A : C5                       push    bc              ;[M80] SAVE THE LOOKS
114B : 01 06 00                 ld      bc,6            ;[M80] MAKE THE LENGTH INCLUDE EVERYTHING UP BY
114E : 2A DA 38                 ld      hl,(STREND)     ;[M80] THE CURRENT END OF STORAGE
1151 : E5                       push    hl              ;[M80] SAVE THIS #
1152 : 09                       add     hl,bc           ;[M80] ADD ON THE AMOUNT OF SPACE EXTRA NOW BEING USED
1153 : C1                       pop     bc              ;[M80] POP OFF HIGH ADDRESS TO MOVE
1154 : E5                       push    hl              ;[M80] SAVE NEW CANDIDATE FOR STREND
1155 : CD 92 0B                 call    BLTU            ;{M80} BLOCK TRANSFER AND CHECK FOR STACK OVERFLOW
1158 : E1                       pop     hl              ;[M80] [H,L]=NEW STREND
1159 : 22 DA 38                 ld      (STREND),hl     ;[M80] BLOCK TRANSFER WAS DONE, SO UPDATE POINTERS
115C : 60                       ld      h,b             ;[M80] GET BACK [H,L] POINTING AT THE END
115D : 69                       ld      l,c             ;[M80] OF THE NEW VARIABLE
115E : 22 D8 38                 ld      (ARYTAB),hl     ;[M80] UPDATE THE ARRAY TABLE POINTER
1161 : 2B         (M80) ZEROER: dec     hl              ;[M80] [H,L] IS RETURNED POINTING TO THE
1162 : 36 00                    ld      (hl),0          ;[M80] END OF THE VARIABLE SO WE
1164 : E7                       rst     COMPAR          ;[M80] ZERO BACKWARDS TO [D,E] WHICH
1165 : 20 FA                    jr      nz,ZEROER       ;[M80] POINTS TO THE START OF THE VARIABLE
1167 : D1                       pop     de              ;
1168 : 73                       ld      (hl),e          ;[M80] PUT DESCRIPTION
1169 : 23                       inc     hl              ;
116A : 72                       ld      (hl),d          ;[M80] OF THIS VARIABLE INTO MEMORY
116B : 23                       inc     hl              ;
116C : EB         (M80) NTFPRT: ex      de,hl           ;[M80] TABLE POINTER BACK INTO [D,E]
116D : E1                       pop     hl              ;[M80] GET BACK THE TEXT POINTER
116E : C9                       ret                     ;
116F
116F                    ; MAKE ALL TYPES ZERO AND SKIP RETURN
116F : 32 E7 38   [M80] FINZER: ld      (FAC),a         ;[M80] MAKE FLOATS ZERO
1172 : 21 6D 03                 ld      hl,REDDY-1      ;[M80] MAKE IT A NULL STRING BY
1175 : 22 E4 38                 ld      (FACLO),hl      ;[M80] POINTING AT A ZERO
1178 : E1         {M80} POPHR2: pop     hl              ;[M80] GET THE TEXT POINTER
1179 : C9                       ret                     ;[M80] RETURN FROM EVAL
117A                    
117A                  + ;[M80] FORMAT OF ARRAYS IN CORE
117A                  | ;[M80]
117A                  | ;[M80] DESCRIPTOR 
117A                  | ;[M80]       LOW BYTE = SECOND CHARCTER (200 BIT IS STRING FLAG)
117A                  | ;[M80]       HIGH BYTE = FIRST CHARACTER
117A                  | ;[M80] LENGTH OF ARRAY IN CORE IN BYTES (DOES NOT INCLUDE DESCRIPTOR)
117A                  | ;[M80] NUMBER OF DIMENSIONS 1 BYTE
117A                  | ;[M80] FOR EACH DIMENSION STARTING WITH THE FIRST A LIST
117A                  | ;[M80] (2 BYTES EACH) OF THE MAX INDICE+1
117A                  | ;[M80] THE VALUES
117A                  | ;
117A : E5         [M80] ISARY:  push    hl              ;[M80] SAVE DIMFLG AND VALTYP FOR RECURSION
117B : 2A AA 38                 ld      hl,(DIMFLG)     ;
117E : E3                       ex      (sp),hl         ;[M80] TEXT POINTER BACK INTO [H,L]
117F : 57                       ld      d,a             ;[M80] SET # DIMENSIONS =0
1180 : D5         [M80] INDLOP: push    de              ;[M80] SAVE NUMBER OF DIMENSIONS
1181 : C5                       push    bc              ;[M80] SAVE LOOKS
1182 : CD 7A 06                 call    INTIDX          ;[M80] EVALUATE INDICE INTO [D,E]
1185 : C1         {M80} OPTB0:  pop     bc              ;[M80] POP OFF THE LOOKS
1186 : F1                       pop     af              ;[M80] [A] = NUMBER OF DIMENSIONS SO FAR;
1187 : EB                       ex      de,hl           ;[M80] [D,E]=TEXT POINTER, [H,L]=INDICE
1188 : E3                       ex      (sp),hl         ;[M80] PUT NDICE ON STACK, [H,L]=VALTYP & DIMFLG
1189 : E5                       push    hl              ;[M80] RESAVE VALTYP AND DIMFLG
118A : EB                       ex      de,hl           ;[M80] [H,L]=TEXT POINTER
118B : 3C                       inc     a               ;[M80] INCREMENT # OF DIMENSIONS
118C : 57                       ld      d,a             ;[M80] [D]=NUMBER OF DIMENSIONS
118D : 7E                       ld      a,(hl)          ;[M80] GET TERMINATING CHARACTER
118E : FE 2C                    cp      ','             ;[M80] A COMMA SO MORE INDICES FOLLOW?
1190 : CA 80 11                 jp      z,INDLOP        ;[M80] IF SO, READ MORE
1193 : CF                       rst     SYNCHK          ;
1194 : 29                       byte    ')'             ;{M80} MAKE SURE THERE IS A BRACKET
1195 : 22 D0 38   {M80} SUBSOK: ld      (TENP2),hl      ;[M80 ]SAVE THE TEXT POINTER
1198 : E1                       pop     hl              ;[M80 ][H,L]= VALTYP & DIMFLG
1199 : 22 AA 38                 ld      (DIMFLG),hl     ;[M80 ]SAVE VALTYP AND DIMFLG
119C : 1E 00                    ld      e,0             ;{M80 }WHEN [D,E] IS POPPED INTO PSW, ZERO FLAG WON'T BE SET
119E : D5                       push    de              ;[M80 ]SAVE NUMBER OF DIMENSIONS
119F : 11                       byte    $11             ;[M80] "LD H," OVER THE NEXT TWO BYTES
11A0
11A0                    ;;Get Pointer to Array
11A0                    ;;BC = Array Variable Name on Entry
11A0                    ;;     Pointer to Number of Dimensions on Exit 
11A0 : E5         [M80] ERSFIN: push    hl              ;[M80] SAVE THE TEXT POINTER
11A1 : F5                       push    af              ;[M80] SAVE A DUMMY NUMBER OF DIMENSIONS WITH THE ZERO FLAG SET
11A2
11A2                    ;[M80] AT THIS POINT [B,C]=LOOKS. THE TEXT POINTER IS IN TEMP2.
11A2                    ;[M80] THE INDICES ARE ALL ON THE STACK, FOLLOWED BY THE NUMBER OF DIMENSIONS.
11A2 : 2A D8 38                 ld      hl,(ARYTAB)     ;[M80] [H,L]=PLACE TO START THE SEARCH
11A5 : 3E                       byte    $3E             ;[M80] "LD A," AROUND THE NEXT BYTE 
11A6 : 19         (M80) LOPFDA: add     hl,de           ;[M80] SKIP OVER THIS ARRAY SINCE IT'S NOT THE ONE
11A7 : ED 5B DA 38              ld      de,(STREND)     ;[M80] GET THE PLACE TO STOP INTO [H,L]     
11AB : E7                       rst     COMPAR          ;[M80] STOPPING TIME?
11AC : 28 25                    jr      z,NOTFDD        ;[M80] YES, COULDN'T FIND THIS ARRAY
11AE : 7E                       ld      a,(hl)          ;[M80] GET FIRST CHARACTER
11AF : 23                       inc     hl              
11B0 : B9                       cp      c               ;[M80] SEE IF IT MATCHES
11B1 : 20 02                    jr      nz,NMARY1       ;[M80] NOT THIS ONE
11B3 : 7E                       ld      a,(hl)          ;[M80] GET SECOND CHARACTER
11B4 : B8                       cp      b               ;[M80] ANOTHER MATCH?
11B5 : 23         (M80) NMARY1: inc     hl              ;[M80] POINT TO SIZE ENTRY
11B6 : 5E         {M80} CNOMAT: ld      e,(hl)          ;[M80] [D,E]=LENGTH
11B7 : 23                       inc     hl              ;[M80] OF THE ARRAY BEING LOOKED AT
11B8 : 56                       ld      d,(hl)          
11B9 : 23                       inc     hl
11BA : 20 EA                    jr      nz,LOPFDA       ;[M80] IF NO MATCH, SKIP THIS ONE AND TRY AGAIN
11BC : 3A AA 38                 ld      a,(DIMFLG)      ;[M80] SEE IF CALLED BY "DIM"
11BF : B7                       or      a               ;[M80] ZERO MEANS NO
11C0 : C2 CD 03                 jp      nz,DDERR        ;[M80] "REDIMENSIONED VARIABLE" IF "DIM" CALLING PTRGET
11C3
11C3                  + ;[M80] TEMP2=THE TEXT POINTER
11C3                  | ;[M80] WE HAVE LOCATED THE VARIABLE WE WERE LOOKING FOR
11C3                  | ;[M80] AT THIS POINT [H,L] POINTS BEYOND THE SIZE TO THE NUMBER OF DIMENSIONS
11C3                  | ;[M80] THE INDICES ARE ON THE STACK FOLLOWED BY THE NUMBER OF DIMENSIONS
11C3                  | ;
11C3 : F1                       pop     af              ;[M80] [A]=NUMBER OF DIMENSIONS
11C4 : 44                       ld      b,h             ;[M80] SET [B,C] TO POINT AT NUMBER OF DIMENSIONS
11C5 : 4D                       ld      c,l             
11C6 : CA 1A 14                 jp      z,POPHRT        ;[M80] "ERASE" IS DONE, SO RETURN TO DO THE ACTUAL ERASURE
11C9 : 96                       sub     (hl)            ;{M80} MAKE SURE DIMENSIONS MATCH
11CA : CA 2B 12                 jp      z,GETDEF        ;[M80] JUMP OFF AND READ E INDICES....
11CD : 11 10 00   [M80] BSERR:  ld      de,ERRBS        ;[M80] "SUBSCRIPT OUT OF RANGE"
11D0 : C3 DB 03                 jp      ERROR
11D3
11D3                  + ;[M80] HERE WHEN VARIABLE IS NOT FOUND IN THE ARRAY TABLE
11D3                  | ;[M80]
11D3                  | ;[M80] BUILDING AN ENTRY:
11D3                  | ;[M80] 
11D3                  | ;[M80]  PUT DOWN THE DESCRIPTOR 
11D3                  | ;[M80]  SETUP NUMER OF DIMENSIONS
11D3                  | ;[M80]  MAKE SURE THERE IS ROOM FOR THE NEW ENTRY
11D3                  | ;[M80]  REMEMBER VARPTR
11D3                  | ;[M80]  TALLY=4 (VALTYP FOR THE EXTENDED)
11D3                  | ;[M80]  SKIP 2 LOCS FOR LATER FILL IN -- THE SIZE
11D3                  | ;[M80] LOOP:    GET AN INDICE
11D3                  | ;[M80]  PUT NUMBER +1 DOWN AT VARPTR AND INCREMENT VARPTR
11D3                  | ;[M80]  TALLY= TALLY * NUMBER+1
11D3                  | ;[M80]  DECREMENT NUMBER-DIMS
11D3                  | ;[M80]  JNZ     LOOP
11D3                  | ;[M80]  CALL REASON WITH [H,L] REFLECTING LAST LOC OF VARIABLE
11D3                  | ;[M80]  UPDATE STREND
11D3                  | ;[M80]  ZERO BACKWARDS
11D3                  | ;[M80]  MAKE TALLY INCLUDE MAXDIMS
11D3                  | ;[M80]  PUT DOWN TALLY
11D3                  | ;[M80]  IF CALLED BY DIMENSION, RETURN
11D3                  | ;[M80]  OTHERWISE INDEX INTO THE VARIABLE AS IF IT
11D3                  | ;[M80]  WERE FOUND ON THE INITIAL SEARCH
11D3                  | ;
11D3 : 11 04 00   [M80] NOTFDD: ld      de,4            ;[M80] [D,E]=SIZE OF ONE VALUE (VALTYP)
11D6 : F1                       pop     af              ;[M80] [A]=NUMBER OF DIMENSIONS
11D7 : CA 97 06                 jp      z,FCERR         ;[M80] "ILLEGAL FUNCTION CALL"
11DA : 71                       ld      (hl),c          ;[M80] PUT DOWN THE DESCRIPTOR
11DB : 23                       inc     hl
11DC : 70                       ld      (hl),b
11DD : 23                       inc     hl
11DE : 4F                       ld      c,a             ;{M80} [C]=ENTRIES NEEDED TO STORE SIZE OF EACH DIMENSION
11DF : CD A0 0B                 call    GETSTK          ;[M80] GET SPACE FOR DIMENSION ENTRIES
11E2 : 23                       inc     hl              ;[M80] SKIP OVER THE SIZE LOCATIONS
11E3 : 23                       inc     hl
11E4 : 22 C3 38                 ld      (TENP3),hl      ;SAVE THE LOCATION TO PUT THE SIZE IN
11E7 : 71                       ld      (hl),c          ;STORE THE NUMBER OF DIMENSIONS
11E8 : 23                       inc     hl
11E9 : 3A AA 38                 ld      a,(DIMFLG)      ;{M80} CALLED BY DIMENSION?
11EC : 17                       rla                     ;[M80] SET CARRY IF SO
11ED : 79                       ld      a,c             ;[M80] [A]=NUMBER OF DIMENSIONS
11EE : 01 0B 00   (M80) LOPPTA: ld      bc,11           ;[M80] MAP 0 TO 11 AND 1 TO 10
11F1 : 30 02                    jr      nc,NOTDIM       ;[M80] DEFAULT DIMENSIONS TO TEN
11F3 : C1         (M80) POPDIM: pop     bc              ;[M80] POP OFF AN INDICE INTO [B,C]
11F4 : 03                       inc     bc              ;[M80] ADD ONE TO IT FOR THE ZERO ENTRY
11F5 : 71         (M80) NOTDIM: ld      (hl),c          ;[M80] PUT THE MAXIMUM DOWN
11F6 : F5                       push    af              ;[M80] SAVE NUMBER OF DIMENSIONS AND DIMFLG (CARRY)
11F7 : 23                       inc     hl
11F8 : 70                       ld      (hl),b
11F9 : 23                       inc     hl
11FA : E5                       push    hl
11FB : CD CA 15                 call    UMULT           ;[M80] MULTIPLY [B,C]=NEWMAX BY CURTOL=[D,E]
11FE : EB                       ex      de,hl           
11FF : E1                       pop     hl              
1200 : F1                       pop     af              ;[M80] GET NUMBER OF DIMENSIONS AND DIMFLG (CARRY) BACK
1201 : 3D                       dec     a               ;[M80] DECREMENT THE NUMBER OF DIMENSIONS LEFT
1202 : 20 EA                    jr      nz,LOPPTA       ;[M80] HANDLE THE OTHER INDICES
1204 : F5                       push    af              ;[M80] SAVE DIMFLG (CARRY)
1205 : 42                       ld      b,d             ;[M80] [B,C]=SIZE
1206 : 4B                       ld      c,e             
1207 : EB                       ex      de,hl           ;[M80] [D,E]=START OF VALUES
1208 : 19                       add     hl,de           ;[M80] [H,L]=END OF VALUES
1209 : DA B7 0B                 jp      c,OMERR         ;[M80] OUT OF MEMORY POINTER BEING GENERATED?
120C : CD A9 0B                 call    REASON          ;[M80] SEE IF THERE IS ROOM FOR THE VALUES
120F : 22 DA 38                 ld      (STREND),hl     ;[M80] UPDATE THE END OF STORAGE
1212 : 2B         (M80) ZERITA: dec     hl              ;[M80] ZERO THE NEW ARRAY
1213 : 36 00                    ld      (hl),000H
1215 : E7                       rst     COMPAR          ;[M80] BACK AT THE BEGINNING?
1216 : 20 FA                    jr      nz,ZERITA       ;[M80] NO, ZERO MORE
1218 : 03                       inc     bc              ;(M80) ADD ONE TO INCLUDE BYTE FOR NUMBER OF DIMENSIONS
1219 : 57                       ld      d,a             ;[M80[ [D]=ZERO
121A : 2A C3 38                 ld      hl,(TENP3)      ;[M80[ GET A POINTER AT THE NUMBER OF DIMENSIONS
121D : 5E                       ld      e,(hl)          ;[M80[ [E]=NUMBER OF DIMENSIONS
121E : EB                       ex      de,hl           ;[M80[ [H,L]=NUMBER OF DIMENSIONS
121F : 29                       add     hl,hl           ;[M80[ [H,L]=NUMBER OF DIMENSIONS TIMES TWO
1220 : 09                       add     hl,bc           ;[M80[ ADD ON THE SIZE TO GET THE TOTAL NUMBER OF BYTES USED
1221 : EB                       ex      de,hl           ;[M80[ [D,E]=TOTAL SIZE
1222 : 2B                       dec     hl              ;[M80[ BACK UP TO POINT TO LOCATION TO PUT
1223 : 2B                       dec     hl              ;[M80[ THE SIZE OF THE ARRAY IN BYTES IN.
1224 : 73                       ld      (hl),e          ;[M80[ PUT DOWN THE SIZE
1225 : 23                       inc     hl
1226 : 72                       ld      (hl),d
1227 : 23                       inc     hl
1228 : F1                       pop     af              ;[M80] GET BACK DIMFLG (CARRY) AND SET [A]=0
1229 : 38 21                    jr      c,FINNOW
122B
122B                    ;[M80] AT THIS POINT [H,L] POINTS BEYOND THE SIZE TO THE NUMBER OF DIMENSIONS
122B                    ;[M80] STRATEGY:
122B                    ;[M80]  NUMDIM=NUMBER OF DIMENSIONS
122B                    ;[M80]  CURTOL=0
122B                    ;[M80] INLPNM:GET A NEW INDICE
122B                    ;[M80]  POP NEW MAX INTO CURMAX
122B                    ;[M80]  MAKE SURE INDICE IS NOT TOO BIG
122B                    ;[M80]  MUTLIPLY CURTOL BY CURMAX
122B                    ;[M80]  ADD INDICE TO CURTOL
122B                    ;[M80]  NUMDIM=NUMDIM-1
122B                    ;[M80]  JNZ     INLPNM
122B                    ;[M80]  USE CURTOL*4 (VALTYP FOR EXTENDED) AS OFFSET
122B                    ;
122B : 47         [M80] GETDEF: ld      b,a             ;[M80] [B,C]=CURTOL=ZERO
122C : 4F                       ld      c,a             
122D : 7E                       ld      a,(hl)          ;[M80] [A]=NUMBER OF DIMENSIONS
122E : 23                       inc     hl              ;[M80] POINT PAST THE NUMBER OF DIMENSIONS
122F : 16                       byte    $16             ;[M80] "LD D," AROUND THE NEXT BYTE
1230 : E1         [M80] INLPNM: pop     hl              ;[M80] [H,L]= POINTER INTO VARIABLE ENTRY
1231 : 5E                       ld      e,(hl)          ;[M80] [D,E]=MAXIMUM FOR THE CURRENT INDICE
1232 : 23                       inc     hl              
1233 : 56                       ld      d,(hl)
1234 : 23                       inc     hl              ;[M80] [H,L]=CURRENT INDICE
1235 : E3                       ex      (sp),hl         ;[M80] POINTER INTO THE VARIABLE GOES ON THE STACK
1236 : F5                       push    af              ;[M80] SAVE THE NUMBER OF DIMENSIONS
1237 : E7                       rst     COMPAR          ;[M80] SEE IF THE CURRENT INDICE IS TOO BIG
1238 : D2 CD 11                 jp      nc,BSERR        ;[M80] IF SO "BAD SUBSCRIPT" ERROR
123B : E5                       push    hl              
123C : CD CA 15                 call    UMULT           ;[M80] CURTOL=CURTOL*CURRENT MAXIMUM
123F : D1                       pop     de              
1240 : 19                       add     hl,de           ;[M80] ADD THE INDICE TO CURTOL
1241 : F1                       pop     af              ;[M80] GET THE NUMBER OF DIMENSIONS IN [A]
1242 : 3D                       dec     a               ;[M80] SEE IF ALL THE INDICES HAVE BEEN PROCESSED
1243 : 44                       ld      b,h             ;[M80] [B,C]=CURTOL IN CASE WE LOOP BACK
1244 : 4D                       ld      c,l
1245 : 20 E9                    jr      nz,INLPNM       ;[M80] PROCESS THE REST OF THE INDICES
1247 : 29                       add     hl,hl           ;[M80] MULTIPLY BY TWO
1248 : 29                       add     hl,hl           ;[M80] NOW MULTIPLIED BY FOUR
1249 : C1         {M80} DONMUL: pop     bc              ;[M80] POP OFF THE ADDRESS OF WHERE THE VALUES BEGIN
124A : 09                       add     hl,bc           ;[M80] ADD IT ONTO CURTOL TO GET PLACE VALUE IS STORED
124B : EB                       ex      de,hl           ;[M80] RETURN THE POINTER IN [D,E]
124C : 2A D0 38   (M80) FINNOW: ld      hl,(TENP2)      ;[M80] REGET THE TEXT POINTER
124F : C9                       ret
1250
1250                  + ;[M80] MATHPK FOR BASIC MCS 8080  GATES/ALLEN/DAVIDOFF
1250                  | ;
1250                  | ;[M80] EXTERNAL LOCATIONS USED BY THE MATH-PACKAGE
1250                  | ;
1250                  | ;[M80] THE FLOATING ACCUMULATOR
1250                  | ;(M80) FACLO:   [LOW ORDER OF MANTISSA (LO)]
1250                  | ;(M80) FACMO:   [MIDDLE ORDER OF MANTISSA (MO)]
1250                  | ;(M80) FACHO:   [HIGH ORDER OF MANTISSA (HO)]
1250                  | ;(M80) FAC:     [EXPONENT]
1250                  | ;(M80)          [TEMPORARY COMPLEMENT OF SIGN IN MSB]
1250                  | ;(M80] ARGLO:           [LOCATION OF SECOND ARGUMENT]
1250                  | ;(M80] ARG:     
1250                  | ;(M80] FBUFFR:  BUFFER FOR FOUT
1250                  | ;[M80]
1250                  | ;[M80] THE FLOATING POINT FORMAT IS AS FOLLOWS:
1250                  | ;[M80]
1250                  | ;[M80] THE SIGN IS THE FIRST BIT OF THE MANTISSA
1250                  | ;[M80] THE MANTISSA IS 24 BITS LONG
1250                  | ;[M80] THE BINARY POINT IS TO THE LEFT OF THE MSB
1250                  | ;[M80] NUMBER = MANTISSA * 2 ^ EXPONENT
1250                  | ;[M80] THE MANTISSA IS POSITIVE, WITH A ONE ASSUMED TO BE WHERE THE SIGN BIT IS
1250                  | ;[M80] THE SIGN OF THE EXPONENT IS THE FIRST BIT OF THE EXPONENT
1250                  | ;[M80] THE EXPONENT IS STORED IN EXCESS 200 I.E. WITH A BIAS OF 200
1250                  | ;[M80] SO, THE EXPONENT IS A SIGNED 8-BIT NUMBER WITH 200 ADDED TO IT
1250                  | ;[M80] AN EXPONENT OF ZERO MEANS THE NUMBER IS ZERO, THE OTHER BYTES ARE IGNORED
1250                  | ;[M80] TO KEEP THE SAME NUMBER IN THE FAC WHILE SHIFTING:
1250                  | ;[M80]  TO SHIFT RIGHT, EXP:=EXP+1
1250                  | ;[M80]  TO SHIFT LEFT,  EXP:=EXP-1
1250                  | ;[M80]
1250                  | ;[M80] SO, IN MEMORY THE NUMBER LOOKS LIKE THIS:
1250                  | ;[M80]  [BITS 17-24 OF THE MANTISSA]
1250                  | ;[M80]  [BITS 9-16 OF THE MANTISSA]
1250                  | ;[M80]  [THE SIGN IN BIT 7, BITS 2-8 OF THE MANTISSA ARE IN BITS 6-0]
1250                  | ;[M80]  [THE EXPONENT AS A SIGNED NUMBER + 200]
1250                  | ;[M80] (REMEMBER THAT BIT 1 OF THE MANTISSA IS ALWAYS A ONE)
1250                  | ;[M80]
1250                  | ;[M80] ARITHMETIC ROUTINE CALLING CONVENTIONS:
1250                  | ;[M80]
1250                  | ;[M80] FOR ONE ARGUMENT FUNCTIONS:
1250                  | ;[M80]  THE ARGUMENT IS IN THE FAC, THE RESULT IS LEFT IN THE FAC
1250                  | ;[M80] FOR TWO ARGUMENT OPERATIONS:
1250                  | ;[M80]  THE FIRST ARGUMENT IS IN B,C,D,E I.E. THE "REGISTERS"
1250                  | ;[M80]  THE SECOND ARGUMENT IS IN THE FAC
1250                  | ;[M80]  THE RESULT IS LEFT IN THE FAC
1250                  | ;[M80] 
1250                  | ;[M80] THE "S" ENTRY POINTS TO THE TWO ARGUMENT OPERATIONS HAVE (HL) POINTING TO
1250                  | ;[M80] THE FIRST ARGUMENT INSTEAD OF THE FIRST ARGUMENT BEING IN THE REGISTERS.
1250                  | ;[M80] MOVRM IS CALLED TO GET THE ARGUMENT IN THE REGISTERS.
1250                  | ;[M80] THE "T" ENTRY POINTS ASSUME THE FIRST ARGUMENT IS ON THE STACK.
1250                  | ;[M80] POPR IS USED TO GET THE ARGUMENT IN THE REGISTERS.
1250                  | ;[M80] NOTE: THE "T" ENTRY POINTS SHOULD ALWAYS BE JUMPED TO AND NEVER CALLED
1250                  | ;[M80] BECAUSE THE RETURN ADDRESS ON THE STACK WILL BE CONFUSED WITH THE NUMBER.
1250                  | ;[M80] 
1250                  | ;[M80] ON THE STACK, THE TWO LO'S ARE PUSHED ON FIRST AND THEN THE HO AND SIGN.
1250                  | ;[M80] THIS IS DONE SO IF A NUMBER IS STORED IN MEMORY, IT CAN BE PUSHED ON THE
1250                  | ;[M80] STACK WITH TWO PUSHM'S.  THE LOWER BYTE OF EACH PART IS IN THE LOWER
1250                  | ;[M80] MEMORY ADDRESS SO WHEN THE NUMBER IS POPPED INTO THE REGISTERS, THE HIGHER
1250                  | ;[M80] ORDER BYTE WILL BE IN THE HIGHER ORDER REGISTER OF THE REGISTER PAIR, I.E.
1250                  | ;[M80] THE HIGHER ORDER BYTE WILL BE POPPED INTO B, D OR H.
1250
1250                    ;[M80] FLOATING POINT ADDITION AND SUBTRACTION                    
1250 : 21 57 17   [M80] FADDH:  ld      hl,FHALF        ;[M80] ENTRY TO ADD 1/2
1253 : CD 31 15   [M80] FADDS:  call    MOVRM           ;[M80] GET ARGUMENT INTO THE REGISTERS
1256 : 18 09                    jr      FADD            ;[M80] DO THE ADDITION
1258
1258 :                  ;[M80] SUBTRACTION      FAC:=ARG-FAC
1258 : CD 31 15   [M80] FSUBS:  call    MOVRM           ;[M80] ENTRY IF POINTER TO ARG IS IN (HL)
125B : 21                       byte    $21             ;;"LD HL," to skip next instruction
125C : C1         [M80] FSUBT:  pop     bc              ;;ENTRY TO FSUB IF ARGUMENT IS ON STACK
125D : D1                       pop     de          
125E : CD 0B 15   [M80] FSUB:   call    NEG             ;[M80] NEGATE SECOND ARGUMENT
1261
1261 :                  ;[M80] ADDITION FAC:=ARG+FAC
1261 : 78         [M80] FADD:   ld      a,b             ;[M80] CHECK IF FIRST ARGUMENT IS ZERO    
1262 : B7                       or      a               ;[M80] GET EXPONENT
1263 : C8                       ret     z               ;[M80] IT IS, RESULT IS NUMBER IN FAC
1264 : 3A E7 38                 ld      a,(FAC)         ;[M80] GET EXPONENT
1267 : B7                       or      a               ;[M80] SEE IF THE NUMBER IS ZERO
1268 : CA 23 15                 jp      z,MOVFR         ;[M80] IT IS, ANSWER IS IN REGISTERS
126B
126B                  + ;;Align Numbers
126B                  | ;[M80] WE WANT TO GET THE SMALLER NUMBER IN THE REGISTERS SO WE CAN SHIFT IT RIGHT
126B                  | ;[M80] AND ALIGN THE BINARY POINTS OF THE TWO NUMBERS.  THEN WE CAN JUST ADD OR
126B                  | ;[M80] SUBTRACT THEM (DEPENDING ON THEIR SIGNS) BYTEWISE.
126B : 90                       sub     b               ;[M80] CHECK RELATIVE SIZES
126C : 30 0C                    jr      nc,FADD1        ;[M80] IS FAC SMALLER?
126E : 2F                       cpl                     ;[M80] YES, NEGATE SHIFT COUNT
126F : 3C                       inc     a               
1270 : EB                       ex      de,hl           ;[M80] SWITCH FAC AND REGISTERS, SAVE (DE)
1271 : CD 13 15                 call    PUSHF           ;[M80] PUT FAC ON STACK
1274 : EB                       ex      de,hl           ;[M80] GET (DE) BACK WHERE IT BELONGS
1275 : CD 23 15                 call    MOVFR           ;[M80] PUT REGISTERS IN THE FAC
1278 : C1                       pop     bc
1279 : D1                       pop     de              ;[M80] GET THE OLD FAC IN THE REGISTERS
127A                    
127A : FE 19      [M80] FADD1:  cp      25              ;ARE WE WITHIN 24 BITS?
127C : D0                       ret     nc              
127D : F5                       push    af              ;SAVE SHIFT COUNT
127E : CD 46 15                 call    UNPACK          ;UNPACK THE NUMBERS
1281 : 67                       ld      h,a             ;SAVE SUBTRACTION FLAG
1282 : F1                       pop     af              ;GET SHIFT COUNT BACK
1283 : CD 30 13                 call    SHIFTR          ;SHIFT REGISTERS RIGHT THE RIGHT AMOUNT
1286
1286                  + ;;Add or Subtract Numbers
1286                  | ;[M80] IF THE NUMBERS HAVE THE SAME SIGN, THEN WE ADD THEM.  IF THE SIGNS ARE
1286                  | ;[M80] DIFFERENT, THEN WE HAVE TO SUBTRACT THEM.  WE HAVE TO DO THIS BECAUSE THE      
1286                  | ;[M80] MANTISSAS ARE POSITIVE.  JUDGING BY THE EXPONENTS, THE LARGER NUMBER IS IN
1286                  | ;[M80] THE FAC, SO IF WE SUBTRACT, THE SIGN OF THE RESULT SHOULD BE THE SIGN OF THE
1286                  | ;[M80] FAC; HOWEVER, IF THE EXPONENTS ARE THE SAME, THE NUMBER IN THE REGISTERS
1286                  | ;[M80] COULD BE BIGGER, SO AFTER WE SUBTRACT THEM, WE HAVE TO CHECK IF THE RESULT
1286                  | ;[M80] WAS NEGATIVE.  IF IT WAS, WE NEGATE THE NUMBER IN THE REGISTERS AND
1286                  | ;[M80] COMPLEMENT THE SIGN OF THE FAC.  (HERE THE FAC IS UNPACKED)
1286                  | ;[M80] IF WE HAVE TO ADD THE NUMBERS, THE SIGN OF THE RESULT IS THE SIGN OF THE
1286                  | ;[M80] FAC.  SO, IN EITHER CASE, WHEN WE ARE ALL DONE, THE SIGN OF THE RESULT
1286                  | ;[M80] WILL BE THE SIGN OF THE FAC.
1286 : 7C                       ld      a,h             ;[M80] GET SUBTRACTION FLAG
1287 : B7                       or      a               
1288 : 21 E4 38                 ld      hl,FACLO        ;[M80] SET POINTER TO LO'S
128B : F2 9F 12                 jp      p,FADD3         ;[M80] SUBTRACT IF THE SIGNS WERE DIFFERENT
128E : CD 10 13                 call    FADDA           ;[M80] ADD THE NUMBERS
1291 : 30 5E                    jr      nc,ROUND        ;[M80] ROUND RESULT IF THERE WAS NO OVERFLOW
1293 : 23                       inc     hl              ;[M80] THERE WAS OVERFLOW
1294 : 34                       inc     (hl)            ;[M80] INCREMENT EXPONENT
1295 : CA D3 03                 jp      z,OVERR
1298 : 2E 01                    ld      l,1             ;[M80] SHIFT RESULT RIGHT ONE, SHIFT CARRY IN
129A : CD 52 13                 call    SHRADD
129D : 18 52                    jr      ROUND           ;[M80] ROUND RESULT AND WE ARE DONE
129F                    
129F                    ;[M80] HERE TO SUBTRACT C,D,E,B FROM ((HL)+0,1,2),0
129F : AF         [M80] FADD3:  xor     a               ;[M80] SUBTRACT NUMBERS, NEGATE UNDERFLOW BYTE
12A0 : 90                       sub     b               
12A1 : 47                       ld      b,a             ;[M80] SAVE IT
12A2 : 7E                       ld      a,(hl)          ;[M80] SUBTRACT LOW ORDERS
12A3 : 9B                       sbc     a,e             
12A4 : 5F                       ld      e,a             
12A5 : 23                       inc     hl              ;[M80] UPDATE POINTER TO NEXT BYTE
12A6 : 7E                       ld      a,(hl)          ;[M80] SUBTRACT MIDDLE ORDERS
12A7 : 9A                       sbc     a,d             
12A8 : 57                       ld      d,a             
12A9 : 23                       inc     hl              ;[M80] UPDATE POINTER TO HIGH ORDERS
12AA : 7E                       ld      a,(hl)          ;[M80] SUBTRACT HIGH ORDERS
12AB : 99                       sbc     a,c
12AC : 4F                       ld      c,a
12AD
12AD                    ;[M80] BECAUSE WE WANT A POSITIVE MANTISSA, CHECK IF WE HAVE TO NEGATE THE NUMBER
12AD : DC 1C 13   [M80] FADFLT: call    c,NEGR
1280
12B0                  + ;NORMALIZE C,D,E,B
12B0                  | ;ALTERS A,B,C,D,E,H,L
12B0                  | ;HERE WE SHIFT THE MANTISSA LEFT UNTIL THE MSB IS A ONE.
12B0                  | ;EXCEPT IN 4K, THE IDEA IS TO SHIFT LEFT BY 8 AS MANY TIMES AS
12B0                  | ;POSSIBLE.
12B0                  | ;
12B0 : 68         [M80] NORMAL: ld      l,b             ;[M80] PUT LOWEST 2 BYTES IN (HL)
12B1 : 63                       ld      h,e             
12B2 : AF                       xor     a               ;[M80] ZERO SHIFT COUNT
12B3 : 47         (M80) NORM1:  ld      b,a             ;[M80] SAVE SHIFT COUNT
12B4 : 79                       ld      a,c             ;[M80] DO WE HAVE 1 BYTE OF ZEROS
12B5 : B7                       or      a               
12B6 : 20 27                    jr      nz,NORM3        ;[M80] NO, SHIFT ONE PLACE AT A TIME
12B8                  - ;[M80] THIS LOOP SPEEDS THINGS UP BY SHIFTING 8 PLACES AT ONE TIME
12B8 : 4A                       ld      c,d             ;[M80] YES, SHIFT OVER 1 BYTE
12B9 : 54                       ld      d,h             
12BA : 65                       ld      h,l             
12BB : 6F                       ld      l,a             ;SHIFT IN 8 ZEROS FOR THE LOW ORDER
12BC : 78                       ld      a,b             ;UPDATE SHIFT COUNT
12BD : D6 08                    sub     8            
12BF : FE E0                    cp      0E0H            ;DID WE SHIFT IN 4 BYTES OF ZEROS?
12C1 : 20 F0                    jr      nz,NORM1        ;NO, TRY TO SHIFT OVER 8 MORE
12C3  
12C3                  + ;[M80] ZERO FAC
12C3                  | ;[M80] ALTERS A ONLY
12C3                  | ;[M80] EXITS WITH A=0
12C3                  | ;[M80] BY OUR FLOATING POINT FORMAT, THE NUMBER IS ZERO IF THE EXPONENT IS ZERO
12C3                  | ;
12C3 : AF               ZERO:   xor     a               ;[M80] ZERO A
12C4 : 32 E7 38         ZERO0:  ld      (FAC),a         ;[M80] ZERO THE FAC'S EXPONENT, ENTRY IF A=0
12C7 : C9                       ret                     ;[M80] ALL DONE
12C8                    
12C8 : 7C         [M80] NORM2:  ld      a,h             ;CHECK FOR CASE OF NORMALIZING A SMALL INT
12C9 : B5                       or      l               
12CA : B2                       or      d               
12CB : 20 0A                    jr      nz,NORM2U       ;DO USUAL THING
12CD : 79                       ld      a,c             ;GET BYTE TO SHIFT
12CE : 05         (M80) NORM2F: dec     b               ;[M80] DECRMENT SHIFT COUNT
12CF : 17                       rla                     ;[M80] SHIFT LEFT
12D0 : 30 FC                    jr      nc,NORM2F       ;[M80] NORMALIZE LIKE SOB
12D2 : 04                       inc     b               ;[M80] CORRECT SHIFT COUNT
12D3 : 1F                       rra                     ;[M80] WE DID IT ONE TOO MANY TIMES
12D4 : 4F                       ld      c,a             ;[M80] RESULT TO [C]
12D5 : 18 0B                    jr      NORM3A          ;[M80] ALL DONE
12D7 : 05         (M80) NORM2U: dec     b               ;[M80] DECREMENT SHIFT COUNT
12D8 : 29                       add     hl,hl           ;[M80] ROTATE (HL) LEFT ONE, SHIFT IN A ZERO
12D9 : 7A                       ld      a,d             ;[M80] ROTATE NEXT HIGHER ORDER LEFT ONE
12DA : 17                       rla                     ;
12DB : 57                       ld      d,a             ;
12DC : 79                       ld      a,c             ;[M80] ROTATE HIGH ORDER LEFT ONE
12DD : 8F                       adc     a,a             ;[M80] SET CONDITION CODES
12DE : 4F                       ld      c,a             ;
12DF : F2 C8 12   (M80) NORM3:  jp      p,NORM2         ;[M80] WE HAVE MORE NORMALIZATION TO DO
12E2 : 78         (M80) NORM3A: ld      a,b             ;[M80] ALL NORMALIZED, GET SHIFT COUNT
12E3 : 5C                       ld      e,h             ;[M80] PUT LO'S BACK IN E,B
12E4 : 45                       ld      b,l             ;
12E5 : B7                       or      a               ;[M80] CHECK IF WE DID NO SHIFTING
12E6 : 28 09                    jr      z,ROUND         ;
12E8 : 21 E7 38                 ld      hl,FAC          ;[M80] LOOK AT FAC'S EXPONENT
12EB : 86                       add     a,(hl)          ;[M80] UPDATE EXPONENT
12EC : 77                       ld      (hl),a          ;
12ED : 30 D4                    jr      nc,ZERO         ;[M80] CHECK FOR UNDERFLOW
12EF : 28 D2                    jr      z,ZERO          ;[M80] NUMBER IS ZERO, ALL DONE
12F1                                                    
12F1                  + ;[M80] ROUND RESULT IN C,D,E,B AND PUT NUMBER IN THE FAC
12F1                  | ;[M80] ALTERS A,B,C,D,E,H,L
12F1                  | ;[M80] WE ROUND C,D,E UP OR DOWN DEPENDING UPON THE MSB OF B
12F1                  | ;
12F1 : 78         [M80] ROUND:  ld      a,b             ;[M80] SEE IF WE SHOULD ROUND UP
12F2 : 21 E7 38   [M80] ROUNDB: ld      hl,FAC          ;[M80] ENTRY FROM FDIV, GET POINTER TO EXPONENT
12F5 : B7                       or      a
12F6 : FC 03 13                 call    m,ROUNDA        ;[M80] DO IT IF NECESSARY
12F9 : 46                       ld      b,(hl)          ;[M80] PUT EXPONENT IN B
12FA                  - ;[80] HERE WE PACK THE HO AND SIGN        
12FA : 23                       inc     hl              ;[M80]  POINT TO SIGN
12FB : 7E                       ld      a,(hl)          ;[M80]  GET SIGN
12FC : E6 80                    and     080H            ;[M80]  GET RID OF UNWANTED BITS
12FE : A9                       xor     c               ;[M80]  PACK SIGN AND HO
12FF : 4F                       ld      c,a             ;[M80]  SAVE IT IN C
1300 : C3 23 15                 jp      MOVFR           ;[M80]  SAVE NUMBER IN FAC
1303
1303                    ;[M80] SUBROUTNE FOR ROUND:  ADD ONE TO C,D,E                  
1303 : 1C               ROUNDA: inc     e               ;[M80] ADD ONE TO THE LOW ORDER, ENTRY FROM QINT
1304 : C0                       ret     nz              ;[M80] ALL DONE IF IT IS NOT ZERO
1305 : 14                       inc     d               ;[M80] ADD ONE TO NEXT HIGHER ORDER
1306 : C0                       ret     nz              ;[M80] ALL DONE IF NO OVERFLOW
1307 : 0C                       inc     c               ;[M80] ADD ONE TO THE HIGHEST ORDER
1308 : C0                       ret     nz              ;[M80] RETURN IF NO OVEFLOW
1309 : 0E 80                    ld      c,$80           ;[M80] THE NUMBER OVERFLOWED, SET NEW HIGH ORDER
130B : 34                       inc     (hl)            ;[M80] UPDATE EXPONENT
130C : C0                       ret     nz              ;[M80] RETURN IF IT DID NOT OVERFLOW
130D : C3 D3 03                 jp      OVERR           ;[M80] OVERFLOW
1310                    
1310                  + ;[M80] ADD (HL)+2,1,0 TO C,D,E
1310                  | ;[M80] THIS CODE IS USED BY FADD, FOUT
1310 : 7E         [M80] FADDA:  ld      a,(hl)          ;[M80] GET LOWEST ORDER
1311 : 83                       add     a,e             ;[M80] ADD IN OTHER LOWEST ORDER
1312 : 5F                       ld      e,a             ;[M80] SAVE IT
1313 : 23                       inc     hl              ;[M80] UPDATE POINTER TO NEXT BYTE
1314 : 7E                       ld      a,(hl)          ;[M80] ADD MIDDLE ORDERS
1315 : 8A                       adc     a,d             
1316 : 57                       ld      d,a             
1317 : 23                       inc     hl              ;[M80] UPDATE POINTER TO HIGH ORDER
1318 : 7E                       ld      a,(hl)          ;[M80] ADD HIGH ORDERS
1319 : 89                       adc     a,c             
131A : 4F                       ld      c,a             
131B : C9                       ret                     ;[M80] ALL DONE
131C
131C                  + ;[M80] NEGATE NUMBER IN C,D,E,B
131C                  | ;[M80] THIS CODE IS USED BY FADD, QINT
131C                  | ;[M80] ALTERS A,B,C,D,E,L
131C                  | ;
131C : 21 E8 38   [M80] NEGR:   ld      hl,FAC+1        ;[M80] NEGATE FAC
131F : 7E                       ld      a,(hl)          ;[M80] GET SIGN
1320 : 2F                       cpl                     ;[M80] COMPLEMENT IT
1321 : 77                       ld      (hl),a          ;[M80] SAVE IT AGAIN
1322 : AF                       xor     a               ;[M80] ZERO A
1323 : 6F                       ld      l,a             ;[M80] SAVE ZERO IN L
1324 : 90                       sub     b               ;[M80] NEGATE LOWEST ORDER
1325 : 47                       ld      b,a             ;[M80] SAVE IT
1326 : 7D                       ld      a,l             ;[M80] GET A ZERO
1327 : 9B                       sbc     a,e             ;[M80] NEGATE NEXT HIGHEST ORDER
1328 : 5F                       ld      e,a             ;[M80] SAVE IT
1329 : 7D                       ld      a,l             ;[M80] GET A ZERO
132A : 9A                       sbc     a,d             ;[M80] NEGATE NEXT HIGHEST ORDER
132B : 57                       ld      d,a             ;[M80] SAVE IT
132C : 7D                       ld      a,l             ;[M80] GET ZERO BACK
132D : 99                       sbc     a,c             ;[M80] NEGATE HIGHEST ORDER
132E : 4F                       ld      c,a             ;[M80] SAVE IT
132F : C9                       ret                     ;[M80] ALL DONE
1330                    
1330                  + ;[M80] SHIFT C,D,E RIGHT
1330                  | ;[M80] A = SHIFT COUNT
1330                  | ;[M80] ALTERS A,B,C,D,E,L
1330                  | ;[M80] THE IDEA (EXCEPT IN 4K) IS TO SHIFT RIGHT 8 PLACES AS MANY TIMES AS
1330                  | ;[M80]  POSSIBLE
1330                  | ;
1330 : 06 00      [M80] SHIFTR: ld      b,0             ;[M80] ZERO OVERFLOW BYTE
1332 : D6 08      (M80) SHFTR1: sub     8               ;[M80] CAN WE SHIFT IT 8 RIGHT?
1334 : 38 07                    jr      c,SHFTR2        ;[M80] NO, SHIFT IT ONE PLACE AT A TIME
1334                  - ;[M80] THIS LOOP SPEEDS THINGS UP BY SHIFTING 8 PLACES AT ONE TIME
1336 : 43                       ld      b,e             ;[M80] SHIFT NUMBER 1 BYTE RIGHT
1337 : 5A                       ld      e,d             
1338 : 51                       ld      d,c             
1339 : 0E 00                    ld      c,0             ;[M80 PUT 0 IN HO
133B : 18 F5                    jr      SHFTR1          ;[M80 TRY TO SHIFT 8 RIGHT AGAIN
133D : C6 09      (M80) SHFTR2: add     a,9             ;[M80 CORRECT SHIFT COUNT
133F : 6F                       ld      l,a             ;[M80 SAVE SHIFT COUNT
133D                  - ;[M80] TEST FOR CASE (VERY COMMON) WHERE SHIFTING SMALL INTEGER RIGHT.
133D                  - ;[M80] THIS HAPPENS IN FOR LOOPS, ETC.
1340 : 7A                       ld      a,d             ;[M80] SEE IF THREE LOWS ARE ZERO.
1341 : B3                       or      e               
1342 : B0                       or      b               
1343 : 20 09                    jr      nz,SHFTR3       ;[M80] IF SO, DO USUAL.
1345 : 79                       ld      a,c             ;[M80] GET HIGH BYTE TO SHIFT
1346 : 2D         (M80) SHFTRF: dec     l               ;[M80] DONE SHIFTING?
1347 : C8                       ret     z               ;[M80] YES, DONE
1348 : 1F                       rra                     ;[M80] ROTATE ONE RIGHT
1349 : 4F                       ld      c,a             ;[M80] SAVE RESULT
134A : 30 FA                    jr      nc,SHFTRF       ;[M80] ZAP BACK AND DO NEXT ONE IF NONE
134C : 18 06                    jr      SHFTC           ;[M80] CONTINUE SHIFTING
134E : AF         (M80) SHFTR3: xor     a               ;[M80] CLEAR CARRY
134F : 2D                       dec     l               ;[M80] ARE WE DONE SHIFTING?
1350 : C8                       ret     z               ;[M80] RETURN IF WE ARE
1351 : 79                       ld      a,c             ;[M80] GET HO
1352 : 1F         [M80] SHRADD: rra                     ;[M80] ENTRY FROM FADD, SHIFT IT RIGHT             
1353 : 4F                       ld      c,a             ;[M80] SAVE IT
1354 : 7A         (M80) SHFTC:  ld      a,d             ;[M80] SHIFT NEXT BYTE RIGHT
1355 : 1F                       rra                     
1356 : 57                       ld      d,a             
1357 : 7B                       ld      a,e             ;[M80] SHIFT LOW ORDER RIGHT
1358 : 1F                       rra                     
1359 : 5F                       ld      e,a             
135A : 78                       ld      a,b             ;[M80] SHIFT OVERFLOW BYTE RIGHT
135B : 1F                       rra                     
135C : 47                       ld      b,a             
135D : 18 EF                    jr      SHFTR3          ;[M80] SEE IF WE ARE DONE
135F
135F :                  ;[M80] CONSTANTS USED BY LOG 
135F : 00 00 00 81(M80) FONE:   byte    $00,$00,$00,$81 ;1
1363 : 04         [M80] LOGP:   byte    4                ;[M80] HART 2524 COEFFICIENTS
1364 : 9A F7 19 83              byte    $9A,$F7,$19,$83  ;[M80] 4.8114746
1368 : 24 63 43 83              byte    $24,$63,$43,$83  ;[M80] 6.105852
136C : 75 CD 8D 84              byte    $75,$CD,$8D,$84  ;[M80] -8.86266
1370 : A9 7F 83 82              byte    $A9,$7F,$83,$82  ;[M80] -2.054667
1374 : 04         [M80] LOGQ:   byte    4
1375 : 00 00 00 81              byte    $00,$00,$00,$81  ;[M80] 1.0
1379 : E2 B0 4D 83              byte    $E2,$B0,$4D,$83  ;[M80] 6.427842
137D : 0A 72 11 83              byte    $0A,$72,$11,$83  ;[M80] 4.545171
1381 : F4 04 35 7F              byte    $F4,$04,$35,$7F  ;[M80] .3535534
1385
1385 :                + ;[M80] NATURAL LOG FUNCTION
1385 :                | ;[M80] CALCULATION IS BY:
1385 :                | ;[M80]  LN(F*2^N)=(N+LOG2(F))*LN(2)
1385 :                | ;[M80] AN APPROXIMATION POLYNOMIAL IS USED TO CALCULATE LOG2(F)
1385 : EF         [M80] LOG:    rst     FSIGN           ;[M80] CHECK FOR A NEGATIVE OR ZERO ARGUMENT
1386 : B7                       or      a               ;[M80] SET CC'S PROPERLY
1387 : EA 97 06                 jp      pe,FCERR        ;[M80] FAC .LE. 0, BLOW HIM OUT OF THE WATER
138A : CD 95 13                 call    LOG2
138D : 01 31 80                 ld      bc,$8031       
1390 : 11 18 72                 ld      de,$7218        ;[M80] GET LN(2)
1393 : 18 36                    jr      FMULT           ;[M80] COMPLETE LOG CALCULATION: USE HART 2524 CALCULATION
1395
1395                    ;[M80] USE HART 2524 CALCULATION
1395 : CD 2E 15   [M80] LOG2:   call    MOVRF           ;[M80] MOVE FAC TO REGISTERS TOO
1398 : 3E 80                    ld      a,080H          
139A : 32 E7 38                 ld      (FAC),a         ;[M80] ZERO THE EXPONENT
139D : A8                       xor     b               ;[M80] REMOVE 200 EXCESS FROM X
139E : F5                       push    af              ;[M80] SAVE EXPONENT
139F : CD 13 15                 call    PUSHF           ;[M80] SAVE THE FAC (X)
13A2 : 21 63 13                 ld      hl,LOGP         ;[M80] POINT TO P CONSTANTS
13A5 : CD 46 18                 call    POLY            ;[M80] CALCULATE P(X)
13A8 : C1                       pop     bc              ;[M80] FETCH X
13A9 : E1                       pop     hl              ;[M80] PUSHF WOULD ALTER DE
13AA : CD 13 15                 call    PUSHF           ;[M80] PUSH P(X) ON THE STACK
13AD : EB                       ex      de,hl           ;[M80] GET LOW BYTES OF X TO (DE)
13AE : CD 23 15                 call    MOVFR           ;[M80] AND MOVE TO FAC
13B1 : 21 74 13                 ld      hl,LOGQ         ;[M80] POINT TO Q COEFFICIENTS
13B4 : CD 46 18                 call    POLY            ;[M80] COMPUTE Q(X)
13B7 : C1                       pop     bc              ;[M80] FETCH P(X) TO REGISTERS
13B8 : D1                       pop     de              ;
13B9 : CD 2F 14                 call    FDIV            ;[M80] CALCULATE P(X)/Q(X)
13BC : F1                       pop     af              ;[M80] RE-FETCH EXPONENT
13BD : CD 13 15                 call    PUSHF           ;[M80] SAVE EVALUATION
13C0 : CD F6 14                 call    FLOAT           ;[M80] FLOAT THE EXPONENT
13C3 : C1                       pop     bc              ;
13C4 : D1                       pop     de              ;
13C5 : C3 61 12                 jp      FADD            ;[M80] GET EVAL. BACK
13C8
13C8                    ;;***Unused code? 
13C8                    ;;;IMULT in [M80] fell into here
13C8 : 21                       byte    $21             ;;[LD HL.] to skip next two instructions
13C9 : C1         (M80) FMULTT: pop     bc              ;[M80] GET FIRST ARGUMENT OFF STACK, ENTRY FROM POLYX
13CA : D1                       pop     de              
13CB
13CB                  + ;[M80] MULTIPLICATION           FAC:=ARG*FAC
13CB                  | ;[M80] ALTERS A,B,C,D,E,H,L
13CB                  | ;
13CB                  | ;[M80] THE PRODUCT WILL BE FORMED IN C,D,E,B. THIS WILL BE IN C,H,L,B PART OF THE
13CB                  | ;[M80] TIME IN ORDER TO USE THE "DAD" INSTRUCTION.  AT FMULT2, WE GET THE NEXT
13CB                  | ;[M80] BYTE OF THE MANTISSA IN THE FAC TO MULTIPLY BY.  ((HL) POINTS TO IT)
13CB                  | ;[M80] (THE FMULT2 SUBROUTINE PRESERVES (HL))  IN 8K, IF THE BYTE IS ZERO, WE JUST
13CB                  | ;[M80] SHIFT THE PRODUCT 8 RIGHT.  THIS BYTE IS THEN SHIFTED RIGHT AND SAVED IN D
13CB                  | ;[M80] (H IN 4K).  THE CARRY DETERMINES IF WE SHOULD ADD IN THE SECOND FACTOR
13CB                  | ;[M80] IF WE DO, WE ADD IT TO C,H,L.  B IS ONLY USED TO DETERMINE WHICH WAY WE
13CB                  | ;[M80] ROUND.  WE THEN SHIFT C,H,L,B (C,D,E,B) IN 4K RIGHT ONE TO GET READY FOR THE
13CB                  | ;[M80] NEXT TIME THROUGH THE LOOP.  NOTE THAT THE CARRY IS SHIFTED INTO THE MSB OF
13CB                  | ;[M80] C.  E HAS A COUNT (L IN 4K) TO DETERMINE WHEN WE HAVE LOOKED AT ALL THE BITS
13CB                  | ;[M80] OF D (H IN 4K).
13CB                  | ;                   
13CB : EF         [M80] FMULT:  rst     FSIGN           ;[M80] CHECK IF FAC IS ZERO
13CC : C8                       ret     z               ;[M80] IF IT IS, RESULT IS ZERO
13CD : 2E 00                    ld      l,0             ;[M80] ADD THE TWO EXPONENTS, L IS A FLAG
13CF : CD AC 14                 call    MULDIV          ;[M80] FIX UP THE EXPONENTS
13D2                  - ;[M80] SAVE THE NUMBER IN THE REGISTERS SO WE CAN ADD IT FAST
13D2 : 79                       ld      a,c             ;[M80] GET HO
13D3 : 32 F6 38                 ld      (RESHO),a       ;[M80] STORE HO OF REGISTERS
13D6 : EB                       ex      de,hl           ;[M80] STORE THE TWO LO'S OF THE REGISTERS
13D7 : 22 F7 38                 ld      (RESMO),hl      ;
13DA : 01 00 00                 ld      bc,0            ;[M80] ZERO THE PRODUCT REGISTERS
13DD : 50                       ld      d,b             ;
13DE : 58                       ld      e,b             ;
13DF : 21 B0 12                 ld      hl,NORMAL       ;
13E2 : E5                       push    hl              ;[M80]  ON THE STACK
13E3 : 21 EB 13                 ld      hl,FMULT2       ;[M80] PUT FMULT2 ON THE STACK TWICE, SO AFTER
13E6 : E5                       push    hl              ;[M80]  WE MULTIPLY BY THE LO BYTE, WE WILL
13E7 : E5                       push    hl              ;[M80]  MULTIPLY BY THE MO AND HO
13E8 : 21 E4 38                 ld      hl,FACLO        ;[M80] GET ADDRESS OF LO OF FAC
13EB : 7E         (M80) FMULT2: ld      a,(hl)          ;[M80] GET BYTE TO MULTIPLY BY
13EC : 23                       inc     hl              ;[M80] MOVE POINTER TO NEXT BYTE
13ED : B7                       or      a               ;
13EE : 28 2C                    jr      z,FMULT3        ;[M80] ARE WE MULTIPLYING BY ZERO?
13F0 : E5                       push    hl              ;[M80] SAVE POINTER
13F1 : 2E 08                    ld      l,8             ;[M80] SET UP A COUNT
13F3 : 1F         (M80) FMULT4: rra                     ;ROTATE BYTE RIGHT
13F4 : 67                       ld      h,a             ;SAVE IT
13F5 : 79                       ld      a,c             ;GET HO
13F6 : 30 0B                    jr      nc,FMULT5        ;DON'T ADD IN NUMBER IF BIT WAS ZERO
13F8 : E5                       push    hl              ;SAVE COUNTERS
13F9 : 2A F7 38                 ld      hl,(RESMO)
13FC : 19                       add     hl,de
13FD : EB                       ex      de,hl
13FE : E1                       pop     hl
13FF : 3A F6 38                 ld      a,(RESHO)
1402 : 89                       adc     a,c
1403 : 1F         (M80) FMULT5: rra                     ;[M80] ROTATE RESULT RIGHT ONE
1404 : 4F                       ld      c,a             ;
1405 : 7A                       ld      a,d             ;[M80] ROTATE NEXT BYTE
1406 : 1F                       rra                     ;
1407 : 57                       ld      d,a             ;
1408 : 7B                       ld      a,e             ;[M80] ROTATE NEXT LOWER ORDER
1409 : 1F                       rra                     ;
140A : 5F                       ld      e,a             ;
140B : 78                       ld      a,b             ;[M80] ROTATE LO
140C : 1F                       rra                     ;
140D : 47                       ld      b,a             ;
140E : E6 10                    and     010H            ;[M80] SEE IF WE ROTATED THRU ST
1410 : 28 04                    jr      z,FML5B1        ;[M80] IF NOT DON'T WORRY
1412 : 78                       ld      a,b             ;[M80] RE FETCH LO
1413 : F6 20                    or      020H            ;[M80] "OR" IN STICKY
1415 : 47                       ld      b,a             ;[M80] BACK TO LO
1416 : 2D               FML5B1: dec     l               ;[M80] ARE WE DONE?
1417 : 7C                       ld      a,h             ;[M80] GET NUMBER WE ARE MULTIPLYING BY
1418 : 20 D9                    jr      nz,FMULT4       ;[M80] MULTIPLY AGAIN IF WE ARE NOT DONE
141A : E1         [M80] POPHRT: pop     hl              ;[M80] GET POINTER TO NUMBER TO MULTIPLY BY
141B : C9                       ret                     ;[M80] ALL DONE
141C : 43         [M80] FMULT3: ld      b,e             ;[M80] MULTIPLY BY ZERO: SHIFT EVERYTHING 8 RIGHT
141D : 5A                       ld      e,d             ;
141E : 51                       ld      d,c             ;
141F : 4F                       ld      c,a             ;[M80] SHIFT IN 8 ZEROS ON THE LEFT
1420 : C9                       ret                     ;[M80] ALL DONE
1421
1421                  + ;[M80]  DIVIDE FAC BY 10
1421                  - ;[M80]  ALTERS A,B,C,D,E,H,L
1421 : CD 13 15   [M80] DIV10:  call    PUSHF           ;[M80] WE HAVE TO DIVIDE -- SAVE COUNT
1424 : 01 20 84                 ld      bc,$8420        ;[M80] 10.0
1427 : 11 00 00                 ld      de,$0000        
142A : CD 23 15                 call    MOVFR           ;[M80] MOVE TEN INTO THE FAC
142D : C1         [M80] FDIVT:  pop     bc              ;[F80] GET NUMBER BACK IN REGISTERS
142E : D1                       pop     de              ;[F80] FALL INTO DIVIDE AND WE ARE DONE
142F
142F                    ;[M80] DIVISION       FAC:=ARG/FAC
142F                    ;[M80] ALTERS A,B,C,D,E,H,L
142F : EF         [M80] FDIV:   rst     FSIGN           ;[M80] CHECK FOR DIVISION BY ZERO
1430 : CA C7 03                 jp      z,DV0ERR        ;[M80] DON'T ALLOW DIVIDE BY ZERO
1433 : 2E FF                    ld      l,255           ;[M80] SUBTRACT THE TWO EXPONENTS, L IS A FLAG
1435 : CD AC 14                 call    MULDIV          ;[M80] FIX UP THE EXPONENTS AND THINGS
1438 : 34                       inc     (hl)
1439 : CA D3 03                 jp      z,OVERR         ;[M80] OVERFLOW
143C : 34                       inc     (hl)
143D : CA D3 03                 jp      z,OVERR         ;[M80] OVERFLOW
1440                  - ;[M80] HERE WE SAVE THE FAC IN MEMORY SO WE CAN SUBTRACT IT FROM THE NUMBER
1440                  - ;[M80] IN THE REGISTERS QUICKLY.
1440 : 2B                       dec     hl              ;[M80] POINT TO HO
1441 : 7E                       ld      a,(hl)          ;[M80] GET HO
1442 : 32 19 38                 ld      (FDIVA+1),a       ;[M80] SAVE IT
1445 : 2B                       dec     hl              ;[M80] SAVE MIDDLE ORDER
1446 : 7E                       ld      a,(hl)          
1447 : 32 15 38                 ld      (FDIVB+1),a       ;[M80] PUT IT WHERE NOTHING WILL HURT IT
144A : 2B                       dec     hl              ;[M80] SAVE LO
144B : 7E                       ld      a,(hl)
144C : 32 11 38                 ld      (FDIVC+1),a
144F                  - ;[M80] THE NUMERATOR WILL BE KEPT IN B,H,L.  THE QUOTIENT WILL BE FORMED IN C,D,E.
144F                  | ;[M80] TO GET A BIT OF THE QUOTIENT, WE FIRST SAVE B,H,L ON THE STACK, THEN
144F                  | ;[M80] SUBTRACT THE DENOMINATOR THAT WE SAVED IN MEMORY.  THE CARRY INDICATES
144F                  | ;[M80] WHETHER OR NOT B,H,L WAS BIGGER THAN THE DENOMINATOR.  IF B,H,L WAS BIGGER,
144F                  | ;[M80] THE NEXT BIT OF THE QUOTIENT IS A ONE.  TO GET THE OLD B,H,L OFF THE STACK,
144F                  | ;[M80] WE POP THEM INTO THE PSW.  IF THE DENOMINATOR WAS BIGGER, THE NEXT BIT OF
144F                  | ;[M80] THE QUOTIENT IS ZERO, AND WE GET THE OLD B,H,L BACK BY POPPING IT OFF THE
144F                  | ;[M80] STACK.  WE HAVE TO KEEP AN EXTRA BIT OF THE QUOTIENT IN FDIVG+1 IN CASE THE
144F                  | ;[M80] DENOMINATOR WAS BIGGER,  THEN B,H,L WILL GET SHIFTED LEFT.  IF THE MSB  OF
144F                  | ;[M80] B WAS ONE, IT HAS TO BE STORED SOMEWHERE, SO WE STORE IT IN FDIVG+1.  THEN
144F                  | ;[M80] THE NEXT TIME THROUGH THE LOOP B,H,L WILL LOOK BIGGER BECAUSE IT HAS AN
144F                  | ;[M80] EXTRA HO BIT IN FDIVG+1. WE ARE DONE DIVIDING WHEN THE MSB OF C IS A ONE.
144F                  | ;[M80] THIS OCCURS WHEN WE HAVE CALCULATED 24 BITS OF THE QUOTIENT.  WHEN WE JUMP
144F                  | ;[M80] TO ROUND, THE 25TH BIT OF THE QUOTIENT DETERMINES WHETHER WE ROUND OR NOT.
144F                  | ;[M80] IT IS IN THE MSB OF A.  IF INITIALLY THE DENOMINATOR IS BIGGER THAN THE
144F                  | ;[M80] NUMERATOR, THE FIRST BIT OF THE QUOTIENT WILL BE ZERO.  THIS MEANS WE
144F                  | ;[M80] WILL GO THROUGH THE DIVIDE LOOP 26 TIMES, SINCE IT STOPS ON THE 25TH BIT
144F                  | ;[M80] AFTER THE FIRST NON-ZERO BIT OF THE QUOTIENT.  SO, THIS QUOTIENT WILL LOOK
144F                  | ;[M80] SHIFTED LEFT ONE FROM THE QUOTIENT OF TWO NUMBERS IN WHICH THE NUMERATOR IS
144F                  | ;[M80] BIGGER.  THIS CAN ONLY OCCUR ON THE FIRST TIME THROUGH THE LOOP, SO C,D,E
144F                  | ;[M80] ARE ALL ZERO.  SO, IF WE FINISH THE LOOP AND C,D,E ARE ALL ZERO, THEN WE
144F                  | ;[M80] MUST DECREMENT THE EXPONENT TO CORRECT FOR THIS.
144F : 41                       ld      b,c             ;[M80] GET NUMBER IN B,H,L
1450 : EB                       ex      de,hl           
1451 : AF                       xor     a               ;[M80] ZERO C,D,E AND HIGHEST ORDER
1452 : 4F                       ld      c,a
1453 : 57                       ld      d,a
1454 : 5F                       ld      e,a
1455 : 32 1C 38                 ld      (FDIVG+1),a
1458 : E5         [M80] FDIV1:  push    hl              ;[M80] SAVE LO'S OF NUMBER              
1459 : C5                       push    bc              ;[M80] SAVE HO OF NUMBER
145A : 7D                       ld      a,l             ;[M80] SUBTRACT NUMBER THAT WAS IN FAC
145B : CD 10 38                 call    FDIVC           ;;Call Divide Routine in RAM for apeed
145E : DE 00                    sbc     a,0             ;[M80] SUBTRACT LO
1460 : 3F                       ccf                     ;[M80] SET CARRY TO CORESPOND TO NEXT QUOTIENT BIT
1461 : 30 07                    jr      nc,FDIV2        ;[M80] GET OLD NUMBER BACK IF WE SUBTRACTED TOO MUCH
1463 : 32 1C 38                 ld      (FDIVG+1),a     ;[M80] UPDATE HIGHEST ORDER
1466 : F1                       pop     af              ;[M80] THE SUBTRACTION WAS GOOD
1467 : F1                       pop     af              ;[M80] GET PREVIOUS NUMBER OFF STACK
1468 : 37                       scf                     ;[M80] NEXT BIT IN QUOTIENT IS A ONE
1469 : D2                       byte    $D2             ;[M80] "JNC" AROUND NEXT 2 BYTES
146A : C1         (M80) FDIV2:  pop     bc              ;[M80] WE SUBTRACTED TOO MUCH
146B : E1                       pop     hl              ;[M80] GET OLD NUMBER BACK
146C : 79                       ld      a,c             ;[M80] ARE WE DONE?
146D : 3C                       inc     a               ;[M80] SET SIGN FLAG WITHOUT AFFECTING CARRY
146E : 3D                       dec     a
146F : 1F                       rra                     ;[M80]PUT CARRY IN MSB
1470 : F2 87 14                 jp      p,DIV2A         ;[M80]NOT READY TO ROUND YET
1473 : 17                       rla                     ;[M80]BIT BACK TO CARRY
1474 : 3A 1C 38                 ld      a,(FDIVG+1)     ;[M80]FETCH EXTRA BIT
1477 : 1F                       rra                     ;[M80]BOTH NOW IN A
1478 : E6 C0                    and     $C0             ;[M80]CLEAR SUPERFLUOUS BITS
147A : F5                       push    af              ;[M80]SAVE FOR LATER
147B : 78                       ld      a,b             ;[M80]FETCH HO OF REMAINDER
147C : B4                       or      h               ;[M80]FETCH HO
147D : B5                       or      l               ;[M80]SEE IF OTHER REMAINDER BITS AND IF SO SET ST
147E : 28 02                    jr      z,DIV2AA        ;[M80]IF NOT IGNORE
1480 : 3E 20                    ld      a,020H          ;[M80]ST BIT
1482 : E1         (M80) DIV2AA: pop     hl              ;[M80]AND THE REST OF REMAINDER
1483 : B4                       or      h               ;[M80]"OR" IN REST
1484 : C3 F2 12                 jp      ROUNDB          ;[M80]USE REMAINDER
1487 : 17         (M80) DIV2A:  rla                     ;[M80]WE AREN'T, GET OLD CARRY BACK
1488 : 7B                       ld      a,e             ;[M80]ROTATE EVERYTHING LEFT ONE
1489 : 17                       rla                     ;[M80]ROTATE NEXT BIT OF QUOTIENT IN
148A : 5F                       ld      e,a
148B : 7A                       ld      a,d
148C : 17                       rla
148D : 57                       ld      d,a
148E : 79                       ld      a,c
148F : 17                       rla
1490 : 4F                       ld      c,a
1491 : 29                       add     hl,hl           ;[M80] ROTATE A ZERO INTO RIGHT END OF NUMBER
1492 : 78                       ld      a,b             ;[M80] THE HO BYTE, FINALLY!
1493 : 17         {M80} FDIV2A: rla                     
1494 : 47                       ld      b,a
1495 : 3A 1C 38   {M80} FDIV2B: ld      a,(FDIVG+1)
1498 : 17                       rla
1499 : 32 1C 38                 ld      (FDIVG+1),a
149C : 79                       ld      a,c             ;[M80] ADD ONE TO EXPONENT IF THE FIRST SUBTRACTION
149D : B2                       or      d               ;[M80]  DID NOT WORK
149E : B3                       or      e               
149F : 20 B7                    jr      nz,FDIV1        ;[M80] THIS ISN'T THE CASE        
14A1 : E5                       push    hl              ;[M80] SAVE PART OF NUMBER
14A2 : 21 E7 38                 ld      hl,FAC          ;[M80] GET POINTER TO FAC
14A5 : 35                       dec     (hl)            ;[M80] DECREMENT EXPONENT
14A6 : E1                       pop     hl              ;[M80] GET NUMBER BACK
14A7 : 20 AF                    jr      nz,FDIV1        ;[M80] DIVIDE MORE IF NO OVERFLOW OCCURED
14A9 : C3 C3 12                 jp      ZERO            ;[M80] UNDERFLOW!!
14AC
14AC                  + ;[M80] CHECK SPECIAL CASES AND ADD EXPONENTS FOR FMULT, FDIV
14AC                  | ;[M80] ALTERS A,B,H,L
14AC                  | ;
14AC : 78         [M80] MULDIV: ld      a,b             ;[M80] IS NUMBER IN REGISTERS ZERO?
14AD : B7                       or      a               
14AE : 28 1D                    jr      z,MULDV2        ;[M80] IT IS, ZERO FAC AND WE ARE DONE
14B0 : 7D                       ld      a,l             ;[M80] GET ADD OR SUBTRACT FLAG
14B1 : 21 E7 38                 ld      hl,FAC          ;[M80] GET POINTER TO EXPONENT
14B4 : AE                       xor     (hl)            ;[M80] GET EXPONENT
14B5 : 80                       add     a,b             ;[M80] ADD IN REGISTER EXPONENT
14B6 : 47                       ld      b,a             ;[M80] SAVE IT
14B7 : 1F                       rra                     ;[M80] CHECK FOR OVERFLOW
14B8 : A8                       xor     b               ;[M80] OVERFLOW IF SIGN IS THE SAME AS CARRY
14B9 : 78                       ld      a,b             ;[M80] GET SUM
14BA : F2 CC 14                 jp      p,MULDV1        ;[M80] WE HAVE OVERFLOW!!
14BD : C6 80                    add     a,$80           ;{M80} PUT EXPONENT IN EXCESS 128
14BF : 77                       ld      (hl),a          ;[M80] SAVE IT IN THE FAC
14C0 : CA 1A 14                 jp      z,POPHRT        ;[M80] WE HAVE UNDEFLOW!! RETURN.
14C3 : CD 46 15                 call    UNPACK          ;[M80] UNPACK THE ARGUMENTS
14C6 : 77                       ld      (hl),a          ;[M80] SAVE THE NEW SIGN
14C7 : 2B         {M80} DCXHRT: dec     hl              ;[M80] POINT TO EXPONENT
14C8 : C9                       ret                     ;[M80] ALL DONE, LEAVE HO IN A
14C8
14C9 : EF         {M80} MLDVEX: rst     FSIGN           ;[M80] ENTRY FROM EXP, PICK UNDERFLOW IF NEGATIVE
14CA : 2F                       cpl                     ;[M80] PICK OVERFLOW IF POSITIVE
14CB : E1                       pop     hl              ;[M80] DON'T SCREW UP STACK
14CC : B7         [M80] MULDV1: or      a               ;[M80] IS ERROR OVERFLOW OR UNDEFLOW?
14CD : E1         [M80] MULDV2: pop     hl              ;[M80] GET OLD RETURN ADDRESS OFF STACK
14CE : F2 C3 12                 jp      p,ZERO
14D1 : C3 D3 03                 jp      OVERR           ;[M80] OVERFLOW
14D1                    
14D1                  + ;[M80] MULTIPLY FAC BY 10
14D1                  | ;[M80] ALTERS A,B,C,D,E,H,L
14D4 : CD 2E 15   [M80] MUL10:  call    MOVRF           ;[M80] GET NUMBER IN REGISTERS
14D7 : 78                       ld      a,b             ;[M80] GET EXPONENT
14D8 : B7                       or      a               ;[M80] RESULT IS ZERO IF ARG IS ZERO
14D9 : C8                       ret     z               ;[M80] IT IS
14DA : C6 02                    add     a,002H          ;[M80] MULTIPLY BY 4 BY ADDING 2 TO EXPONENT
14DC : DA D3 03                 jp      c,OVERR         ;{M80} OVERFLOW
14DF : 47                       ld      b,a             ;[M80] RESTORE EXPONENT
14E0 : CD 61 12                 call    FADD            ;[M80] ADD IN ORIGINAL NUMBER TO GET 5 TIMES IT
14E3 : 21 E7 38                 ld      hl,FAC          ;[M80] ADD 1 TO EXPONENT TO MULTIPLY NUMBER BY
14E6 : 34                       inc     (hl)            ;[M80]  2 TO GET 10 TIMES ORIGINAL NUMBER
14E7 : C0                       ret     nz              ;[M80] ALL DONE IF NO OVERFLOW
14E8 : C3 D3 03                 jp      OVERR           ;{M80} OVERFLOW
14EB
14EB                    ;;Jumped to from FSIGN 
14EB : 3A E6 38   [M80] SIGNC:  ld      a,(FACHO)       ;[M80] GET SIGN OF FACHO, IT IS NON-ZERO
14EE : FE                       byte    $FE             ;"CP" AROUND NEXT BYTE
14EF : 2F         [M80] FCOMPS: cpl                     ;ENTRY FROM FCOMP, COMPLEMENT SIGN
14F0 : 17         (M80) ICOMPS: rla                     ;ENTRY FROM ICOMP, PUT SIGN BIT IN CARRY
14F1 : 9F         [M80] SIGNS:  sbc     a,a             ;A=0 IF CARRY WAS 0, A=377 IF CARRY WAS 1
14F2 : C0                       ret     nz              ;RETURN IF NUMBER WAS NEGATIVE
14F3 : 3C         (M80) INRART: inc     a               ;PUT ONE IN A IF NUMBER WAS POSITIVE
14F4 : C9                       ret                     ;ALL DONE
14F5
14F5                    ;;The SGN() Function
14F5 : EF               SGN:    rst     FSIGN           ;;Get sign of FAC
14F6
14F6                  + ;[M80] FLOAT THE SIGNED INTEGER IN A
14F6                  | ;[M80] ALTERS A,B,C,D,E,H,L
14F6 : 06 88      [M80] FLOAT:  ld      b,$88           ;[M80] SET EXPONENT CORRECTLY
14F8 : 11 00 00                 ld      de,0            ;[M80] ZERO D,E
14FB
14FB                  + ;[M80] FLOAT THE SIGNED NUMBER IN B,A,D,E
14FB                  | ;[M80] ALTERS A,B,C,D,E,H,L
14FB : 21 E7 38   [M80] FLOATR: ld      hl,FAC          ;[M80] GET POINTER TO FAC
14FE : 4F                       ld      c,a             ;[M80] PUT HO IN C
14FF : 70                       ld      (hl),b          ;[M80] PUT EXPONENT IN THE FAC
1500 : 06 00                    ld      b,0             ;[M80] ZERO OVERFLOW BYTE
1502 : 23                       inc     hl              ;[M80] POINT TO SIGN
1503 : 36 80                    ld      (hl),128        ;[M80] ASSUME A POSITIVE NUMBER
1505 : 17                       rla                     ;[M80] PUT SIGN IN CARRY
1506 : C3 AD 12                 jp      FADFLT          ;[M80] GO AND FLOAT THE NUMBER
1509
1509                    ;[M80] ABSOLUTE VALUE OF FAC
1509 : EF         [M80] ABS:    rst     FSIGN           ;[M80] GET THE SIGN OF THE FAC IN A
150A : F0                       ret     p               ;[M80] IF IT IS POSITIVE, WE ARE DONE
150B
150B                    ;[M80] NEGATE ANY TYPE VALUE IN THE FAC             
150B : 21 E6 38   [M80] NEG:    ld      hl,FACHO        ;[M80[ GET POINTER TO SIGN
150E : 7E                       ld      a,(hl)          ;[M80[ GET SIGN
150F : EE 80                    xor     $80             ;[M80[ COMPLEMENT SIGN BIT
1511 : 77                       ld      (hl),a          ;[M80[ SAVE IT
1512 : C9                       ret                     ;[M80[ ALL DONE
1513
1513                    ;[M80] PUT FAC ON STACK, ALTERS D,E 
1513 : EB         [M80] PUSHF:  ex      de,hl           ;[M80] SAVE (HL)
1514 : 2A E4 38                 ld      hl,(FACLO)      ;[M80] GET LO'S
1517 : E3                       ex      (sp),hl         ;[M80] SWITCH LO'S AND RET ADDR
1518 : E5                       push    hl              ;[M80] PUT RET ADDR BACK ON STACK
1519 : 2A E6 38                 ld      hl,(FACHO)      ;[M80] GET HO'S
151C : E3                       ex      (sp),hl         ;[M80] SWITCH HO'S AND RET ADDR
151D : E5                       push    hl              ;[M80] PUT RET ADDR BACK ON STACK
151E : EB                       ex      de,hl           ;[M80] GET OLD (HL) BACK
151F : C9                       ret                     ;[M80] ALL DONE
1520
1520 : CD 31 15   [M80] MOVFM:  call    MOVRM           ;[M80] MOVE NUMBER FROM MEMORY [(HL)] TO FAC
1523 : EB         [M80] MOVFR:  ex      de,hl           ;[M80] MOVE REGISTERS (B,C,D,E) TO FAC
1524 : 22 E4 38                 ld      (FACLO),hl      ;[M80] PUT THEM WHERE THEY BELONG
1527 : 60                       ld      h,b             ;[M80] GET HO'S IN (HL)
1528 : 69                       ld      l,c             ;
1529 : 22 E6 38                 ld      (FACHO),hl      ;[M80] PUT HO'S WHERE THEY BELONG
152C : EB                       ex      de,hl           ;[M80] GET OLD (HL) BACK
152D : C9                       ret                     ;[M80] ALL DONE
152E
152E : 21 E4 38   [M80] MOVRF:  ld      hl,FACLO        ;[M80] MOVE FAC TO REGISTERS (B,C,D,E)
1531 : 5E         [M80] MOVRM:  ld      e,(hl)          ;[M80] GET NUMBER IN REGISTERS (B,C,D,E) FROM MEMORY [(HL)]
1532 : 23                       inc     hl              ;[M80] POINT TO MO
1533 : 56                       ld      d,(hl)          ;[M80] GET MO, ENTRY FOR BILL
1534 : 23                       inc     hl              ;[M80] POINT TO HO
1535 : 4E                       ld      c,(hl)          ;[M80] GET HO
1536 : 23                       inc     hl              ;[M80] POINT TO EXPONENT
1537 : 46                       ld      b,(hl)          ;[M80] GET EXPONENT
1538 : 23         [M80] INXHRT: inc     hl              ;[M80] INC POINTER TO BEGINNING OF NEXT NUMBER
1539 : C9                       ret                     ;[M80] ALL DONE
153A
153A                  + ;[M80] MOVE NUMBER FROM FAC TO MEMORY [(HL)]
153A                  | ;[M80] ALTERS A,B,D,E,H,L
153A : 11 E4 38   [M80] MOVMF:  ld      de,FACLO        ;GET POINTER TO FAC
153D
153D                  + ;MOVE NUMBER FROM (DE) TO (HL)
153D                  | ;ALTERS A,B,D,E,H,L
153D                  | ;EXITS WITH (DE):=(DE)+4, (HL):=(HL)+4
153D : 06 04      [M80] MOVE:   ld      b,4             ;[M80] SET COUNTER
153F : 1A         (M80) MOVE1:  ld      a,(de)          ;[M80] GET WORD
1540 : 77                       ld      (hl),a          ;[M80] PUT IT WHERE IT BELONGS
1541 : 13                       inc     de              ;[M80] INCREMENT POINTERS TO NEXT WORD
1542 : 23                       inc     hl
1543 : 10 FA                    djnz    MOVE1
1545 : C9                       ret
1546
1546                  + ;[M80] UNPACK THE FAC AND THE REGISTERS
1546                  | ;[M80] ALTERS A,C,H,L
1546                  | ;[M80] WHEN THE NUMBER IN THE FAC IS UNACKED, THE ASSUMED ONE IN THE
1546                  | ;[M80] MANTISSA IS RESTORED, AND THE COMPLEMENT OF THE SIGN IS PLACED
1546                  | ;[M80] IN FAC+1
1546 : 21 E6 38   [M80] UNPACK: ld      hl,FACHO        ;[M80] POINT TO HO AND SIGN
1549 : 7E                       ld      a,(hl)          ;[M80] GET HO AND SIGN
154A : 07                       rlca                    ;[M80] DUPLICATE THE SIGN IN CARRY AND THE LSB
154B : 37                       scf                     ;[M80] RESTORE THE HIDDEN ONE
154C : 1F                       rra                     ;[M80] RESTORE THE NUMBER IN A
154D : 77                       ld      (hl),a          ;[M80] SAVE HO
154E : 3F                       ccf                     ;[M80] GET THE COMPLEMENT OF THE SIGN
154F : 1F                       rra                     ;[M80] GET IT IN THE SIGN BIT
1550 : 23                       inc     hl              ;[M80] POINT TO TEMPORARY SIGN BYTE
1551 : 23                       inc     hl
1552 : 77                       ld      (hl),a          ;[M80] SAVE COMPLEMENT OF SIGN
1553 : 79                       ld      a,c             ;[M80] GET HO AND SIGN OF THE REGISTERS
1554 : 07                       rlca                    ;[M80] DUPLICATE THE SIGN IN CARRY AND THE LSB
1555 : 37                       scf                     ;[M80] RESTORE THE HIDDEN ONE
1556 : 1F                       rra                     ;[M80] RESTORE THE HO IN A
1557 : 4F                       ld      c,a             ;[M80] SAVE THE HO
1558 : 1F                       rra                     ;[M80] GET THE SIGN BACK
1559 : AE                       xor     (hl)            ;[M80] COMPARE SIGN OF FAC AND SIGN OF REGISTERS
155A : C9                       ret                     ;[M80] ALL DONE
155B
155B                  + ;[M80] COMPARE TWO NUMBERS
155B                  | ;[M80] A=1 IF ARG .LT. FAC
155B                  | ;[M80] A=0 IF ARG=FAC
155B                  | ;[M80] A=-1 IF ARG .GT. FAC
155B                  | ;[M80] DOREL DEPENDS UPON THE FACT THAT FCOMP RETURNS WITH CARRY ON
155B                  | ;{M80}  IFF A HAS $7F
155B                  | ;[M80] ALTERS A,H,L
155B                  | ;
155B : 78         [M80] FCOMP:  ld      a,b             ;[M80] CHECK IF ARG IS ZERO
155C : B7                       or      a               ;
155D : CA 28 00                 jp      z,FSIGN         ;
1560 : 21 EF 14                 ld      hl,FCOMPS       ;[M80] WE JUMP TO FCOMPS WHEN WE ARE DONE
1563 : E5                       push    hl              ;[M80] PUT THE ADDRESS ON THE STACK
1564 : EF                       rst     FSIGN           ;[M80] CHECK IF FAC IS ZERO
1565 : 79                       ld      a,c             ;[M80] IF IT IS, RESULT IS MINUS THE SIGN OF ARG
1566 : C8                       ret     z               ;[M80] IT IS
1567 : 21 E6 38                 ld      hl,FACHO        ;[M80] POINT TO SIGN OF FAC
156A : AE                       xor     (hl)            ;[M80] SEE IF THE SIGNS ARE THE SAME
156B : 79                       ld      a,c             ;[M80] IF THEY ARE DIFFERENT, RESULT IS SIGN OF ARG
156C : F8                       ret     m               ;[M80] THEY ARE DIFFERENT
156D : CD 73 15                 call    FCOMP2          ;[M80] CHECK THE REST OF THE NUMBER
1570 : 1F         {M80} FCOMPD: rra                     ;[M80] NUMBERS ARE DIFFERENT, CHANGE SIGN IF
1571 : A9                       xor     c               ;[M80]  BOTH NUMBERS ARE NEGATIVE
1572 : C9                       ret                     ;[M80] GO SET UP A
1573 : 23         (M80) FCOMP2: inc     hl              ;POINT TO EXPONENT
1574 : 78                       ld      a,b             ;GET EXPONENT OF ARG
1575 : BE                       cp      (hl)            ;COMPARE THE TWO
1576 : C0                       ret     nz              ;NUMBERS ARE DIFFERENT
1577 : 2B                       dec     hl              ;POINT TO HO
1578 : 79                       ld      a,c             ;GET HO OF ARG
1579 : BE                       cp      (hl)            ;COMPARE WITH HO OF FAC
157A : C0                       ret     nz              ;THEY ARE DIFFERENT
157B : 2B                       dec     hl              ;POINT TO MO OF FAC
157C : 7A                       ld      a,d             ;GET MO OF ARG
157D : BE                       cp      (hl)            ;COMPARE WITH MO OF FAC
157E : C0                       ret     nz              ;THE NUMBERS ARE DIFFERENT
157F : 2B                       dec     hl              ;POINT TO LO OF FAC
1580 : 7B                       ld      a,e             ;GET LO OF ARG
1581 : 96                       sub     (hl)            ;SUBTRACT LO OF FAC
1582 : C0                       ret     nz              ;NUMBERS ARE DIFFERENT
1583 : E1                       pop     hl              ;NUMBERS ARE THE SAME, DON'T SCREW UP STACK
1584 : E1                       pop     hl              ;
1585 : C9                       ret                     ;ALL DONE
1586
1586                  + ;[M80] QUICK GREATEST INTEGER FUNCTION 
1586                  | ;[M80] LEAVES INT(FAC) IN C,D,E (SIGNED) ALTERS A,B,C,D,E 
1586                  | ;[M80] ASSUMES THE EXPONENT OF FAC IS IN A AND FAC .LT. 2^23 = 8388608
1586                  | ;[M80] 
1586                  | ;[M80] THE HARD CASE IN QINT IS NEGATIVE NON-INTEGERS.  TO HANDLE THIS, IF THE
1586                  | ;[M80] NUMBER IS NEGATIVE, WE REGARD THE 3-BYTE MANTISSA AS A 3-BYTE INTEGER AND
1586                  | ;[M80] SUBTARCT ONE.  THEN ALL THE FRACTIONAL BITS ARE SHIFTED OUT BY SHIFTING THE
1586                  | ;[M80] MANTISSA RIGHT.  THEN, IF THE NUMBER WAS NEGATIVE, WE ADD ONE.  SO, IF WE
1586                  | ;[M80] HAD A NEGATIVE INTEGER, ALL THE BITS TO THE RIGHT OF THE BINARY POINT WERE
1586                  | ;[M80] ZERO.  SO THE NET EFFECT IS WE HAVE THE ORIGINAL NUMBER IN C,D,E.  IF THE
1586                  | ;[M80] NUMBER WAS A NEGATIVE NON-INTEGER, THERE IS AT LEAST ONE NON-ZERO BIT TO THE
1586                  | ;[M80] RIGHT OF THE BINARY POINT.  SO THE NET EFFECT IS THAT WE GET THE ABSOLUTE
1586                  | ;[M80] VALUE OF INT(FAC) IN C,D,E.  C,D,E IS THEN NEGATED IF THE ORIGINAL NUMBER WAS
1586                  | ;[M80] NEGATIVE SO THE RESULT WILL BE SIGNED.
1586                  | ;
1586 : 47         [M80] QINT:   ld      b,a             ;[M80] ZERO B,C,D,E IN CASE THE NUMBER IS ZERO
1587 : 4F                       ld      c,a
1588 : 57                       ld      d,a
1589 : 5F                       ld      e,a
158A : B7                       or      a               ;[M80] SET CONDITION CODES
158B : C8                       ret     z               ;[M80] IT IS ZERO, WE ARE DONE
158C : E5                       push    hl              ;[M80] SAVE (HL)
158D : CD 2E 15                 call    MOVRF           ;[M80] GET NUMBER IN THE REGISTERS
1590 : CD 46 15                 call    UNPACK          ;[M80] UNPACK THE NUMBER
1593 : AE                       xor     (hl)            ;[M80] GET SIGN OF NUMBER
1594 : 67                       ld      h,a             ;[M80] DON'T LOSE IT
1595 : FC AA 15                 call    m,QINTA         ;[M80] SUBTRACT 1 FROM LO IF NUMBER IS NEGATIVE
1598 : 3E 98                    ld      a,$98           ;[M80] SEE HOW MANY WE HAVE TO SHIFT TO CHANGE
159A : 90                       sub     b               ;[M80]  NUMBER TO AN INTEGER
159B : CD 30 13                 call    SHIFTR          ;[M80] SHIFT NUMBER TO GET RID OF FRACTIONAL BITS           
159E : 7C                       ld      a,h             ;[M80] GET SIGN
159F : 17                       rla                     ;[M80] PUT SIGN IN CARRY SO IT WILL NOT BE CHANGED
15A0 : DC 03 13                 call    c,ROUNDA        ;[M80] IF NUMBER WAS NEGATIVE, ADD ONE
15A3 : 06 00                    ld      b,0             ;[M80] FORGET THE BITS WE SHIFTED OUT
15A5 : DC 1C 13                 call    c,NEGR          ;[M80] NEGATE NUMBER IF IT WAS NEGATIVE
15A8 : E1                       pop     hl              ;[M80] GET OLD (HL) BACK
15A9 : C9                       ret                     ;[M80] ALL DONE
;;;The last comment seems to be directed to Bill Gates, most likely from Monte Davidoff,
;;;who wrote the floating point math routines for Altair Basic. 
15AA : 1B         [M80] QINTA:  dec     de              ;[M80] SUBTRACT ONE FROM C,D,E
15AB : 7A                       ld      a,d             ;[M80] WE HAVE TO SUBTRACT ONE FROM C IF
15AC : A3                       and     e               ;[M80]  D AND E ARE BOTH ALL ONES
15AD : 3C                       inc     a               ;[M80] SEE IF BOTH WERE -1
15AE : C0                       ret     nz              ;[M80] THEY WERE NOT, WE ARE DONE
15AF : 0B                       dec     bc              ;[M80] THIS IS FOR BILL.  C WILL NEVER BE ZERO
15B0 : C9                       ret                     ;[M80]  (THE MSB WILL ALWAYS BE ONE) SO "DCX    B"
15B1                                                    ;[M80] z AND "DCR       C" ARE FUNCTIONALLY EQUIVALENT
15B1                    ;[M80] GREATEST INTEGER FUNCTION
15B1 : 21 E7 38   [M80] INT:    ld      hl,FAC          ;[M80] GET EXPONENT
15B4 : 7E                       ld      a,(hl)          
15B5 : FE 98                    cp      $98             ;[M80] SEE IF NUMBER HAS ANY FRACTIONAL BITS
15B7 : 3A E4 38                 ld      a,(FACLO)       ;[M80] THE ONLY GUY WHO NEEDS THIS DOESN'T CARE ABOUT THE SIGN
15BA : D0                       ret     nc              ;[M80] IT DOES NOT
15BB : 7E                       ld      a,(hl)          ;[M80] GET EXPONENT BACK
15BC : CD 86 15                 call    QINT            ;[M80] IT DOES, SHIFT THEM OUT
15BF : 36 98                    ld      (hl),$98        ;[M80] CHANGE EXPONENT SO IT WILL BE CORRECT
15C1 : 7B                       ld      a,e             ;[M80] GET LO
15C2 : F5                       push    af              ;[M80] SAVE IT
15C3 : 79                       ld      a,c             ;[M80] NEGATE NUMBER IF IT IS NEGATIVE
15C4 : 17                       rla                     ;[M80] PUT SIGN IN CARRY
15C5 : CD AD 12                 call    FADFLT          ;[M80] REFLOAT NUMBER
15C8 : F1                       pop     af              ;[M80] GET LO BACK
15C9 : C9                       ret                     ;[M80] ALL DONE
15CA
15CA                  # ;[M80] INTEGER ARITHMETIC ROUTINES
15CA                    
15CA                  + ;[M80] INTEGER MULTIPLY FOR MULTIPLY DIMENSIONED ARRAYS
15CA                  | ;[M80]  (DE):=(BC)*(DE)
15CA                  | ;[M80] OVERFLOW CAUSES A BS ERROR
15CA                  | ;[M80] ALTERS A,B,C,D,E
15CA : 21 00 00   [M80] UMULT:  ld      hl,0            ;[M80] ZERO PRODUCT REGISTERS
15CD : 78                       ld      a,b             ;[M80] CHECK IF (BC) IS ZERO
15CE : B1                       or      c               ;[M80] IF SO, JUST RETURN, (HL) IS ALREADY ZERO
15CF : C8                       ret     z               ;[M80] THIS IS DONE FOR SPEED
15D0 : 3E 10                    ld      a,16            ;[M80] THIS IS DONE FOR SPEED
15D2 : 29         (M80) UMULT1: add     hl,hl           ;[M80] ROTATE (HL) LEFT ONE
15D3 : DA CD 11                 jp      c,BSERR         ;{M80} IF OVERFLOW, BAD SUBSCRIPT ERROR
15D6 : EB                       ex      de,hl
15D7 : 29                       add     hl,hl           ;[M80] ROTATE (DE) LEFT ONE
15D8 : EB                       ex      de,hl
15D9 : D2 E0 15                 jp      nc,UMULT2       ;[M80] ADD IN (BC) IF HO WAS 1
15DC : 09                       add     hl,bc
15DD : DA CD 11                 jp      c,BSERR
15E0 : 3D         (M80) UMULT2: dec     a               ;[M80] CHECK FOR OVERFLOW
15E1 : C2 D2 15                 jp      nz,UMULT1       ;[M80] SEE IF DONE
15E4 : C9                       ret
15E5
15E5                  + ;[M80] FLOATING POINT INPUT ROUTINE
15E5                  | ;[M80] ALTERS ALL REGISTERS
15E5                  | ;[M80] THE NUMBER IS LEFT IN FAC
15E5                  | ;[M80] AT ENTRY, (HL) POINTS TO THE FIRST CHARACTER IN A TEXT BUFFER.
15E5                  | ;[M80] THE FIRST CHARACTER IS ALSO IN A.  WE PACK THE DIGITS INTO THE FAC
15E5                  | ;[M80] AS AN INTEGER AND KEEP TRACK OF WHERE THE DECIMAL POINT IS.
15E5                  | ;[M80] C IS 377 IF WE HAVE NOT SEEN A DECIMAL POINT, 0 IF WE HAVE.
15E5                  | ;[M80] B IS THE NUMBER OF DIGITS AFTER THE DECIMAL POINT.
15E5                  | ;[M80] AT THE END, B AND THE EXPONENT (IN E) ARE USED TO DETERMINE HOW MANY
15E5                  | ;[M80] TIMES WE MULTIPLY OR DIVIDE BY TEN TO GET THE CORRECT NUMBER.
15E5 : FE 2D      [M80] FIN:    cp      '-'             ;[M80] SEE IF NUMBER IS NEGATIVE
15E7 : F5                       push    af              ;[M80] SAVE SIGN
15E8 : 28 05                    jr      z,FIN1          
15EA : FE 2B                    cp      '+'             ;[M80] IGNORE MINUS SIGN
15EC : 28 01                    jr      z,FIN1          ;[M80] IGNORE A LEADING SIGN
15EE : 2B                       dec     hl              ;[M80] SET CHARACTER POINTER BACK ONE
15EF : CD C3 12   (M80) FIN1:   call    ZERO            ;{M80} GO ZERO THE FAC
15F2 : 47                       ld      b,a             
15F3 : 57                       ld      d,a             ;;[D,E] = $0000
15F4 : 5F                       ld      e,a
15F5 : 2F                       cpl
15F6 : 4F                       ld      c,a             ;;[B,C] = $00FF 
15F7                  - ;[M80] HERE TO CHECK FOR A DIGIT, A DECIMAL POINT, "E" OR "D"
15F7 : D7         [M80] FINC:   rst     CHRGET          ;[M80] GET THE NEXT CHARACTER OF THE NUMBER
15F8 : DA 3F 16                 jp      c,FINDIG        ;[M80] WE HAVE A DIGIT
15FB : FE 2E                    cp      '.'             ;[M80] CHECK FOR A DECIMAL POINT
15FD : CA 1A 16                 jp      z,FINDP         ;[M80] WE HAVE ONE, I GUESS
1600 : FE 65                    cp      'e'             
1602 : CA 0A 16                 jp      z,FINC1
1605 : FE 45                    cp      'E'             ;[M80] CHECK FOR A SINGLE PRECISION EXPONENT
1607 : C2 1E 16                 jp      nz,FINE
160A : D7         (M80) FINC1:  rst     CHRGET
160B : CD 98 0A                 call    MINPLS
160E : D7         (M80) FINEC:  rst     CHRGET          ;[M80] GET THE NEXT CHARATER
160F : DA 61 16                 jp      c,FINEDG        ;[M80] PACK THE NEXT DIGIT INTO THE EXPONENT
1612 : 14                       inc     d               ;[M80] IT WAS NOT A DIGIT, PUT THE CORRECT SIGN ON
1613 : C2 1E 16                 jp      nz,FINE         ;[M80]  THE EXPONENT, IT IS POSITIVE
1616 : AF                       xor     a               ;[M80] THE EXPONENT IS NEGATIVE
1617 : 93                       sub     e               ;[M80] NEGATE IT
1618 : 5F                       ld      e,a             ;[M80] SAVE IT AGAIN
1619 : 0C                       inc     c
161A                    ;[M80] HERE TO SET THE DECIMAL POINT FLAG
161A : 0C         (M80) FINDP:  inc     c               ;[M80] SET THE FLAG
161B : CA F7 15                 jp      z,FINC          ;[M80] CONTINUE LOOKING FOR DIGITS
161E                    ;[M80] HERE TO FINISH UP THE NUMBER
161E : E5         (M80) FINE:   push    hl              ;[M80] SAVE THE TEXT POINTER
161F : 7B                       ld      a,e             ;[M80] FIND OUT HOW MANY TIMES WE HAVE TO MULTIPLY
1620 : 90                       sub     b               ;[M80]  OR DIVIDE BY TEN
1621                    ;[M80] HERE TO MULTIPLY OR DIVIDE BY TEN THE CORRECT NUMBER OF TIMES                    
1621 : F4 37 16   [M80] FINE2:  call    p,FINMUL        ;[M80] MULTIPLY IF WE HAVE TO
1624 : F2 2D 16                 jp      p,FINE3
1627 : F5                       push    af
1628 : CD 21 14                 call    DIV10           ;[M80] DIVIDE IF WE HAVE TO
162B : F1                       pop     af              ;[M80] GET THE SIGN
162C : 3C                       inc     a
162D : C2 21 16   (~~~) FINE3:  jp      nz,FINE2        ;[M80] MULTIPLY OR DIVIDE AGAIN IF WE ARE NOT DONE
1630                    ;[M80] HERE TO PUT THE CORRECT SIGN ON THE NUMBER
1630 : D1                       pop     de              ;[M80] GET THE TEXT POINTER
1631 : F1                       pop     af              ;[M80] GET THE SIGN
1632 : CC 0B 15                 call    z,NEG           ;[M80] NEGATE IF NECESSARY
1635 : EB                       ex      de,hl           ;[M80] GET THE TEXT POINTER IN (HL)
1636 : C9                       ret
1637
1637                  + ;[M80] THIS SUBROUTINE MULIPLIES BY TEN ONCE.
1637                  | ;[M80] IT IS A SUBROUTINE BECAUSE IT SAVES BYTES WHEN WE CHECK IF A IS ZERO
1637                  | ;[M80] ALTERS ALL REGISTERS
1637 : C8         [M80] FINMUL: ret     z               ;[M80] RETURN IF EXPONENT IS ZERO, ENTRY FROM FOUT
1638 : F5         [M80] FINMLT: push    af
1639 : CD D4 14                 call    MUL10           ;[M80] MULTIPLY BY 10.0
163C : F1                       pop     af
163D : 3D         {M80} DCRART: dec     a               ;[M80] DECREASE IT
163E : C9                       ret                     ;[M80] ALL DONE
163F
163F                    ;[M80] HERE TO PACK THE NEXT DIGIT OF THE NUMBER INTO THE FAC
163F                    ;[M80] WE MULTIPLY THE FAC BY TEN AND ADD IN THE NEXT DIGIT
163F : D5         [M80] FINDIG: push    de              ;[M80] SAVE EXPONENT INFORMATION
1640 : 57                       ld      d,a             ;[M80] INCREMENT DECIMAL PLACE COUNT IF WE ARE
1641 : 78                       ld      a,b             ;[M80]  PAST THE DECIMAL POINT
1642 : 89                       adc     a,c             ;
1643 : 47                       ld      b,a             ;
1644 : C5                       push    bc              ;[M80] SAVE DECIMAL POINT INFORMATION
1645 : E5                       push    hl              ;[M80] SAVE TEXT POINTER
1646 : D5                       push    de              ;
1647 : CD D4 14                 call    MUL10           ;
164A : F1                       pop     af              ;[M80] GET THE DIGIT
164B : D6 30                    sub     '0'             ;[M80] CONVERT IT TO ASCII
164D : CD 56 16                 call    FINLOG          ;[M65] ADD IT IN
1650 : E1                       pop     hl              ;
1651 : C1                       pop     bc              ;
1652 : D1                       pop     de              ;
1653 : C3 F7 15                 jp      FINC            ;
1656
1656 : CD 13 15   [M65] FINLOG: call    PUSHF           ;[M65] SAVE FAC FOR LATER
1659 : CD F6 14                 call    FLOAT           ;[M65] FLOAT THE VALUE IN ACCA
165C : C1         [M80] FADDT:  pop     bc              ;[M80] GET ARG IN REGISTERS, ENTRY TO FADD IF
165D : D1                       pop     de              ;[M80]  ARGUMENT IS ON STACK.  JUMP TO FADD
165E : C3 61 12                 jp      FADD            ;[M80] ADD IT IN
1661                    
1661 : 7B         [M80] FINEDG: ld      a,e             ;EXPONENT DIGIT -- MULTIPLY EXPONENT BY 10
1662 : 07                       rlca                    ;FIRST BY 4
1663 : 07                       rlca
1664 : 83                       add     a,e             ;ADD 1 TO MAKE 5
1665 : 07                       rlca                    ;NOW DOUBLE TO GET 10
1666 : 86                       add     a,(hl)          ;ADD IT IN
1667 : D6 30                    sub     '0'             ;SUBTRACT OFF ASCII CODE
1669 : 5F                       ld      e,a             ;STORE EXPONENT
166A : C3 0E 16                 jp      FINEC
166D
166D                    ;[M80] FLOATING POINT OUTPUT ROUTINE
166D : E5         [M80] INPRT:  push    hl              ;[M80] ENTRY TO LINPRT
166E : 21 69 03                 ld      hl,INTXT        ;[M80] SAVE LINE NUMBER
1671 : CD 9D 0E                 call    STROUT          ;[M80] PRINT MESSAGE
1674 : E1                       pop     hl
1675                    
1675                  + ;[M80] PRINT THE 2 BYTE NUMBER IN H,L
1675                  | ;[M80] ALTERS ALL REGISTERS
1675 : 11 9C 0E   [M80] LINPRT: ld      de,STROUI       
1678 : D5                       push    de
1679 : EB                       ex      de,hl
167A : AF                       xor     a
167B : 06 98                    ld      b,$98
167D : CD FB 14                 call    FLOATR
1680
1680                  + ;[M80] FLOATING OUTPUT OF FAC
1680                  | ;[M80] ALTERS ALL REGISTERS
1680                  | ;[M80] THE ORIGINAL CONTENTS OF THE FAC IS LOST
1680                  | ;[M80] 
1680                  | ;[M80]        OUTPUT THE VALUE IN THE FAC ACCORDING TO THE FORMAT SPECIFICATIONS
1680                  | ;[M80]        IN A,B,C
1680                  | ;[M80]        ALL REGISTERS ARE ALTERED
1680                  | ;[M80]        THE ORIGINAL CONTENTS OF THE FAC IS LOST
1680                  | ;[M80] 
1680                  | ;[M80]        THE FORMAT IS SPECIFIED IN A, B AND C AS FOLLOWS:
1680                  | ;[M80]        THE BITS OF A MEAN THE FOLLOWING:
1680                  | ;[M80] BIT 7  0 MEANS FREE FORMAT OUTPUT, I.E. THE OTHER BITS OF A MUST BE ZERO,
1680                  | ;[M80]        TRAILING ZEROS ARE SUPPRESSED, A NUMBER IS PRINTED IN FIXED OR FLOATING
1680                  | ;[M80]        POINT NOTATION ACCORDING TO ITS MAGNITUDE, THE NUMBER IS LEFT
1680                  | ;[M80]        JUSTIFIED IN ITS FIELD, B AND C ARE IGNORED.
1680                  | ;[M80]        1 MEANS FIXED FORMAT OUTPUT, I.E. THE OTHER BITS OF A ARE CHECKED FOR
1680                  | ;[M80]        FORMATTING INFORMATION, THE NUMBER IS RIGHT JUSTIFIED IN ITS FIELD,
1680                  | ;[M80]        TRAILING ZEROS ARE NOT SUPPRESSED.  THIS IS USED FOR PRINT USING.
1680                  | ;[M80] BIT 6  1 MEANS GROUP THE DIGITS IN THE INTEGER PART OF THE NUMBER INTO GROUPS
1680                  | ;[M80]        OF THREE AND SEPARATE THE GROUPS BY COMMAS
1680                  | ;[M80]        0 MEANS DON'T PRINT THE NUMBER WITH COMMAS
1680                  | ;[M80] BIT 5  1 MEANS FILL THE LEADING SPACES IN THE FIELD WITH ASTERISKS ("*")
1680                  | ;[M80] BIT 4  1 MEANS OUTPUT THE NUMBER WITH A FLOATING DOLLAR SIGN ("$")
1680                  | ;[M80] BIT 3  1 MEANS PRINT THE SIGN OF A POSITIVE NUMBER AS A PLUS SIGN ("+")
1680                  | ;[M80]        INSTEAD OF A SPACE
1680                  | ;[M80] BIT 2  1 MEANS PRINT THE SIGN OF THE NUMBER AFTER THE NUMBER
1680                  | ;[M80] BIT 1  UNUSED
1680                  | ;[M80] BIT 0  1 MEANS PRINT THE NUMBER IN FLOATING POINT NOTATION I.E. "E NOTATION"
1680                  | ;[M80]        IF THIS BIT IS ON, THE COMMA SPECIFICATION (BIT 6) IS IGNORED.
1680                  | ;[M80]        0 MEANS PRINT THE NUMBER IN FIXED POINT NOTATION.  NUMBERS .GE. 1E16
1680                  | ;[M80]        CANNOT BE PRINTED IN FIXED POINT NOTATION.
1680                  | ;[M80] 
1680                  | ;[M80]        B AND C TELL HOW BIG THE FIELD IS:
1680                  | ;[M80] B   =  THE NUMBER OF PLACES IN THE FIELD TO THE LEFT OF THE DECIMAL POINT
1680                  | ;[M80]        (B DOES NOT INCLUDE THE DECIMAL POINT)
1680                  | ;[M80] C   =  THE NUMBER OF PLACES IN THE FIELD TO THE RIGHT OF THE DECIMAL POINT
1680                  | ;[M80]        (C INCLUDES THE DECIMAL POINT)
1680                  | ;[M80]        B AND C DO NOT INCLUDE THE 4 POSITIONS FOR THE EXPONENT IF BIT 0 IS ON
1680                  | ;[M80]        FOUT ASSUMES B+C .LE. 24 (DECIMAL)
1680                  | ;[M80]        IF THE NUMBER IS TOO BIG TO FIT IN THE FIELD, A PERCENT SIGN ("%") IS
1680                  | ;[M80]        PRINTED AND THE FIELD IS EXTENDED TO HOLD THE NUMBER.
1680                  | ;
1680 : 21 E9 38   [M80] FOUT:   ld      hl,FBUFFR+1     ;[M80] GET A POINTER INTO FBUFFR
1683 : E5                       push    hl              ;{M80} SAVE IT
1684 : EF                       rst     FSIGN
1685 : 36 20                    ld      (hl),' '        ;[M80] PUT A SPACE FOR POSITIVE NUMBERS IN THE BUFFER
1687 : F2 8C 16                 jp      p,FOUT2         ;[M80] IF WE HAVE A NEGATIVE NUMBER, NEGATE IT
168A : 36 2D                    ld      (hl),'-'        ;[M80]  AND PUT A MINUS SIGN IN THE BUFFER
168C : 23               FOUT2:  inc     hl              ;[M80] POINT TO WHERE THE NEXT CHARACTER GOES
168D : 36 30                    ld      (hl),'0'        ;[M80] PUT A ZERO IN THE BUFFER IN CASE THE NUMBER IS ZERO
168F : CA 42 17                 jp      z,FOUTZR        ;[M80] IF THE NUMBER IS ZERO, FINISH IT UP
1692 : E5                       push    hl              ;[M80] SAVE THE BUFFER POINTER
1693 : FC 0B 15                 call    m,NEG           ;[M80] NEGATE THE NUMBER
1696 : AF                       xor     a               ;[M80] ZERO THE EXPONENT              
1697 : F5                       push    af              ;[M80] SAVE IT
1698 : CD 48 17                 call    FOUNVC          ;[M80] IS THE FAC TOO BIG OR TOO SMALL?
169B : 01 43 91   [M80] FOUNV1: ld      bc,$9143        ;
169E : 11 F8 4F                 ld      de,$4FF8        ;[M80] GET 99999.95 TO SEE IF THE FAC IS BIG
16A1 : CD 5B 15                 call    FCOMP           ;[M80]  ENOUGH YET
16A4 : B7                       or      a               ;[M80] GO DO THE CHECK
16A5 : E2 B9 16   {M80} FOUNV5: jp      po,FOUTCS       ;[M80] IT ISN'T ANY MORE, WE ARE DONE 
16A8 : F1                       pop     af              ;[M80] IT IS, MULTIPLY BY TEN
16A9 : CD 38 16                 call    FINMLT          ;
16AC : F5                       push    af              ;[M80] SAVE THE EXPONENT AGAIN
16AD : C3 9B 16                 jp      FOUNV1          ;[M80] NOW SEE IF IT IS BIG ENOUGH
16B0 : CD 21 14   (M80) FOUNV2: call    DIV10           ;[M80] THE FAC IS TOO BIG, DIVIDE IT BY TEN
16B3 : F1                       pop     af              ;
16B4 : 3C                       inc     a               ;
16B5 : F5                       push    af              ;
16B6 : CD 48 17                 call    FOUNVC          ;[M80] SEE IF THE FAC IS SMALL ENOUGH
16B9 : CD 50 12   (M80) FOUTCS: call    FADDH           ;[M80] ROUND NUMBER TO NEAREST INTEGER
16BC : 3C                       inc     a               ;[M80] MAKE A NON-ZERO, SINCE NUMBER IS POSITIVE AND NON-ZERO
16BD : CD 86 15                 call    QINT            ;[M80] GET INTEGER PART IN C,D,E
16C0 : CD 23 15                 call    MOVFR           ;[M80] SAVE NUMBER IN FAC
16C3 : 01 06 03                 ld      bc,$0306        ;;[B] = 3, [C] = 6        
16C6 : F1                       pop     af              ;
16C7 : 81                       add     a,c             ;
16C8 : 3C                       inc     a               ;
16C9 : FA D5 16                 jp      m,FOUCDC        ;
16CC : FE 08                    cp      8               ;
16CE : D2 D5 16                 jp      nc,FOUCDC       ;
16D1 : 3C                       inc     a               ;
16D2 : 47                       ld      b,a             ;
16D3 : 3E 02                    ld      a,2             ;
16D5 : 3D         (M80) FOUCDC: dec     a               ;
16D6 : 3D                       dec     a               ;
16D7 : E1                       pop     hl              ;[M80] GET THE BUFFER POINTER BACK
16D8 : F5                       push    af              ;
16D9 : 11 5E 17                 ld      de,FOSTBL       ;
16DC : 05         {M80} FOUTAN: dec     b               ;
16DD : C2 E6 16                 jp      nz,FOUTED       ;
16E0 : 36 2E                    ld      (hl),'.'        ;[M80] PUT IN D.P.
16E2 : 23                       inc     hl              ;[M80] POINT TO NEXT BUFFER POSTION
16E3 : 36 30                    ld      (hl),'0'        ;
16E5 : 23                       inc     hl              ;
16E6 : 05         (M80) FOUTED: dec     b               ;[M80] ENTRY TO PUT A DECIMAL POINT IN THE BUFFER
16E7 : 36 2E      {M80} FOUTDP: ld      (hl),'.'        ;{M80} PUT THE DECIMAL POINT IN
16E9 : CC 38 15                 call    z,INXHRT        ;
16EC : C5         {M80} FOUTCV: push    bc              ;[M80[ SAVE THE DECIMAL POINT AND COMMA COUNTS
16ED : E5                       push    hl              ;[M80[ SAVE THE BUFFER POINTER
16EE : D5                       push    de              ;[M80[ SAVE (DE)
16EF : CD 2E 15                 call    MOVRF           ;{M80} GET NUMBER IN THE REGISTERS
16F2 : E1                       pop     hl              ;[M80] GET THE BUFFER POINTER BACK
16F3 : 06 2F      {M80} FOUCD1: ld      b,'0'-1         ;[M80] SET UP THE COUNT FOR THE DIGIT        
16F5 : 04         (M80) FOUCD2: inc     b               ;[M80] INCREMENT THE DIGIT COUNT
16F6 : 7B                       ld      a,e             ;{M80} SUBTRACT THE TWO NUMBERS
16F7 : 96                       sub     (hl)            ;;Subtract LO
16F8 : 5F                       ld      e,a             ;
16F9 : 23                       inc     hl              ;
16FA : 7A                       ld      a,d             ;
16FB : 9E                       sbc     a,(hl)          ;;Subtract MO
16FC : 57                       ld      d,a             ;
16FD : 23                       inc     hl              ;
16FE : 79                       ld      a,c             ;
16FF : 9E                       sbc     a,(hl)          ;;Subtract HO
1700 : 4F                       ld      c,a             ;
1701 : 2B                       dec     hl              ;
1702 : 2B                       dec     hl              ;;Backup Pointer
1703 : D2 F5 16                 jp      nc,FOUCD2       ;[M80] IF NOT LESS THAN THE POWER OF TEN, SUBTRACT AGAIN
1706 : CD 10 13                 call    FADDA           ;[M80] ADD THE TWO NUMBERS
1709 : 23                       inc     hl
170A : CD 23 15                 call    MOVFR           ;{M80} PUT REGISTERS IN THE FAC
170D : EB                       ex      de,hl           ;[M80] PUT THE POWER OF TEN POINTER IN (DE).
170E : E1                       pop     hl              ;[M80] GET THE BUFFER POINTER BACK
170F : 70                       ld      (hl),b          ;[M80] PUT THE DIGIT INTO THE BUFFER
1710 : 23                       inc     hl              ;[M80] INCREMENT THE BUFFER POINTER
1711 : C1                       pop     bc              ;[M80] GET THE DECIMAL POINT AND COMMA COUNTS
1712 : 0D                       dec     c               ;[M80] HAVE WE PRINTED THE LAST DIGIT?
1713 : C2 E6 16                 jp      nz,FOUTED       ;[M80] NO, GO DO THE NEXT ONE
1716 : 05                       dec     b               ;
1717 : CA 26 17                 jp      z,FOFLDN        ;
171A : 2B         (M80) FOFRS2: dec     hl              ;[M80] MOVE BACK TO THE LAST CHARACTER
171B : 7E                       ld      a,(hl)          ;[M80] GET IT AND SEE IF IT WAS ZERO
171C : FE 30                    cp      '0'             ;
171E : CA 1A 17                 jp      z,FOFRS2        ;[M80] IT WAS, CONTINUE SUPPRESSING
1721 : FE 2E                    cp      '.'             ;[M80] HAVE WE SUPPRESSED ALL THE FRACTIONAL DIGITS?
1723 : C4 38 15                 call    nz,INXHRT       ;[M80] YES, IGNORE THE DECIMAL POINT ALSO
1726 : F1         (M80) FOFLDN: pop     af              ;[M80] GET THE EXPONENT BACK
1727 : CA 45 17                 jp      z,FOUTDN        ;[M80] WE ARE DONE IF WE ARE IN FIXED POINT NOTATION
172A : 36 45                    ld      (hl),'E'        ;
172C : 23                       inc     hl              ;
172D : 36 2B                    ld      (hl),'+'        ;[M80] A PLUS IF POSITIVE
172F : F2 36 17                 jp      p,FOUCE1        ;
1732 : 36 2D                    ld      (hl),'-'        ;[M80] A MINUS IF NEGATIVE
1734 : 2F                       cpl                     ;[M80] NEGATE EXPONENT
1735 : 3C                       inc     a               ;
1736                    ;[M80] CALCULATE THE TWO DIGIT EXPONENT
1736 : 06 2F      (M80) FOUCE1: ld      b,'0'-1         ;[M80] INITIALIZE TEN'S DIGIT COUNT
1738 : 04         (M80) FOUCE2: inc     b               ;[M80] INCREMENT DIGIT
1739 : D6 0A                    sub     10              ;[M80] SUBTRACT TEN
173B : D2 38 17                 jp      nc,FOUCE2       ;[M80] DO IT AGAIN IF RESULT WAS POSITIVE
173E : C6 3A                    add     a,'0'+10        ;[M80] ADD BACK IN TEN AND CONVERT TO ASCII
1740 : 23                       inc     hl              ;[M80] PUT THE EXPONENT IN THE BUFFER
1741 : 70                       ld      (hl),b          ;[M80] PUT TEN'S DIGIT OF EXPONENT IN BUFFER
1742 : 23         (M80) FOUTZR: inc     hl              ;[M80] WHEN WE JUMP TO HERE, A IS ZERO
1743 : 77                       ld      (hl),a          ;[M80] PUT ONE'S DIGIT IN BUFFER
1744 : 23                       inc     hl              ;[M80] INCREMENT POINTER
1745                    ;HERE TO FINISH UP PRINTING A FREE FORMAT ZERO
1745 : 71         (M80) FOUTDN: ld      (hl),c          ;[M80] PUT A ZERO AT THE END OF THE NUMBER
1746 : E1                       pop     hl              ;
1747 : C9                       ret                     ;
1748                    
1748 : 01 74 94   [M80] FOUNVC: ld      bc,$9474        ;
174B : 11 F7 23                 ld      de,$23F7        ;[M80] GET 999999.5 TO SEE IF THE FAC IS TOO BIG
174E : CD 5B 15                 call    FCOMP           ;
1751 : B7                       or      a               ;
1752 : E1         {M80} FONVC2: pop     hl              ;
1753 : E2 B0 16                 jp      po,FOUNV2       ;[M80] GO DO THE CHECK
1756 : E9                       jp      (hl)            ;[M80] IT ISN'T TOO BIG, JUST RETURN
1757                    
1757 : 00 00 00 80      FHALF:  byte    $00,$00,$00,$80 ;[M65] 1/2
175B : 40                       ld      b,b
175C : 42                       ld      b,d
175D : 0F                       rrca
175E
175E                    ;[M80] SINGLE PRECISION POWER OF TEN TABLE
175E : A0 86 01   [M80] FOSTBL: byte    $A0,$86,$01     ;[M80] 1E5
1761 : 10 27 00                 byte    $10,$27,$00     ;[M80] 1E4
1764 : E8 03 00                 byte    $E8,$03,$00     ;[M80] 1000
1767 : 64 00 00                 byte    $64,$00,$00     ;[M80] 100
176A : 0A 00 00                 byte    $0A,$00,$00     ;[M80] 10
176E : 01 00 00                 byte    $01,$00,$00     ;[M80] 1
176E
1770                    ;[M80] SUBROUTINE FOR FPWR, ATN
1770 : 21 0B 15         PSHNEG: ld      hl,NEG          ;[M80] GET THE ADDRESS OF NEG
1773 : E3                       ex      (sp),hl         ;[M80] SWITCH RET ADDR AND ADDR OF NEG
1774 : E9                       jp      (hl)            ;[M80] RETURN, THE ADDRESS OF NEG IS ON THE STACK
1775
1775 :                  ;[M80] SQUARE ROOT FUNCTION: WE USE SQR(X)=X^.5
1775 : CD 13 15   [M80] SQR:    call    PUSHF           ;[M80] SAVE ARG X
1778 : 21 57 17                 ld      hl,FHALF        ;[M80] GET 1/2
177B : CD 20 15                 call    MOVFM           ;[M80] SQR(X)=X^.5
177E
177E : C1         [M80] FPWRT:  pop     bc              ;[M80] GET ARG IN REGISTERS, ENTRY TO FPWR IF
177F : D1                       pop     de              ;[M80]  ARGUMENT IS ON STACK.  FALL INTO FPWR
1780
1780                  + ;[M80] EXPONENTIATION    ---    X^Y
1780                  | ;[M80] N.B.  0^0=1
1780                  | ;[M80] FIRST WE CHECK IF Y=0, IF SO, THE RESULT IS 1.
1780                  | ;[M80] NEXT, WE CHECK IF X=0, IF SO, THE RESULT IS 0.
1780                  | ;[M80] THEN WE CHECK IF X IS POSITIVE, IF NOT, WE CHECK THAT Y IS A
1780                  | ;[M80] NEGATIVE INTEGER, AND WHETHER IT IS EVEN OR ODD.  IF Y IS A NEGATIVE
1780                  | ;[M80] INTEGER, WE NEGATE X.  IF NOT, LOG WILL GIVE AN FC ERROR WHEN WE CALL
1780                  | ;[M80] IT.  IF X IS NEGATIVE AND Y IS ODD, WE PUSH THE ADDRESS OF NEG ON THE
1780                  | ;[M80] STACK SO WE WILL RETURN TO IT AND GET A NEGATIVE RESULT.  TO COMPUTE
1780                  | ;[M80] THE RESULT WE USE X^Y=EXP(Y*LOG(X))
1780 : EF         [M80] FPWR:   rst     FSIGN           ;[M80] SEE IF Y IS ZERO
1781 : 78                       ld      a,b             ;[M80] SEE IF X IS ZERO
1782 : CA CD 17                 jp      z,EXP           ;[M80] IT IS, RESULT IS ONE
1785 : F2 8C 17                 jp      p,POSEXP        ;[M80] POSITIVE EXPONENT
1788 : B7                       or      a               ;[M80] IS IT ZERO TO MINUS POWER?
1789 : CA C7 03                 jp      z,DV0ERR        ;[M80] GIVE DIV BY ZERO AND CONTINUE
178C : B7         [M80] POSEXP: or      a               ;
178D : CA C4 12                 jp      z,ZERO0         ;[M80]IT IS, RESULT IS ZERO
1790 : D5                       push    de              ;[M80] SAVE X ON STACK
1791 : C5                       push    bc              ;
1792 : 79                       ld      a,c             ;[M80] CHECK THE SIGN OF X
1793 : F6 7F                    or      $7F             ;[M80] TURN THE ZERO FLAG OFF
1795 : CD 2E 15                 call    MOVRF           ;[M80] GET Y IN THE REGISTERS
1798 : F2 B5 17                 jp      p,FPWR1         ;[M80] NO PROBLEMS IF X IS POSITIVE
179B : F5                       push    af              ;
179C : 3A E7 38                 ld      a,(FAC)         ;
179F : FE 99                    cp      $99             ;
17A1 : 38 03                    jr      c,FPWRT1        ;
17A3 : F1                       pop     af              ;
17A4 : 18 0F                    jr      FPWR1           ;
17A6 : F1         (M65) FPWRT1: pop     af              ;
17A7 : D5                       push    de              ;
17A8 : C5                       push    bc              ;[M80] SAVE Y
17A9 : CD B1 15                 call    INT             ;[M80] SEE IF Y IS AN INTEGER
17AC : C1                       pop     bc              ;
17AD : D1                       pop     de              ;[M80] GET Y BACK
17AE : F5                       push    af              ;[M80] SAVE LO OF INT FOR EVEN AND ODD INFORMATION
17AF : CD 5B 15                 call    FCOMP           ;[M80] SEE IF WE HAVE AN INTEGER
17B2 : E1                       pop     hl              ;[M80] GET EVEN-ODD INFORMATION
17B3 : 7C                       ld      a,h             ;[M80] PUT EVEN-ODD FLAG IN CARRY
17B4 : 1F                       rra                     ;
17B5 : E1         (M80) FPWR1:  pop     hl              ;[M80] GET X BACK IN FAC
17B6 : 22 E6 38                 ld      (FACHO),hl      ;[M80] STORE HO'S
17B9 : E1                       pop     hl              ;[M80] GET LO'S OFF STACK
17BA : 22 E4 38                 ld      (FACLO),hl      ;[M80] STORE THEM IN FAC
17BD : DC 70 17                 call    c,PSHNEG        ;[M80] NEGATE NUMBER AT END IF Y WAS ODD
17C0 : CC 0B 15                 call    z,NEG           ;[M80] NEGATE THE NEGATIVE NUMBER
17C3 : D5                       push    de              ;[M80] SAVE Y AGAIN
17C4 : C5                       push    bc              ;
17C5 : CD 85 13                 call    LOG             ;[M80] COMPUTE  EXP(Y*LOG(X))
17C8 : C1                       pop     bc              ;
17C9 : D1                       pop     de              ;[M80] IF X WAS NEGATIVE AND Y NOT AN INTEGER THEN
17CA : CD CB 13                 call    FMULT           ;[M80]  LOG WILL BLOW HIM OUT OF THE WATER
17CD
17CD                  + ;[M80] THE FUNCTION EXP(X) CALCULATES e^X WHERE e=2.718282
17CD                  | ;[M80]        THE TECHNIQUE USED IS TO EMPLOY A COUPLE
17CD                  | ;[M80]        OF FUNDAMENTAL IDENTITIES THAT ALLOWS US TO
17CD                  | ;[M80]        USE THE BASE 2 THROUGH THE DIFFICULT PORTIONS OF
17CD                  | ;[M80]        THE CALCULATION:
17CD                  | ;[M80]
17CD                  | ;[M80]          (1)e^X=2^y  WHERE y=X*LOG2(e) [LOG2(e) IS
17CD                  | ;[M80]                                          LOG BASE 2
17CD                  | ;[M80]                                          OF e ]
17CD                  | ;[M80]          
17CD                  | ;[M80]          (2) 2^y=2^[ INT(y)+(y-INT(y)]
17CD                  | ;[M80]          (3) IF Ny=INT(y) THEN
17CD                  | ;[M80]              2^(Ny+y-Ny)=[2^Ny]*[2^(y-Ny)]
17CD                  | ;[M80]
17CD                  | ;[M80]        NOW, SINCE 2^Ny IS EASY TO COMPUTE (AN EXPONENT
17CD                  | ;[M80]        CALCULATION WITH MANTISSA BITS OF ZERO) THE DIFFICULT
17CD                  | ;[M80]        PORTION IS TO COMPUTE 2^(Y-Ny) WHERE 0.LE.(Y-Ny).LT.1
17CD                  | ;[M80]        THIS IS ACCOMPLISHED WITH A POLYNOMIAL APPROXIMATION
17CD                  | ;[M80]        TO 2^Z WHERE 0.LE.Z.LT.1  . ONCE THIS IS COMPUTED WE
17CD                  | ;[M80]        HAVE TO EFFECT THE MULTIPLY BY 2^Ny .
17CD : 01 38 81   [M80] EXP:    ld      bc,$8138        ;[M65] LOG(e) BASE 2
17D0 : 11 3B AA                 ld      de,$AA3B        ;[M80] GET LOG2(e)
17D3 : CD CB 13                 call    FMULT           ;[M80] y=FAC*LOG2(e)
17D6 : 3A E7 38                 ld      a,(FAC)         ;[M80] MUST SEE IF TOO LARGE
17D9 : FE 88                    cp      $88             ;[M80] ABS .GT. 128?
17DB : 30 22                    jr      nc,EXP100       ;[M80] IF SO OVERFLOW
17DD : FE 68                    cp      $68             ;[M80] IF TOO SMALL ANSWER IS 1
17DF : 38 30                    jr      c,EXP200        ;
17E1 : CD 13 15                 call    PUSHF           ;[M80] SAVE y
17E4 : CD B1 15                 call    INT             ;[M80] DETERMINE INTEGER POWER OF 2
17E7 : C6 81                    add     a,$81          ;[M80] INTEGER WAS RETURNED IN A, BIAS IS 201
17E9 : C1                       pop     bc              ;
17EA : D1                       pop     de              ;[M80] RECALL y
17EB : 28 15                    jr      z,EXP110        ;[M80] OVERFLOW
17ED : F5                       push    af              ;[M80] SAVE EXPONENT
17EE : CD 5E 12                 call    FSUB            ;[M80] FAC=y-INT(y)
17F1 : 21 1A 18                 ld      hl,EXPBCN       ;[M80] WILL USE HART 1302 POLY. EVAL NOW
17F4 : CD 46 18                 call    POLY            ;[M80] COMPUTE 2^[y-INT(y)]
17F7 : C1                       pop     bc              ;[M80] INTEGER POWER OF 2 EXPONENT
17F8 : 11 00 00                 ld      de,0            ;[M80] NOW HAVE FLOATING REPRESENTATION 
17FB : 4A                       ld      c,d             ;[M80] OF INT(y) IN (BCDE)
17FC : C3 CB 13                 jp      FMULT           ;[M80] MULTIPLY BY 2^[y-INT(y)] AND RETURN
17FD
17FF : CD 13 15   (M80) EXP100: call    PUSHF           ;[M80] IF NEG. THEN JUMP TO ZERO
1802 : 3A E6 38   (M80) EXP110: ld      a,(FACHO)       ;
1805 : B7                       or      a               ;[M80] OVERFLOW IF PLUS
1806 : F2 0E 18                 jp      p,EXP115        ;[M80] NEED STACK RIGHT
1809 : F1                       pop     af              ;
180A : F1                       pop     af              ;
180B : C3 C3 12                 jp      ZERO            ;[M80] GO ZERO THE FAC
180E : C3 D3 03   (M80) EXP115: jp      OVERR           ;[M80] OVERFLOW
1811 : 01 00 81   (M80) EXP200: ld      bc,$8100        ;
1814 : 11 00 00                 ld      de,$0000        ;1.
1817 : C3 23 15                 jp      MOVFR           ;
181A
181A              [M80] ;*************************************************************
181A              [M80] ;       Hart 1302 polynomial coefficients
181A              [M80] ;*************************************************************
181A : 07         [M80] EXPBCN  byte    7               ;[M80] DEGREE + 1
181B : 7C 88 59 74              byte    $7C,$88,$59,$74 ;[M80] .00020745577403-
181F : E0 97 26 77              byte    $E0,$97,$26,$77 ;[M80] .00127100574569-
1823 : C4 1D 1E 7A              byte    $C4,$1D,$1E,$7A ;[M80] .00965065093202+
1827 : 5E 50 63 7C              byte    $5E,$50,$63,$7C ;[M80] .05549656508324+
182B : 1A FE 75 7E              byte    $1A,$FE,$75,$7E ;[M80] .24022713817633-
182F : 18 72 31 80              byte    $18,$72,$31,$80 ;[M80] .69314717213716+
1833 : 00 00 00 81              byte    $00,$00,$00,$81 ;[M80] 1.0
1837                    
1837                 +  ;[M80] POLYNOMIAL EVALUATOR AND THE RANDOM NUMBER GENERATOR
1837                 |  ;[M80] EVALUATE P(X^2)*X
1837                 |  ;[M80] POINTER TO DEGREE+1 IS IN (HL)
1837                 |  ;[M80] THE CONSTANTS FOLLOW THE DEGREE
1837                 |  ;[M80] CONSTANTS SHOULD BE STORED IN REVERSE ORDER, FAC HAS X
1837                 |  ;[M80] WE COMPUTE:
1837                 |  ;[M80]  C0*X+C1*X^3+C2*X^5+C3*X^7+...+C(N)*X^(2*N+1)
1837                    
1837 : CD 13 15   [M80] POLYX:  call    PUSHF           ;SAVE X
183A : 11 C9 13                 ld      de,013C9H       ;PUT ADDRESS OF FMULTT ON STACK SO WHEN WE
183D : D5                       push    de              ; RETURN WE WILL MULTIPLY BY X
183E : E5         {M80} POLYX2: push    hl              ;SAVE CONSTANT POINTER
183F : CD 2E 15                 call    MOVRF           ;SQUARE X
1842 : CD CB 13                 call    FMULT           ;
1845 : E1                       pop     hl              ;GET CONSTANT POINTER
1846                   
1846                  + ;[M80] POLYNOMIAL EVALUATOR
1846                  | ;[M80] POINTER TO DEGREE+1 IS IN (HL), IT IS UPDATED
1846                  | ;[M80] THE CONSTANTS FOLLOW THE DEGREE
1846                  | ;[M80] CONSTANTS SHOULD BE STORED IN REVERSE ORDER, FAC HAS X
1846                  | ;[M80] WE COMPUTE:
1846                  | ;[M80]  C0+C1*X+C2*X^2+C3*X^3+...+C(N-1)*X^(N-1)+C(N)*X^N
1846 : CD 13 15   [M80] POLY:   call    PUSHF           ;[M80] SAVE X
1849 : 7E                       ld      a,(hl)          ;[M80] GET DEGREE
184A : 23                       inc     hl              ;[M80] INCREMENT POINTER TO FIRST CONSTANT
184B : CD 20 15                 call    MOVFM           ;[M80] MOVE FIRST CONSTANT TO FAC
184E : 06                       byte    $06             ;[M80] "MVI	B" OVER NEXT BYTE
184F : F1         (M80) POLY1:  pop     af              ;[M80] GET DEGREE
1850 : C1                       pop     bc              ;
1851 : D1                       pop     de              ;[M80] GET X
1852 : 3D                       dec     a               ;[M80] ARE WE DONE?
1853 : C8                       ret     z               ;[M80] YES, RETURN
1854 : D5                       push    de              ;
1855 : C5                       push    bc              ;[M80] NO, SAVE X
1856 : F5                       push    af              ;[M80] SAVE DEGREE
1857 : E5                       push    hl              ;[M80] SAVE CONSTANT POINTER
1858 : CD CB 13                 call    FMULT           ;[M80] EVALUATE THE POLY, MULTIPLY BY X
185B : E1                       pop     hl              ;[M80] GET LOCATION OF CONSTANTS
185C : CD 31 15                 call    MOVRM           ;[M80] GET CONSTANT
185F : E5                       push    hl              ;[M80] STORE LOCATION OF CONSTANTS SO FADD AND FMULT
1860 : CD 61 12                 call    FADD            ;[M80]  WILL NOT SCREW THEM UP, ADD IN CONSTANT
1863 : E1                       pop     hl              ;[M80] MOVE CONSTANT POINTER TO NEXT CONSTANT
1864 : 18 E9                    jr      POLY1           ;[M80] SEE IF DONE
1866
1866                  | ;[M80] PSUEDO-RANDOM NUMBER GENERATOR
1866                  | ;[M80] IF ARG=0, THE LAST RANDOM NUMBER GENERATED IS RETURNED
1866                  | ;[M80] IF ARG .LT. 0, A NEW SEQUENCE OF RANDOM NUMBERS IS STARTED
1866                  | ;[M80]  USING THE ARGUMENT
1866                  | ;[M80] TO FORM THE NEXT RANDOM NUMBER IN THE SEQUENCE, WE MULTIPLY THE
1866                  | ;[M80] PREVIOUS RANDOM NUMBER BY A RANDOM CONSTANT, AND ADD IN ANOTHER
1866                  | ;[M80] RANDOM CONSTANT.  THEN THE HO AND LO BYTES ARE SWITCHED, THE
1866                  | ;[M80] EXPONENT IS PUT WHERE IT WILL BE SHIFTED IN BY NORMAL, AND THE
1866                  | ;[M80] EXPONENT IN THE FAC SET TO 200 SO THE RESULT WILL BE LESS THAN 1.
1866                  | ;[M80] THIS IS THEN NORMALIZED AND SAVED FOR THE NEXT TIME.
1866                  | ;[M80] THE HO AND LO BYTES WERE SWITCHED SO WE HAVE A RANDOM CHANCE OF
1866                  | ;[M80] GETTING A NUMBER LESS THAN OR GREATER THAN .5
1866                  | ;
1866 : EF         [M80] RND:    rst     FSIGN           ;[M80] GET SIGN OF ARG
1867 : 21 20 38                 ld      hl,RNDCNT+1         ;
186A : FA C4 18                 jp      m,RNDSTR        ;[M80] START NEW SEQUENCE IF NEGATIVE
186D : 21 41 38                 ld      hl,RNDX         ;[M80] GET LAST NUMBER GENERATED
1870 : CD 20 15                 call    MOVFM           ;
1873 : 21 20 38                 ld      hl,RNDCNT+1         ;
1876 : C8                       ret     z               ;[M80] RETURN LAST NUMBER GENERATED IF ZERO
1877 : 86                       add     a,(hl)          ;[M80] GET COUNTER INTO CONSTANTS AND ADD ONE
1878 : E6 07                    and     7               ;
187A : 06 00                    ld      b,0             ;
187C : 77                       ld      (hl),a          ;
187D : 23                       inc     hl              ;
187E : 87                       add     a,a             ;
187F : 87                       add     a,a             ;
1880 : 4F                       ld      c,a             ;
1881 : 09                       add     hl,bc           ;
1882 : CD 31 15                 call    MOVRM           ;
1885 : CD CB 13                 call    FMULT           ;
1888 : 3A 1F 38                 ld      a,(RNDCNT)      ;
188B : 3C                       inc     a               ;
188C : E6 03                    and     3               ;
188E : 06 00                    ld      b,0             ;
1890 : FE 01                    cp      1               ;
1892 : 88                       adc     a,b             ;
1893 : 32 1F 38                 ld      (RNDCNT),a      ;
1896 : 21 C7 18                 ld      hl,RNDTB2-4     ;
1899 : 87                       add     a,a             ;
189A : 87                       add     a,a             ;
189B : 4F                       ld      c,a             ;
189C : 09                       add     hl,bc           ;
189D : CD 53 12                 call    FADDS           ;
18A0 : CD 2E 15   [M80] RND1:   call    MOVRF           ;[M80] SWITCH HO AND LO BYTES,
18A3 : 7B                       ld      a,e             ;[M80] GET LO
18A4 : 59                       ld      e,c             ;[M80] PUT HO IN LO BYTE
18A5 : EE 4F                    xor     $4F             ;
18A7 : 4F                       ld      c,a             ;[M80] PUT LO IN HO BYTE
18A8 : 36 80                    ld      (hl),128        ;[M80] MAKE RESULT POSITIVE
18AA : 2B                       dec     hl              ;[M80] GET POINTER TO EXPONENT
18AB : 46                       ld      b,(hl)          ;[M80] PUT EXPONENT IN OVERFLOW POSITION
18AC : 36 80                    ld      (hl),128        ;[M80] SET EXP SO RESULT WILL BE BETWEEN 0 AND 1
18AE : 21 1E 38                 ld      hl,RNDCNT-1     ;
18B1 : 34                       inc     (hl)            ;[M80] INCREMENT THE PERTUBATION COUNT
18B2 : 7E                       ld      a,(hl)          ;[M80] SEE IF ITS TIME
18B3 : D6 AB                    sub     $AB             ;
18B5 : 20 04                    jr      nz,NTPTRB       ;
18B7 : 77                       ld      (hl),a          ;[M80] ZERO THE COUNTER
18B8 : 0C                       inc     c               ;
18B9 : 15                       dec     d               ;
18BA : 1C                       inc     e               ;
18BB : CD B0 12   (M80) NTPTRB: call    NORMAL          ;[M80] NORMALIZE THE RESULT
18BE : 21 41 38                 ld      hl,RNDX         ;[M80] SAVE RANDOM NUMBER GENERATED FOR NEXT
18C1 : C3 3A 15                 jp      MOVMF           ;[M80]  TIME
18C4 : 77         (M80) RNDSTR: ld      (hl),a          ;[M80] ZERO THE COUNTERS
18C5 : 2B                       dec     hl              ;
18C6 : 77                       ld      (hl),a          ;
18C7 : 2B                       dec     hl              ;
18C8 : 77                       ld      (hl),a          ;
18C9 : 18 D5                    jr      RND1            ;
18CB
18CB : 68 B1 46 68[M80] RNDTB2: byte    $68,$B1,$46,$68
18CF : 99 E9 92 69              byte    $99,$E9,$92,$69
18D3 : 10 D1 75 68              byte    $10,$D1,$75,$68
18D7
18D7                  + ;[M80] COSINE FUNCTION
18D7                  | ;[M80] IDEA: USE COS(X)=SIN(X+PI/2)
18D7 : 21 53 19   [M80] COS:    ld      hl,PI2          ;[M80] ADD PI/2 TO FAC
18DA : CD 53 12                 call    FADDS           ;
18DD
18DD                  + ;[M80] SINE FUNCTION
18DD                  | ;[M80] IDEA: USE IDENTITIES TO GET FAC IN QUADRANTS I OR IV
18DD                  | ;[M80] THE FAC IS DIVIDED BY 2*PI AND THE INTEGER PART IS IGNORED BECAUSE
18DD                  | ;[M80] SIN(X+2*PI)=SIN(X).  THEN THE ARGUMENT CAN BE COMPARED WITH PI/2 BY
18DD                  | ;[M80] COMPARING THE RESULT OF THE DIVISION WITH PI/2/(2*PI)=1/4.
18DD                  | ;[M80] IDENTITIES ARE THEN USED TO GET THE RESULT IN QUADRANTS I OR IV.
18DD                  | ;[M80] AN APPROXIMATION POLYNOMIAL IS THEN USED TO COMPUTE SIN(X).
18DD : 3A E7 38   [M80] SIN:    ld      a,(FAC)         ;[M80] WILL SEE IF .LT.2^-10
18E0 : FE 77                    cp      $77             ;[M80] AND IF SO SIN(X)=X
18E2 : D8                       ret     c               ;
18E3 : 3A E6 38                 ld      a,(FACHO)       ;
18E6 : B7                       or      a               ;
18E7 : F2 F3 18                 jp      p,SIN1          ;[M65] FIRST QUADRANT
18EA : E6 7F                    and     07FH            ;
18EC : 32 E6 38                 ld      (FACHO),a       ;
18EF : 11 0B 15                 ld      de,NEG          ;;Return to NEG
18F2 : D5                       push    de              ;
18F3 : 01 22 7E   [M65] SIN1:   ld      bc,$7E22        ;
18F6 : 11 83 F9                 ld      de,$F983        ;[M80] WILL CALCULATE X=FAC/(2*PI)
18F9 : CD CB 13                 call    FMULT           ;
18FC : CD 13 15                 call    PUSHF           ;[M80] SAVE X
18FF : CD B1 15                 call    INT             ;[M80] FAC=INT(X)
1902 : C1                       pop     bc              ;
1903 : D1                       pop     de              ;[M80] FETCH X TO REGISTERS
1904 : CD 5E 12                 call    FSUB            ;[M80] FAC=X-INT(X)
1907 : 01 00 7F                 ld      bc,$7F00        ;
190A : 11 00 00                 ld      de,$0000        ;[M80] GET 1/4
190D : CD 5B 15                 call    FCOMP           ;[M80] FAC=FAC-1/4
1910 : FA 35 19                 jp      m,SIN2A         ;
1913 : 01 80 7F                 ld      bc,$7F80        ;
1916 : 11 00 00                 ld      de,$0000        ;[M80] -1/4
1919 : CD 61 12                 call    FADD            ;
191C : 01 80 80                 ld      bc,$8080        ;[M80] -1/2
191F : 11 00 00                 ld      de,$0000        ;
1922 : CD 61 12                 call    FADD            ;[M80] X=X-1/2
1925 : EF                       rst     FSIGN           ;[M80] MAKE SURE IF QUADRANTS II,IV
1926 : F4 0B 15                 call    p,NEG           ;[M80] WE WORK WITH 1/4-X
1929 : 01 00 7F                 ld      bc,$7F00        ;
192C : 11 00 00                 ld      de,$0000        ;[M80] 1/4
192F : CD 61 12                 call    FADD            ;
1932 : CD 0B 15                 call    NEG             ;
1935 : 3A E6 38   [M80] SIN2A:  ld      a,(FACHO)       ;[M80] MUST REDUCE TO [0,1/4]
1938 : B7                       or      a               ;[M80] SIGN IN PSW
1939 : F5                       push    af              ;[M80] SAVE FOR POSSIBLE NEG. AFTER CALC
193A : F2 42 19                 jp      p,SIN3          ;
193D : EE 80                    xor     $80             ;
193F : 32 E6 38                 ld      (FACHO),a       ;[M80] NOW IN [0,1/4]
1942 : 21 5B 19   [M80] SIN3:   ld      hl,SINCON       ;[M80] POINT TO HART COEFFICIENTS
1945 : CD 37 18                 call    POLYX           ;[M80] DO POLY EVAL
1948 : F1                       pop     af              ;[M80] NOW TO DO SIGN
1949 : F0                       ret     p               ;[M80] OK IF POS
194A : 3A E6 38                 ld      a,(FACHO)       ;[M80] FETCH SIGN BYTE
194D : EE 80                    xor     080H            ;[M80] MAKE NEG
194F : 32 E6 38                 ld      (FACHO),a       ;[M80] REPLACE SIGN
1952 : C9                       ret
1953                        
1953 : DB 0F 49 81[M80] PI2:    byte    $DB,$0F,$49,$81 ;[M80] PI/2
1957 : 00 00 00 7F{M80} FR4:    byte    $00,$00,$00,$7F ;[M80] 1/4
195B
195B                  + ;[M80] HART ALGORITHM 3341 CONSTANTS
195B                  | ;[M80] NOTE THAT HART CONSTANTS HAVE BEEN SCALED BY A POWER OF 2
195B                  | ;[M80] THIS IS DUE TO RANGE REDUCTION AS A % OF 2*PI RATHER THAN PI/2
195B                  | ;[M80] WOULD NEED TO MULTIPLY ARGUMENT BY 4 BUT INSTEAD WE FACTOR THIS
195B                  | ;[M80] THRU THE CONSTANTS.
195B : 05               SINCON: byte    5               ;[M80] DEGREE
195C : FB D7 1E 86              byte    $FB,$D7,$1E,$86 ;[M80] .1514851E-3
1960 : 65 26 99 87              byte    $65,$26,$99,$87 ;[M80] -.4673767E-2
1964 : 58 34 23 87              byte    $58,$34,$23,$87 ;[M80] .7968968E-1
1968 : E1 5D A5 86              byte    $E1,$5D,$A5,$86 ;[M80] -.6459637
196C : DB 0F 49 83              byte    $DB,$0F,$49,$83 ;[M80] 1.570796
1970
1970                  + ;[M80] TANGENT FUNCTION
1970                  | ;[M80] TAN(X)=SIN(X)/COS(X)
1970 : CD 13 15   [M80] TAN:    call    PUSHF           ;[M80] SAVE ARG
1973 : CD DD 18                 call    SIN             ;[M80]    TAN(X)=SIN(X)/COS(X)
1976 : C1                       pop     bc              ;[M80] GET X OFF STACK
1977 : E1                       pop     hl              ;[M80] PUSHF SMASHES (DE)
1978 : CD 13 15                 call    PUSHF           ;
197B : EB                       ex      de,hl           ;[M80] GET LO'S WHERE THEY BELONG
197C : CD 23 15                 call    MOVFR           ;
197F : CD D7 18                 call    COS             ;
1982 : C3 2D 14                 jp      FDIVT           ;
1985
1985                  + ;ARCTANGENT FUNCTION
1985                  | ;;Not Implemented
1985 : F7         [M80] ATN:    rst     HOOKDO          ;;execute hook routine 15 (ATN)
1986 : 0E         {~~~} HOOK14: byte    14              ;;if not implemented
1988 : C3 C4 03                 jp      SNERR           ;;  generate SYNTAX error
198A
198A                    ;;RST OUTCHR jumps here
198A : F7         [M80] OUTDO:  rst     HOOKDO          ;;execute hook routine 13 (OUTDOX)
198B : 0D         {~~~} HOOK13: byte    13              ;
198C : F5         {M80} OUTCON: push    af              ;
198D : 3A 47 38   {M80} LPTCOD: ld      a,(PRTFLG)      ;[M80] SEE IF WE WANT TO TALK TO LPT
1990 : B7                       or      a               ;[M80] TEST BITS
1991 : CA D6 19                 jp      z,TTYPOP        ;[M80] IF ZERO THEN NOT
1994                    ;;Print character in [A] to printer
1994 : F1                       pop     af              ;
1995 : F5                       push    af              ;
1996 : FE 09                    cp      9               ;[M80] TAB
1998 : 20 0C                    jr      nz,NOTABL       ;[M80] NO
199A                    ;; Print spaces until next Tab Stop is reached
199A : 3E 20      (M80) MORSPL: ld      a,' '           ;[M80] GET SPACE
199C : DF                       rst     OUTCHR          ;[M80] SEND IT
199D : 3A 46 38                 ld      a,(LPTPOS)      ;[M80] GET CURRENT PRINT POSIT
19A0 : E6 07                    and     7               ;[M80] AT TAB STOP?
19A2 : 20 F6                    jr      nz,MORSPL       ;[M80] GO BACK IF MORE TO PRINT
19A4 : F1                       pop     af              ;[M80] POP OFF CHAR
19A5 : C9                       ret                     ;[M80] RETURN
19A6
19A6 : F1         (M80) NOTABL: pop     af              ;[M80] GET CHAR BACK
19A7 : F5                       push    af              ;[M80] SAVE AGAIN
19A8 : D6 0D                    sub     13              ;[M80] IF FUNNY CONTROL CHAR, (LF) DO NOTHING
19AA : 28 0B                    jr      z,ZERLP1        ;
19AC : 38 0C                    jr      c,LPTPOP        ;[M80] JUST PRINT CHAR
19AE : 3A 46 38                 ld      a,(LPTPOS)      ;[M80] GET POSIT
19B1 : 3C                       inc     a               ;
19B2 : FE 84                    cp      132             ;
19B4 : CC C7 19                 call    z,PRINTW        ;
19B7 : 32 46 38   (M80) ZERLP1: ld      (LPTPOS),a      ;;Save print pos
19BA : F1         (~~~) LPTPOP: pop     af              ;;Print character on stack
19BB : C3 E8 1A   (M80) LPTCHR: jp      LPTOUT          ;; Print raw character to printer

19BE : AF         [M80] FINLPT: xor     a               ;[M80] RESET PRINT FLAG SO
19BF : 32 47 38                 ld      (PRTFLG),a      ;[M80] OUTPUT GOES TO TERMINAL
19C2 : 3A 46 38                 ld      a,(LPTPOS)      ;[M80] GET CURRENT LPT POSIT
19C5 : B7                       or      a               ;[M80] ON LEFT HAND MARGIN ALREADY?
19C6 : C8                       ret     z               ;[M80] YES, RETURN
19C7
19C7 : 3E 0D      (M80) PRINTW: ld      a,13            ;[M80] PUT OUT CRLF
19C9 : CD BB 19                 call    LPTCHR          ;
19CC : 3E 0A                    ld      a,10            ;
19CE : CD BB 19                 call    LPTCHR          ;
19D1 : AF                       xor     a               ;[M80] ZERO LPTPOS
19D2 : 32 46 38                 ld      (LPTPOS),a      ;
19D5 : C9                       ret                     ;[M80] DONE
19D6
19D6 : F1         [M80] TTYPOP: pop     af              ;Print character on stack to screen
19D7 : C3 72 1D                 jp      TTYCHR          ;
19DA
19DA                    ;[M80] INCHR, TRYIN - CHARACTER INPUT ROUTINES
19DA : CD 2F 1A   [M80] INCHR:  call    CQINCH          ;;Get Character from Keyboard
19DD : C9                       ret                     ;
19DE
19DE                  + ; CRDONZ Only does a CR if TTYPOS is not Zero.
19DE                  | ; In other words, only print a carriage return when not at left margin.
19DE : 3A 00 38   [M80] CRDONZ: ld      a,(TTYPOS)      ;GET CURRENT TTYPOS
19E1 : B7                       or      a               ;SET CC'S
19E2 : C8                       ret     z               ;IF ALREADY ZERO, RETURN
19E3 : 18 05                    jr      CRDO            ;DO CR
19E5 : 36 00      [M80] FININL: ld      (hl),0          ;PUT A ZERO AT THE END OF BUF
19E7 : 21 5F 38                 ld      hl,BUFMIN       ;SETUP POINTER
19EA : 3E 0D      [M80] CRDO:   ld      a,13            ;
19EC : DF                       rst     OUTCHR          ;
19ED : 3E 0A                    ld      a,10            ;
19EF : DF         {M80} CRFINO: rst     OUTCHR          ;
19F0 : 3A 47 38   [M80] CRFIN:  ld      a,(PRTFLG)      ;[M80] SEE IF OUTPUTTING TO PRINTER
19F3 : B7                       or      a               ;
19F4 : 28 04                    jr      z,CRCONT        ;[M80] NOT PRINTER, CONTINUE
19F6 : AF                       xor     a               ;[M80] CRFIN MUST ALWAYS RETURN WITH A=0
19F7 : 32 46 38                 ld      (LPTPOS),a      ;;Set Print Head position to 0
19FA : C9         (M80) CRCONT: ret                     ;
19FB
19FB                    ;;The INKEY$ function
19FB : D7         [M80] INKEY:  rst     CHRGET          ;
19FC : E5                       push    hl              ;[M80] SAVE THE TEXT POINTER
19FD : CD 18 1A                 call    CHARCG          ;[M80] GET CHARC AND CLEAR IF SET
1A00 : 28 09                    jr      z,NULRT         ;{M80} NO CHAR, RETURN NULL STRING
1A02 : F5         {M80} BUFCIN: push    af              ;
1A03 : CD 4E 0E                 call    STRIN1          ;[M80] MAKE ONE CHAR STRING
1A06 : F1                       pop     af              ;
1A07 : 5F                       ld      e,a             ;[M80] CHAR TO [D]
1A08 : CD 19 10                 call    SETSTR          ;[M80] STUFF IN DESCRIPTOR AND GOTO PUTNEW
1A0B : 21 6D 03   (M80) NULRT:  ld      hl,REDDY-1      ;
1A0E : 22 E4 38                 ld      (FACLO),hl      ;
1A11 : 3E 01                    ld      a,1             ;
1A13 : 32 AB 38                 ld      (VALTYP),a      ;;Set Type to String
1A16 : E1                       pop     hl              ;
1A17 : C9                       ret                     ;
1A18                    
1A18 : E5         [M80] CHARCG: push    hl              ;
1A19 : 21 0A 38                 ld      hl,CHARC        ;
1A1C : 7E                       ld      a,(hl)          ;[M80] GET SAVED CHAR
1A1D : 36 00                    ld      (hl),0          ;[M80] CLEAR IT
1A1F : B7                       or      a               ;[M80] IS THERE ONE?
1A20 : CC 39 1A                 call    z,CNTCCN        ;{M80} SEE IF ITS CONTROL-C          
1A23 : E1                       pop     hl              ;
1A24 : C9                       ret                     ; 
1A25                    
1A25 : CD 39 1A   [M80] ISCNTC: call    CNTCCN          ;{M80} SEE IF ITS CONTROL-C          
1A28 : C8                       ret     z               ;[M80] IF NONE, RETURN
1A29 : 32 0A 38                 ld      (CHARC),a       ;{M80} SAVE CHAR
1A2C : FE 13                    cp      $13             ;[M80] PAUSE? (^S)
1A2E : C0                       ret     nz              ;{M80} IF PAUSE, READ NEXT CHAR
1A2F
1A2F : AF         [M65] CQINCH: xor     a               ;
1A30 : 32 0A 38                 ld      (CHARC),a       ;{M80} CLEAR SAVED CHAR
1A33 : CD 39 1A   (~~~) CQINC1: call    CNTCCN          ;
1A36 : 28 FB                    jr      z,CQINC1        ;
1A38 : C9                       ret                     ;
1A39
1A39 : CD 7E 1E   (~~~) CNTCCN: call    INCHRH          ;{M80} READ THE CHARACTER THAT WAS PRESSED
1A3C : FE 03                    cp      3               ;[M80] ^C?
1A3E : 20 0A                    jr      nz,CNTCCR       ;;No, set flags and return
1A40 : 3A 5E 38         WRMCON: ld      a,(CLFLAG)       ;Get CLOAD Status
1A43 : B7                       or      a               ;;Is it 0?
1A44 : CC BE 0B                 call    z,SCRTCH        ;;Bad CLOAD, do a NEW
1A47 : C3 CE 1F                 jp      WRMFIN          ;;Finish Warm Start
1A4A : B7         (~~~) CNTCCR: or      a               ;;Set flags
1A4B : C9                       ret                     ;
1A4C
1A4C : AF               PRESET: xor     a               ;[EUB] PRESET FLAG
1A4D : 18 02                    jr      PPRSET          ;
1A4F : 3E 01            PSET:   ld      a,1             ;[EUB] PSET FLAG
1A51 : 08               PPRSET: ex      af,af'          ;;Save PSET/PRESET flag
1A52 : CD 7F 1A                 call    SCAND           ;;Parse (X,Y)
1A55 : CD 8E 1A         PPRSDO: call    SCALXY          ;;Convert X,Y
1A58 : 28 02                    jr      z,RSET          ;;Semigraphics at screen location?
1A5A : 36 A0                    ld      (hl),$A0        ;;No, store base semigraphic
1A5C : 08         (~~~) RSETC:  ex      af,af'          ;;Restore PSET/PRESET flag 
1A5D : B7                       or      a               ;;Set flags
1A5E : 1A                       ld      a,(de)          ;;Get semigraphic offset
1A5F : 20 03                    jr      nz,PSETC        ;;PRESET?
1A61 : 2F                       cpl                     ;;Invert to create mask
1A62 : A6                       and     (hl)            ;;and clear offset bit
1A63 : 06                       byte    $06             ;;"LD B," around next instruction
1A64 : B6         (~~~) PSETC:  or      (hl)            ;;If PRESET, set offset bit
1A65 : 77                       ld      (hl),a          ;;Store at screen location
1A66 : E1                       pop     hl              ;;Restore text pointer
1A67 : C9                       ret                     ;
1A68
1A68                    ;;The PPOINT function
1A68 : D7               POINT:  rst     CHRGET          ;;Eat character
1A69 : CD 7F 1A                 call    SCAND           ;;Parse (X,Y)
1A6C : CD 8E 1A                 call    SCALXY          ;;Convert X,Y
1A6F : 20 06                    jr      nz,POINTZ       ;;Not semigraphics? Return 0
1A71 : 1A                       ld      a,(de)          ;;Get bit offset
1A72 : A6                       and     (hl)            ;;Mask with screen character
1A73 : 16 01                    ld      d,1             ;
1A75 : 20 02                    jr      nz,POINTR       ;;Bit set? Return 1
1A77 : 16 00            POINTZ: ld      d,0             ;
1A79 : AF               POINTR: xor     a               ;;Clear Accumulator 
1A7A : CD 23 0B                 call    FLOATD           ;
1A7D : E1                       pop     hl              ;;Restore text pointer
1A7E : C9                       ret                     ;
1A7F
1A7F                    ;;Get parameters for PSET, PRESET, POINT, and SOUND
1A7F                    ;;Scans program text in the format (x-ooord,y-coord)
1A7F                    ;;Returns x-ooord in BC, y-coord in DE
1A7F : CF         [GWB] SCAND:  rst     SYNCHK
1A80 : 28                       byte    '('             ;[GWB] SKIP OVER OPEN PAREN
1A81 : CD D0 1A                 call    GETINT          ;[GWB] SCAN X INTO [D,E]
1A84 : D5                       push    de              ;[GWB] SAVE WHILE SCANNING Y
1A85 : CF                       rst     SYNCHK          ;
1A86 : 2C                       byte    ','             ;[GWB] SCAN COMMA
1A87 : CD D0 1A                 call    GETINT          ;[GWB] GET Y INTO [D,E]
1A8A : CF                       rst     SYNCHK          ;
1A8B : 29                       byte    ')'             ;{GWB} SKIP OVER CLOSE PAREN
1A8C : C1                       pop     bc              ;[GWB] GET BACK X INTO [B,C]
1A8D : C9                       ret                     ;
1A8E
1A8E                  + ;;Convert PSET Coordinates to Screen Position and Character Mask
1A8E                  | ;;On entry: BC = X-Coordinate 
1A8E                  | ;;          DE = Y-Coordinate
1A8E                  | ;;If BC > 71 or DE > 79, generates an FC error
1A8E                  | ;;On exit: A = Masked Character at Screen Offset
1A8E                  | ;;        DE = Address of Character Offset
1A8E                  | ;;        HL = Offset into Screen
1A8E : E3         [GWB] SCALXY: ex      (sp),hl         ;;Save Registers
1A8F : E5                       push    hl
1A90 : C5                       push    bc              ;;BC=X Coordinate
1A91 : D5                       push    de              ;;DE=Y Coordinate
1A92 : 21 47 00                 ld      hl,71           
1A95 : E7                       rst     COMPAR          ;;If Y greater than 71
1A96 : DA 97 06   (~~~) FCERRP: jp      c,FCERR         ;;Function Call error
1A99 : 21 4F 00                 ld      hl,79
1A9C : C5                       push    bc
1A9D : D1                       pop     de              
1A9E : E7                       rst     COMPAR          ;;If X greater than 79
1A9F : 38 F5                    jr      c,FCERRP        ;;Function Call error
1AA1 : D1                       pop     de              
1AA2 : C1                       pop     bc
1AA3 : 21 28 30                 ld      hl,SCREEN+40    ;;Starting screen offset
1AA6 : 7B                       ld      a,e             ;;A=Y Coordinate
1AA7 : 11 28 00                 ld      de,40           ;;Screen width
1AAA : FE 03            SCALPY: cp      3               ;;Less than 3?
1AAC : 38 06                    jr      c,SCALEX        ;;Convert X
1AAE : 19                       add     hl,de           ;;Add a line to offset
1AAF : 3D                       dec     a               ;;Subtract 3
1AB0 : 3D                       dec     a               ;
1AB1 : 3D                       dec     a               ;
1AB2 : 18 F6                    jr      SCALPY          ;;Repeat
1AB4 : 07               SCALEX: rlca                    ;;Multiply remainder by 2
1AB5 : CB 29                    sra     c               ;;Column = X-Coordinate / 2 
1AB7 : 30 01                    jr      nc,SCALES       ;;Was it odd?
1AB9 : 3C                       inc     a               ;;Yes, add one to remainder
1ABA : 09               SCALES: add     hl,bc           ;;Add column to screen offset
1ABB : 11 CA 1A                 ld      de,BITTAB       ;
1ABE : B7               SCALEB: or      a               ;;Check bit#
1ABF : 28 04                    jr      z,SCALEC        ;;0? Mask screen character
1AC1 : 13                       inc     de              ;;Bump table pointer
1AC2 : 3D                       dec     a               ;;Decrement bit#
1AC3 : 18 F9                    jr      SCALEB          ;;and repeat
1AC5 : 7E               SCALEC: ld      a,(hl)          ;;Get character at screen offset
1AC6 : F6 A0                    or      $A0             ;
1AC8 : AE                       xor     (hl)            ;;Flip bits 5 and 7
1AC9 : C9                       ret                     ;
1ACA                         
1ACA : 01 02 04 08      BITTAB: byte    $01,$02,$04,$08,$10,$40
1ACE : 10 40                    
1AD0                    
1AD0                    ;;Parse an Integer                     
1AD0 : CD 85 09         GETINT: call    FRMEVL          ;;Get a number
1AD3 : C3 82 06                 jp      FRCINT          ;;Convert to an Integer
1AD6
1AD6 : D5               SOUND:  push    de
1AD7 : CD 7F 1A                 call    SCAND
1ADA : E5                       push    hl
1ADB : CD 64 1E                 call    SOUNDS
1ADE : E1                       pop     hl
1ADF : D1                       pop     de
1AE0 : C9                       ret
1AE1
1AE1                    ;;Print CR/LF to printer
1AE1 : 3E 0D            LPCRLF: ld      a,13            ;;Send CR to printer
1AE3 : CD E8 1A                 call    LPTOUT          ;
1AE6 : 3E 0A                    ld      a,10            ;;Send LF to printer
1AE8              [M80] LPTOUT: ;Primitive print character to printer routine
1AE8 : F7                       rst     HOOKDO          ;;Call Extended ROM Hook Routine
1AE9 : 11         {~~~} HOOK17: byte    17              ;
1AEA : F5                       push    af              ;;Save character
1AEB : F5                       push    af              ;;Save Registers
1AEC : D9                       exx                     ;
1AED : DB FE            LPTRDY: in      a,($FE)         ;;Wait for printer to be ready
1AEF : E6 01                    and     1               ;
1AF1 : 28 FA                    jr      z,LPTRDY        ;
1AF3                    ;;Send framed byte to printer port
1AF3 : CD 08 1B   {~~~} OUTBYT: call    OUTBIZ          ;;Send Start Bit
1AF6 : 1E 08                    ld      e,8             ;;Send 8 bits to printer
1AF8 : F1                       pop     af              ;;Restore character
1AF9 : CD 0A 1B         OUTBTS: call    OUTBIT          ;;Send bit 0 to printer
1AFC : 0F                       rrca                    ;;Rotate bits
1AFD : 1D                       dec     e               ;;Decrement counter and loop
1AFE : 20 F9                    jr      nz,OUTBTS       ;
1B00 : 3E 01                    ld      a,1             ;;Send Stop Bit
1B02 : CD 0A 1B                 call    OUTBIT          ;
1B05 : D9                       exx                     ;;Restore Registers
1B06 : F1                       pop     af              ;
1B07 : C9                       ret                     ;
1B08
1B08                    ;;Send zero bit to printer port
1B08 : 3E 00            OUTBIZ: ld      a,0              ;Write zero bit to printer port
1B0A                    ;;Send bit 0 of A to printer port
1B0A : D3 FE            OUTBIT: out     ($FE),a         ;;Write bit to printer port
1B0C : 26 B1                    ld      h,177           ;;Wait 2,849 cycles (700 microseconds)
1B0E : 25               OUTDLY: dec     h               ;;Wait [HL]*16+17 cycles
1B0F : 20 FD                    jr      nz,OUTDLY       ;
1B11 : 00                       nop                     ;
1B12 : 00                       nop                     ;
1B13 : 00                       nop                     ;
1B14 : C9                       ret                     ;
1B15
1B15                    ;;Copy Screen Contents to Printer
1B15                    ;;Assumes printer line width is 40
1B15 : E5               COPY:   push    hl              ;;Save Text Pointer
1B16 : D5                       push    de              ;
1B17 : CD E1 1A                 call    LPCRLF          ;;Print CR/LF
1B1A : 21 28 30                 ld      hl,SCREEN+40    ;;Row 1, Column 0
1B1D : 11 E8 33                 ld      de,SCREEN+1000  ;;End of Screen
1B20 : 7E         (~~~) COPY1:  ld      a,(hl)          ;;Get Screen Character
1B21 : CD E8 1A                 call    LPTOUT          ;;Print it
1B24 : 23                       inc     hl              ;;Bump pointer
1B25 : E7                       rst     COMPAR          ;;Are we there yet?
1B26 : 38 F8                    jr      c,COPY1         ;;No, do it again
1B28 : CD E1 1A                 call    LPCRLF          ;;Print CR/LF
1B2B : D1                       pop     de              ;
1B2C : E1                       pop     hl              ;;Restore Text Pointer
1B2D : C9                       ret                     ;
182E
1B2E                  + ;;Display Tape Control Messages
1B2E                  | ;;Displays control messages, then waits for RETURN key
1B2E                  | ;;PPLAY displays CLOAD message
1B2E                  | ;;PRECRD displays CSAVE message
1B2E                  | ;;Preserves all registers
1B2E : E5               PPLAY:  push    hl              ;;Save all Registers
1B2F : D5                       push    de              ;
1B30 : C5                       push    bc              ;
1B31 : 21 E8 1B                 ld      hl,PLAYT        ;;"Press <PLAY>" 
1B34 : F5               PRETRN: push    af              ;;Entry point for "Press <RECORD>"
1B35 : CD 9D 0E                 call    STROUT          ;
1B38 : 21 B5 00                 ld      hl,STARTT       ;
1B3B : CD 9D 0E                 call    STROUT          ;;Print "Press RETURN key to start"
1B3E : CD 7E 1E   (~~~) PRETRL: call    INCHRH          ;
1B41 : FE 0D                    cp      13              ;
1B43 : 20 F9                    jr      nz,PRETRL       ;;Wait for RETURN key
1B45 : CD EA 19                 call    CRDO            ;Print CR/LF
1B48 : F1                       pop     af              ;
1B49 : C1                       pop     bc              ;
1B4A : D1                       pop     de              ;
1B4B : E1                       pop     hl              ;;Restore all Registers
1B4C : C9                       ret                     ;
1B4D
1B4D                  + ;;Read Byte from Tape
1B4D                  | ;;Returns Byte in A
1B4D                  | ;;All other registers preserved
1B4D : D9               RDBYTE: exx                     ;;Save index registers
1B4E : 0E FC                    ld      c,252           ;;Tape I/O Port
1B50 : CD 62 1B   (~~~) RDBYT2: call    RDBIT           ;;Wait for Start Bit (0)
1B53 : 38 FB                    jr      c,RDBYT2        ;
1B55 : 26 08                    ld      h,8             ;;Now read 8 bits
1B57 : CD 62 1B         RDBYT3: call    RDBIT           ;;Read next bit
1B5A : CB 15                    rl      l               ;;Rotate into L
1B5C : 25                       dec     h               ;
1B5D : 20 F8                    jr      nz,RDBYT3       ;;Loop until done
1B5F : 7D                       ld      a,l             ;;Copy byte into A
1B60 : D9                       exx                     ;;Restore index registers
1B61 : C9                       ret                     ;
1B62
1B62                  + ;;Read Bit from Tape
1B62                  | ;;Looks for a pulse train of two square waves with leading
1B62                  | ;;negative halves, then measures the total length of the
1B62                  | ;;square waves in cycles and compares it to as threshold
1B62                  | ;;of 2633 cycles, which (at a clock speed of 3.579545 MHz)
1B62                  | ;;equates to 1369 microseconds, about halfway between the
1B62                  | ;;1723 and 868 microseconds for a mark and space, respectively.
1B62                  | ;
1B62                    ;;First wait for the leading negative half of the pulse train
1B62 : ED 78            RDBIT:  in      a,(c)           ;;Read tape port
1B64 : 1F                       rra                     ;;Rotate low bit into Carry
1B65 : 38 FB                    jr      c,RDBIT         ;;If 1, do it again
1B66                  + ;;Then wait for the start of the positive half of the square wave
1B67                  | ;;Ends 15 cycles after detection
1B67 : ED 78      (~~~) RDBIT2: in      a,(c)           ;;Read tape port
1B69 : 1F                       rra                     ;;Rotate low bit into Carry     
1B6A : 30 FB                    jr      nc,RDBIT2       ;;If 0, do it again             
1B6C : AF                       xor     a               ;;Start counter at 0            
1B6D                  + ;;Now measure length of positive half
1B6D                  | ;;Total cycles is iterations * 36 - 5
1B6D : 3C         (~~~) RDBIT3: inc     a               ;;Increment counter            
1B6E : ED 40                    in      b,(c)           ;;Read tape port               
1B70 : CB 18                    rr      b               ;;Rotate low bit into Carry    
1B72 : 38 F9                    jr      c,RDBIT3        ;;If 1, do it again            
1B74                  + ;;Add length of negative half
1B74                  | ;;Total cycles is iterations * 36 - 5
1B74 : 3C         (~~~) RDBIT4: inc     a               ;;Increment counter             
1B75 : ED 40                    in      b,(c)           ;;Read tape port
1B77 : CB 18                    rr      b               ;;Rotate low bit into Carry
1B79 : 30 F9                    jr      nc,RDBIT4       ;;If 0, do it again
1B7B                  + ;;Check Total Length
1B7B                  | ;;Total length in cycles is A*36+5. 
1B7B : FE 49                    cp      73              ;;Set Carry if at least 2633 cycles
1B7D : C9                       ret                     ;
1B7E                    
1B7E : C9         (~~~) RWARYR: ret                     ;;Return from RWARYD
1B7F
1B7F                    ;;CSAVE tape control
1B7F : E5               PRECRD: push    hl              ;;Save Registers
1B80 : D5                       push    de              ;
1B81 : C5                       push    bc              ;
1B82 : 21 F7 1B                 ld      hl,RECORT       ;;"Press <RECORD>"
1B85 : 18 AD                    jr      PRETRN          ;;Wait for RETURN  
1B87
1B87                    ;;Write byte to tape twice
1B87 : CD 8A 1B         WRBYT2: call    WRBYTE          ;;Call WRBYTE, then drop into it
1B8A                    
1B8A                    ;;Write framed byte to tape                    
1B8A                    ;;Writes a start bit (0) , the bits of the byte, then two stop bits (1)
1B8A : F5               WRBYTE: push    af              ;;Save all registers
1B8B : D9                       exx                     ;
1B8C : 0E FC                    ld      c,252           ;;Tape I/O Port           
1B8E : F5                       push    af              ;;Save byte
1B8F : AF                       xor     a               ;
1B90 : 1E 01                    ld      e,1             ;
1B92 : CD A5 1B                 call    WRBITS          ;;Write start bit ($00) 
1B95 : F1                       pop     af              ;;Restore byte
1B96 : 1E 08                    ld      e,8             ;
1B98 : CD A5 1B                 call    WRBITS          ;;Write 8 bits of byte
1B9B : 3E FF                    ld      a,$FF           ;
1B9D : 1E 02                    ld      e,2             ;
1B9F : CD A5 1B                 call    WRBITS          ;;Write stop bits (2 x $FF)
1BA2 : D9                       exx                     ;
1BA3 : F1                       pop     af              ;;Restore all registers
1BA4 : C9                       ret                     ;
1BA5
1BA5                  + ;;Write E most significant bits of A to Tape
1BA5                  | ;;Each bit is written as two full square waves, negative half first
1BA5                  | ;;The leading negative half and trailing positive half frame the
1BA5                  | ;;(positive half first) square wave (that RDBITS looks for 
1BA5                  | ;;A mark (1) and space (0) have wave lengths of 2078 and 4126 cycles,
1BA5                  | ;;respectively. At a clock speed of 3.579545 MHz, these equate to
1BA5                  | ;;1723 and 868 microseconds, resulting in approximate frequencies
1BA5                  | ;;of 1723 Hz for a mark and 868 Hz for a space. 
1BA5 : 17               WRBITS: rla                     ;;Rotate MSB into Carry
1BA6 : 2E 40                    ld      l,64            ;;Preset Pulse Length 1,039 cycles for a 1
1BA8 : 38 02                    jr      c,WRBIT2        ;;Was bit a 1?
1BAA : 2E 80                    ld      l,128           ;;No, set Pulse Length 2,063 cycles for a 0
1BAC                    ;;Write Bit with Pulse Length L ;
1BAC : 06 04            WRBIT2: ld      b,4             ;;Countdown - + - +                  
1BAE : ED 41            WRBIT3: out     (c),b           ;;Writing 0, 1, 0, 1  
1BB0 : 65                       ld      h,l             ;;Each pulse is L*16+15 cycles      
1BB1 : 25               WRBIT4: dec     h               ;                4     
1BB2 : 20 FD                    jr      nz,WRBIT4       ;                                   
1BB4 : 05                       dec     b               ;                                   
1BB5 : 20 F7                    jr      nz,WRBIT3       ;;Write next pulse                  
1BB7 : 1D                       dec     e               ;
1BB8 : 20 EB                    jr      nz,WRBITS       ;;Write next bit
1BBA : C9                       ret                     ;
1BBB : C9                       ret                     ;;Orphan instruction
1BBC
1BBC                  + ;;Write SYNC to tape
1BBC                  | ;;Writes 12 $FF then a $00
1BBC                  | ;;All registers preserved
1BBC : F5               WRSYNC: push    af              ;;Save registers
1BBD : C5                       push    bc              ;
1BBE : 06 0C                    ld      b,12            ;
1BC0 : 3E FF            WRSYN2: ld      a,$FF           ;
1BC2 : CD 8A 1B                 call    WRBYTE          ;;Write $FF to tape
1BC5 : 10 F9                    djnz    WRSYN2          ;;Do it 11 more times
1BC7 : AF                       xor     a               ;
1BC8 : CD 8A 1B                 call    WRBYTE          ;;Write $00 to tape
1BCB : C1                       pop     bc              ;
1BCC : F1                       pop     af              ;;Restore registers
1BCD : C9                       ret                     ;
1BCE
1BCE                  + ;;Read SYNC from tape
1BCE                  | ;;Reads bytes until it gets 6 $FF followed by a $00
1BCE                  | ;;All registers preserved
1BCE : F5               RDSYNC: push    af              ;;Save registers
1BCF : C5                       push    bc              ;
1BD0 : 06 06      (~~~) RDSYN1: ld      b,6             ;;Do 6 times
1BD2 : CD 4D 1B   (~~~) RDSYN2: call    RDBYTE          ;
1BD5 : 3C                       inc     a               ;
1BD6 : 20 F8                    jr      nz,RDSYN1       ;;If not $FF, start all over
1BD8 : 10 F8                    djnz    RDSYN2          ;;Repeat until 6 $FF read
1BDA : CD 4D 1B   (~~~) RDSYN3: call    RDBYTE          ;
1BDD : B7                       or      a               ;
1BDE : 28 05                    jr      z,RDSYN4        ;;If $00, we are done
1BE0 : 3C                       inc     a               ;
1BE1 : 28 F7                    jr      z,RDSYN3        ;;If $FF, read another byte
1BE3 : 18 EB                    jr      RDSYN1          ;;Otherwise, start all over
1BE5 : C1         (~~~) RDSYN4: pop     bc              ;
1BE6 : F1                       pop     af              ;;Restore registers
1BE7 : C9                       ret                     ;
1BE8
1BE8 : 50 72 65 73      PLAYT:  byte    "Press <PLAY>",13,10,0          ;
1BEC : 73 20 3C 50
1BF0 : 4C 41 59 3E
1BF4 : 0D 0A 00   
1BF7
1BF7 : 50 72 65 73      RECORT: byte    "Press <RECORD>",13,10,0        ;
1BFB : 73 20 3C 52
1BFF : 45 43 4F 52
1C03 : 44 3E 0D 0A
1C07 : 00         
1C08
1C08 : F7               CSAVE:  rst     HOOKDO          ;
1C09 : 15         {~~~} HOOK21: byte    21              ;
1C0A : FE AA                    cp      MULTK           ;;If * Token
1C0C : CA 62 0C                 jp      z,CSARY        ;;Do CSAVE*
1C0F : CD B8 1C                 call    NAMFIL          ;;Scan filename
1C12 : E5                       push    hl              ;;Save text pointer
1C13 : CD 25 1D                 call    WRHEAP           ;
1C16 : 2A 4F 38                 ld      hl,(TXTTAB)     ;
1C19 : CD 38 1D                 call    CSAVEP          ;
1C1C : 06 0F            WRTAIL: ld      b,15            ;;Write 16 $00 to tape
1C1E : AF                       xor     a               ;
1C1F : CD 8A 1B         CSAVE3: call    WRBYTE          ;
1C22 : 10 FB                    djnz    CSAVE3          ;
1C24 : 01 40 1F                 ld      bc,8000         ;
1C27 : CD 4B 1D                 call    SLEEP           ;;Delay 200,000 cycles ~ 50 milliseconds
1C2A : E1                       pop     hl              ;;Restore Text Pointer
1C2B : C9                       ret                     ;
1C2C
1C2C : F7               CLOAD:  rst     HOOKDO
1C2D : 14         {~~~} HOOK20: byte    20
1C2E : FE AA                    cp      MULTK           ;;Check for token after CLOAD
1C30 : CA 63 0C                 jp      z,CLARY         ;;If *, CLOAD variable
1C33 : D6 95                    sub     PRINTK          ;
1C35 : 28 02                    jr      z,CLOADQ        ;;If ?, A will be $FF (verify)
1C37 : AF                       xor     a               ;;otherwise it will be 0 (load)
1C38 : 01                       byte    $01             ;;"LD BC," over two instructions
1C39 : 2F               CLOADQ: cpl                     ;;A = $FF
1C3A : 23                       inc     hl              ;;Bump text pointer
1C3B : FE 01                    cp      1               ;;If A is 0, set C, else clear C 
1C3D : F5                       push    af              ;;Save A and C
1C3E : 3E FF                    ld      a,$FF           ;
1C40 : 32 5E 38                 ld      (CLFLAG),a      ;;Set Cload Flag to $FF
1C43 : CD B1 1C                 call    NAMFIN          ;;Get FILNAM if present
1C46                  + ;;Look for Filename
1C46                  | ;;Reads tape until a file matching FILNAM is found
1C46                  | ;;If first character of FILNAM is NUL, matches next file on tape
1C46 : AF         (~~~) CLOADF: xor     a               ;
1C47 : 32 5D 38                 ld      (INSYNC),a       ;;Clear SYNC flag
1C4A : D5                       push    de              ;
1C4B : CD 2E 1B                 call    PPLAY           ;;"Press <PLAY>", wait for RETURN
1C4E : CD D9 1C                 call    RDHEAD          ;
1C51 : 21 57 38                 ld      hl,FILNAF       ;;Filename found on tape
1C54 : CD ED 1C                 call    CMPNAM          ;;Compare with FILNAM
1C57 : D1                       pop     de              ;
1C58 : 28 12                    jr      z,CLOADC        ;;If they match, continue CLOAD
1C5A : 21 06 1D                 ld      hl,SKIPT        ;
1C5D : CD 0D 1D                 call    OUTNAM          ;;"Skip: " + NAMFIL
1C60 : 06 0A      (~~~) CLOADE: ld      b,10            ;;???Skip to end of file
1C62 : CD 4D 1B   (~~~) CLOAD2: call    RDBYTE          ;
1C65 : B7                       or      a               ;
1C66 : 20 F8                    jr      nz,CLOADE       ;;Not $00, start over
1C68 : 10 F8                    djnz    CLOAD2          ;;Loop until 10 in a row
1C6A : 18 DA                    jr      CLOADF          ;;Check next file
1C6C : 21 FE 1C   (~~~) CLOADC: ld      hl,FOUNDT       ;
1C6F : CD 0D 1D                 call    OUTNAM          ;;"Found:" + NAMFIL
1C72 : F1                       pop     af              ;;Restore mode
1C73 : 32 E4 38                 ld      (FACLO),a       ;;and aave it
1C76 : DC BE 0B                 call    c,SCRTCH        ;;If not CLOAD?, do a NEW
1C79 : 3A E4 38                 ld      a,(FACLO)       ;;Get mode back
1C7C : FE 01                    cp      1               ;;and check it
1C7E : 32 5E 38                 ld      (CLFLAG),a      ;;Store in FlagE
1C81 : 2A 4F 38                 ld      hl,(TXTTAB)     ;;Set pointer to BASIC program
1C84 : CD 51 1D                 call    CLOADP          ;;Load/verify program
1C87 : 20 11                    jr      nz,CLOADV       ;;Check CLOAD? status
1C89 : 22 D6 38                 ld      (VARTAB),hl     ;;Set end of program
1C8C : 21 6E 03   (~~~) CLOADR: ld      hl,REDDY        ;
1C8F : CD 9D 0E                 call    STROUT          ;[M80] PRINT "OK" PREMATURELY
1C92 : 3E FF                    ld      a,$FF           ;
1C94 : 32 5E 38                 ld      (CLFLAG),a       ;;Set FlagE to $FF
1C97 : C3 80 04                 jp      FINI            ;
1C9A : 23         (~~~) CLOADV: inc     hl              ;
1C9B : EB                       ex      de,hl           ;
1C9C : 2A D6 38                 ld      hl,(VARTAB)     ;
1C9F : E7                       rst     COMPAR          ;;Text pointer past end of program?
1CA0 : 38 EA                    jr      c,CLOADR        ;;Yes, CLOAD? successful
1CA2 : 21 AB 1C                 ld      hl,BADT         ;
1CA5 : CD 9D 0E                 call    STROUT          ;;"Bad"
1CA8 : C3 01 04                 jp      STPRDY          ;;Abort to direct mode
1CAB
1CAB : 42 61 64 0D      BADT:   byte    "Bad",13,10,0
1CAF : 0A 00
1CB1                    ;;Scan a Filename for CLOAD command
1CB1 : AF               NAMFIN: xor     a               ;;Store 0
1CB2 : 32 51 38                 ld      (FILNAM),a      ;;in first character of FILNAM
1CB5 : 2B                       dec     hl              ;;Backup text pointer
1CB6 : D7                       rst     CHRGET          ;;Check for terminator
1CB7 : C8                       ret     z               ;;If found, return
1CB8
1CB8                    ;{GWB} Scan a Filename for CSAVE command                    
1CB8 : CD 85 09   [GWB] NAMFIL: call    FRMEVL          ;[GWB] Evaluate string
1CBB : E5                       push    hl              ;[GWB] save text pointer
1CBC : CD 06 10                 call    ASC2            ;;DE = Pointer to File Name
1CBF : 2B                       dec     hl              ;
1CC0 : 2B                       dec     hl              ;
1CC1 : 2B                       dec     hl              ;
1CC2 : 46                       ld      b,(hl)          ;
1CC3 : 0E 06                    ld      c,6             ;;Maximum File Name Length
1CC5 : 21 51 38                 ld      hl,FILNAM       ;
1CC8 : 1A         (~~~) NAMFL1: ld      a,(de)          ;;Copy String to FILNAM
1CC9 : 77                       ld      (hl),a          ;
1CCA : 23                       inc     hl              ;
1CCB : 13                       inc     de              ;
1CCC : 0D                       dec     c               ;
1CCD : 28 08                    jr      z,NAMFL3        ;
1CCF : 10 F7                    djnz    NAMFL1          ;
1CD1 : 41                       ld      b,c             ;
1CD2 : 36 00      (~~~) NAMFL2: ld      (hl),0          ;;Pad with NULs to length of 6
1CD4 : 23                       inc     hl              ;
1CD5 : 10 FB                    djnz    NAMFL2          ;
1CD7 : E1         (~~~) NAMFL3: pop     hl              ;
1CD8 : C9                       ret                     ;
1CD9
1CD9                    ;;Read File Header from Tape
1CD9 : CD CE 1B         RDHEAD: call    RDSYNC          ;;Wait for SYNC
1CDC : AF         {~~~} RDNAME: xor     a               ;
1CDD : 32 5D 38                 ld      (INSYNC),a      ;;Clear SYNC flag
1CE0 : 21 57 38                 ld      hl,FILNAF       ;
1CE3 : 06 06                    ld      b,6             ;;Read 6 bytes into FINLAF
1CE5 : CD 4D 1B   (~~~) RDNAML: call    RDBYTE          ;
1CE8 : 77                       ld      (hl),a          ;
1CE9 : 23                       inc     hl              ;
1CEA : 10 F9                    djnz    RDNAML          ;
1CEC : C9                       ret                     ;

1CED                    ;;Compare Filename
1CED                    ;;Compares the 6 bytes string to by HL to FILNAM
1CED                    ;;Returns Z Set if the two are equal or FILNAM is an empty string
1CED                    ;;Otherwise, return Z Clear
1CED : 01 51 38         CMPNAM: ld      bc,FILNAM       ;
1CED                    ;;Entry Point to Compare FILNAM to String pointed to by BC
1CF0 : 1E 06      {---} CMPNAF: ld      e,6             ;;Check 6 characters
1CF2 : 0A                       ld      a,(bc)          ;
1CF3 : B7                       or      a               ;;First character of FILNAM
1CF4 : C8                       ret     z               ;;If NUL return Equsl
1CF5 : 0A         (~~~) CMPNAL: ld      a,(bc)          ;;Compare FILNAM character
1CF6 : BE                       cp      (hl)            ;;with FILNAF character
1CF7 : 23                       inc     hl              ;;Bump pointers
1CF8 : 03                       inc     bc              ;
1CF9 : C0                       ret     nz              ;;If different, return Not Equal
1CFA : 1D                       dec     e               ;
1CFB : 20 F8                    jr      nz,CMPNAL       ;;Decrememt counter and loop
1CFD : C9                       ret                     ;
1CFE
1CFE : 46 6F 75 6E      FOUNDT: byte    "Found: ",0
1D02 : 64 3A 20 00 
1D06 : 53 6B 69 70      SKIPT:  byte    "Skip: ",0        
1D0A : 3A 20 00                 
1D0D                    ;;Print string then filename read from tape 
1D0D : D5               OUTNAM: push    de              ;;Save DE and AF
1D0E : F5                       push    af              ;
1D0F : CD 9D 0E                 call    STROUT          ;;Print string pointed to by HL
1D12                    ;;Print filename read from tape
1D12 : 21 57 38   {~~~} OUTNMF: ld      hl,FILNAF       ;;Pointer to filename
1D15 : 06 06                    ld      b,6             ;;Filenames are 6 characters long
1D17 : 7E               OUTNM1: ld      a,(hl)          ;
1D18 : 23                       inc     hl              ;
1D19 : B7                       or      a               
1D1A : 28 01                    jr      z,OUTNM2        ;;ASCII NUL?
1D1C : DF                       rst     OUTCHR          ;;No, print character
1D1D : 10 F8            OUTNM2: djnz    OUTNM1          ;;Countdown and loop
1D1F : CD EA 19                 call    CRDO            ;;Print CR/LF
1D22 : F1                       pop     af              ;
1D23 : D1                       pop     de              ;;Restore AF and DE
1D24 : C9                       ret                     ;
1D25    
1D25                    ;;Prompt User, Wait for RETURN, and Write Header
1D25 : CD 7F 1B         WRHEAP: call    PRECRD          ;;"Press <RECORD>", wait for RETURN
1D28                    ;;Write File Header to Tape
1D28 : CD BC 1B   {~~~} WRHEAD: call    WRSYNC          ;;Write SYNC to tape
1D2B : 06 06      {~~~} WRNAME: ld      b,6
1D2D : 21 51 38                 ld      hl,FILNAM       ;;Write Filename to tape 
1D30 : 7E         (~~~) WRNAML: ld      a,(hl)
1D31 : 23                       inc     hl
1D32 : CD 8A 1B                 call    WRBYTE
1D35 : 10 F9                    djnz    WRNAML
1D37 : C9                       ret
1D38                        
1D38                    ;;Save Program Text to tape 
1D38 : CD BC 1B         CSAVEP: call    WRSYNC          ;;Write SYNC to tape
1D3B : EB                       ex      de,hl           ;;Save from TXTTAB
1D3C : 2A D6 38                 ld      hl,(VARTAB)     ;;to VARTAB
1D3F
1D3F                    ;;Save RAM from DE to HL on tape
1D3F : 1A               CSAVEB: ld      a,(de)          ;;Get byte from memory
1D40 : 13                       inc     de              ;;Bump pointer
1D41 : CD 8A 1B                 call    WRBYTE          ;;Write byte to text
1D44 : E7                       rst     COMPAR          ;;Are we there yet?
1D45 : 20 F8                    jr      nz,CSAVEB       ;;No, write another
1D47 : C9                       ret                     ;
1D48
1D48                    ;;;Orphan code?
1D48 : 01 00 00         SLEEPS: ld      bc,0            ;Sleep maximum amount
1D4B                    
1D4B                    ;;Pause program execution
1D4B                    ;;Delays BC*25-5 cycles
1D4B : 0B               SLEEP:  dec     bc              ;;Decrement Counter
1D4C : 78                       ld      a,b             ;                  
1D4D : B1                       or      c               ;;Is it 0?         
1D4E : 20 FB                    jr      nz,SLEEP        ;;If not, loop     
1D50 : C9                       ret                     ;                  
1D51
1D51                    ;;Load Program Text from tape 
1D51 : CD CE 1B         CLOADP: call    RDSYNC          ;;Wait for SYNC
1D54 : 3E FF                    ld      a,$FF
1D56 : 32 5D 38                 ld      (INSYNC),a      ;;Set SYNC flag
1D59 : 9F                       sbc     a,a             ;;A = 0
1D5A : 2F                       cpl                     ;;A = $FF ???WHY?
1D5B : 57                       ld      d,a             ;;D = $FF
1D5C : 06 0A      (~~~) CLOADB: ld      b,10            ;
1D5E : CD 4D 1B   (~~~) CLOADN: call    RDBYTE          ;;Get Byte
1D61 : 5F                       ld      e,a             ;;Save it
1D62 : 96                       sub     (hl)            ;;Compare with byte in memory
1D63 : A2                       and     d               ;;If CLOAD?
1D64 : C0                       ret     nz              ;;and different, return with Zero cleared
1D65 : 73                       ld      (hl),e          ;;Store byte in memory
1D66 : CD A9 0B                 call    REASON          ;;If no space left, OM error
1D69 : 7E                       ld      a,(hl)          ;;Get byte back
1D6A : B7                       or      a               ;;Set flags
1D6B : 23                       inc     hl              ;;Bump text pointer
1D6C : 20 EE                    jr      nz,CLOADB       ;;Not 0, reset counter
1D6E : 10 EE                    djnz    CLOADN          ;;Loop until 256 $00 are read 
1D70 : AF                       xor     a               ;;Return with Zero set
1D71 : C9                       ret
                        ;
1D72              [M80] TTYCHR: ;Print character to screen
1D72 : F7                       rst     HOOKDO          ;;Call Extended BASIC Hook Routine
1D73 : 13         {~~~} HOOK19: byte    19              ;
1D74 : F5                       push    af              ;;Save character
1D75 : FE 0A                    cp      10              ;[M80] LINE FEED?
1D77 : 28 1A                    jr      z,ISLF          ;
1D79 : 3A 00 38                 ld      a,(TTYPOS)      ;
1D7C : B7                       or      a               ;;At beginning of line?
1D7D : 20 14                    jr      nz,ISLF         ;;No, skip line counter check
1D7F : 3A 08 38                 ld      a,(CNTOFL)      ;
1D82 : B7                       or      a               ;;Is line Counter 0?
1D83 : 28 0E                    jr      z,ISLF          ;;Then no pauses
1D85 : 3D                       dec     a               ;
1D86 : 32 08 38                 ld      (CNTOFL),a      ;;Decrement Line Counter
1D89 : 20 08                    jr      nz,ISLF         ;;Not 0, don't pause
1D8B : 3E 17                    ld      a,23            ;
1D8D : 32 08 38                 ld      (CNTOFL),a      ;;Reset line counter
1D90 : CD 2F 1A                 call    CQINCH          ;;Wait for character from keyboard
1D93 : F1         (~~~) ISLF:   pop     af              ;;Retrieve Character
1D94                    ;;Print Character, bypassing Extended Hook and Line Counter checks
1D94 : F5               TTYOUT: push    af              ;
1D95 : D9                       exx                     ;;Save HL on Stack
1D96 : FE 07                    cp      7               ;;Is it BEL!
1D98 : CA 14 1E                 jp      z,BEEP          ;;Make Beep Sound
1D9B : FE 0B                    cp      11              ;;Is it CLS?
1D9D : CA 45 1E                 jp      z,TTYCLR        ;;Clear the Screen
1DA0 : 5F                       ld      e,a             ;;Save A
1DA1 : 2A 01 38                 ld      hl,(CURRAM)     ;
1DA4 : 3A 0D 38                 ld      a,(CURCHR)      ;;Get character under cursor
1DA7 : 77                       ld      (hl),a          ;;Place at current screen position
1DA8 : 7B                       ld      a,e             ;;Restore A
1DA9 : FE 08                    cp      8               ;;Is it BS?
1DAB : 28 30                    jr      z,BS            ;;Do Back Space
1DAD : FE 0D                    cp      13              ;;Is it CR?
1DAF : 28 0D                    jr      z,CR            ;;Do Carriage Return
1DB1 : FE 0A                    cp      10              ;;Is it LF?
1DB3 : 28 13                    jr      z,LF            ;;Do Line Feed
1DB5 : 2A 01 38                 ld      hl,(CURRAM)     ;;Place character at
1DB8 : 77                       ld      (hl),a          ;;current position on screen
1DB9 : CD 1F 1E                 call    TTYMOV          ;;Move Cursor Right
1DBC : 18 2C                    jr      TTYFIN          ;;Finish Up
1DBE                    ;;Carriage Return: Move Cursor to Beginning of Current Line
1DBE : ED 5B 00 38(~~~) CR:     ld      de,(TTYPOS)     ;
1DC2 : AF                       xor     a               ;
1DC3 : 57                       ld      d,a             ;;Subtract Cursor Column  
1DC4 : ED 52                    sbc     hl,de           ;;from Screen Position
1DC6 : 18 1F                    jr      TTYFIS          ;
1DC8                    ;;Line Feed: Move Cursor Down One Line
1DC8 : 11 C0 33   (~~~) LF:     ld      de,SCREEN+960   ;
1DCB : E7                       rst     COMPAR          ;;Cursor on Last Row?
1DCC : D2 D8 1D                 jp      nc,LFS          ;;Yes, Scroll and Finish Up
1DCF : 11 28 00                 ld      de,40           ;       
1DD2 : 19                       add     hl,de           ;;Add 40 to Move Down One Line
1DD3 : 22 01 38                 ld      (CURRAM),hl     ;;Save New Screen Position
1DD6 : 18 12                    jr      TTYFIN          ;
1DD8 : CD FE 1D   (~~~) LFS:    call    SCROLL          ;;Scroll Up and Keep Screen Position
1DDB : 18 0D                    jr      TTYFIN          ;
1DDD                    ;;Back Space: Move Cursor Left and Delete Character 
1DDD : 3A 00 38   (~~~) BS:     ld      a,(TTYPOS)      ;
1DE0 : B7                       or      a               ;;At First Column?
1DE1 : 28 02                    jr      z,NOBS          ;
1DE3 : 2B                       dec     hl              ;;No, Move One to the Left
1DE4 : 3D                       dec     a               ;
1DE5 : 36 20      (~~~) NOBS:   ld      (hl),' '        ;;Erase Character at Position
1DE7 : CD 3E 1E   (~~~) TTYFIS: call    TTYSAV          ;;Save Column and Position
1DEA : 2A 01 38   (~~~) TTYFIN: ld      hl,(CURRAM)     ;
1DED : 7E                       ld      a,(hl)          ;;Get character at position
1DEE : 32 0D 38                 ld      (CURCHR),a      ;;Save character under cursor 
1DF1 : 36 7F                    ld      (hl),$7F        ;Display Cursor
1DF3 : D9         (~~~) TTYXPR: exx                     ;Restore [BC], [DE] and [HL]
1DF4 : F1                       pop     af              ;Restore [AF]
1DF5 : C9                       ret
1DF6
1DF6                    ;;Restore Character Under Cursor
1DF6                    ;;*** Orphan Code?
1DF6 : 2A 01 38                 ld      hl,(CURRAM)     ;;Get position
1DF9 : 3A 0D 38                 ld      a,(CURCHR)      ;;Get character
1DFC : 77                       ld      (hl),a          ;;Put character at position
1DFD : C9                       ret                     ;
1DFE
1DFE                    ;;Scroll Screen Up one Line
1DFE : 01 98 03         SCROLL: ld      bc,920          ;;Move 23 * 40 bytes
1E01 : 11 28 30                 ld      de,SCREEN+40    ;;To Row 1 Column 0
1E04 : 21 50 30                 ld      hl,SCREEN+80    ;;From Row 2 Column 1
1E07 : ED B0                    ldir                    ;
1E09 : 06 28                    ld      b,40            ;;Loop 40 Times
1E0B : 21 C1 33                 ld      hl,SCREEN+961   ;;Starting at Row 23, Column 0
1E0E : 36 20      (~~~) SCROLP: ld      (hl),' '        ;;Put Space
1E10 : 23                       inc     hl              ;;Next Column
1E11 : 10 FB                    djnz    SCROLP          ;;Do it again
1E13 : C9                       ret                     ;
1E14
1E14                    ;;Make a Beep Sound
1E14 : 01 C8 00   (~~~) BEEP:   ld      bc,200          ;
1E17 : 11 32 00                 ld      de,50           ;
1E1A : CD 64 1E                 call    SOUNDS          ;;Play freq 50, delay 300
1E1D : 18 D4                    jr      TTYXPR          ;;Restore Registers and return
1E1F
1E1F                    ;;Move Cursor one character to the right
1E1F : 2A 01 38         TTYMOV: ld      hl,(CURRAM)     ;
1E22 : 3A 00 38                 ld      a,(TTYPOS)      ;
1E25 : 23                       inc     hl              ;;Increment Position in Memory
1E26 : 3C                       inc     a               ;;Increment Cursor Column
1E27 : FE 26                    cp      38              ;;Less than 39?
1E29 : 38 13                    jr      c,TTYSAV        ;;Save and Return
1E2B : 23                       inc     hl              ;
1E2C : 23                       inc     hl              ;;Skip border columns
1E2D : 11 E8 33                 ld      de,SCREEN+1000  ;
1E30 : E7                       rst     COMPAR          ;;Past End of Screen?
1E31 : 3E 00                    ld      a,0             ;;Cursor Column = 0
1E33 : 38 09                    jr      c,TTYSAV        ;;No, Save Position and Column
1E35 : 21 C1 33                 ld      hl,033C1H       ;;Yes, Position = Row 24, Column 0  
1E38 : CD 3E 1E                 call    TTYSAV          ;Save Position and Column
1E3B : C3 FE 1D                 jp      SCROLL          ;Scroll Screen
1E3E
1E3E                    ;;Update Current Screen Position and Cursor Column
1E3E : 22 01 38         TTYSAV: ld      (CURRAM),hl     ;;Position in Screen RAM
1E41 : 32 00 38                 ld      (TTYPOS),a      ;;Cursor Column
1E44 : C9                       ret                     ;
1E45
1E45                    ;;Clear Screen
1E45 : 06 20            TTYCLR: ld      b,' '           ;
1E47 : 21 00 30                 ld      hl,SCREEN       ;
1E4A : CD 59 1E                 call    FILLIT          ;;Write to Sreen RAM
1E4D : 06 06                    ld      b,6             ;;Black on Light Cyan
1E4F : CD 59 1E                 call    FILLIT          ;;Write to Color RAM
1E52 : 21 29 30                 ld      hl,SCREEN+41    ;;Home Cursor
1E55 : AF                       xor     a               ;;Column = 0
1E56 : C3 E7 1D                 jp      TTYFIS          ;;Save and Finish
1E59
1E59                    ;;Fill 1024 bytes atarting at HL with A                     
1E59 : 11 FF 03         FILLIT: ld      de,$3FF         ;;Count down from 1023 
1E5C                    ;;Fill BC bytes atartinf at HL with A
1E5C : 70               FILLIP: ld      (hl),b          ;;Store byte
1E5D : 23                       inc     hl              ;;Increment pointer
1E5E : 1B                       dec     de              ;;Decrement Counter
1E5F : 7A                       ld      a,d             ;
1E60 : B3                       or      e               ;;Is it 0?
1E61 : 20 F9                    jr      nz,FILLIP       ;;No, Loop
1E63 : C9                       ret                     ;
1e64
1E64 : 78         [GWB] SOUNDS: ld      a,b             ;;Play frequency [DE] for duration [BC]
1E65 : B1                       or      c               ;;If BC = 0 return
1E66 : C8                       ret     z               ;
1E67 : AF                       xor     a               ;
1E68 : D3 FC                    out     ($FC),a         ;;Write 0 to port $FC
1E6A : CD 76 1E                 call    SDELAY          ;
1E6D : 3C                       inc     a               ;
1E6E : D3 FC                    out     ($FC),a         ;;Write 1 to port $FC
1E70 : CD 76 1E                 call    SDELAY          ;;Delay [DE]*31+44 cycles
1E73 : 0B                       dec     bc              ;;Decrememt duration counter and loop
1E74 : 18 EE                    jr      SOUNDS          ;
1E76    
1E76 : D5               SDELAY: push    de              ;;Delay [DE]*31+27 cycles
1E77 : E1                       pop     hl              ;;Copy freq delay to HL (+10)
1E78 : 7C               SDELAL: ld      a,h             ;
1E79 : B5                       or      l               ;
1E7A : C8                       ret     z               ;;If 0, return
1E7B : 2B                       dec     hl              ;
1E7C : 18 FA                    jr      SDELAL          ;;Decrement and loop
1E7E                    
1E7E                  + ;;INCHRH, INCHRC, and INCHRI - Get Character from Keyboard 
                      | ;;The Keyboard Matrix is 8 columns by 6 rows. The columns are wired to
                      | ;;to address lines A8 through A15 and the rows to I/O Port 255.
                      | ;;When the Z80 executes and IN instruction, it puts the contents of BC 
                      | ;;on the address bus. So to read the keyboard, B is loaded with a column
                      | ;;mask, C is loaded with $FF, and OUT (C) reads the rows.
                      | ;;
                      | ;;        A8  A9  A10 A11 A12 A13 A14 A15            
                      | ;;    D0   =   -   9   8   6   5   3   2
                      | ;;    D1  <--  /   O   I   Y   T   E   W
                      | ;;    D2   :   0   K   7   G   4   S   L
                      | ;;    D3  RTN  P   M   U   V   R   Z   Q
                      | ;;    D4   ;   L   N   H   C   D  SPC    
                      | ;;    D5   .   ,   J   B   F   X   A
                      | ;;
                      | ;; Note: The RESET key is wired directly to the Z80 reset line.
1E7E : F7               INCHRH: rst     HOOKDO
1E7F : 12         {~~~} HOOK18: byte    18
1E80 : D9               INCHRC: exx                     ;;Save Registers        
1E81 : 2A 0B 38         INCHRI: ld      hl,(RESPTR)
1E84 : 7C                       ld      a,h
1E85 : B7                       or      a
1E86 : 28 1A                    jr      z,KEYSCN
1E88 : EB                       ex      de,hl           ;;Save HL
1E89 : 21 0F 38                 ld      hl,KCOUNT
1E8C : 34                       inc     (hl)            ;;Increment debounce counter
1E8D : 7E                       ld      a,(hl)          ;;Get Value
1E8E : FE 0F                    cp      15              ;;Less than 15?
1E90 : 38 3C                    jr      c,KEYFIN        ;;Yes, finish up
1E92 : 36 05                    ld      (hl),5          ;;Set debounce counter to 5
1E94 : EB                       ex      de,hl           ;;Restore HL
1E95 : 23                       inc     hl
1E96 : 7E                       ld      a,(hl)
1E97 : 22 0B 38                 ld      (RESPTR),hl
1E9A : B7                       or      a
1E9B : F2 36 1F                 jp      p,KEYRET
1E9E : AF                       xor     a
1E9F : 32 0C 38                 ld      (RESPTR+1),a
1EA2                    ;;Scan Keyboard
1EA2 : 01 FF 00         KEYSCN: ld      bc,$FF          ;;B=0 to scan all columns
1EA5 : ED 78                    in      a,(c)           ;;Read rows from I/O Port 255
1EA7 : 2F                       cpl                     ;;and Invert
1EA8 : E6 3F                    and     $3F             ;;Check all rows
1EAA : 21 0E 38                 ld      hl,LSTX         ;;Pointer to last scan code
1EAD : 28 16                    jr      z,NOKEYS        ;;No key pressed? ???do a thing
1EAF                            ;;???Check for Shift and Control Keys
1EAF : 06 7F                    ld      b,$7F           ;;Scanning column 7 - %01111111
1EB1 : ED 78                    in      a,(c)           ;;Read rows and invert
1EB3 : 2F                       cpl
1EB4 : E6 0F                    and     $0F             ;;Check rows 0 through 3 - %00001111
1EB6 : 20 1F                    jr      nz,KEYDN        ;;Key down? Process it
1EB6                            ;;Scan the Rest of the Columns
1EB8 : 06 BF                    ld      b,$BF           ;;Start with column 6 - %10111111 
1EBA : ED 78      (~~~) KEYSCL: in      a,(c)           ;;Read rows and invert
1EBC : 2F                       cpl                     ;
1EBD : E6 3F                    and     $3F             ;;Check rows 0 through 5 - %00111111
1EBF : 20 16                    jr      nz,KEYDN        ;;Key down? Process it
1EC1 : CB 08                    rrc     b               ;;Next column
1EC3 : 38 F5                    jr      c,KEYSCL        ;;Loop if not out of columns
1EC5 : 23               NOKEYS: inc     hl              ;;Point to KCOUNT           
1EC6 : 3E 46                    ld      a,70            ;
1EC8 : BE                       cp      (hl)            ;
1EC9 : 38 03                    jr      c,KEYFIN        ;;Less than 70? Clean up and return
1ECB : 28 04                    jr      z,SCNINC        ;;0? Increment KCOUNT and return
1ECD : 34                       inc     (hl)            ;
1ECE : AF               KEYFIN: xor     a               ;;Clear A
1ECF : D9                       exx                     ;;Restore Registers
1ED0 : C9                       ret                     ;
1ED1 : 34               SCNINC: inc     (hl)            ;;Increment KCOUNT
1ED2 : 2B                       dec     hl              ;
1ED3 : 36 00                    ld      (hl),0          ;;Clear LSTX 
1ED5 : 18 F7                    jr      KEYFIN          ;;Clean up and Return
1ED7
1ED7                    ;;Process Key Currently Pressed
1ED7 : 11 00 00         KEYDN:  ld      de,0            ;
1EDA : 1C               KEYROW: inc     e               ;;Get row number (1-5) 
1EDB : 1F                       rra                     ;
1EDC : 30 FC                    jr      nc,KEYROW       ;
1EDE : 7B                       ld      a,e             ;
1EDF : CB 18            KEYCOL: rr      b               ;;Add column number times 6
1EE1 : 30 04                    jr      nc,KEYCHK       ;
1EE3 : C6 06                    add     a,6             ;
1EE5 : 18 F8                    jr      KEYCOL          ;
1EE7 : 5F               KEYCHK: ld      e,a             ;
1EE8 : BE                       cp      (hl)            ;;Compare scan code to LSTX
1EE9 : 77                       ld      (hl),a          ;;Update LSTX with scan code
1EEA : 23                       inc     hl              ;;Point to KCOUNT
1EEB : 20 0F                    jr      nz,KEYCLR       ;;Not the same? Clesr KCOUNT snd exit
1EED : 3E 04                    ld      a,4             
1EEF : BE                       cp      (hl)            ;;Check KCOUNT
1EF0 : 38 05                    jr      c,KEYFN6        ;;Greater than 4? Set to 6 and return
1EF2 : 28 0C                    jr      z,KEYASC        ;;Equal to 4? Convert scan code
1EF4 : 34                       inc     (hl)            ;;Increment KCOUNT
1EF5 : 18 02                    jr      KEYFN2          ;;Clean up and exit
1EF7 : 36 06            KEYFN6: ld      (hl),6          ;;Set KCOUNT to 6
1EF9 : AF               KEYFN2: xor     a               ;;Clear A
1EFA : D9                       exx                     ;;Restore registers
1EFB : C9                       ret                     ;
1EFC : 36 00            KEYCLR: ld      (hl),0          ;;Clear KCOUNT
1EFE : 18 F9                    jr      KEYFN2          ;;Clean up and return
1EFF                    ;;Convert Keyboard Scan Code to ASCII Character
1F00 : 34               KEYASC: inc     (hl)            ;;Increment KCOUNT
1F01 : 06 7F                    ld      b,$7F           ;;Read column 7
1F03 : ED 78                    in      a,(c)           ;;Get row
1F05 : CB 6F                    bit     5,a             ;;Check Control key
1F07 : DD 21 93 1F              ld      ix,CTLTAB-1     ;;Point to control table
1F0B : 28 0C                    jr      z,KEYLUP        ;;Control? Do lookup
1F0D : CB 67                    bit     4,a             ;;Check Shift key
1F0F : DD 21 65 1F              ld      ix,SHFTAB-1     ;;Point to shift table
1F13 : 28 04                    jr      z,KEYLUP        ;;Shift? Do lookup
1F15 : DD 21 37 1F              ld      ix,KEYTAB-1       
1F19 : DD 19            KEYLUP: add     ix,de           ;;Get pointer into table
1F1B : DD 7E 00                 ld      a,(ix+0)        ;;Load ASCII value
1F1E : B7                       or      a               ;;Reserved Word? 
1F1F : F2 36 1F                 jp      p,KEYRET        ;;No, return ASCII code
1F22 : D6 7F                    sub     $7F             ;;Convert to Reserved Word Count
1F24 : 4F                       ld      c,a             ;;and copy to C
1F25 : 21 44 02                 ld      hl,RESLST-1     ;;Point to Reserved Word List
1F28 : 23               KEYRES: inc     hl              ;;Bump pointer
1F29 : 7E                       ld      a,(hl)          ;;Get next character
1F2A : B7                       or      a               ;;First letter of reserved word?
1F2B : F2 28 1F                 jp      p,KEYRES        ;;No, loop
1F2E : 0D                       dec     c               ;;Decrement Count
1F2F : 20 F7                    jr      nz,KEYRES       ;;Not 0? Find next word
1F31 : 22 0B 38                 ld      (RESPTR),hl     ;;Save Keyword Address
1F34 : E6 7F                    and     $7F             ;;Strip high bit from first character
1F36 : D9               KEYRET: exx                     ;;Restore Registers
1F37 : C9                       ret
1F38
1F38                    ;;Unmodified Key Lookup Table
1F38 : 3D 08 3A 0D      KEYTAB: byte    '=',$08,':',$0D,';','.' ;;Backspace and Return
1F3C : 3B 2E                                                    
1F3E : 2D 2F 30 70              byte    '-','/','0','p','l',',' ;
1F42 : 6C 2C                                                    
1F44 : 39 6F 6B 6D              byte    '9','o','k','m','n','j' ;
1F48 : 6E 6A                                                    
1F4A : 38 69 37 75              byte    '8','i','7','u','h','b' ;
1F4E : 68 62                                                    
1F50 : 36 79 67 76              byte    '6','y','g','v','c','f' ;
1F54 : 63 66                                                    
1F56 : 35 74 34 72              byte    '5','t','4','r','d','x' ;
1F5A : 64 78                                                    
1F5C : 33 65 73 7A              byte    '3','e','s','z',' ','a' ;
1F60 : 20 61                                                    
1F62 : 32 77 31 71              byte    '2','w','1','q'         ;
                        ;;Shifted Key Lookup Table
1F66 : 2B 5C 2A 0D      SHFTAB: byte    '+',$5C,'*',$0D,'@','>' ;;Backslash, Return
1F6A : 40 3E                                                    
1F6C : 5F 5E 3F 50              byte    '_','^','?','P','L','<' ;
1F70 : 4C 3C                                                    
1F72 : 29 4F 4B 4D              byte    ')','O','K','M','N','J' ;
1F76 : 4E 4A                                                    
1F78 : 28 49 27 55              byte    '(','I',$27,'U','H','B' ;;Apostrophe
1F7C : 48 42                                                    
1F7E : 26 59 47 56              byte    '&','Y','G','V','C','F' ;
1F82 : 43 46                                                    
1F84 : 25 54 24 52              byte    '%','T','$','R','D','X' ;
1F88 : 44 58                                                    
1F8A : 23 45 53 5A              byte    '#','E','S','Z',' ','A' ;
1F8E : 20 41                                                    
1F90 : 22 57 21 51              byte    $22,'W','!','Q'         ;;Quotation Mark
1F94
1F94                    ;;Control Key Lookup Table
1F94 : 82 1C C1 0D      CTLTAB: byte    $82,$1C,$C1,$0D,$94,$C4 ;;NEXT ^\ PEEK Return POKE VAL
1F98 : 94 C4                                                    ;; 
1F9A : 81 1E 30 10              byte    $81,$1E,$30,$10,$CA,$C3 ;;FOR ^^ 0 ^P POINT STR$
1F9E : CA C3                                                    ;; 
1FA0 : 92 0F 9D 0D              byte    $92,$0F,$9D,$0D,$C8,$9C ;;COPY ^O PRESET ^M RIGHT$, SET
1FA4 : C8 9C                                                    ;; 
1FA6 : 8D 09 8C 15              byte    $8D,$09,$8C,$15,$08,$C9 ;;RETURN ^I GOSUB ^U ^H MID$
1FAA : 08 C9                                                    ;; 
1FAC : 90 19 07 C7              byte    $90,$19,$07,$C7,$03,$83 ;;ON ^Y ^G LEFT$ ^C DATA
1FB0 : 03 83                                                    ;; 
1FB2 : 88 84 A5 12              byte    $88,$84,$A5,$12,$86,$18 ;;GOTO INPUT THEN ^R READ ^X
1FB6 : 86 18                                                    ;; 
1FB8 : 8A 85 13 9A              byte    $8A,$85,$13,$9A,$C6,$9B ;;IF DIM ^S CLOAD CHR$ CSAVE
1FBC : C6 9B                                                    ;; 
1FBE : 97 8E 89 11              byte    $97,$8E,$89,$11         ;;LIST REM RUN ^Q
1FC2
1FC2                    ;;Check for Ctrl-C, called from NEWSTT
1FC2 : E5               INCNTC: push    hl                      ;;Save text pointer
1FC3 : 21 04 00                 ld      hl,4                    ;
1FC6 : 39                       add     hl,sp                   ;
1FC7 : 22 F9 38                 ld      (SAVSTK),hl             ;;Save stack pointer less 2 entries
1FCA : E1                       pop     hl                      ;;Restore text pointer
1FCB : C3 25 1A                 jp      ISCNTC                  ;;Check for Ctrl-C
1FCE
1FCE                    ;;Finish up Warm Start
1FCE : 2A F9 38         WRMFIN: ld      hl,(SAVSTK)             ;;Restore stack pointer
1FD1 : F9                       ld      sp,hl                   ;
1FD2 : 2A CE 38                 ld      hl,(SAVTXT)             ;;Restore text pointer
1FD5 : CD 20 0C                 call    STOPC                   ;;Enter direct mode
1FD8
1FD8                  + ;;Save Stack Pointer
1FD8                  | ;;Called from STKINI. Stores stack pointer in TEMPST
1FD8                  | ;;;This code is inline in all the reference sources
1FD8 : 2B               STKSAV: dec     hl              ;TAKE INTO ACCOUNT FNDFOR STOPPER
1FD9 : 2B                       dec     hl              ;
1FDA : 22 F9 38                 ld      (SAVSTK),hl     ;MAKE SURE SAVSTK OK JUST IN CASE
1FDD : 21 B1 38                 ld      hl,TEMPST       ;INCREMENT BACK FOR SPHL
1FE0 : C9                       ret                     ;
1FE1
1FE1                    ;;Power Up/Reset Routine: Jumped to from RST 0 
1FE1 : 3E FF      [M80] JMPINI: ld      a,$FF           ;;Turn off printer and Cold Start
1FE3 : D3 FE                    out     ($FE),a         ;;Write $FF to Printer Port
1FE5 : C3 41 00                 jp      INIT            ;[M80] INIT IS THE INTIALIZATION ROUTINE
1FE8
1FE8                    ;;Start Extended Basic
1FE8 : 3E AA            XBASIC: ld      a,$AA           ;;
1FEA : D3 FF                    out     ($FF),a         ;;Write Unlock Code to Port 255
1FEC : 32 09 38                 ld      (LASTFF),a      ;;Save It
1FEF : C3 10 20                 jp      XSTART          ;;Jump to Extended BASIC Startup
1FF2
1FF2                    ;;Called from COLDST to print BASIC startup message
1FF2 : 21 5F 01   [GWB] PRNTIT: ld      hl,HEDING       ;Print copyright message and return
1FF5 : C3 9D 0E                 jp      STROUT          ;
1FF8
1FF8                    ;;Pad rest of ROM space
1FF8 : F5 F5 F5 F5              byte    $F5,$F5,$F5,$F5,$F5,$F5,$F5,$F5 
1FFC : F5 F5 F5 F5
2000 :                          end                    ;End of Program!
