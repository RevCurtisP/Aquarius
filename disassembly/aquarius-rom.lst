;;Mattel Aquarius Microsoft S1, S2, and Extended Basic ROM disassembly
;;
;;Annotated by Curtis F Kaylor
;;
;;Originally disassembled with dasmx, but modified to a custom syntax

;;Listing format:
;;
;;Columns Contents
;;  1-4   S1 address (or ---- for equates) - If blank, code is not in S1 ROM
;;  6-9   S2 address (or ---- for equates) - If blank, code is not in S2 ROM
;;  11    Separator between address and machine code bytes
;;        Normally ":" for lines of Code or " " for Comments and Equates 
;;        If lower case "x", line is Standard BASIC referenced from Extended Basic
;;        If Upper case "X", line is Extended Basic only
;;        If "=", the label is to be for an EQU to address in Extended BASIC
;;        If "-", line contains the comment to use when processing the next "="
;; 13-23  Hexadecimal machine code bytes (up to four per line)
;; 24-28  Label Source ("~~~" if not found in any source}
;;        [ ] = Global - referenced in external routine(s)
;;        ( ) = Local - referenced in the same routine
;;        { } = Unused - not referenced in code, but found in source documents
;;  28    For comments starting at column 30, this is a collapse indicator
;;        that can be used in an interactive display of the listing
;;        A " " or "+" means the comment line is always shown
;;        A "|" means the comment line can be collapsed into the previous "+"
;; 30-36  Label - All labels are upper case
;; 38-44  Op-Code - All opocodes are in lower case
;;        Pseudo-Op "equ" is used for labels that are only defined once
;;        while "=" is used for labels that are redefined
;;        Hexadecimal numbers are prefixed with a "$" (Motorola format)
;;        and Binary numbers are prefixed with a %"
;;  46-   Operand 
;;  ---   Comments begin with ";" 
;;        If from a source document, it is followed with the source ID in brackets
;;        ";;" precedes a comment from an annotator
;;        ";;;" precedes meta-comments, which sre not part of the assembly code
;;        "***" denotes comments where the code is unclear
;;
;;  Lines beginning with ":" are temporary lines to allow progressive testing of 
;;  conversion to a source file and subsequent assembly. They will be added
;;  and removed as needed until the generated source code fully assembles.
;;
;;Labels and comments are taken from the following:
;;  Original Source Code (Canonical Labels and Comments)
;;    [M80] Microsoft Basic-80 5.2 Source [198]
;;          winworldpc.com/product/microsoft-basic/80
;;    [M65] Microsoft BASIC for 6502 Original Source Code [1978]
;;          www.pagetable.com/?p=774
;;    [GWB] Microsoft GW-BASIC Interpreter Source Code [1983]
;;          https://github.com/microsoft/GW-BASIC
;;  Commented Disassemby Listings (Non-Canonical)
;;    [A4K] Altair BASIC 3.2 (4K) - Annotated Disassembly [1975]
;;          altairbasic.org/
;;    [A8K] Altair BASIC 8K - Disassembly [1978]
;;          www.autometer.de/unix4fun/z80pack/ftp/altair/basic8k78.orge
;;    [TR1] TRS-80 Model I Level II Basic ROM Disassembly
;;          http://www.trs-80.com/wordpress/zaps-patches-pokes-tips/rom-cpu-info-page/
;;  Third Party Reference Materials (Non-Canonical)
;;    [L2R] Level II ROM Reference Manual [1980]
;;          https://www.classic-computers.org.nz/system-80/manuals_Level%20II%20ROM%20Reference%20Manual.pdf
;;    [M64] COMPUTE!'s Mapping the C64
;;    [EBU] Extended BASIC Unravelled II for the Tandy TRS-80 Color Computer
;;          https://colorcomputerarchive.com/repo/Documents/Books/Unravelled%20Series/extended-basic-unravelled.pdf
;;
;;Label sources are denoted to the left of the label and comment sources are denoted at the beginning of the comment.
;;
;;Comments taken from the above sources are preceded by a single semicolon, while unsourced comments
;;are preceded by two semicolons, and annotations are preceded by three semicolons.
;
;
;S1   S2  x
----                         ;;Mattel Aquarius Microsoft S1 Basic ROM 
     ----                    ;;Mattel Aquarius Microsoft S2 Basic ROM
---- ---- X                  ;;Mattel Aquarius Microsoft Extended Basic ROM
---- ----                    ;;
---- ---- x                  ;;BASIC Constants
---- ----                    CLMWID  equ     14      ;[M80] MAKE COMMA COLUMNS FOURTEEN CHARACTERS
---- ----                    LPTSIZ  equ     132     ;{M80} WIDTH OF PRINTER
---- ---- X                  SGBASE  equ     $A0     ;;Base Semigraphics Character
  
                             ;;System Variables
---- ---- x                  SCREEN  equ     $3000   ;;Screen Character Matrix
---- ---- x                  COLOR   equ     $3400   ;;Screen Color Matrix
---- ----              [M80] TTYPOS  equ     $3800   ;[M80] STORE TERMINAL POSITION HERE
---- ---- x                  CURRAM  equ     $3801   ;;Position in CHARACTER RAM of cursor
---- ---- x            [M65] USRPOK  equ     $3803   ;;JP instruction for USR() routine
~~~~ ~~~~                    USRADD  equ     $3804   ;;Address of USR routine
---- ---- x                  HOOK    equ     $3806   ;;Extended ROM Hook Vector
---- ----              [M80] CNTOFL  equ     $3808   ;;Line Counter. If not 0,  
---- ----                    SCRMBL  equ     $3809   ;;Last Scramble byte output to port #FF
---- ----              [M80] CHARC   equ     $380A   ;[M80] ISCNTC STORES EATEN CHAR HERE WHEN NOT A ^C
---- ----                    RESPTR  equ     $380B   ;;Pointer to Ctrl-Key Reserved Word    
---- ---- x                  CURCHR  equ     $380D   ;;Character under Cursor
---- ----              [M64] LSTX    equ     $380E   ;[M64] Matrix Coordinate of Last Key Pressed
---- ----                    KCOUNT  equ     $380F   ;;Keyboard debounce counter
---- ----              [M80] FDIVC   equ     $3810   ;    
---- ----              [M80] FDIVB   equ     $3814   ;    
---- ----              [M80] FDIVA   equ     $3818   ;    
---- ----              [M80] FDIVG   equ     $381B   ;    
                             ;               $381E   ;{M80} RND FUNCTION PERTUBATION COUNT
---- ----              [M80] RNDCNT  equ     $381F   ; 
                             ;       equ     $3820   ; 
~~~~ ~~~~              [M80] RNDTAB  equ     $3821   ;;Random Number TABLE
                                                     ;;;Pointed into by loading HL to RNDCNT and adding to it
---- ----              [M80] RNDX    equ     $3841   ;[M80] LAST RANDOM NUMBER GENERATED, BETWEEN 0 AND 1
---- ----              [M80] LPTPOS  equ     $3846   ;[M80] POSITION OF LPT PRINT HEAD
---- ----              [M80] PRTFLG  equ     $3847   ;[M80] WHETHER OUTPUT GOES TO LPT
---- ----              [M80] LINLEN  equ     $3848   ;;Length of a Screen Line
---- ----              [M80] CLMLST  equ     $3849   ;[M80] POSITION OF LAST COMMA COLUMN
---- ----              [M80] RUBSW   equ     $384A   ;[M80] RUBOUT SWITCH =1 INSIDE THE PROCESSING OF A RUBOUT (INLIN)
---- ---- x            [M80] TOPMEM  equ     $384B   ;[M80] TOP LOCATION TO USE FOR THE STACK INITIALLY SET UP BY INIT 
---- ----                                            ;[M80] ACCORDING TO MEMORY SIZE TO ALLOW FOR 50 BYTES OF STRING SPACE.
---- ----                                            ;[M80] CHANGED BY A CLEAR COMMAND WITH AN ARGUMENT.
---- ----              [M80] CURLIN  equ     $384D   ;[M80] CURRENT LINE #
---- ---- x            [M80] TXTTAB  equ     $384F   ;[M80] POINTER TO BEGINNING OF TEXT
---- ----                                            ;[M80] DOESN'T CHANGE AFTER BEING SETUP BY INIT.
---- ----              [GWB] FILNAM  equ     $3851   ;;File Name for CSAVE and CLOAD    
---- ----                    FILNAF  equ     $3857   ;;File Name Read from Cassette
---- ----                    INSYNC  equ     $385D   ;;Contains $FF between read of SYNC and data from tape         
---- ----                    CLFLAG  equ     $385E   ;;Flags whether doing CLOAD (0) or CLOAD? ($FF)
---- ----              [M80] BUFMIN  equ     $385F   ;{M80} START OF BUFFER
---- ---- x            [M80] BUF     equ     $3860   ;[M80] TYPE IN STORED HERE. DIRECT STATEMENTS EXECUTE OUT OF HERE. 
---- ----                                            ;[M80] REMEMBER "INPUT" SMASHES BUF. MUST BE AT A LOWER ADDRESS THAN DSCTMP
---- ----                                            ;[M80] OR ASSIGNMENT OF STRING VALUES IN DIRECT STATEMENTS WON'T COPY INTO
---- ----                                            ;[M80] STRING SPACE -- WHICH IT MUST ALLOW FOR SINGLE QUOTE IN BIG LINE
---- ----                    OLDSTK  equ     $3865   ;;Deprecated: Top Of Stack - Now Set by STKINI
----                         TMPSTK  equ     $386A   ;;Temporary Stack - Set by INIT
     ----                    TMPSTK  equ     $38A0   ;;Temporary Stack - Set by INIT
---- ---- x            [M80] ENDBUF  equ     $38A9   ;[M80] PLACE TO STOP BIG LINES
---- ---- X            [M80] BUFLEN  equ     ENDBUF-BUF-1  ;;Buffer Length
---- ----              [M80] DIMFLG  equ     $38AA   ;[M80] IN GETTING A POINTER TO A VARIABLE IT IS IMPORTANT TO REMEMBER 
---- ----                                            ;[M80] WHETHER IT IS BEING DONE FOR "DIM" OR NOT
---- ----              [M80] VALTYP  equ     $38AB   ;[M80] THE TYPE INDICATOR 0=NUMERIC 1=STRING
---- ----              [M80] DORES   equ     $38AC   ;[M80] WHETHER CAN OR CAN'T CRUNCH RES'D WORDS TURNED ON WHEN "DATA"
---- ----                                            ;[M80] BEING SCANNED BY CRUNCH SO UNQUOTED STRINGS WON'T BE CRUNCHED.
---- ---- x            [M80] MEMSIZ  equ     $38AD   ;[M80] HIGHEST LOCATION IN MEMORY
---- ----              [M80] TEMPPT  equ     $38AF   ;[M80] POINTER AT FIRST FREE TEMP DESCRIPTOR. INITIALIZED TO POINT TO TEMPST
---- ----              [M80] TEMPST  equ     $38B1   ;[M80] STORAGE FOR NUMTMP TEMP DESCRIPTORS
---- ----              [M80] DSCTMP  equ     $38BD   ;[M80] STRING FUNCTIONS BUILD ANSWER DESCRIPTOR HERE
---- ----              [M80] FRETOP  equ     $38C1   ;{M80} TOP OF FREE STRING SPACE 
---- ----              [M80] TENP3   equ     $38C3   ;[M80] USED MOMENTARILY BY FRMEVL. USED IN EXTENDED BY FOUT AND
---- ----                                            ;[M80] USER DEFINED FUNCTIONS ARRAY VARIABLE HANDLING TEMPORARY
---- ----              [M80] TEMP8   equ     $38C5   ;[M80] USED TO STORE THE ADDRESS OF THE END OF STRING ARRAYS IN GARBAGE COLLECTION
---- ----              [M80] ENDFOR  equ     $38C7   ;[M80] SAVED TEXT POINTER AT END OF "FOR" STATEMENT
---- ----              [M80] DATLIN  equ     $38C9   ;[M80] DATA LINE # -- REMEMBER FOR ERRORS
---- ---- x            [M80] SUBFLG  equ     $38CB   ;[M80] FLAG WHETHER SUBSCRIPTED VARIABLE ALLOWED "FOR" AND USER-DEFINED 
---- ----                                            ;[M80] FUNCTION POINTER FETCHING TURN THIS ON BEFORE CALLING PTRGET SO 
---- ----                                            ;[M80] ARRAYS WON'T BE DETECTED. STKINI AND PTRGET CLEAR IT.
---- ----              [M80] USFLG   equ     $38CC   ;;Direct Mode Flag    
---- ----              [M80] FLGINP  equ     $38CD   ;[M80] FLAGS WHETHER WE ARE DOING "INPUT" OR A READ
---- ----              [M80] SAVTXT  equ     $38CE   ;[M80] PLACE WHERE NEWSTT SAVES TEXT POINTER
---- ----              [M80] TENP2   equ     $38D0   ;[M80] FORMULA EVALUATOR TEMP MUST BE PRESERVED BY OPERATORS
---- ----                                            ;[M80] USED IN EXTENDED BY FOUT AND USER-DEFINED FUNCTIONS
---- ----              [M80] OLDLIN  equ     $38D2   ;[M80] OLD LINE NUMBER (SETUP BY ^C,"STOP" OR "END" IN A PROGRAM)
---- ----              [M80] OLDTXT  equ     $38D4   ;[M80] OLD TEXT POINTER
---- ----              [M80] VARTAB  equ     $38D6   ;[M80] POINTER TO START OF SIMPLE VARIABLE SPACE. UPDATED WHENEVER 
                                                     ;[M80] THE SIZE OF THE PROGRAM CHANGES, SET TO [TXTTAB] BY SCRATCH ("NEW").
---- ----              [M80] ARYTAB  equ     $38D8   ;[M80] POINTER TO BEGINNING OF ARRAY TABLE. INCREMENTED BY 6 WHENEVER 
---- ----                                            ;[M80] A NEW SIMPLE VARIABLE IS FOUND, AND SET TO [VARTAB] BY CLEARC.
---- ----              [M80] STREND  equ     $38DA   ;[M80] END OF STORAGE IN USE. INCREASED WHENEVER A NEW ARRAY 
---- ----                                            ;[M80] OR SIMPLE VARIABLE IS ENCOUNTERED SET TO [VARTAB] BY CLEARC.
---- ----              [M80] DATPTR  equ     $38DC   ;[M80] POINTER TO DATA. INITIALIZED TO POINT AT THE ZERO IN FRONT OF [TXTTAB]
---- ----                                            ;[M80] BY "RESTORE" WHICH IS CALLED BY CLEARC. UPDATED BY EXECUTION OF A "READ"
---- ---- x            [M65] VARNAM  equ     $38DE   ;;Variable Name
---- ---- x            [M65] VARPNT  equ     $38E0   ;;Pointer to Variable
---- ---- X            [~~~] FNPARM  equ     $38E2   ;;Defined Function Parameter
---- ----              [M80] FACLO   equ     $38E4   ;[M80] LOW ORDER OF MANTISSA
~~~~ ~~~~              {M80} FACMO   equ     $38E5   ;[M80] MIDDLE ORDER OF MANTISSA
---- ----              [M80] FACHO   equ     $38E6   ;[M80] HIGH ORDER OF MANTISSA
---- ---- x            [M80] FAC     equ     $38E7   ;[M80] EXPONENT
---- ----              [M80] FBUFFR  equ     $38E8   ;[M80] BUFFER FOR FOUT
---- ----              [M65] RESHO   equ     $38F6   ;[M65] RESULT OF MULTIPLIER AND DIVIDER    
---- ----              [M65] RESMO   equ     $38F7   ;;RESMO and RESLO are loaded into and stored from HL 
~~~~ ~~~~              {M65} RESLO   equ     $38F8   ;
---- ----              [M80] SAVSTK  equ     $38F9   ;[M80] NEWSTT SAVES STACK HERE BEFORE SO THAT ERROR REVERY CAN
                                                     ;[M80] CAN RESTORE THE STACK WHEN AN ERROR OCCURS
----                         BASTXT  equ     $38FA   ;;???First byte of program gets clobbered by NEWSTT
     ----                    ;;        $38FB-$38FF   ;;??Unused
     ----                    ;;              $3900   ;;This is always 0
     ----                    BASTXT  equ     $3901   ;;Start of Basic Program 

---- ---- X                  ;;Extended BASIC System Variables
---- ---- X                  FORCLR  equ     $3900   ;;Foreground Color
---- ---- X                  ATRBYT  equ     $3902   ;;Current Graphics Attributes
---- ---- X            [GWB] GXPOS   equ     $3903   ;[GWB] X Position of Second Coordinate
---- ---- X            [GWB] GYPOS   equ     $3905   ;[GWB] Y Position of Second Coordinate
---- ---- X            [GWB] GRPACY  equ     $3907   ;[GWB] Previous Y Coordinate
---- ---- X            [GWB] GRPACX  equ     $3909   ;[GWB] Previous X Coordinate
---- ---- X            [GWB] MAXUPD  equ     $390B   ;;Jump Instruction
---- ---- X                  ;;              $390C   ;[GWB] Address of Major Axis Move Update
---- ---- X            [GWB] MINUPD  equ     $390E   ;;Jump Instruction
---- ---- X                  ;;              $390F   ;[GWB] Address of Minor Axis Move Update
---- ---- X            [GWB] MAXDEL  equ     $3911   ;[GWB] Largest Delta for Line
---- ---- X            [GWB] MINDEL  equ     $3913   ;[GWB] Smaller of 2 Deltas for Line
---- ---- X            [GWB] ASPECT  equ     $3915   ;[GWB] ASPECT RATIO
---- ---- X            [GWB] CENCNT  equ     $3917   ;[GWB] END CIRCLE POINT COUNT
---- ---- X            [GWB] GLINEF  equ     $3919   ;[GWB] LINE-TO-CENTER FLAG
---- ---- X            [GWB] CNPNTS  equ     $391A   ;[GWB] 1/8 NO. OF PTS IN CIRCLE
---- ---- X            [GWB] CPLOTF  equ     $391C   ;[GWB] PLOT FLAG
---- ---- X            [GWB] CPCNT   equ     $391D   ;[GWB] ;1/8 NO. OF PTS IN CIRCLE
---- ---- X            [GWB] CPCNT8  equ     $391F   ;[GWB] NO. OF PTS IN CIRCLE
---- ---- X            [GWB] CRCSUM  equ     $3921   ;[GWB] CIRCLE SUM
---- ---- X            [GWB] CSTCNT  equ     $3923   ;[GWB] START COUNT
---- ---- X            [GWB] CSCLXY  equ     $3925   ;[GWB] FLAG WHETHER ASPECT WAS .GT. 1
---- ---- X                  CURLOC  equ     $3926   ;;Current Point Address
---- ---- X                  PINDEX  equ     $3928   ;;Point Bit Mask Index
---- ---- X            [GWB] CXOFF   equ     $3929   ;[GWB] X OFFSET FROM CENTER SAVE LOC
---- ---- X            [GWB] CYOFF   equ     $392B   ;[GWB] Y OFFSET SAVE LOCATION
---- ---- X                  BUFRET  equ     $392F   ;;BUFLIN Return Address
---- ---- X                  BUFPTR  equ     $3931   ;;Pointer into BUF while Unpacking Line
---- ---- X                  DRWSCL  equ     $3933   ;[GWB] DRAW: SCALE - DRAW POS,Scaling factor
---- ---- X                  DRWFLG  equ     $3934   ;[GWB] OPTION FLAGS - DRAW flag
---- ---- X                  DRWANG  equ     $3935   ;[GWB] DRAW "ANGLE" (0..3) - DRAW translation angle
---- ---- X                  MCLPTR  equ     $3936   ;[GWB] MAC LANG PTR
---- ---- X                  MCLLEN  equ     $3938   ;[GWB] STRING LENGTH
---- ---- X                  MCLTAB  equ     $3939   ;[GWB] ;PTR TO COMMAND TABLE
---- ---- X                  PUTFLG  equ     $393B   ;[GWB] WHETHER DOING PUT() OR GET()
---- ---- X                  ARYPNT  equ     $393C   ;;Pointer into GET/PUT Array
---- ---- X                  OPCJMP  equ     $393E   ;;Jump Instruction
---- ---- X                  OPCADR  equ     $393F   ;;Draw Operator Routine Address
---- ---- X                  GYMAX   equ     $3941   ;;Maximum X Position: 39
---- ---- X                  GXMAX   equ     $3942   ;;Maximum Y Position: 23
---- ---- X                  ;;        $3943-$3947   ;Probably Unused
---- ---- X                  ;;              $3948   ;;This is always 0
---- ---- X                  BASTXT  equ     $3949   ;;Start of Extended Basic Program 

     
                             ;;External Addresses
---- ----              [~~~] EXTBAS  equ     $2000   ;;Start of Extended Basic
---- ----              [~~~] XSTART  equ     $2010   ;;Extended BASIC Startup Routine
---- ----              [~~~] XINIT   equ     $E010   ;;ROM Cartridge Initialization Entry Point
     
---- ----                            org     $0000   ;;Starting Address of Standard BASIC

          X                  ;;Standard BASIC Subroutines
0000 0000
0000 0000                  + ;;RST 0 - Startup
0000 0000                  | ;;On power up or reset, the Z80 jumps to this RST
0000 0000                  | ;;The instruction RST START is functionally equivalent to doing
0000 0000                  | ;;a hardware reset.
0000      : C3 41 00   [M80] START:  jp      INIT              ;;Start Initialization
     0000 : C3 E1 1F   [M80] START:  jp      JMPINI            ;;Start Initialization
0003 0003 : 82 06 22                 byte    $82,$06,$22       ;;Revision Date 1982-06-22
0006 0006 : 0B                       byte    11                ;;Revision Number?
0007 0007 : 00                       nop                       ;;Pad out the RST routine
0008 0008
0008 0008 -                + ;;RST 1 - Syntax Check
0008 0008                  | ;;Check for Matching Character
0008 0008                  | ;[M65] "SYNCHK" LOOKS AT THE CURRENT CHARACTER TO MAKE SURE IT
0008 0008                  | ;[M65] IS THE SPECIFIC THING IN THE BYTE IMMEDIATELY FOLLOWING
0008 0008                  | ;[M65] "RST SYNCHK". IF NOT, IT CALLS THE "SYNTAX ERROR" ROUTINE.
0008 0008                  | ;[M65] OTHERWISE IT GOBBLES THE NEXT CHAR AND RETURNS,
0008 0008                  | ;
0008 0008                  | ;[M65] [A]=NEW CHAR AND [H,L] IS ADVANCED BY "CHRGET".
0008 0008                  | ;
0008 0008                  | ;;;In Basic versions that don't use RST, this routine is named SYNCHR
0008 0008 = 7E         [M80] SYNCHK: ld      a,(hl)
0009 0009 : E3                       ex      (sp),hl
000A 000A : BE                       cp      (hl)              ;[M65] CHARACTERS EQUAL?
000B 000B : 23                       inc     hl
000C 000C : E3                       ex      (sp),hl
000D 000D : C2 C4 03                 jp      nz,SNERR          ;[M65] "SYNTAX ERROR"
0010 0010 
0010 0010 -                + ;;RST 2 - Get Next Character
0010 0010                  | ;[M80] CHRGET - THE NEXT CHARACTER SCAN ROUTINE
0010 0010                  | ;[M65] "CHRGET" USES [H,L] AS THE CURRENT TEXT PNTR
0010 0010                  | ;[M65] FETCHES A NEW CHARACTER INTO ACCA AFTER INCREMENTING [H,L]
0010 0010                  | ;[M65] AND SETS CONDITION CODES ACCORDING TO WHAT'S IN ACCA.
0010 0010                  | ;[M65]       NOT C=  NUMERIC   ("0" THRU "9")
0010 0010                  | ;[M65]       Z=      ":" OR END-OF-LINE (A NULL)
0010 0010                  | ;[M65]
0010 0010                  | ;[M65] [ACCA] = NEW CHAR.
0010 0010                  | ;[M65] [H,L]=[H,L]+1
0010 0010                  | 
0010 0010                  | ;;Since the text pointer is kept in HL, the 8080 versions of Basic
0010 0010                  | ;;use LD A,HL to get the current character, rather than CHRGOT
0010 0010                  |
0010 0010                  | ;;;Basic versions that don't use RST use CALL CHRGTR instead
0010 0010 = 23         [M65] CHRGET: inc     hl                ;[M65] INCREMENT THE TEXT PNTR
0011 0011 : 7E         {M65} CHRGOT: ld      a,(hl)            ;;Entry point to get current character
0012 0012 : FE 3A      {M65} QNUM:   cp      ':'               ;[M65] IS IT A ":"?
0014 0014 : D0                       ret     nc                ;[M65] IT IS .GE. ":"
0015 0015 : C3 70 06                 jp      CHRCON            ;;Continue in CHRGETR
0018 0018 
0018 0018 -                + ;;RST 3 - Output Character
0018 0018                  | ;{M80}  RST OUTCHR prints char in [A] no registers affected
0018 0018                  | ;{M80}    to either terminal or printer depending on flag:
0018 0018                  | ;{M80}    PRTFLG if non-zero print to printer
0018 0018                  | ;
0018 0018                  | ;;;Basic versions that don't use RST use CALL OUTDO instead
0018 0018 = C3 8A 19   [GWB] OUTCHR: jp      OUTDO             ;;Execute print character routine
001B 001B : 00 00 00 00              byte    0,0,0,0,0         ;;Pad out the RST routine
001F 001F : 00                                                 ;;;(The hook call code from OUTDO could be moved here)
0020 0020 
0020 0020 -                + ;;RST 4 - Integer Compare
0020 0020                  | ;[TR1] Compares HL with DE. After execution, 
0020 0020                  | ;;If HL = DE, Z flag is set 
0020 0020                  | ;;If HL <> DE, Z flag is reset
0020 0020                  | ;;If HL < DE, C flag is set
0020 0020                  | ;;If HL >= DE, C flag is reset
0020 0020                  | ;;;In versions that don't use RST, this routine is named DCOMPR
0020 0020 = 7C         [M80] COMPAR: ld      a,h               ;;Compare [DE] to [HL]
0021 0021 : 92                       sub     d                 ;;Sets Z flag if equal
0022 0022 : C0                       ret     nz                ;;Sets Carry if [DE] > [HL]
0023 0023 : 7D                       ld      a,l               ;;Destroys [A]
0024 0024 : 93                       sub     e                 ;
0025 0025 : C9                       ret                       ;
0026 0026 : 00 00                    byte    0,0               ;;Pad out the RST routine
0028 0028 
0028 0028 -                + ;;RST 5 - Get sign of Floating Point Argument
0028 0028                  | ;[M80] PUT SIGN OF FAC IN A.
0028 0028                  | ;[M80] ALTERS A ONLY
0028 0028                  | ;[M80] LEAVES FAC ALONE
0028 0028                  | ;
0028 0028                  | ;;;Basic versions that don't use RST use CALL SIGN insteaoard
0028 0028 = 3A E7 38   [M80] FSIGN:  ld      a,(FAC)           ;
002B 002B : B7                       or      a                 ;[M65] IF NUMBER IS ZERO, SO IS RESULT
002C 002C : C2 EB 14                 jp      nz,SIGNC          ;;Check sign of mantissa if not 0
002F 002F : C9                       ret                       ;
0030 0030
0030 0030                  + ;;RST 6 - Extended BASIC Hook Dispatch
0030 0030                  | ;;The additional functionality of Extended Basic are invoked via this RST.
0030 0030                  | ;;Each RST HOOK instruction is followed by a byte that indicates which hook
0030 0030                  | ;;routine to execute. On startup, this routine jumps to NOHOOK, which skips
0030 0030                  | ;;the hook number byte the does a RET.
0030 0030                  | ;;
0030 0030                  | ;;Extended Basic overwrites the address in HOOK, enabling hook dispatch.
0030 0030                  | ;;
0030 0030                  } ;;
0030 0030                  | ;;*** TODO: List the hook routines.  
0030 0030 : DD 2A 06 38      HOOKDO: ld      ix,(HOOK)         ;;Get hook routine address
0034 0034 : DD E9                    jp      (ix)              ;;and jump to it
0036 0036 : 00 00                    byte    0,0               ;;Pad out RST routine
0038 0038 
0038 0038                  + ;;RST 7 - Execute USR Routine
0038 0038                  | ;;The instruction RST USRFN executes user defined code at
0038 0038                  | ;;the address in USR via the JP instruction in USRPOK.
0038 0038                  | ;;
0038 0038                  | ;;This is the same entry point used by the USR function.
0038 0038                  | ;;***TODO: how to detect a USR() call
0038 0038 : C3 03 38   [M80] USRFN:  jp      USRPOK            ;;Execute USR() routine
003B 003B
003B 003B                  + ;;Default Extended BASIC Hook Routine
003B 003B                  | ;;The system variable HOOK is loaded with the address of this 
003B 003B                  | ;;routine on startup, so that all RST HOOK instructions
003B 003B                  | ;;are routed here. 
003B 003B                  | ;;
003B 003B                  | ;;This routine returns to the second byte after the RST 
003B 003B                  | ;;RST instruction, preserving all registers.
003B 003B : D9               NOHOOK: exx                       ;;Save BC, DE, and HL
003C 003C : E1                       pop     hl                ;;Get return address off stack
003D 003D : 23                       inc     hl                ;;Increment to skip byte after RST
003E 003E : E5                       push    hl                ;;Put new return address on stack
003F 003F : D9                       exx                       ;;Restore BC, DE, and HL 
0040 0040 : C9                       ret                       ;;and Return
0041 0041
0041 0041 : 31 A0 38   [M80] INIT:   ld      sp,TMPSTK         ;[M80] SET UP TEMP STACK
0044 0044 : 3E 0B                    ld      a,11              ;
0046      : CD 74 1D                 call    TTYCH             ;;Print CLS to Clear Screen
     0046 : CD 94 1D                 call    TTYOUT            ;;Print CLS to Clear Screen
0049 0049 : 2A 01 38                 ld      hl,(CURRAM)       ;
004C 004C : 36 20                    ld      (hl),' '          ;;Place Space on Screen
004E 004E : 3E 07                    ld      a,7               ;
0050      : CD 74 1D                 call    TTYCH             ;;Print BEL to Sound Beep 
     0050 : CD 94 1D                 call    TTYOUT            ;;Print BEL to Sound Beep 
0053 0053 : AF                       xor     a                 ;
0054 0054 : D3 FF                    out     ($FF),a           ;;Output 0 to I/O Port 255;
0056 0056 : 21 FF 2F                 ld      hl,$2FFF          ;
0059 0059 : 22 5D 38                 ld      (INSYNC),hl       ;
005C 005C  
005C 005C                    ;;Check for Catridge ROM at $E010
005C 005C : 11 11 E0         CRTCHK: ld      de,XINIT+1        ;
005F 005F : 21 81 00                 ld      hl,CRTSIG-1       ;
0062 0062 : 1B         (~~~) CRTCH1: dec     de                ;
0063 0063 : 1B                       dec     de                ;
0064 0064 : 23                       inc     hl                ;
0065 0065 : 1A                       ld      a,(de)            ;
0066 0066 : 0F                       rrca                      ;
0067 0067 : 0F                       rrca                      ;
0068 0068 : 83                       add     a,e               ;
0069 0069 : BE                       cp      (hl)              ;
006A 006A : 28 F6                    jr      z,CRTCH1          ;
006C 006C : 7E                       ld      a,(hl)            ;
006D 006D : B7                       or      a                 ;
006E 006E : 20 19                    jr      nz,RESET          ;;ROM not found, start Basic
0070 0070 : EB                       ex      de,hl             ;;Encryption Key Address into HL
0071 0071 : 06 0C                    ld      b,$0C             ;
0073 0073 : 86         (~~~) CRTCH2: add     a,(hl)            ;
0074 0074 : 23                       inc     hl                ;
0075 0075 : 80                       add     a,b               ;
0076 0076 : 05                       dec     b                 ;
0077 0077 : 20 FA                    jr      nz,CRTCH2         ;
0079 0079 : AE                       xor     (hl)              ;
007A 007A : D3 FF                    out     ($FF),a           ;
007C 007C : 32 09 38                 ld      (SCRMBL),a        ;
007F 007F : C3 10 E0                 jp      XINIT             ;;Execute Cartridge Code
0082 0082
0082 0082 : 2B 37 24 24      CRTSIG: byte    "+7$$3,",0        ;;$A000 Cartridge Signature
0086 0086 : 33 2C 00
0089 0089
0089 0089                  + ;;Display Startup Screen
0089 0089                  | ;;Copies the bytes at BASICT and STARTT directly to
0089 0089                  | ;;specific positions in screen memory.
0089 0089 : 11 A1 31         RESET:  ld      de,SCREEN+417     ;;Display "BASIC"
008C 008C : 21 B0 00                 ld      hl,BASICT         ;;at line 10, column 17
008F 008F : 01 05 00                 ld      bc,STARTT-BASICT  ;
0092 0092 : ED B0                    ldir                      ;
0094 0094 : 11 10 32                 ld      de,SCREEN+528     ;;Display Start Message
0097 0097 : 21 B5 00                 ld      hl,STARTT         ;at line 13, column 8
009A 009A : 01 19 00                 ld      bc,STARTE-STARTT  ;
009D 009D : ED B0                    ldir                      ;
009F 009F
009F 009F -                + ;;Cycle Screen Colors
009F 009F                  | ;;Cycles through backround colors by sequentially
009F 009F                  | ;;calling the COLORS routine in a loop.
009F 009F = 06 03            CYCLE:  ld      b,3               ;;Black on Yellow
00A1 00A1 : CD CF 00                 call    COLORS            ;
00A4 00A4 : 06 02                    ld      b,2               ;;Black on Green
00A6 00A6 : CD CF 00                 call    COLORS            ;
00A9 00A9 : 06 06                    ld      b,6               ;;Black on Light Cyan
00AB 00AB : CD CF 00                 call    COLORS            ;
00AE 00AE : 18 EF                    jr      CYCLE             ;
00B0 00B0
00B0 00B0 -                + ;;Start Screen Text
00B0 00B0                  | ;;Copied directly into Screen RAM by the RESET routine
00B0 00B0 = 42 41 53 49      BASICT: byte    "BASIC"                         
00B4 00B4 : 43
00B5 00B5 -                  ;;Start Screen Prompt
00B5 00B5 = 50 72 65 73      STARTT: byte    "Press RETURN key to start"     
00B9 00B9 : 73 20 52 45
00BD 00BD : 54 55 52 4E
00C1 00C1 : 20 6B 65 79
00C5 00C5 : 20 74 6F 20
00C9 00C9 : 73 74 61 72
00CD 00CD : 74       
00CE 00CE = 00               STARTE: byte    0                 ;;End of Start Screen Prompt
00CF 00CF
00CF 00CF                  + ;;Set Screen Colors and Check for Keypress
00CF 00CF                  | ;;Fills color RAM with the foreground/backround colors
00CF 00CF                  | ;;pssed in the accumulator, then goes into a delay loop
00CF 00CF                  | ;;that checks for a keypress.
00CF 00CF                  | ;;
00CF 00CF                  | ;;If RETURN is pressed, execution passes to COLDST,
00CF 00CF                  | ;;initializing the Basic interpreter,
00CF 00CF                  | ;;
00CF 00CF                  | ;;If CTRL-C is pressed, execution passes to WARMST,
00CF 00CF                  | ;;preserving the Basic program and returning the user
00CF 00CF                  | ;;to the "Ok" prompt.
00CF 00CF : 21 00 34         COLORS: ld      hl,COLOR          ;;Store Accumulator in all bytes of Color
00D2 00D2 : 70         (~~~) COLOR1: ld      (hl),b            ;;memory, addresses $3400 through $3FFF
00D3 00D3 : 23                       inc     hl                ;;
00D4 00D4 : 7C                       ld      a,h               ;;NOTE: This wipes out $3B80 through $3FFF,
00D5 00D5 : FE 38                    cp      $38               ;;which are after the end of Color memory.
00D7 00D7 : 20 F9                    jr      nz,COLOR1         ;
00D9 00D9 : 21 00 40                 ld      hl,$4000          ;;Loop 12,288 times
00DC 00DC : CD 80 1E   (~~~) COLOR2: call    INCHRC            ;;Check for keypress
00DF 00DF : FE 0D                    cp      13                ;{M80} IS IT A CARRIAGE RETURN?
00E1 00E1 : 28 1A                    jr      z,COLDST          ;;Cold Start
00E3 00E3 : FE 03                    cp      3                 ;;Is it CTRL-C?
00E5 00E5 : 28 06                    jr      z,WARMST          ;;Warm Start
00E7 00E7 : 2B                       dec     hl                ;;Decrement Counter
00E8 00E8 : 7C                       ld      a,h               ;
00E9 00E9 : B5                       or      l                 ;
00EA 00EA : 20 F0                    jr      nz,COLOR2         ;;If not 0, loop
00EC 00EC : C9                       ret                       ;;Back to CYCLE
00ED 00ED
00ED 00ED                  + ;;Basic Interpreter Warm Start
00ED 00ED                  | ;;Clears the screen, resets I/O port $FF, initializes
00ED 00ED                  | ;;the hardware stack, 
00ED 00ED                  | ;;***then does other stuff.
00ED 00ED : 3E 0B            WARMST: ld      a,11              ;
00EF 00EF : CD 72 1D                 call    TTYCHR            ;;Clear Screen
00F2 00F2 : 3A 09 38                 ld      a,(SCRMBL)        ;
00F5 00F5 : D3 FF                    out     ($FF),a           ;;Reset I/O Port 255 
00F7 00F7 : CD E5 0B                 call    STKINI            ;;Initialize stack
00FA 00FA : CD 40 1A                 call    WRMCON            ;;Finish Up
0108 00FD
0108 00FD                    COLDST: 
00FD      : 3A 33 39                 ld      a,($3933)
0100      : 8C                       adc     a,h
0101      : 85                       add     a,l
0102      : 86                       add     a,(hl)
0103      : D3 FF                    out     ($FF),a           ;;Write it to I/O Port 255
0105      : 32 09 38                 ld      (SCRMBL),a        ;;and save it for later
0108 00FD : 21 87 01                 ld      hl,DEFALT         ;Set System Variable Default Values
010B 0100 : 01 51 00                 ld      bc,81             ;
010E 0103 : 11 03 38                 ld      de,USRPOK         ;;Copy 80 bytes starting at DEFALT
0111 0106 : ED B0                    ldir                      ;;to the first 80 bytes of System Variables
0113 0108 : AF                       xor     a                 ;
0114 0109 : 32 A9 38                 ld      (ENDBUF),a        ;;Clear byte after end of BUF
0117 010C : 32 00 39                 ld      (BASTXT-1),a      ;;Clear byte before start of basic program
011A 010F                    ;;Test Memory to Find Top of RAM  
011A 010F : 21 64 39                 ld      hl,BASTXT+99      ;;Set RAM Test starting address
011D 0112 : 23               MEMTST: inc     hl                ;;Bump pointer
011E 0113 : 4E                       ld      c,(hl)            ;;Save contents of location
011F 0114 : 7C                       ld      a,h               ;
0120 0115 : B5                       or      l                 ;;Wrapped around to $0000?
0121 0116 : 28 0B                    jr      z,MEMCHK          ;;Yes, go on to check memory
0123 0118 : A9                       xor     c                 ;;Scramble bits into A 
0124 0119 : 77                       ld      (hl),a            ;;and write to location
0125 011A : 46                       ld      b,(hl)            ;;Read back into B
0126 011B : 2F                       cpl                       ;;Invert scrambled bits
0127 011C : 77                       ld      (hl),a            ;;Write to location
0128 011D : 7E                       ld      a,(hl)            ;;read it back
0129 011E : 2F                       cpl                       ;;and revert back
012A 011F : 71                       ld      (hl),c            ;;Write original byte to location
012B 0120 : B8                       cp      b                 ;;Did reads match writes?
012C 0121 : 28 EF                    jr      z,MEMTST          ;;Yes, check next location
012E 0123                    ;;Check Memory Size               ;
012E 0123 : 2B         (~~~) MEMCHK: dec     hl                ;;Back up to last good address
012F 0124 : 11 2C 3A                 ld      de,BASTXT+299     ;
0132 0127 : E7                       rst     COMPAR            ;;Is there enough RAM?
0133 0128 : DA B7 0B                 jp      c,OMERR           ;;No, Out of Memory error
0136 012B                    ;;Set Top of memory 
0136 012B : 11 CE FF   {~~~} MEMSET: ld      de,$FFCE        
0139 012E : 22 AD 38                 ld      (MEMSIZ),hl       ;;Set MEMSIZ to last RAM location
013C 0131 : 19                       add     hl,de
013D 0132 : 22 4B 38                 ld      (TOPMEM),hl       ;;Set TOPMEM t0 MEMSIZ-50
0140 0135 : CD BE 0B                 call    SCRTCH            ;;Perform NEW
     0138 : CD F2 1F                 call    PRNTIT            ;;Print copyright message
0143      : 21 62 01                 ld      hl,HEDING         ;;Print copyright message
0146      : CD 9D 0E                 call    STROUT
0149 013B : 31 65 38                 ld      sp,OLDSTK         ;;Top of of stack used to be here 
014C 013E : CD E5 0B                 call    STKINI            ;;Set stack pointer to TOPMEM
014F 0141                    ;;Check for Extended BASIC
014F 0141 : 21 05 20                 ld      hl,EXTBAS+5       ;;End of signature in Extended BASIC
0152 0144 : 11 82 00                 ld      de,CRTSIG         ;;Text to check signature against
0155 0147 : 1A         (~~~) EXTCHK: ld      a,(de)            ;;Get byte from signature
0156 0148 : B7                       or      a                 ;;Did we reach a terminator?
     0149 : CA E8 1F                 jp      z,XBASIC          ;;Yes, start Extended BASIC
0157      : CA 10 20                 jp      z,XSTART          ;;Yes, start Extended BASIC
015A 014C : BE                       cp      (hl)              ;;Does it match byte in ROM?
015B      : C2 02 04                 jp      nz,READY          ;;No, move on
     014D : 20 04                    jr      nz,INITFF         ;;No, move on
015E 014F : 2B                       dec     hl                ;;Move backward in Extended BASIC
015F 0150 : 13                       inc     de                ;;and forward in test signature 
0160      : 18 F3                    jr      EXTCHK            ;;Compare next character
     0151 : 18 F4                    jr      EXTCHK            ;;Compare next character
     0153 
     0153                    ;;Initialize I/O Port 255
     0153 : ED 5F      (~~~) INITFF: ld      a,r               ;;Read random number from Refresh Register
     0155 : 17                       rla                       ;;Rotate left
     0156 : 81                       add     a,c               ;;Copy in bit that was rotated out
     0157 : D3 FF                    out     ($FF),a           ;;Write it to I/O Port 255
     0159 : 32 09 38                 ld      (SCRMBL),a        ;;and save it for later
     015C : C3 02 04                 jp      READY             ;;Enter direct mode
0162 015F
0162 015F = 0B         [GWB] HEDING: byte    11                ;;Copyright Message
0163 0160 : 43 6F 70 79              byte    "Copyright ",5," "
0167 0164 : 72 69 67 68
016B 0168 : 74 20 05 20
016F 016C : 31 39 38 32              byte    "1982 by Microsoft Inc."
0173 0170 : 20 62 79 20
0177 0174 : 4D 69 63 72
017B 0178 : 6F 73 6F 66
017F 017C : 74 20 49 6E
0183 0180 : 63 2E 
     0182 : 20 53 32                 byte    " S2"
0185 0184 : 0A 00                    byte    10,0   
0187 0187
0187 0187 -                          ;;System Variable Default Values - 81 ($51) bytes
0187 0187 = C3 97 06         DEFALT: jp      FCERR             ;;3803 USRPOK
018A 018A : 3B 00                    word    NOHOOK            ;;3806 HOOK
018C 018C : 00                       byte    0                 ;;3808 CNTOFL
018D 018D : A3                       byte    163               ;;3809 SCRMBL
018E 018E : 00                       byte    0                 ;;380A CHARC 
018F 018F : 00 00                    word    0                 ;;380B RESPTR
0191 0191 : 20                       byte    ' '               ;;380D CURCHR
0192 0192 : 00                       byte    0                 ;;380E LSTX  
0193 0193 : 00                       byte    0                 ;;380F KCOUNT
0194 0194 : D6 00                    sub     $00               ;;3810 FDIVC 
0196 0196 : 6F                       ld      l,a               ;;3812       
0197 0197 : 7C                       ld      a,h               ;;3813       
0198 0198 : DE 00                    sbc     a,00              ;;3814 FDIVB 
019A 019A : 67                       ld      h,a               ;;3816       
019B 019B : 78                       ld      a,b               ;;3817       
019C 019C : DE 00                    sbc     a,00              ;;3818 FDIVA 
019E 019E : 47                       ld      b,a               ;;381A       
019F 019F : 3E 00                    ld      a,0               ;;381B FDIVG 
01A1 01A1 : C9                       ret                       ;;381D          
01A2 01A2 : 00                       byte    0                 ;;381E          
01A3 01A3 : 00                       byte    0                 ;;381F RNDCNT 
01A4 01A4 : 00                       byte    0                 ;;3820
01A5 01A5 : 35 4A CA 99              byte    $35,$4A,$CA,$99   ;;3821 RNDTAB
01A9 01A9 : 39 1C 76 98              byte    $39,$1C,$76,$98   ;;3825
01AD 01AD : 22 95 B3 98              byte    $22,$95,$B3,$98   ;;3829
01B1 01B1 : 0A DD 47 98              byte    $0A,$DD,$47,$98   ;;383D
01B5 01B5 : 53 D1 99 99              byte    $53,$D1,$99,$99   ;;3831
01B9 01B9 : 0A 1A 9F 98              byte    $0A,$1A,$9F,$98   ;;3835
01BD 01BD : 65 BC CD 98              byte    $65,$BC,$CD,$98   ;;3839
01C1 01C1 : D6 77 3E 98              byte    $D6,$77,$3E,$98   ;;383D
01C5 01C5 : 52 C7 4F 80              byte    $52,$C7,$4F,$80   ;;3841 RNDX
01C9 01C9 : 00                       byte    $00               ;;3845
01CA 01CA : 00                       byte    $00               ;;3846 LPTPOS
01CB 01CB : 00                       byte    $00               ;;3847 PRTFLG
01CC 01CC : 28                       byte    $28               ;;3848 LINLEN
01CD 01CD : 0E                       byte    $0E               ;;3849 CLMLST
01CE 01CE : 00                       byte    $00               ;;384A RUBSW 
01CF      : 5D 39                    byte    $5D,$39           ;;384B TOPMEM
     01CF : 64 39                    byte    $64,$39           ;;3964 TOPMEM
01D1 01D1 : FE FF                    byte    $FE,$FF           ;;384D CURLIN
01D3      : FA 38                    word    BASTXT            ;;384F TXTTAB
     01D3 : 01 39                    word    BASTXT            ;;3901 TXTTAB
01D5 01D5
01D5 01D5                  + ;[M65] STATEMENT DISPATCH ADDRESSES
01D5 01D5                  | ;[M65] WHEN A STATEMENT IS TO BE EXECUTED, THE FIRST
01D5 01D5                  | ;[M65] CHARACTER OF THE STATEMENT IS EXAMINED
01D5 01D5                  | ;[M65] TO SEE IF IT IS LESS THAN THE RESERVED
01D5 01D5                  | ;[M65] WORD TOKEN FOR THE LOWEST NUMBERED STATEMENT NAME.
01D5 01D5                  | ;[M65] IF SO, THE "LET" CODE IS CALLED TO
01D5 01D5                  | ;[M65] TREAT THE STATEMENT AS AN ASSIGNMENT STATEMENT.
01D5 01D5                  | ;[M65] OTHERWISE A CHECK IS MADE TO MAKE SURE THE
01D5 01D5                  | ;[M65] RESERVED WORD NUMBER IS NOT TOO LARGE TO BE A
01D5 01D5                  | ;[M65] STATEMENT TYPE NUMBER. IF NOT THE ADDRESS
01D5 01D5                  | ;[M65] TO DISPATCH TO IS FETCHED FROM "STMDSP" (THE STATEMENT
01D5 01D5                  | ;[M65] DISPATCH LIST) USING THE RESERVED WORD
01D5 01D5                  | ;[M65] NUMBER FOR THE STATEMENT TO CALCULATE AN INDEX INTO
01D5 01D5                  | ;[M65] THE LIST.
01D5 01D5                  | ;
01D5 01D5              [M65] STMDSP: ;MARKS START OF STATEMENT LIST
01D5 01D5 : 21 0C                    word    ENDS              ;;$0C21
01D7 01D7 : BC 05                    word    FOR               ;;$05BC
01D9 01D9 : 13 0D                    word    NEXT              ;;$0D13
01DB 01DB : 1C 07                    word    DATA              ;;$071C
01DD 01DD : 93 08                    word    INPUT             ;;$0893
01DF 01DF : CC 10                    word    DIM               ;;$10CC
01E1 01E1 : BE 08                    word    READ              ;;$08BE
01E3 01E3 : 31 07                    word    LET               ;;$0731
01E5 01E5 : DC 06                    word    GOTO              ;;$06DC
01E7 01E7 : BE 06                    word    RUN               ;;$06BE
01E9 01E9 : 9C 07                    word    IFS               ;;$079C
01EB 01EB : 05 0C                    word    RESTOR            ;;$0C05
01ED 01ED : CB 06                    word    GOSUB             ;;$06CB
01EF 01EF : F8 06                    word    RETURN            ;;$06F8
01F1 01F1 : 1E 07                    word    REM               ;;$071E
01F3 01F3 : 1F 0C                    word    STOP              ;;$0C1F
01F5 01F5 : 80 07                    word    ONGOTO            ;;$0780
01F7 01F7 : B5 07                    word    LPRINT            ;;$07B5
01F9 01F9 : 15 1B                    word    COPY              ;;$1B15
01FB 01FB : 3B 0B                    word    DEF               ;;$0B3B
01FD 01FD : 6D 0B                    word    POKE              ;;$0B6D
01FF 01FF : BC 07                    word    PRINT             ;;$07BC
0201 0201 : 4B 0C                    word    CONT              ;;$0C4B
0203 0203 : 6C 05                    word    LIST              ;;$056C
0205 0205 : 67 05                    word    LLIST             ;;$0567
0207 0207 : CD 0C                    word    CLEAR             ;;$0CCD
0209 0209 : 2C 1C                    word    CLOAD             ;;$1C2C
020B 020B : 08 1C                    word    CSAVE             ;;$1C08
020D 020D : 4F 1A                    word    PSET              ;;$1A4F
020F 020F : 4C 1A                    word    PRESET            ;;$1A4C
0211 0211 : D6 1A                    word    SOUND             ;;$1AD6
0213 0213 : BD 0B                    word    SCRATH            ;;$0BBD NEW
0215 0215                    ;;Function Dispatch Table
0215 0215 : F5 14      [M80] FUNDSP: word    SGN               ;;$14F5
0217 0217 : B1 15                    word    INT               ;;$15B1
0219 0219 : 09 15                    word    ABS               ;;$1509
021B 021B : 03 38                    word    USRPOK            ;;$3803 USR()
021D 021D : A8 10                    word    FRE               ;;$10A8
022F 022F : 2E 0B                    word    LPOS              ;;$0B2E
0221 0221 : 33 0B                    word    POS               ;;$0B33
0223 0223 : 75 17                    word    SQR               ;;$1775
0225 0225 : 66 18                    word    RND               ;;$1866
0227 0227 : 85 13                    word    LOG               ;;$1385
0229 0229 : CD 17                    word    EXP               ;;$17CD
022B 022B : D7 18                    word    COS               ;;$18D7
022D 022D : DD 18                    word    SIN               ;;$18DD
022F 022F : 70 19                    word    TAN               ;;$1970
0231 0231 : 85 19                    word    ATN               ;;$1985
0233 0233 : 63 0B                    word    PEEK              ;;$0B63
0235 0235 : F3 0F                    word    LEN               ;;$0FF3
0237 0237 : 29 0E                    word    STR               ;;$0E29
0239 0239 : 84 10                    word    VAL               ;;$1084
023B 023B : 02 10                    word    ASC               ;;$1002
023D 023D : 13 10                    word    CHR               ;;$1013
023F 023F : 21 10                    word    LEFT              ;;$1021
0241 0241 : 50 10                    word    RIGHT             ;;$1050
0243 0243 : 59 10                    word    MID               ;;$1059
0245 0245
0245 0245                  + ;;Statement Tokens
0245 0245                  | ;[M65] TOKENS FOR RESERVED WORDS ALWAYS HAVE THE MOST
0245 0245                  | ;[M65] SIGNIFICANT BIT ON.
0245 0245                  | ;;;The first (or only) character of each keyword has bit 7 set.
0245 0245                  | ;;;In Altair and 6502 Basic, bit 7 was set in the last character
0245 0245 :            [M65] RESLST: ;[M65] THE LIST OF RESERVED WORDS:
0245 0245                    TK      =       $80               ;;Tokens start at 128
0245 0245 :            [M65] ENDTK   equ     TK                ;
0245 0245 : C5 4E 44                 byte    'E'+$80,"ND"      ;;$80
0248 0248                    TK      =            TK+1              
0248 0248 :            [M65] FORTK   equ     TK                ;
0248 0248 : C6 4F 52                 byte    'F'+$80,"OR"      ;;$81
024B 024B                    TK      =            TK+1              
024B 024B : CE 45 58 54              byte    'N'+$80,"EXT"     ;;$82
024F 024F                    TK      =            TK+1              
024F 024F :            [M65] DATATK  equ     TK                ;
024F 024F : C4 41 54 41              byte    'D'+$80,"ATA"     ;;$83
0253 0253                    TK      =            TK+1              
0253 0253 :                  INPUTK  equ     TK                ;
0253 0253 : C9 4E 50 55              byte    'I'+$80,"NPUT"    ;;$84
0257 0257 : 54 
0258 0258                    TK      =            TK+1              
0258 0258 : C4 49 4D                 byte    'D'+$80,"IM"      ;;$85
025B 025B                    TK      =            TK+1              
025B 025B : D2 45 41 44              byte    'R'+$80,"EAD"     ;;$86
025F 025F                    TK      =            TK+1              
025F 025F : CC 45 54                 byte    'L'+$80,"ET"      ;;$87
0262 0262                    TK      =            TK+1              
0262 0262              [M65] GOTOTK  equ     TK                
0262 0262 X                  GOTOTK  equ     $88               ;;The GOTO Token
0262 0262 : C7 4F 54 4F              byte    'G'+$80,"OTO"     ;;$88
0266 0266                    TK      =            TK+1              
0266 0266 : D2 55 4E                 byte    'R'+$80,"UN"      ;;$89
0269 0269                    TK      =            TK+1              
0269 0269 : C9 46                    byte    'I'+$80,"F"       ;;$8A
026B 026B                    TK      =            TK+1              
026B 026B : D2 45 53 54              byte    'R'+$80,"ESTORE"  ;;$8B
026F 026F : 4F 52 45 
0272 0272                    TK      =            TK+1              
0272 0272 :            [M65] GOSUTK  equ     TK                ;
0272 0272 : C7 4F 53 55              byte    'G'+$80,"OSUB"    ;;$8C
0276 0276 : 42 
0277 0277                    TK      =            TK+1              
0277 0277 : D2 45 54 55              byte    'R'+$80,"ETURN"   ;;$8D
027B 027B : 52 4E                                              ;
027D 027D                    TK      =            TK+1              
027D 027D :            [M65] REMTK   equ     TK                ;
027D 027D : D2 45 4D                 byte    'R'+$80,"EM"      ;;$8E
0280 0280                    TK      =            TK+1              
0280 0280 : D3 54 4F 50              byte    'S'+$80,"TOP"     ;;$8F
0282 0282                    TK      =            TK+1              
0284 0284 : CF 4E                    byte    'O'+$80,"N"       ;;$90
0286 0286                    TK      =            TK+1              
0286 0286 : CC 50 52 49              byte    'L'+$80,"PRINT"   ;;$91
028A 028A : 4E 54                                              ;
028C 028C                    TK      =            TK+1              
028C 028C : C3 4F 50 59              byte    'C'+$80,"OPY"     ;;$92
0290 0290                    TK      =            TK+1              
0290 0290 : C4 45 46                 byte    'D'+$80,"EF"      ;;$93
0293 0293                    TK      =            TK+1              
0293 0293 : D0 4F 4B 45              byte    'P'+$80,"OKE"     ;;$94
0297 0297                    TK      =            TK+1              
0297 0297 :            [M65] PRINTK  equ     TK                ;
0297 0297 : D0 52 49 4E              byte    'P'+$80,"RINT"    ;;$95
029B 029B : 54 
029C 029C                    TK      =            TK+1              
029C 029C : C3 4F 4E 54              byte    'C'+$80,"ONT"     ;;$96
02A0 02A0                    TK      =            TK+1              
02A0 02A0 : CC 49 53 54              byte    'L'+$80,"IST"     ;;$97
02A4 02A4                    TK      =            TK+1              
02A4 02A4 : CC 4C 49 53              byte    'L'+$80,"LIST"    ;;$98
02A8 02A8 : 54 
02A9 02A9                    TK      =            TK+1              
02A9 02A9 : C3 4C 45 41              byte    'C'+$80,"LEAR"    ;;$99
02AD 02AD : 52 
02AE 02AE                    TK      =            TK+1              
02AE 02AE : C3 4C 4F 41              byte    'C'+$80,"LOAD"    ;;$9A
02B2 02B2 : 44 
02B3 02B3                    TK      =            TK+1              
02B3 02B3 : C3 53 41 56              byte    'C'+$80,"SAVE"    ;;$9B
02B7 02B7 : 45 
02B8 02B8                    TK      =            TK+1              
02B8 02B8 T                  PSETTK  equ     $9C               ;;The PSET Token
02B8 02B8 : D0 53 45 54              byte    'P'+$80,"SET"     ;;$9C
02BC 02BC                    TK      =            TK+1              
02B8 02B8 T                  PRESTK  equ     $9D               ;;The PRESET Token
02BC 02BC : D0 52 45 53              byte    'P'+$80,"RESET"   ;;$9D
02C0 02C0 : 45 54                                              ;
02C2 02C2                    TK      =            TK+1              
02C2 02C2 : D3 4F 55 4E              byte    'S'+$80,"OUND"    ;;$9E
02C6 02C6 : 44 
02C7 02C7                    TK      =            TK+1              
02C7 02C7 :            [M65] SCRATK  equ     TK                ;
02C7 02C7 : CE 45 57                 byte    'N'+$80,"EW"      ;;$9F
02CA 02CA                    TK      =            TK+1              
02CA 02CA :                  ;[M65] END OF COMMAND LIST        ;
02CA 02CA :                  TABTK   equ     TK                ;
02CA 02CA : D4 41 42 28              byte    'T'+$80,"AB("     ;;$A0
02CE 02CE                    TK      =            TK+1              
02CE 02CE :            [M80] TOTK    equ     TK                ;
02CE 02CE : D4 4F                    byte    'T'+$80,"O"       ;;$A1
02D0 02D0                    TK      =            TK+1              
02CA 02CA :            [M80] FNTK    equ     TK                ;
02D0 02D0 T                  FNTK    equ     $A2               ;;The FN Token
02D0 02D0 : C6 4E                    byte    'F'+$80,"N"       ;;$A2
02D2 02D2                    TK      =            TK+1              
02D2 02D2 :                  SPCTK   equ     TK                ;
02D2 02D2 : D3 50 43 28              byte    'S'+$80,"PC("     ;;$A3
02D6 02D6                    TK      =            TK+1              
02D6 02D6 :                  INKETK  equ     TK                ;
02D6 02D6 : C9 4E 4B 45              byte    'I'+$80,"NKEY$"   ;;$A4
02DA 02DA : 59 24  
02DC 02DC                    TK      =            TK+1              
02DC 02DC :            [M65] THENTK  equ     TK                ;
02DC 02DC : D4 48 45 4E              byte    'T'+$80,"HEN"     ;;$A5
02E0 02E0                    TK      =            TK+1              
02E0 02E0 :            [M80] NOTTK   equ     TK                ;
02E0 02E0 : CE 4F 54                 byte    'N'+$80,"OT"      ;;$A6
02E3 02E3                    TK      =            TK+1              
02E3 02E3 :            [M65] STEPTK  equ     TK                ;
02E3 02E3 T                  STEPTK  equ     $A7               ;;The STEP Token
02E3 02E3 : D3 54 45 50              byte    'S'+$80,"TEP"     ;;$A7
02E7 02E7                    TK      =            TK+1              
02E7 02E7  
02E7 02E7 :                  ;;Operators                           
02E7 02E7 :            [M80] PLUSTK  equ     TK                ;
02E7 02E7 : AB                       byte    '+'+$80           ;;$A8 plus
02E8 02E8                    TK      =            TK+1              
02E8 02E8 :            [M80] MINUTK  equ     TK                ;
02E8 02E8 T                  MINUTK  equ     $A9               ;The - Token
02E8 02E8 : AD                       byte    '-'+$80           ;;$A9 minus
02E9 02E9                    TK      =            TK+1              
02E9 02E9 :            [M80] MULTK   equ     TK                ;
02E9 02E9 : AA                       byte    '*'+$80           ;;$AA times
02EA 02EA                    TK      =            TK+1              
02EA 02EA :            [M80] DIVTK   equ     TK                ;
02EA 02EA : AF                       byte    '/'+$80           ;;$AB divide
02EB 02EB                    TK      =            TK+1              
02EB 02EB :            [M80] EXPTK   equ     TK                ;
02EB 02EB : DE                       byte    '^'+$80           ;;$AC
02EC 02EC                    TK      =            TK+1              
02EC 02EC :                  ANDTK   equ     TK                
02EC 02EC T                  ANDTK   equ     $AD               ;;The AND Token
02EC 02EC : C1 4E 44                 byte    'A'+$80,"ND"      ;;$AD
02EF 02EF                    TK      =            TK+1              
02EF 02EF :                  ORTK    equ     TK                
02EF 02EF T                  ORTK    equ     $AE               ;;The OR Token
02EF 02EF : CF 52                    byte    'O'+$80,"R"       ;;$AE
02F1 02F1                    TK      =            TK+1              
02F1 02F1 :            [M80] GREATK  equ     TK                ;
02F1 02F1 : BE                       byte    '>'+$80           ;;$AF greater than
02F2 02F2                    TK      =            TK+1              
02F2 02F2              [M80] EQUATK  equ     TK                
02F2 02F2 T                  EQUATK  equ     $B0               ;;The Equals Token
02F2 02F2 : BD                       byte    '='+$80           ;;$B0 equals
02F3 02F3                    TK      =            TK+1              
02F3 02F3 :            [M80] LESSTK  equ     TK                ;
02F3 02F3 : BC                       byte    '<'+$80           ;;$B1 less than
02F3 02F3                    TK      =            TK+1              
02F4 02F4
02F4 02F4 :                + ;;Functions
02F4 02F4 :                | ;[M65] NOTE DANGER OF ONE RESERVED WORD BEING A PART
02F4 02F4 :                | ;[M65] OF ANOTHER:
02F4 02F4 :                | ;[M65] IE . . IF 2 GREATER THAN F OR T=5 THEN...
02F4 02F4 :                | ;[M65] WILL NOT WORK!!! SINCE "FOR" WILL BE CRUNCHED!!
02F4 02F4 :                | ;[M65] IN ANY CASE MAKE SURE THE SMALLER WORD APPEARS
02F4 02F4 :                | ;[M65] SECOND IN THE RESERVED WORD TABLE ("INP" AND "INPUT")
02F4 02F4 :                | ;[M65] ANOTHER EXAMPLE: IF T OR Q THEN ... "TO" IS CRUNCHED
02F4 02F4 :            [M65] ONEFUN  equ     TK                ;;*** This might go after SGN
02F4 02F4 : D3 47 4E                 byte    'S'+$80,"GN"      ;;$B2
02F7 02F7                    TK      =            TK+1              
02F7 02F7 : C9 4E 54                 byte    'I'+$80,"NT"      ;;$B3
02FA 02FA                    TK      =            TK+1              
02FA 02FA : C1 42 53                 byte    'A'+$80,"BS"      ;;$B4
02FD 02FD                    TK      =            TK+1              
02FD 02FD : D5 53 52                 byte    'U'+$80,"SR"      ;;$B5
0300 0300                    TK      =            TK+1              
0300 0300 : C6 52 45                 byte    'F'+$80,"RE"      ;;$B6
0303 0303                    TK      =            TK+1              
0303 0303 : CC 50 4F 53              byte    'L'+$80,"POS"     ;;$B7
0307 0307                    TK      =            TK+1              
0307 0307 : D0 4F 53                 byte    'P'+$80,"OS"      ;;$B8
030A 030A                    TK      =            TK+1              
030A 030A : D3 51 52                 byte    'S'+$80,"QR"      ;;$B9
030D 030D                    TK      =            TK+1              
030D 030D : D2 4E 44                 byte    'R'+$80,"ND"      ;;$BA
0310 0310                    TK      =            TK+1              
0310 0310 : CC 4F 47                 byte    'L'+$80,"OG"      ;;$BB
0313 0313                    TK      =            TK+1              
0313 0313 : C5 58 50                 byte    'E'+$80,"XP"      ;;$BC
0316 0316                    TK      =            TK+1              
0316 0316 : C3 4F 53                 byte    'C'+$80,"OS"      ;;$BD
0319 0319                    TK      =            TK+1              
0319 0319 : D3 49 4E                 byte    'S'+$80,"IN"      ;;$BE
031C 031C                    TK      =            TK+1              
031C 031C : D4 41 4E                 byte    'T'+$80,"AN"      ;;$BF
031F 031F                    TK      =            TK+1              
031F 031F : C1 54 4E                 byte    'A'+$80,"TN"      ;;$C0
0322 0322                    TK      =            TK+1              
0322 0322 : D0 45 45 4B              byte    'P'+$80,"EEK"     ;;$C1
0326 0326                    TK      =            TK+1              
0326 0326 : CC 45 4E                 byte    'L'+$80,"EN"      ;;$C2
0329 0329                    TK      =            TK+1              
0329 0329 : D3 54 52 24              byte    'S'+$80,"TR$"     ;;$C3
032D 032D                    TK      =            TK+1              
032D 032D : D6 41 4C                 byte    'V'+$80,"AL"      ;;$C4
0330 0330                    TK      =            TK+1              
0330 0330 : C1 53 43                 byte    'A'+$80,"SC"      ;;$C5
0333 0333                    TK      =            TK+1              
0333 0333                    CHRTK   equ     TK  
0333 0333 : C3 48 52 24              byte    'C'+$80,"HR$"     ;;$C6
0337 0337                    TK      =            TK+1              
0337 0337 : CC 45 46 54              byte    'L'+$80,"EFT$"    ;;$C7
033B 033B : 24 
033C 033C                    TK      =            TK+1              
033C 033C : D2 49 47 48              byte    'R'+$80,"IGHT$"   ;;$C8
0340 0340 : 54 24  
0342 0342                    TK      =            TK+1              
0342 0342 : CD 49 44 24              byte    'M'+$80,"ID$"     ;;$C9
0346 0346                    TK      =            TK+1              
0346 0346                    POINTK  equ     TK  
0346 0346 X                  POINTK  equ     $CA               ;;The POINT Token
0346 0346 : D0 4F 49 4E              byte    'P'+$80,"OINT"    ;;$CA
034A 034A : 54
034B 034B 
;;The token crunching routine stops here, but the token expansion routine does not
;;so any 'tokens' above $CA will produce strange results when LISTed
034B 034B : 80                       byte    $80               ;;End of List Marker
034C034C
034C 034C                    ;OPERATOR TABLE CONTAINS PRECEDENCE FOLLOWED BY THE ROUTINE ADDRESS
034C 034C : 79         [M80] OPTAB:  byte    121               ;ADD
034D 034D : 5C 16                    word    FADDT             ;
034F 034F : 79                       byte    121               ;SUBTRACT
0350 0350 : 5C 12                    word    FSUBT             ;
0352 0352 : 7C                       byte    124               ;MULTIPLY
0353 0353 : C9 13                    word    FMULTT            ;
0355 0355 : 7C                       byte    124               ;DIVIDE
0356 0356 : 2D 14                    word    FDIVT             ;
0358 0358 : 7F                       byte    127               ;POWER
0359 0359 : 7E 17                    word    FPWRT             ;
035B 035B : 50                       byte    80                ;AND
035C 035C : A9 0A                    word    ANDOP             ;
035E 035E : 46                       byte    70                ;OR
035F 035F : A8 0A                    word    OROP              ;    
0361 0361
0361 0361                    ;{M80} NEEDED FOR MESSAGES
0361 0361
0361 0361 : 20 45 72 72[M65] ERR:    byte    " Error",7,0    
0365 0365 : 6F 72 07 00
0369 0369
0369 0369 : 20 69 6E 20[M65] INTXT:  byte    " in ",0        
036C 036C : 00
036E 036E
036E 036E : 4F 6B 0D 0A[M80] REDDY:  byte    "Ok",13,10,0      ;;FINZER and NULRT rely on REDDY-1 being a 0!
0372 0372 : 00
0373 0373
0373 0373 : 42 72 65 61[M80] BRKTXT: byte    "Break",0
0377 0377 : 6B 00
0379 0379
0379 0379                  + ; [M65] ERROR MESSAGES
0379 0379                  | ; [M65] WHEN AN ERROR CONDITION IS DETECTED,
0379 0379                  | ; [M65] [ACCX] MUST BE SET UP TO INDICATE WHICH ERROR
0379 0379                  | ; [M65] MESSAGE IS APPROPRIATE AND A BRANCH MUST BE MADE
0379 0379                  | ; [M65] TO "ERROR". THE STACK WILL BE RESET AND ALL
0379 0379                  | ; [M65] PROGRAM CONTEXT WILL BE LOST. VARIABLES
0379 0379                  | ; [M65] VALUES AND THE ACTUAL PROGRAM REMAIN INTACT.
0379 0379                  | ; [M65] ONLY THE VALUE OF [ACCX] IS IMPORTANT WHEN
0379 0379                  | ; [M65] THE BRANCH IS MADE TO ERROR. [ACCX] IS USED AS AN
0379 0379                  | ; [M65] INDEX INTO "ERRTAB" WHICH GIVES THE TWO
0379 0379                  | ; [M65] CHARACTER ERROR MESSAGE THAT WILL BE PRINTED ON THE
0379 0379                  | ; [M65] USER'S TERMINAL.
0379 0379                  | ;
0379 0379 :            [M80] ERRTAB: ;;List OF Error Messages
0379 0379 :            [M80] ERRNF   equ     *-ERRTAB          ;;$00
0379 0379 : 4E 46                    byte    "NF"              ;[M80] NEXT without FOR
037B 037B :            [M80] ERRSN   equ     *-ERRTAB          ;;$02
037B 037B : 53 4E                    byte    "SN"              ;[M80] Syntax error
037D 037D :            [M80] ERRRG   equ     *-ERRTAB          ;;$04
037D 037D : 52 47                    byte    "RG"              ;[M80] RETURN without GOSUB
037F 037F :            [M80] ERROD   equ     *-ERRTAB          ;;$06
037F 037F : 4F 44                    byte    "OD"              ;[M80] Out of DATA
0381 0381 :            [M80] ERRFC   equ     *-ERRTAB          ;;$08
0381 0381 : 46 43                    byte    "FC"              ;[M80] Illegal function call
0383 0383 :            [M80] ERROV   equ     *-ERRTAB          ;;$0A
0383 0383 : 4F 56                    byte    "OV"              ;[M80] Overflow
0385 0385 :            [M80] ERROM   equ     *-ERRTAB          ;;$0C
0385 0385 : 4F 4D                    byte    "OM"              ;[M80] Out of memory
0387 0387 :            [M80] ERRUS   equ     *-ERRTAB          ;;$0E
0387 0387 : 55 4C                    byte    "UL"              ;[M80] Undefined line number
0389 0389              [M80] ERRBS   equ     *-ERRTAB          ;;$10
0389 0389 : 42 53                    byte    "BS"              ;[M80] Subscript out of range
038B 038B              [M80] ERRDDS  equ     *-ERRTAB          ;;$12
038B 038B : 44 44                    byte    "DD"              ;[M80] Duplicate Definition
038D 038D              [M80] ERRDV0  equ     *-ERRTAB          ;;$14
038D 038D : 2F 30                    byte    "/0"              ;[M80] Division by zero
038F 038F              [M80] ERRID   equ     *-ERRTAB          ;;$16
038F 038F : 49 44                    byte    "ID"              ;[M80] Illegal direct
0391 0391              [M80] ERRTM   equ     *-ERRTAB          ;;$18
0391 0391 : 54 4D                    byte    "TM"              ;[M80] Type mismatch
0393 0393              [M80] ERRSO   equ     *-ERRTAB          ;;$1A
0393 0393 : 4F 53                    byte    "OS"              ;[M80] Out of string space
0395 0395              [M80] ERRLS   equ     *-ERRTAB          ;;$1C
0395 0395 : 4C 53                    byte    "LS"              ;[M80] String too long
0397 0397              [M80] ERRST   equ     *-ERRTAB          ;;$1E
0397 0397 : 53 54                    byte    "ST"              ;[M80] String formula too complex
0399 0399              [M80] ERRCN   equ     *-ERRTAB          ;;$20
0399 0399 : 43 4E                    byte    "CN"              ;[M80] Can't continue
039B 039B              [M80] ERRUF   equ     *-ERRTAB          ;;$22
039B 039B : 55 46                    byte    "UF"              ;[M80] Undefined user function
039D 039D              [M80] ERRMO   equ     *-ERRTAB          ;;$24
039D 039D : 4D 4F                    byte    "MO"              ;[M80] Missing operand
039F 039F
039F 039F                  + ;[M80] FIND A "FOR" ENTRY ON THE STACK WITH THE VARIABLE POINTER PASSED IN [D,E]
039F 039F                  | ;[M65] MOST SMALL ROUTINES ARE FAIRLY SIMPLE
039F 039F                  | ;[M65] AND ARE DOCUMENTED IN PLACE. "FNDFOR" IS
039F 039F                  | ;[M65] USED FOR FINDING "FOR" ENTRIES ON
039F 039F                  | ;[M65] THE STACK. WHENEVER A "FOR" IS EXECUTED, A
039F 039F                  | ;[M65] 16-BYTE ENTRY IS PUSHED ONTO THE STACK.
039F 039F                  | ;[M65] BEFORE THIS IS DONE, HOWEVER, A CHECK
039F 039F                  | ;[M65] MUST BE MADE TO SEE IF THERE
039F 039F                  | ;[M65] ARE ANY "FOR" ENTRIES ALREADY ON THE STACK
039F 039F                  | ;[M65] FOR THE SAME LOOP VARIABLE. IF SO, THAT "FOR" ENTRY
039F 039F                  | ;[M65] AND ALL OTHER "FOR" ENTRIES THAT WERE MADE AFTER IT
039F 039F                  | ;[M65] ARE ELIMINATED FROM THE STACK. THIS IS SO A
039F 039F                  | ;[M65] PROGRAM THAT JUMPS OUT OF THE MIDDLE
039F 039F                  | ;[M65] OF A "FOR" LOOP AND THEN RESTARTS THE LOOP AGAIN
039F 039F                  | ;[M65] AND AGAIN WON'T USE UP 18 BYTES OF STACK
039F 039F                  | ;[M65] SPACE EVERY TIME. THE "NEXT" CODE ALSO
039F 039F                  | ;[M65] CALLS "FNDFOR" TO SEARCH FOR A "FOR" ENTRY WITH
039F 039F                  | ;[M65] THE LOOP VARIABLE IN
039F 039F                  | ;[M65] THE "NEXT". AT WHATEVER POINT A MATCH IS FOUND
039F 039F                  | ;[M65] THE STACK IS RESET. IF NO MATCH IS FOUND A
039F 039F                  | ;[M65] "NEXT WITHOUT FOR"  ERROR OCCURS. GOSUB EXECUTION
039F 039F                  | ;[M65] ALSO PUTS A 5-BYTE ENTRY ON STACK.
039F 039F                  | ;[M65] WHEN A RETURN IS EXECUTED "FNDFOR" IS
039F 039F                  | ;[M65] CALLED WITH A VARIABLE POINTER THAT CAN'T
039F 039F                  | ;[M65] BE MATCHED. WHEN "FNDFOR" HAS RUN
039F 039F                  | ;[M65] THROUGH ALL THE "FOR" ENTRIES ON THE STACK  
039F 039F                  | ;[M65] IT RETURNS AND THE RETURN CODE MAKES
039F 039F                  | ;[M65] SURE THE ENTRY THAT WAS STOPPED
039F 039F                  | ;[M65] ON IS A GOSUB ENTRY. THIS ASSURES THAT
039F 039F                  | ;[M65] IF YOU GOSUB TO A SECTION OF CODE
039F 039F                  | ;[M65] IN WHICH A FOR LOOP IS ENTERED BUT NEVER
039F 039F                  | ;[M65] EXITED THE RETURN WILL STILL BE
039F 039F                  | ;[M65] ABLE TO FIND THE MOST RECENT
039F 039F                  | ;[M65] GOSUB ENTRY. THE "RETURN" CODE ELIMINATES THE
039F 039F                  | ;[M65] "GOSUB" ENTRY AND ALL "FOR" ENTRIES MADE AFTER
039F 039F                  | ;[M65] THE GOSUB ENTRY.
039F 039F                  | ;
039F 039F :            [M80] FORSIZ  equ     13                ;;Size of a FOR entry on the stack
039F 039F
039F 039F : 21 04 00   [M80] FNDFOR: ld      hl,4+0            ;[M80] IGNORING THE RETURN ADDRESS OF                      --BC--  --DE--  --HL--  Stack
03A2 03A2 : 39                       add     hl,sp             ;[M80] THIS SUBROUTINE, SET [H,L]=SP                                       StkPtr
03A3 03A3 : 7E         [M80] LOOPER: ld      a,(hl)            ;[M80] SEE WHAT TYPE OF THING IS ON THE STACK              
03A4 03A4 : 23                       inc     hl                ;                                                                           SP+1   SP+3
03A5 03A5 : FE 81                    cp      FORTK             ;[M80] IS THIS STACK ENTRY A "FOR"?
03A7 03A7 : C0                       ret     nz                ;[M80] NO SO OK
03A8 03A8 : 4E                       ld      c,(hl)            ;[M80] DO EQUIVALENT OF PUSHM / XTHL                                        
03A9 03A9 : 23                       inc     hl                ;                                                                           SP+2
03AA 03AA : 46                       ld      b,(hl)            ;                                                          (SP+1)                 
03AB 03AB : 23                       inc     hl                ;                                                                           SP+3   
03AC 03AC : E5                       push    hl                ;[M80] PUT H  ON                                                                   SP+3
03AD 03AD : 60                       ld      h,b               ;[M80] PUSH B / XTHL IS SLOWER
03AE 03AE : 69                       ld      l,c               ;
03AF 03AF : 7A                       ld      a,d               ;[M80] FOR THE "NEXT" STATMENT WITHOUT AN ARGUMENT
03B0 03B0 : B3                       or      e                 ;[M80] WE MATCH ON ANYTHING
03B1 03B1 : EB                       ex      de,hl             ;[M80] MAKE SURE WE RETURN [D,E]
03B2 03B2 : 28 02                    jr      z,POPGOF          ;[M80] POINTING TO THE VARIABLE
03B4 03B4 : EB                       ex      de,hl             ;
03B5 03B5 : E7                       rst     COMPAR            ;
03B6 03B6 : 01 0D 00   [M80] POPGOF: ld      bc,FORSIZ         ;[M80] TO WIPE OUT A "FOR" ENTRY
03B9 03B9 : E1                       pop     hl                ;[M80] IF VARIABLE IN THIS ENTRY MATCHES RETURN
03BA 03BA : C8                       ret     z                 ;[M80] WITH [H,L] POINTING THE BOTTOM OF THE ENTRY
03BB 03BB : 09                       add     hl,bc             ;[M80] NOW POINTING TO THE START OF THE NEXT ENTRY.
03BC 03BC : 18 E5                    jr      LOOPER            ;[M80] SEE IF ITS A "FOR" ENTRY AND IF THE VARIABLE MATCHES
03BE 03BE  
03BE 03BE : 2A C9 38   [M80] DATSNE: ld      hl,(DATLIN)       ;[M80] GET DATA LINE
03C1 03C1 : 22 4D 38                 ld      (CURLIN),hl       ;[M80] MAKE IT CURRENT LINE
03C4 03C4 = 1E 02      [M80] SNERR:  ld      e,ERRSN           ;[M80] "SYNTAX ERROR"
03C6 03C6 : 01                       byte    $01               ;[M80] "LD BC," OVER THE NEXT 2
03C7 03C7 : 1E 14      [M80] DV0ERR: ld      e,ERRDV0          ;[M80] DIVISION BY ZERO
03C9 03C9 : 01                       byte    $01               ;[M80] "LD BC," OVER THE NEXT 2
03CA 03CA : 1E 00      [M80] NFERR:  ld      e,ERRNF           ;[M80] "NEXT WITHOUT FOR" ERROR
03CC 03CC : 01                       byte    $01               ;[M80] "LD BC," OVER THE NEXT 2
03CD 03CD : 1E 12      [M80] DDERR:  ld      e,ERRDDS          ;[M80] "REDIMENSIONED VARIABLE"
03CF 03CF : 01                       byte    $01               ;[M80] "LD BC," OVER THE NEXT 2
03D0 03D0 = 1E 22      [M80] UFERR:  ld      e,ERRUF           ;[M80] "UNDEFINED FUNCTION" ERROR
03D2 03D2 : 01                       byte    $01               ;[M80] "LD BC," OVER THE NEXT 2
03D3 03D3 : 1E 0A      [M80] OVERR:  ld      e,ERROV           ;;      Overflow Error
03D5 03D5 : 01                       byte    $01               ;[M80] "LD BC," OVER THE NEXT 2
03D6 03D6 : 1E 24      [M80] MOERR:  ld      e,ERRMO           ;;     Missing Operand
03D8 03D8 : 01                       byte    $01               ;[M80] "LD BC," OVER THE NEXT 2
03D9 03D9 : 1E 18      [M80] TMERR:  ld      e,ERRTM           ;[M80] TYPE MISMATCH ERROR
03DB 03DB  
03DB 03DB : CD E5 0B   [M80] ERROR:  call    STKINI            ;
03DE 03DE : F7                       rst     HOOKDO            ;;call Hook Service Routine
03DF 03DF : 00         {~~~} HOOK0:  byte    0                 ;
03E0 03E0 : CD DE 19   (M65) ERRCRD: call    CRDONZ            ;
03E3 03E3 : 21 79 03                 ld      hl,ERRTAB         ;
03E6 03E6 : F7         {~~~} ERRCRH: rst     HOOKDO            ;;call Hook Service Routine
03E7 03E7 : 01         {~~~} HOOK1:  byte    1                 ;
03E8 03E8 : 57                       ld      d,a               ;;Add Error Offset
03E9 03E9 : 19                       add     hl,de             ;
03EA 03EA : 3E 3F                    ld      a,'?'             ;[M65] PRINT A QUESTION MARK
03EC 03EC : DF                       rst     OUTCHR            ;
03ED 03ED : 7E         (M80) ERRFIN: ld      a,(hl)            ;[M65] GET FIRST CHR OF ERR MSG.
03EE 03EE : DF                       rst     OUTCHR            ;[M65] OUTPUT IT.
03EF 03EF : D7                       rst     CHRGET            ;[M65] GET SECOND CHR.
03F0 03F0 : DF                       rst     OUTCHR            ;[M65] OUTPUT IT.
03F1 03F1 : 21 61 03                 ld      hl,ERR            ;;" Error"
03F4 03F4 : CD 9D 0E   [M80] ERRFN1: call    STROUT            ;[M80] PRINT MESSAGE
03F7 03F7 : 2A 4D 38                 ld      hl,(CURLIN)       ;[M80] RESTORE LINE NUMBER
03FA 03FA : 7C                       ld      a,h               ;[M80] SEE IF IN DIRECT MODE
03FB 03FB : A5                       and     l                 ;
03FC 03FC : 3C                       inc     a                 ;[M80] ZERO SAYS DIRECT MODE
03FD 03FD : C4 6D 16                 call    nz,INPRT          ;[M80] PRINT LINE NUMBER IN [H,L]
0400 0400 : 3E                       byte    $3E               ;[M80] SKIP THE NEXT BYTE WITH "MVI A,0"
0401 0401
0401 0401                  - ;[M80] FOR "LIST" COMMAND STOPPING
0401 0401 : C1         [M80] STPRDY: pop     bc                      
0402 0402  
0402 0402 -                  ;;Enter Immediate Mode
0402 0402 = F7         [M80] READY:  rst     HOOKDO            ;;Call hook routine
0403 0403 : 02         {~~~} HOOK2:  byte    2                 ;
0404 0404 : CD BE 19                 call    FINLPT            ;[M80] PRINT ANY LEFT OVERS
0407 0407 : AF                       xor     a                 ;
0408 0408 : 32 08 38                 ld      (CNTOFL),a        ;[M80] FORCE OUTPUT
040B 040B : CD DE 19                 call    CRDONZ            ;[M80] IF NOT ALREADY AT LEFT, SEND CRLF
040E 040E : 21 6E 03                 ld      hl,REDDY          ;[M80] "OK" CRLF CRLF
0411 0411 : CD 9D 0E                 call    STROUT            ;
0414 0414                                                      ;
0414 0414 : 21 FF FF   [M80] MAIN:   ld      hl,$FFFF          ;
0417 0417 : 22 4D 38                 ld      (CURLIN),hl       ;[M80] SETUP CURLIN FOR DIRECT MODE
;;;GW-BASIC and CP/M Basic have Automatic Line Numbering Logic here
041A 041A : CD 85 0D   {M80} NTAUTO: call    INLIN             ;[M80] GET A LINE FROM TTY
041D 041D : 38 F5                    jr      c,MAIN            ;[M80] IGNORE ^C S
041F 041F : D7                       rst     CHRGET            ;[M80] GET THE FIRST
0420 0420 : 3C                       inc     a                 ;[M80] SEE IF 0 SAVING THE CARRY FLAG
0421 0421 : 3D                       dec     a                 ;
0422 0422 : 28 F0                    jr      z,MAIN            ;[M80] IF SO, A BLANK LINE WAS INPUT
0424 0424 : F5                       push    af                ;[M80] SAVE STATUS INDICATOR FOR 1ST CHARACTER
0425 0425 : CD 9C 06   {M65} MAIN1:  call    SCNLIN            ;[M80] READ IN A LINE #
;;;GW-BASIC snd CP/M Basic have extra logic here           ;
0428 0428 -                  ;;Tokenize Entered Line
0428 0428 = D5         [M80] EDENT:  push    de                ;[M80] SAVE LINE #
0429 0429 : CD BC 04                 call    CRUNCH            ;[M80] CRUNCH THE LINE DOWN
042C 042C : 47                       ld      b,a               ;[M65] RETAIN CHARACTER COUNT.
042D 042D : D1                       pop     de                ;[M80] RESTORE LINE #
042E 042E : F1                       pop     af                ;[M80] WAS THERE A LINE #?
042F 042F : F7                       rst     HOOKDO            ;;Call Hook Dispatch Routine
0430 0430 : 03         {~~~} HOOK3:  byte    3                 ;
0431 0431 : D2 4B 06                 jp      nc,GONE           ;
0434 0434 : D5                       push    de                ;
0435 0435 : C5                       push    bc                ;[M80] SAVE LINE # AND CHARACTER COUNT
0436 0436 : AF                       xor     a                 ;
0437 0437 : 32 CC 38                 ld      (USFLG),a         ;{M80} RESET THE FLAG
043A 043A : D7                       rst     CHRGET            ;[M80] REMEMBER IF THIS LINE IS
043B 043B : B7                       or      a                 ;[M80] SET THE ZERO FLAG ON ZERO
043C 043C : F5                       push    af                ;[M80] BLANK SO WE DON'T INSERT IT
043D 043D : CD 9F 04                 call    FNDLIN            ;[M80] GET A POINTER TO THE LINE
0440 0440 : 38 06                    jr      c,LEXIST          ;[M80] LINE EXISTS, DELETE IT
0442 0442 : F1                       pop     af                ;[M80] GET FLAG SAYS WHETHER LINE BLANK
0443 0443 : F5                       push    af                ;[M80] SAVE BACK
0444 0444 : CA F3 06                 jp      z,USERR           ;[M80] SAVE BACK
0447 0447 : B7                       or      a                 ;[M80] TRYING TO DELETE NON-EXISTANT LINE, ERROR
0448 0448 : C5         (M80) LEXIST: push    bc                ;[M80] SAVE THE POINTER
0449 0449 : 30 10                    jr      nc,NODEL          ;
0FFB 0FFB                    ;[M80] DELETE THE LINE
044B 044B : EB         {M80} DEL:    ex      de,hl             ;[M80] [D,E] NOW HAVE THE POINTER TO NEXT LINE
044C 044C : 2A D6 38                 ld      hl,(VARTAB)       ;[M80] COMPACTIFYING TO VARTAB
044F 044F : 1A         (M80) MLOOP:  ld      a,(de)            ;
0450 0450 : 02                       ld      (bc),a            ;[M80] SHOVING DOWN TO ELIMINATE A LINE
0451 0451 : 03                       inc     bc                ;
0452 0452 : 13                       inc     de                ;
0453 0453 : E7                       rst     COMPAR            ;
0454 0454 : 20 F9                    jr      nz,MLOOP          ;[M80] DONE COMPACTIFYING?
0456 0456 : 60                       ld      h,b               ;
0457 0457 : 69                       ld      l,c               ;;HL = new end of program
0458 0458 : 22 D6 38                 ld      (VARTAB),hl       ;[M65] SETUP [VARTAB]
045B 045B : D1         (M80) NODEL:  pop     de                ;[M80] POP POINTER AT PLACE TO INSERT
045C 045C : F1                       pop     af                ;[M80] SEE IF THIS LINE HAD ANYTHING ON IT
045D 045D : 28 21                    jr      z,FINI            ;[M80] IF NOT DON'T INSERT
045F 045F : 2A D6 38   (M80) LEVFRE: ld      hl,(VARTAB)       ;[M80] CURRENT END
0462 0462 : E3                       ex      (sp),hl           ;[M80] [H,L]=CHARACTER COUNT. VARTAB ONTO STACK
0463 0463 : C1                       pop     bc                ;[M80] [B,C]=OLD VARTAB
0464 0464 : 09                       add     hl,bc             ;
0465 0465 : E5                       push    hl                ;[M80] SAVE NEW VARTAB
0466 0466 : CD 92 0B                 call    BLTU              ;;Create space for new line
0469 0469 : E1                       pop     hl                ;[M80] POP OFF VARTAB
046A 046A : 22 D6 38                 ld      (VARTAB),hl       ;[M80] UPDATE VARTAB
046D 046D : EB                       ex      de,hl             ;
046E 046E : 74                       ld      (hl),h            ;[M80] FOOL CHEAD WITH NON-ZERO LINK
046F 046F : D1                       pop     de                ;[M80] GET LINE # OFF STACK
0470 0470 : 23                       inc     hl                ;[M80] SO IT DOESN'T THINK THIS LINK
0471 0471 : 23                       inc     hl                ;[M80] IS THE END OF THE PROGRAM
0472 0472 : 73                       ld      (hl),e            ;
0473 0473 : 23                       inc     hl                ;[M80] PUT DOWN LINE #
0474 0474 : 72                       ld      (hl),d            ;
0475 0475 : 23                       inc     hl                ;
0476 0476 : 11 60 38                 ld      de,BUF            ;[M80] MOVE LINE FRM BUF TO PROGRAM AREA
0479 0479 : 1A         (M80) MLOOPR: ld      a,(de)            ;[M80] NOW TRANSFERING LINE IN FROM BUF
047A 047A : 77                       ld      (hl),a            ;
047B 047B : 23                       inc     hl                ;
047C 047C : 13                       inc     de                ;
047D 047D : B7                       or      a                 ;;If not line terminator, keep going
047E 047E : 20 F9                    jr      nz,MLOOPR         ;
0480 0480
0480 0480 : F7         [M80] FINI:   rst     HOOKDO            ;
0481 0481 : 04         {~~~} HOOK4:  byte    4                 ;
0482 0482 : CD CB 0B                 call    RUNC              ;[M80] DO CLEAR & SET UP STACK 
0485 0485 : F7         {M80} LINKER: rst     HOOKDO            ;
0486 0486 : 05         {~~~} HOOK5:  byte    5                 ;
0487 0487 : 23                       inc     hl                ;;HL=TXTTAB
0488 0488 : EB                       ex      de,hl             ;;DE=TXTTAB
0489 0489
0489 0489                  + ;;Fix Basic Line Links 
0489 0489                  | ;[M80] CHEAD GOES THROUGH PROGRAM STORAGE AND FIXES
0489 0489                  | ;[M80] UP ALL THE LINKS. THE END OF EACH
0489 0489                  | ;[M80] LINE IS FOUND BY SEARCHING FOR THE ZERO AT THE END.
0489 0489                  | ;[M80] THE DOUBLE ZERO LINK IS USED TO DETECT THE END OF THE PROGRAM
0489 0489                  | ;
0489 0489 : 62         [M80] CHEAD:  ld      h,d               ;[H,L]=[D,E]
048A 048A : 6B                       ld      l,e               ;
048B 048B : 7E                       ld      a,(hl)            ;[M80] SEE IF END OF CHAIN
048C 048C : 23                       inc     hl                ;[M80] BUMP POINTER
048D 048D : B6                       or      (hl)              ;[M80] 2ND BYTE
048E 048E : CA 14 04                 jp      z,MAIN            ;
0491 0491 : 23                       inc     hl                ;[M80] FIX HL TO START OF TEXT
0492 0492 : 23                       inc     hl                ;
0493 0493 : 23                       inc     hl                ;
0494 0494 : AF                       xor     a                 ;SET CC'S
0495 0495 : BE         (M80) CZLOOP: cp      (hl)              ;;Skip to end of Basic line
0496 0496 : 23                       inc     hl                ;
0497 0497 : 20 FC                    jr      nz,CZLOOP         ;
0499 0499 : EB                       ex      de,hl             ;SWITCH TEMP
049A 049A : 73                       ld      (hl),e            ;DO FIRST BYTE OF FIXUP
049B 049B : 23                       inc     hl                ;ADVANCE POINTER
049C 049C : 72                       ld      (hl),d            ;2ND BYTE OF FIXUP
049D 049D : 18 EA                    jr      CHEAD             ;KEEP CHAINING TIL DONE
049F 049F
049F 049F -                + ;;Find Basic Line
049F 049F                  | ;[M80] FNDLIN SEARCHES THE PROGRAM TEXT FOR THE LINE
049F 049F                  | ;[M80] WHOSE LINE # IS PASSED IN [D,E]. [D,E] IS PRESERVED.
049F 049F                  | ;[M80] THERE ARE THREE POSSIBLE RETURNS:
049F 049F                  | ;[M80]
049F 049F                  | ;[M80]  1) ZERO FLAG SET. CARRY NOT SET.  LINE NOT FOUND.
049F 049F                  | ;[M80]     NO LINE IN PROGRAM GREATER THAN ONE SOUGHT.
049F 049F                  | ;[M80]     [B,C] POINTS TO TWO ZERO BYTES AT END OF PROGRAM.
049F 049F                  | ;[M80]     [H,L]=[B,C]
049F 049F                  | ;[M80]
049F 049F                  | ;[M80]  2) ZERO, CARRY SET.
049F 049F                  | ;[M80]     [B,C] POINTS TO THE LINK FIELD IN THE LINE
049F 049F                  | ;[M80]     WHICH IS THE LINE SEARCHED FOR.
049F 049F                  | ;[M80]     [H,L] POINTS TO THE LINK FIELD IN THE NEXT LINE.
049F 049F                  | ;[M80]
049F 049F                  | ;[M80]  3) NON-ZERO, CARRY NOT SET.
049F 049F                  | ;[M80]     LINE NOT FOUND, [B,C]  POINTS TO LINE IN PROGRAM
049F 049F                  | ;[M80]     GREATER THAN ONE SEARCHED FOR.
049F 049F                  | ;[M80]     [H,L] POINTS TO THE LINK FIELD IN THE NEXT LINE.
049F 049F = 2A 4F 38         FNDLIN: ld      hl,(TXTTAB)       ;[M80] GET POINTER TO START OF TEXT
04A2 04A2 : 44               LOOP:   ld      b,h               ;[M80] IF EXITING BECAUSE OF END OF PROGRAM,
04A3 04A3 : 4D                       ld      c,l               ;[M80] SET [B,C] TO POINT TO DOUBLE ZEROES.
04A4 04A4 : 7E                       ld      a,(hl)            ;[M80] GET WORD POINTER TO
04A5 04A5 : 23                       inc     hl                ;[M80] BUMP POINTER
04A6 04A6 : B6                       or      (hl)              ;[M80] GET 2ND BYTE
04A7 04A7 : 2B                       dec     hl                ;[M80] GO BACK
04A8 04A8 : C8                       ret     z                 ;[M80] IF ZERO THEN DONE
04A9 04A9 : 23                       inc     hl                ;[M80] SKIP PAST AND GET THE LINE #
04AA 04AA : 23                       inc     hl                ;
04AB 04AB : 7E                       ld      a,(hl)            ;[M80] INTO [H,L] FOR COMPARISON WITH
04AC 04AC : 23                       inc     hl                ;[M80] THE LINE # BEING SEARCHED FOR
04AD 04AD : 66                       ld      h,(hl)            ;[M80] WHICH IS IN [D,E]
04AE 04AE : 6F                       ld      l,a               ;
04AF 04AF : E7                       rst     COMPAR            ;[M80] SEE IF IT MATCHES OR IF WE'VE GONE TOO FAR
04B0 04B0 : 60                       ld      h,b               ;[M80] MAKE [H,L] POINT TO THE START OF THE
04B1 04B1 : 69                       ld      l,c               ;[M80] LINE BEYOND THIS ONE, BY PICKING
04B2 04B2 : 7E                       ld      a,(hl)            ;[M80] UP THE LINK THAT [B,C] POINTS AT
04B3 04B3 : 23                       inc     hl                ;
04B4 04B4 : 66                       ld      h,(hl)            ;
04B5 04B5 : 6F                       ld      l,a               ;
04B6 04B6 : 3F                       ccf                       ;[M80] TURN CARRY OFF
04B7 04B7 : C8                       ret     z                 ;[M80] EQUAL RETURN
04B8 04B8 : 3F                       ccf                       ;[M80] MAKE CARRY ZERO
04B9 04B9 : D0                       ret     nc                ;[M80] NO MATCH RETURN (GREATER)
04BA 04BA : 18 E6                    jr      LOOP              ;[M80] KEEP LOOPING
04BC 04BC
04BC 04BC -                + ;;Convert Keyword to Token
04BC 04BC                  | ;[M80] ALL "RESERVED" WORDS ARE TRANSLATED INTO SINGLE
04BC 04BC                  | ;[M80] ONE OR TWO (IF TWO, FIRST IS ALWAYS 377 OCTAL)
04BC 04BC                  | ;[M80] BYTES WITH THE MSB ON. THIS SAVES SPACE AND TIME
04BC 04BC                  | ;[M80] BY ALLOWING FOR TABLE DISPATCH DURING EXECUTION.
04BC 04BC                  | ;[M80] THEREFORE ALL STATEMENTS APPEAR TOGETHER IN THE
04BC 04BC                  | ;[M80] RESERVED WORD LIST IN THE SAME
04BC 04BC                  | ;[M80] ORDER THEY APPEAR IN IN STMDSP.
04BC 04BC : AF         [M80] CRUNCH: xor     a                 ;SAY EXPECTING FLOATING NUMBERS
04BD 04BD : 32 AC 38                 ld      (DORES),a         ;ALLOW CRUNCHING
04C0 04C0 : 0E 05                    ld      c,5               ;LENGTH OF KRUNCH BUFFER
04C2 04C2 : 11 60 38                 ld      de,BUF            ;SETUP DESTINATION POINTER
04C5 04C5 : 7E         [M80] KLOOP:  ld      a,(hl)            ;GET CHARACTER FROM BUF
04C6 04C6 : FE 20                    cp      ' '               ;SPACE?
04C8 04C8 : CA 3C 05                 jp      z,STUFFH          ;JUST STUFF AWAY
04CB 04CB : 47                       ld      b,a               ;SETUP B WITH A QUOTE IF IT IS A STRING
04CC 04CC : FE 22                    cp      '"'               ;QUOTE SIGN?
04CE 04CE : CA 58 05                 jp      z,STRNG           ;YES, GO TO SPECIAL STRING HANDLING
04D1 04D1 : B7                       or      a                 ;END OF LINE?
04D2 04D2 : CA 5E 05                 jp      z,CRDONE          ;YES, DONE CRUNCHING
04D5 04D5 : 3A AC 38                 ld      a,(DORES)         ;IN DATA STATEMENT AND NO CRUNCH?
04D8 04D8 : B7                       or      a 
04D9 04D9 : 7E                       ld      a,(hl)            ;GET THE CHARACTER AGAIN
04DA 04DA : C2 3C 05                 jp      nz,STUFFH         ;IF NO CRUNCHING JUST STORE THE CHARACTER
04DD 04DD : FE 3F                    cp      '?'               ;A QMARK?
04DF 04DF : 3E 95                    ld      a,PRINTK          ;
04E1 04E1 : CA 3C 05                 jp      z,STUFFH          ;THEN USE A "PRINT" TOKEN
04E4 04E4 : 7E                       ld      a,(hl)            ;
04E5 04E5 : FE 30                    cp      '0'               ;[M65] SKIP NUMERICS.
04E7 04E7 : 38 05                    jr      c,MUSTCR          ;
04E9 04E9 : FE 3C                    cp      '<'               ;[M65] ":" AND ";" ARE ENTERED STRAIGHTAWAY.
04EB 04EB : DA 3C 05                 jp      c,STUFFH          ;
04EE 04EE : D5         [M65] MUSTCR: push    de                ;[M65] SAVE BUFFER POINTER.
04EF 04EF : 11 44 02                 ld      de,RESLST-1       ;[M65] LOAD RESLST POINTER.
04F2 04F2 : C5                       push    bc                ;[M65] SAVE TEXT POINTER FOR LATER USE.
04F3 04F3 : 01 36 05                 ld      bc,NOTGOS         ;[M80] PLACE TO RETURN IF NOT FUNNY GO
04F6 04F6 : C5                       push    bc                ;
04F7 04F7 : 06 7F                    ld      b,$7F             ;
04F9 04F9 = 7E         [~~~] CRUNCX: ld      a,(hl)            ;[M80] GET CHAR FROM MEMORY
04FA 04FA : FE 61                    cp      'a'               ;[M80] IS IT LOWER CASE RANGE
04FC 04FC : 38 07                    jr      c,RESCON          ;[M80] LESS
04FE 04FE : FE 7B                    cp      '{'               ;[M80] GREATER
0500 0500 : 30 03                    jr      nc,RESCON         ;[M80] TEST
0502 0502 : E6 5F                    and     $5F               ;[M80] MAKE UPPER CASE
0504 0504 : 77                       ld      (hl),a            ;;and put it back
0505 0505 : 4E         [N65] RESCON: ld      c,(hl)            ;[M80 SAVE CHAR IN [C]
0506 0506                    ;;Find next Reserved Word that starts with this character
0506 0506 : EB                       ex      de,hl             ;;HL=RESLST Pointer, DE=Text Pointer
0507 0507 : 23         (M80) LOPPSI: inc     hl                ;[M80] BUMP RESLST POINTER
0508 0508 : B6                       or      (hl)              ;[M80] SET CC'S
0509 0509 : F2 07 05                 jp      p,LOPPSI          ;[M80] SEE IF REST OF CHARS MATCH
050C 050C : 04                       inc     b                 ;
050D 050D : 7E                       ld      a,(hl)            ;[M80] GET BYTE FROM RESERVED WORD LIST
050E 050E : E6 7F                    and     $7F               ;[M80] GET RID OF HIGH BIT
0510 0510 : C8                       ret     z                 ;[M80] IF=0 THEN END OF THIS CHARS RESLT
0511 0511 : B9                       cp      c                 ;[M80] COMPARE TO CHAR FROM SOURCE LINE
0512 0512 : 20 F3                    jr      nz,LOPPSI         ;[M80] IF NO MATCH, SEARCH FOR NEXT RESWRD
0514 0514 : EB                       ex      de,hl             ;;DE=RESLST Pointer, HL=Text Pointer
0515 0515 : E5                       push    hl                ;;Save Text Pointer
0516 0516 : 13         (M80) LOPSKP: inc     de                ;[M80] POINT AFTER TOKEN
0517 0517 : 1A                       ld      a,(de)            ;[M80] GET A BYTE FROM RESWRD LIST
0518 0518 : B7                       or      a                 ;[M80] BUMP RESLST POINTER
0519 0519 : FA 32 05                 jp      m,NOTFNT          ;[M80] SET CC'S
051C 051C : 4F                       ld      c,a               ;[M80] NOT END OF RESWRD, KEEP SKIPPING
051D 051D : 78                       ld      a,b               ;
051E 051E : FE 88                    cp      GOTOTK            ;
0520 0520 : 20 02                    jr      nz,MAKUPL         ;
0522 0522 : D7                       rst     CHRGET            ;
0523 0523 : 2B                       dec     hl                ;[M80] FIX TEXT POINTER
0524 0524 : 23         (M80) MAKUPL: inc     hl                ;
0525 0525 : 7E                       ld      a,(hl)            ;
0526 0526 : FE 61                    cp      'a'               ;[M80] IS IT LOWER CASE RANGE
0528 0528 : 38 02                    jr      c,MAKUPS          ;[M80] LESS
052A 052A : E6 5F                    and     $5F               ;[M80] MAKE UPPER CASE
052C 052C : B9         (M80) MAKUPS: cp      c                 ;[M80] COMPARE TO CHAR FROM SOURCE LINE
052D 052D : 28 E7                    jr      z,LOPSKP          ;[M80] IF NO MATCH, SEARCH FOR NEXT RESWRD
052F 052F : E1                       pop     hl                ;
0530 0530 : 18 D3                    jr      RESCON            ;
0532 0532 : 48         (M80) NOTFNT: ld      c,b               ;
0533 0533 : F1                       pop     af                ;
0534 0534 : EB                       ex      de,hl             ;
0535 0535 : C9                       ret                       ;
0536 0536 : F7         [M80] NOTGOS: rst     HOOKDO            ;
0537 0537 : 0A         {~~~} HOOK10: byte    10                ;
0538 0538 : EB                       ex      de,hl             ;;HL=text pointer, DE=krunch pointer 
0539 0539 : 79                       ld      a,c               ;;Get token
053A 053A : C1                       pop     bc                ;
053B 053B : D1                       pop     de                ;
053C 053C
053C 053C                    ;;Copy character to crunch buffer
053C 053C : 23         [M80] STUFFH: inc     hl                ;[M80] ENTRY TO BUMP [H,L]
053D 053D : 12         {M80} KRNSAV: ld      (de),a            ;[M80] SAVE BYTE IN KRUNCH BUFFER
053E 053E : 13                       inc     de                ;[M80] BUMP POINTER
053F 053F : 0C                       inc     c                 ;;Increment buffer count
0540 0540 : D6 3A                    sub     ':'               ;[M65] IS IT A ":"?"
0542 0542 : 28 04                    jr      z,COLIS           ;[M65] YES, ALLOW CRUNCHING AGAIN.
0544 0544 : FE 49                    cp      DATATK-':'        ;[M65] IS IT A DATATK?
0546 0546 : 20 03                    jr      nz,NODATT         ;[M65] NO, SEE IF IT IS REM TOKEN.
0548 0548
0548 0548 : 32 AC 38   (M80) COLIS:  ld      (DORES),a         ;[M65] SETUP FLAG.
054B 054B : D6 54      (M80) NODATT: sub     REMTK-':'         ;[M65] REM ONLY STOPS ON NULL.
054D 054D : C2 C5 04                 jp      nz,KLOOP          ;[M65] NO, CONTINUE CRUNCHING.
0550 0550 : 47                       ld      b,a               ;{M80} SAVE TERMINATOR IN [B]
0551 0551 : 7E         (M80) STR1:   ld      a,(hl)            ;[M80] GET A CHAR
0552 0552 : B7                       or      a                 ;[M80] SET CONDITION CODES
0553 0553 : 28 09                    jr      z,CRDONE          ;[M80] IF END OF LINE THEN DONE
0555 0555 : B8                       cp      b                 ;[M80] COMPARE CHAR WITH THIS TERMINATOR
0556 0556 : 28 E4                    jr      z,STUFFH          ;[M80] IF YES, DONE WITH STRING
0558 0558
0558 0558 : 23         (M80) STRNG:  inc     hl                ;[M80] INCREMENT TEXT POINTER
0559 0559 : 12                       ld      (de),a            ;[M80] SAVE CHAR IN KRUNCH BUFFER
055A 055A : 0C                       inc     c                 ;;Increment buffer count
055B 055B : 13                       inc     de                ;[M65] INCREMENT BUFFER POINTER.
055C 055C : 18 F3                    jr      STR1              ;[M80] KEEP LOOPING
055E 055E
055E 055E : 21 5F 38   (M80) CRDONE: ld      hl,BUF-1          ;[M80] GET POINTER TO CHAR BEFORE BUF AS "GONE" DOES A CHRGET
0561 0561 : 12                       ld      (de),a            ;[M80] NEED THREE 0'S ON THE END
0562 0562 : 13                       inc     de                ;[M80] ONE FOR END-OF-LINE
0563 0563 : 12                       ld      (de),a            ;[M80] AND 2 FOR A ZERO LINK
0564 0564 : 13                       inc     de                ;[M80] SINCE IF THIS IS A DIRECT STATEMENT
0565 0565 : 12                       ld      (de),a            ;[M80] ITS END MUST LOOK LIKE THE END OF A PROGRAM
0566 0566 : C9                       ret                       ;[M80] END OF CRUNCHING
0567 0567
0567 0567                    ;;The LLIST and LIST commands
0567 0567 : 3E 01      [M80] LLIST:  ld      a,1               ;[M80] PRTFLG=1 FOR REGULAR LIST
0569 0569 : 32 47 38                 ld      (PRTFLG),a        ;[M80] SAVE IN I/O FLAG (END OF LPT)
056C 056C : 3E 17      [M80] LIST:   ld      a,23              ;;Set line count to 23
056E 056E : 32 08 38                 ld      (CNTOFL),a        ;
0571 0571 : CD 9C 06                 call    SCNLIN            ;[M80] SCAN LINE RANGE
0574 0574 : C0                       ret     nz                ;
0575 0575 : C1                       pop     bc                ;[M80] GET RID OF NEWSTT RETURN ADDR
0576 0576 : CD 9F 04                 call    FNDLIN            ;[M80] DONT EVEN LIST LINE #
0579 0579 : C5                       push    bc                ;[M80] SAVE POINTER TO 1ST LINE
057A 057A : E1         (M80) LIST4:  pop     hl                ;[M80] GET POINTER TO LINE
057B 057B : 4E                       ld      c,(hl)            ;[M80] [B,C]=THE LINK POINTING TO THE NEXT
057C 057C : 23                       inc     hl                ;
057D 057D : 46                       ld      b,(hl)            ;
057E 057E : 23                       inc     hl                ;
057F 057F : 78                       ld      a,b               ;[M80] SEE IF END OF CHAIN
0580 0580 : B1                       or      c                 ;
0581 0581 : CA 02 04                 jp      z,READY           ;[M80] LAST LINE, STOP.
0584 0584 : CD 25 1A                 call    ISCNTC            ;[M80] CHECK FOR CONTROL-C
0587 0587 : C5                       push    bc                ;[M80] SAVE LINK
0588 0588 : CD EA 19                 call    CRDO              ;
058B 058B : 5E                       ld      e,(hl)            ;[M80] [B,C]=THE LINK POINTING TO THE NEXT LINE
058C 058C : 23                       inc     hl                ;
058D 058D : 56                       ld      d,(hl)            ;
058E 058E : 23                       inc     hl                ;
058F 058F : E5                       push    hl                ;[M80] DON'T ALLOW ^C
0590 0590 : EB                       ex      de,hl             ;[M80] GET LINE # IN [H,L]
0591 0591 : CD 75 16                 call    LINPRT            ;[M80] PRINT AS INT WITHOUT LEADING SPACE
0594 0594 : 3E 20                    ld      a,' '             ;
0596 0596 : E1                       pop     hl                ;
0597 0597 : DF         (M65) PLOOP:  rst     OUTCHR            ;[M80] PRINT A SPACE AFTER THE LINE #
0598 0598 = 7E         [M80] LISPRT: ld      a,(hl)            ;;Detokenize and Print Line
0599 0599 : 23                       inc     hl                ;[M80] INCR POINTER
059A 059A : B7                       or      a                 ;[M80] SET CC
059B 059B : 28 DD                    jr      z,LIST4           ;[M80] IF =0 THEN END OF LINE
059D 059D : F2 97 05                 jp      p,PLOOP           ;
05A0 05A0 : F7                       rst     HOOKDO            ;;Handle Extended BASIC Tokens
05A1 05A1 : 16         {~~~} HOOK22: byte    22                ;
05A2 05A2 : D6 7F                    sub     $7F               ;
05A4 05A4 : 4F                       ld      c,a               ;
05A5 05A5 : 11 45 02                 ld      de,RESLST         ;[M80] GET PTR TO START OF RESERVED WORD LIST
05A8 05A8 = 1A         (M80) RESSRC: ld      a,(de)            ;[M80] GET CHAR FROM RESLST
05A9 05A9 : 13                       inc     de                ;[M80] BUMP SOURCE PTR
05AA 05AA : B7                       or      a                 ;[M80] SET CC'S
05AB 05AB : F2 A8 05                 jp      p,RESSRC          ;[M80] IF NOT END OF THIS RESWRD, THEN KEEP LOOKING
05AE 05AE : 0D                       dec     c                 ;
05AF 05AF : 20 F7                    jr      nz,RESSRC         ;
05B1 05B1 : E6 7F      [M80] MORLNP: and     $7F               ;[M80] AND OFF HIGH ORDER BIT
05B3 05B3 : DF                       rst     OUTCHR            ;[M80] STORE THIS CHAR
05B4 05B4 : 1A         {M80} MORPUR: ld      a,(de)            ;[M80] GET BYTE FROM RESWRD
05B5 05B5 : 13                       inc     de                ;[M80] BUMP POINTER
05B6 05B6 : B7                       or      a                 ;[M80] SET CC'S
05B7 05B7 : F2 B1 05                 jp      p,MORLNP          ;[M80] END OF RESWRD?
05BA 05BA : 18 DC                    jr      LISPRT            ;[M80] PRINT NEXT CHAR
05BC 05BC
05BC 05BC                  + ;[M80] "FOR" STATEMENT
05BC 05BC                  | ;[M80] A "FOR" ENTRY ON THE STACK HAS THE FOLLOWING FORMAT:
05BC 05BC                  | ;[M80]
05BC 05BC                  | ;[M80] LOW ADDRESS
05BC 05BC                  | ;[M80]  TOKEN ($FOR IN HIGH BYTE)  1 BYTE
05BC 05BC                  | ;[M80]  A POINTER TO THE LOOP VARIABLE  2 BYTES
05BC 05BC                  | ;[M80]  A BYTE REFLECTING THE SIGN OF THE INCREMENT 1 BYTE
05BC 05BC                  | ;[M80]  THE STEP 4 BYTES
05BC 05BC                  | ;[M80]  THE UPPER VALUE 4 BYTES
05BC 05BC                  | ;[M80]  THE LINE # OF THE "FOR" STATEMENT 2 BYTES
05BC 05BC                  | ;[M80]  A TEXT POINTER INTO THE "FOR" STATEMENT 2 BYTES
05BC 05BC                  | ;[M80] HIGH ADDRESS
05BC 05BC                  | ;[M80]
05BC 05BC                  | ;[M80] TOTAL 16 BYTES
05BC 05BC                  | ;;;*** On the Aquarius, the entry is only 13 bytes
05BC 05BC : 3E 64      [M80] FOR:    ld      a,100
05BE 05BE : 32 CB 38                 ld      (SUBFLG),a        ;[M80] DONT RECOGNIZE SUBSCRIPTED VARIABLES
05C1 05C1 : CD 31 07                 call    LET               ;[M65] READ VARIABLE AND ASSIGN INITIAL VALUE
05C4 05C4 : C1                       pop     bc                ;                                                          --BC--  --DE--  --HL--  Stack
05C5 05C5 : E5                       push    hl                ;[M80] SAVE THE TEXT POINTER                                               TxtPtr  TxtPtr
05C6 05C6 : CD 1C 07                 call    DATA              ;[M80] SET [H,L]=END OF STATEMENT
05C9 05C9 : 22 C7 38                 ld      (ENDFOR),hl       ;[M80] SAVE FOR COMPARISON
05CC 05CC : 21 02 00                 ld      hl,2              ;[M80] SET UP POINTER INTO STACK                                               
05CF 05CF : 39                       add     hl,sp             ;;                                                                          SP+1 
05D0 05D0 : CD A3 03   (M80) LPFORM: call    LOOPER            ;[M80] MUST HAVE VARIABLE POINTER IN [D,E]                                 
05D3 05D3 : 20 14                    jr      nz,NOTOL          ;[M80] NO MATCHING ENTRY, DON'T ELIMINATE ANYTHING
05D5 05D5 : 09                       add     hl,bc             ;[M80] ELIMINATE THE MATCHING ENTRY
05D6 05D6 : D5                       push    de                ;[M80] SAVE THE TEXT POINTER
05D7 05D7 : 2B                       dec     hl                ;[M80] SEE IF END TEXT POINTER OF MATCHING ENTRY
05D8 05D8 : 56                       ld      d,(hl)            ;[M80] MATCHES THE FOR WE ARE HANDLING
05D9 05D9 : 2B                       dec     hl                ;[M80] PICK UP THE END OF THE "FOR" TEXT POINTER
05DA 05DA : 5E                       ld      e,(hl)            ;[M80] FOR THE ENTRY ON THE STACK
05DB 05DB : 23                       inc     hl                ;[M80] WITHOUT CHANGING [H,L]
05DC 05DC : 23                       inc     hl                ;
05DD 05DD : E5                       push    hl                ;[M80] SAVE THE STACK POINTER FOR THE COMPARISON
05DE 05DE : 2A C7 38                 ld      hl,(ENDFOR)       ;[M80] GET ENDING TEXT POINTER FOR THIS "FOR"
05E1 05E1 : E7                       rst     COMPAR            ;[M80] SEE IF THEY MATCH
05E2 05E2 : E1                       pop     hl                ;[M80] GET BACK THE STACK POINTER                        
05E3 05E3 : D1                       pop     de                ;;;                                                      
05E4 05E4 : 20 EA                    jr      nz,LPFORM         ;;[M80] KEEP SEARCHING IF NO MATCH                       
05E6 05E6 : D1                       pop     de                ;[M80] GET BACK THE TEXT POINTER                         
05E7 05E7 : F9                       ld      sp,hl             ;[M80] DO THE ELIMINATION                                
05E8 05E8 : 0C                       inc     c                 ;;; SHLD SAVSTK in CP/M BASOC                            
05E9 05E9 : D1         (M80) NOTOL:  pop     de                ;;;                                                      
05EA 05EA : EB                       ex      de,hl             ;[M80] [H,L]=TEXT POINTER                                
05EB 05EB : 0E 08                    ld      c,8               ;[M80] MAKE SURE 16 BYTES ARE AVAILABLE                  
05ED 05ED : CD A0 0B                 call    GETSTK            ;[M80] OFF OF THE STACK                                  
05F0 05F0 : E5                       push    hl                ;[M80] REALLY SAVE THE TEXT POINTER                      
05F1 05F1 : 2A C7 38                 ld      hl,(ENDFOR)       ;[M80] PICK UP POINTER AT END OF "FOR"                   
05F4 05F4 : E3                       ex      (sp),hl           ;[M80] PUT POINTER ON STACK AND RESTORE TEXT POINTER     
05F5 05F5 : E5                       push    hl                ;[M80] PUSH POINTER TO VARIABLE ONTO THE STACK             
05F6 05F6 : 2A 4D 38                 ld      hl,(CURLIN)       ;[M80] [H,L] GET THE CURRENT LINE #                        
05F9 05F9 : E3                       ex      (sp),hl           ;[M80] LINE # ON THE STACK AND [H,L] IS THE TEXT POINTER   
05FA 05FA : CD 75 09                 call    CHKNUM            ;
05FD 05FD : CF                       rst     SYNCHK            ;
05FE 05FE : A1                       byte    TOTK              ;[M80] "TO" IS NECESSARY
05FF 05FF : CD 72 09                 call    FRMNUM            ;[M65] VALUE MUST BE A NUMBER
0602 0602 : E5                       push    hl                ;
0603 0603 : CD 2E 15                 call    MOVRF             ;[M80] GET THE STUFF
0606 0606 : E1                       pop     hl                ;[M80] REGAIN TEXT POINTER
0607 0607 : C5                       push    bc                ;[M80] OPPOSITE OF PUSHR
0608 0608 : D5                       push    de                ;[M80] SAVE THE SIGN OF THE INCREMENT
0609 0609 : 01 00 81                 ld      bc,$8100          ;[M80] DEFAULT THE STEP TO BE 1
060C 060C : 51                       ld      d,c               ;
060D 060D : 5A                       ld      e,d               ;[M80] GET 1.0 IN THE REGISTERS
060E 060E : 7E                       ld      a,(hl)            ;[M80] GET TERMINATING CHARACTER
060F 060F : FE A7                    cp      STEPTK            ;[M80] DO WE HAVE "STEP" ?
0611 0611 : 3E 01                    ld      a,1               ;[M80] SETUP DEFAULT SIGN
0613 0613 : 20 0A                    jr      nz,ONEON          ;[M65] NO. ASSUME 1.0.
0615 0615 : D7                       rst     CHRGET            ;[M65] YES. ADVANCE POINTER
0616 0616 : CD 72 09                 call    FRMNUM            ;
0619 0619 : E5                       push    hl                ;
061A 061A : CD 2E 15                 call    MOVRF             ;[M80] SET UP THE REGISTERS
061D 061D : EF                       rst     FSIGN             ;[M80] GET THE SIGN OF THE INCREMENT
061E 061E : E1         {M80} STPSGN: pop     hl                ;[M80] POP OFF THE TEXT POINTER
061F 061F : C5         (M80) ONEON:  push    bc                ;[M80] PUT VALUE ON BACKWARDS
0620 0620 : D5                       push    de                ;[M80] OPPOSITE OF PUSHR
0621 0621 : F5                       push    af                ;
0622 0622 : 33                       inc     sp                ;
0623 0623 : E5                       push    hl                ;
0624 0624 : 2A CE 38                 ld      hl,(SAVTXT)       ;
0627 0627 : E3                       ex      (sp),hl           ;
0628 0628 : 06 81      [M80] NXTCON: ld      b,FORTK           ;[M80] PUT A 'FOR' TOKEN ONTO THE STACK
062A 062A : C5                       push    bc                ;
062B 062B : 33                       inc     sp                ;[M80] THE "TOKEN" ONLY TAKES ONE BYTE OF STACK SPACE
062C 062C                                                    
062C 062C                  + ;[M80] NEW STATEMENT FETCHER
062C 062C                  | ;[M80] BACK HERE FOR NEW STATEMENT. CHARACTER POINTED TO BY [H,L]
062C 062C                  | ;[M80] ":" OR END-OF-LINE. THE ADDRESS OF THIS LOCATION IS
062C 062C                  | ;[M80] LEFT ON THE STACK WHEN A STATEMENT IS EXECUTED SO
062C 062C                  | ;[M80] IT CAN MERELY DO A RETURN WHEN IT IS DONE.
062C 062C              [M80] NEWSTT: 
062C      : CD 25 1A                 call    ISCNTC
062F      : 22 CE 38                 ld      (SAVTXT),hl       ;USED BY CONTINUE AND INPUT AND CLEAR AND PRINT USING
     062C : 22 CE 38                 ..
     062F : CD C2 1F                 call    INCNTC            ;;*** might be [M65] ISCNTC
0632 0632 : 7E                       ld      a,(hl)            ;;Get Terminator
0633 0633 : FE 3A                    cp      ':'               ;[M80] IS IT A COLON?
0635 0635 : 28 14                    jr      z,GONE            ;
0637 0637 : B7                       or      a                 ;
0638 0638 : C2 C4 03                 jp      nz,SNERR          ;[M80] MUST BE A ZERO
063B 063B : 23                       inc     hl                ;
063C 063C : 7E         {M80} GONE4:  ld      a,(hl)            ;[M80] IF POINTER IS ZERO, END OF PROGRAM
063D 063D : 23                       inc     hl                ;
063E 063E : B6                       or      (hl)              ;[M80] OR IN HIGH PART
063F 063F : CA 29 0C                 jp      z,ENDCON          ;[M80] FIX SYNTAX ERROR IN UNENDED ERROR ROUTINE
0642 0642 : 23                       inc     hl                ;
0643 0643 : 5E                       ld      e,(hl)            ;
0644 0644 : 23                       inc     hl                ;
0645 0645 : 56                       ld      d,(hl)            ;[M80] GET LINE # IN [D,E]
0646 0646 : EB                       ex      de,hl             ;[M80] [H,L]=LINE #
0647 0647 : 22 4D 38                 ld      (CURLIN),hl       ;[M80] SETUP CURLIN WITH THE CURRENT LINE #
064A 064A : EB                       ex      de,hl             ;;DE=Line#, HL=Text Pointer
064B 064B 064B  
064B 064B : D7         [M80] GONE:   rst     CHRGET            ;[M80] GET THE STATEMENT TYPE
064C 064C : 11 2C 06                 ld      de,NEWSTT         ;[M80] PUSH ON A RETURN ADDRESS OF NEWSTT
064F 064F : D5                       push    de                ;[M80] STATEMENT
0650 0650 : C8         [M80] GONE3:  ret     z                 ;[M80] IF A TERMINATOR TRY AGAIN
0651 0651                    ;[M80] "IF" COMES HERE  
0651 0651 : D6 80      [M80] GONE2:  sub     $80               ;[M80] "ON ... GOTO" AND "ON ... GOSUB" COME HERE
0653 0653 : DA 31 07                 jp      c,LET             ;[M80] MUST BE A LET
0656 0656 : FE 20                    cp      TABTK-$80         ;;End of Statement Tokens
0658 0658 : F7                       rst     HOOKDO            ;;Handle Extended BASIC Statement Tokens
0659 0659 : 17         {~~~} HOOK23: byte    23                ;
065A 065A : D2 C4 03                 jp      nc,SNERR          ;;Not a Statement Token
065D 065D : 07                       rlca                      ;[M80] MULTIPLY BY 2
065E 065E : 4F                       ld      c,a               ;
065F 065F : 06 00                    ld      b,0               ;;Offset = (Token - 128) * 2 
0661 0661 : EB                       ex      de,hl             ;
0662 0662 : 21 D5 01                 ld      hl,STMDSP         ;[M80] STATEMENT DISPATCH TABLE
0665 0665 -                  ;;Add Offset to Table and Dispatch
0665 0665 = 09         [~~~] GONE5:  add     hl,bc             ;[M80] ADD ON OFFSET
0666 0666 : 4E                       ld      c,(hl)            ;[M80] PUSH THE ADDRESS TO GO TO ONTO
0667 0667 : 23                       inc     hl                ;[M80] THE STACK
0668 0668 : 46                       ld      b,(hl)            ;[M80] PUSHM SAVES BYTES BUT NOT SPEED
0669 0669 : C5                       push    bc                ;
066A 066A : EB                       ex      de,hl             ;[M80] RESTORE THE TEXT POINTER
066B 066B                  + ;;Execute Statement
066B 066B                  | ;[M80] NEWSTT FALLS INTO CHRGET. THIS FETCHES THE FIRST CHAR AFTER
066B 066B                  | ;[M80] THE STATEMENT TOKEN AND THE CHRGET'S "RET" DISPATCHES TO STATEMENT
066B 066B -                  ;;Skip Statement Token and Execute
066B 066B = 23         [M80] CHRGTR: inc     hl                ;[M80] DUPLICATION OF CHRGET RST FOR SPEED
066C 066C = 7E         [M80] CHRGT2: ld      a,(hl)            ;Alternate CHRGOT
066D 066D : FE 3A                    cp      ':'               ;[M80] SEE CHRGET RST FOR EXPLANATION
066F 066F : D0                       ret     nc                ;
0670 0670                    ;[M80] CHRCON IS THE CONTINUATION OF THE CHRGET RST                  
0670 0670 : FE 20      [M80] CHRCON: cp      ' '               ;[M80] MUST SKIP SPACES
0672 0672 : 28 F7                    jr      z,CHRGTR          ;[M80] GET ANOTHER CHARACTER
0674 0674 : FE 30                    cp      '0'               ;[M80] ALL CHARS .GT. "9" HAVE RET'D SO
0676 0676 : 3F                       ccf                       ;[M80] TURN CARRY ON IF NUMERIC.
0677 0677 : 3C                       inc     a                 ;[M80] ALSO, SETZ IF NULL.
0678 0678 : 3D                       dec     a                 ;
0679 0679 : C9         {M80} CHRRTS: ret                       ;[M80] RETURN TO CALLER.
067A 067A
067A 067A                  + ;[M80] INTIDX READS A FORMULA FROM THE CURRENT POSITION AND
067A 067A                  | ;[M80] TURNS IT INTO A POSITIVE INTEGER
067A 067A                  | ;[M80] LEAVING THE RESULT IN [D,E].  NEGATIVE ARGUMENTS
067A 067A                  | ;[M80] ARE NOT ALLOWED. [H,L] POINTS TO THE TERMINATING
067A 067A                  | ;[M80] CHARACTER OF THE FORMULA ON RETURN.
067A 067A                  | ;
067A 067A : D7               INTIDX: rst     CHRGET            ;
067B 067B : CD 72 09         INTID2: call    FRMNUM            ;{M80} READ FORMULA AND GET RESULT AS INTEGER IN [D,E]
067E 067E : EF               INTFR2: rst     FSIGN             ;[M80] DON'T ALLOW NEGATIVE NUMBERS
067F 067F : FA 97 06                 jp      m,FCERR           ;[M80] TOO BIG. FUNCTION CALL ERROR
0682 0682  
0682 0682 -                  ;;Convert FAC to Integer and Return in [D,E]
0682 0682 = 3A E7 38   [M80] FRCINT: ld      a,(FAC)           ;
0685 0685 : FE 90                    cp      144               ;[M65] FAC .GT. 32767?
0687 0687 : DA 86 15                 jp      c,QINT            ;[M65] GO TO QINT AND SHOVE IT
068A 068A : 01 80 90   {~~~} FRCIN1: ld      bc,$9080          ;
068D 068D : 11 00 00                 ld      de,$0000          ;[M65] -32768
0690 0690 : E5                       push    hl                ;
0691 0691 : CD 5B 15                 call    FCOMP             ;[M65] SEE IF FAC=[B,C,D,E]
0694 0694 : E1                       pop     hl                ;
0695 0695 : 51                       ld      d,c               ;
0696 0696 : C8                       ret     z                 ;[M65] NO, FAC IS TOO BIG.
0697 0697  
0697 0697 = 1E 08      [M80] FCERR:  ld      e,ERRFC           ;[M65] "FUNCTION CALL" ERROR
0699 0699 : C3 DB 03                 jp      ERROR             ;
069C 069C
069C 069C                    ;[M80]  LINGET READS A LINE # FROM THE CURRENT TEXT POSITION
069C 069C                    ;[M80] 
069C 069C                    ;[M80]  LINE NUMBERS RANGE FROM 0 TO 65529
069C 069C                    ;[M80] 
069C 069C                    ;[M80]  THE ANSWER IS RETURNED IN [D,E].
069C 069C                    ;[M80]  [H,L] IS UPDATED TO POINT TO THE TERMINATING CHARACTER
069C 069C                    ;[M80]  AND [A] CONTAINS THE TERMINATING CHARACTER WITH CONDITION
069C 069C                    ;[M80]  CODES SET UP TO REFLECT ITS VALUE.
069C 069C                    ;
069C 069C -                  ;;Back Up and Read Line Number
069C 069C = 2B         [M80] SCNLIN: dec     hl              
069D 069D : 11 00 00   [M80] LINGET: ld      de,0              ;[M80] ASSUME START LIST AT ZERO
06A0 06A0 : D7         (M80) MORLIN: rst     CHRGET            ;;Get next character
06A1 06A1 : D0                       ret     nc                ;[M80] WAS IT A DIGIT
06A2 06A2 : E5                       push    hl                ;
06A3 06A3 : F5                       push    af                ;
06A4 06A4 : 21 98 19                 ld      hl,0+6552         ;[M80] SEE IF THE LINE # IS TOO BIG
06A7 06A7 : E7                       rst     COMPAR            ;
06A8 06A8 : 38 11                    jr      c,POPHSR          ;[M80] YES, DON'T SCAN ANY MORE DIGITS AND GIVE SYNTAX ERROR
06AA 06AA : 62                       ld      h,d               ;[M80] SAVE [D,E]
06AB 06AB : 6B                       ld      l,e               ;
06AC 06AC : 19                       add     hl,de             ;
06AD 06AD : 29                       add     hl,hl             ;
06AE 06AE : 19                       add     hl,de             ;
06AF 06AF : 29                       add     hl,hl             ;[M80] PUTTING [D,E]*10 INTO [H,L]
06B0 06B0 : F1                       pop     af                ;
06B1 06B1 : D6 30                    sub     '0'               ;
06B3 06B3 : 5F                       ld      e,a               ;
06B4 06B4 : 16 00                    ld      d,0               ;
06B6 06B6 : 19                       add     hl,de             ;[M80] ADD THE NEW DIGIT
06B7 06B7 : EB                       ex      de,hl             ;
06B8 06B8 : E1                       pop     hl                ;[M80] GET BACK TEXT POINTER
06B9 06B9 : 18 E5                    jr      MORLIN            ;
06BB 06BB : F1         (M80) POPHSR: pop     af                ;[M80] GET OFF TERMINATING DIGIT
06BC 06BC : E1                       pop     hl                ;[M80] GET BACK OLD TEXT POINTER
06BD 06BD : C9                       ret                       ;
06BE 06BE  
06BE 06BE : F7         [M80] RUN:    rst     HOOKDO            ;Call Hook Routine
06BF 06BF : 18         {~~~} HOOK24: byte    24                ;
06C0 06C0 : CA CB 0B                 jp      z,RUNC            ;[M80] NO LINE # ARGUMENT
06C3 06C3 : CD CF 0B   {M80} CONRUN: call    CLEARC            ;RESET THE STACK,DATPTR,VARIABLES ...
06C6 06C6 : 01 2C 06                 ld      bc,NEWSTT         ;
06C9 06C9 : 18 10                    jr      RUNC2             ;[M80] PUT "NEWSTT" ON AND FALL INTO "GOTO"
06CB 06CB
06CB 06CB                  + ;[M80] GOSUB STATEMENT
06CB 06CB                  | ;[M80] A "GOSUB" ENTRY ON THE STACK HAS THE FOLLOWING FORMAT
06CB 06CB                  | ;[M80]
06CB 06CB                  | ;[M80] LOW ADDRESS
06CB 06CB                  | ;[M80]
06CB 06CB                  | ;[M80]  A TOKEN EQUAL TO $GOSUB 1 BYTE
06CB 06CB                  | ;[M80]  THE LINE # OF THE THE "GOSUB" STATEMENT 2 BYTES
06CB 06CB                  | ;[M80]  A POINTER INTO THE TEXT OF THE "GOSUB" 2 BYTES
06CB 06CB                  | ;[M80]
06CB 06CB                  | ;[M80] HIGH ADDRESS
06CB 06CB                  | ;[M80]
06CB 06CB                  | ;[M80] TOTAL 5 BYTES
06CB 06CB : 0E 03      [M80] GOSUB:  ld      c,3               ;[M80] "GOSUB" ENTRIES ARE 5 BYTES LONG
06CD 06CD : CD A0 0B                 call    GETSTK            ;[M80] MAKE SURE THERE IS ROOM
06D0 06D0 : C1                       pop     bc                ;[M80] POP OFF RETURN ADDRESS OF "NEWSTT"
06D1 06D1 : E5                       push    hl                ;[M80] REALLY PUSH THE TEXT POINTER
06D2 06D2 : E5                       push    hl                ;[M80] SAVE TEXT POINTER
06D3 06D3 : 2A 4D 38                 ld      hl,(CURLIN)       ;[M80] GET THE CURRENT LINE #
06D6 06D6 : E3                       ex      (sp),hl           ;[M80] PUT CURLIN ON THE STACK AND [H,L]=TEXT PTR
06D7 06D7 : 3E 8C                    ld      a,GOSUTK          ;
06D9 06D9 : F5                       push    af                ;[M80] PUT GOSUB TOKEN ON THE STACK
06DA 06DA : 33                       inc     sp                ;[M80] THE GOSUB TOKEN TAKES ONLY ONE BYTE
06DB 06DB  
06DB 06DB : C5         [M80] RUNC2:  push    bc                ;[M80] RESTORE RETURN ADDRESS OF "NEWSTT"
06DC 06DC  
06DC 06DC : CD 9C 06   [M80] GOTO:   call    SCNLIN            ;[M80] PICK UP THE LINE # AND PUT IT IN [D,E]
06DF 06DF : CD 1E 07                 call    REM               ;[M80] SKIP TO THE END OF THIS LINE
06E2 06E2 : 23                       inc     hl                ;[M80] POINT AT THE LINK BEYOND IT
06E3 06E3 : E5                       push    hl                ;[M80] SAVE THE POINTER
06E4 06E4 : 2A 4D 38                 ld      hl,(CURLIN)       ;[M80] GET THE CURRENT LINE #
06E7 06E7 : E7                       rst     COMPAR            ;;Is target line less than current line
06E8 06E8 : E1                       pop     hl                ;[M80] [H,L]=CURRENT POINTER
06E9 06E9 : DC A2 04                 call    c,LOOP            ;[M80] SEARCH FROM THIS POINT
06EC 06EC : D4 9F 04                 call    nc,FNDLIN         ;[M80] SEARCH FROM THE BEGINNING -- ACTUALLY
06EF 06EF : 60                       ld      h,b               ;[M80] [H,L]= POINTER TO THE START OF THE MATCHED LINE
06F0 06F0 : 69                       ld      l,c               ;
06F1 06F1 : 2B                       dec     hl                ;
06F2 06F2 : D8                       ret     c                 ;[M80] GO TO NEWSTT
06F3 06F3 -                  ;{M80} GIVE A "US" ERROR
06F3 06F3 = 1E 0E      [M80] USERR:  ld      e,ERRUS           ;[M80] C=MATCH, SO IF NO MATCH WE
06F5 06F5 : C3 DB 03                 jp      ERROR             ;[M80] GIVE A "US" ERROR
06F8 06F8
06F8 06F8                  + ;[M80] RETURN STATEMENT
06F8 06F8                  | ;[M80] SEE "GOSUB" FOR THE FORMAT OF THE STACK ENTRY
06F8 06F8                  | ;[M80] "RETURN" RESTORES THE LINE NUMBER AND TEXT POINTER ON THE STACK
06F8 06F8                  | ;[M80] AFTER ELIMINATING ALL THE "FOR" ENTRIES IN FRONT OF THE "GOSUB"
06F8 06F8                  | ;[M80] ENTRY
06F8 06F8 : C0         [M80] RETURN: ret     nz                ;[M80] BLOW HIM UP IF THERE ISN'T A TERMINATOR
06F9 06F9 : 16 FF                    ld      d,255             ;[M80] MAKE SURE VARIABLE POINTER IN [D,E] NEVER GETS MATCHED
06FB 06FB : CD 9F 03                 call    FNDFOR            ;[M80] GO PAST ALL THE "FOR" ENTRIES
06FE 06FE : F9                       ld      sp,hl             ;[M80] UPDATE THE STACK
06FF 06FF : FE 8C                    cp      GOSUTK            ;
0701 0701 : 1E 04                    ld      e,ERRRG           ;[M80] ERROR ERRRG IS "RETURN WITHOUT GOSUB"
0703 0703 : C2 DB 03                 jp      nz,ERROR          ;
0706 0706 : E1                       pop     hl                ;GET LINE # "GOSUB" WAS FROM
0707 0707 : 22 4D 38                 ld      (CURLIN),hl       ;PUT IT INTO CURLIN
070A 070A : 23                       inc     hl                ;
070B 070B : 7C                       ld      a,h               ;
070C 070C : B5                       or      l                 ;;Is line number $FFFF
070D 070D : 20 07                    jr      nz,RETU1          ;;No, carry on
070F 070F : 3A CC 38                 ld      a,(USFLG)         ;
0712 0712 : B7                       or      a                 ;;Is flag set?
0713 0713 : C2 01 04                 jp      nz,STPRDY         ;;Yes, abort to direct mode
0716 0716 : 21 2C 06   (M65) RETU1:  ld      hl,NEWSTT         ;[M80] PUT RETURN ADDRESS OF "NEWSTT" BACK ON STACK
0719 0719 : E3                       ex      (sp),hl           ;[M80] GET TEXT POINTER FROM "GOSUB"
071A 071A : 3E                       byte    $3E               ;{M80} "LD A," AROUND POP HL
071B 071B : E1         [M80] DATAH:  pop     hl                ;[M80] GET TEXT POINTER OFF STACK
071C 071C -                  ;;The DATA Statement
071C 071C = 01         [M80] DATA:   byte    $01               ;[M80] "LD BC," TO PICK UP ":" INTO C AND SKIP
071D 071D : 3A                       byte    ':'               ;{M80} ":" ONLY APPLIES IF QUOTES HAVE MATCHED UP
071E 071E                    ;;The REM Statement
071E 071E : 0E         [M80] REM:    byte    $0E               ;[M80] "LD C,"   THE ONLY TERMINATOR IS ZERO
071F 071F : 00                       byte    0                 ;[M80] NO-OPERATION "DATA" ACTUALLY EXECUTES THIS 0
0720 0720 : 06 00                    ld      b,0               ;[M80] INSIDE QUOTES THE ONLY TERMINATOR IS ZERO
0722 0722 : 79         (M80) EXCHQT: ld      a,c               ;[M80] WHEN A QUOTE IS SEEN THE SECOND
0723 0723 : 48                       ld      c,b               ;[M80] TERMINATOR IS TRADED, SO IN "DATA"
0724 0724 : 47                       ld      b,a               ;[M80] COLONS INSIDE QUOTATIONS WILL HAVE NO EFFECT
0725 0725 : 7E         (M80) REMER:  ld      a,(hl)            ;[M80] GET A CHAR
0726 0726 : B7                       or      a                 ;[M80] ZERO IS ALWAYS A TERMINATOR
0727 0727 : C8                       ret     z                 ;
0728 0728 : B8                       cp      b                 ;[M80] TEST FOR THE OTHER TERMINATOR
0729 0729 : C8                       ret     z                 ;
072A 072A : 23                       inc     hl                ;
072B 072B : FE 22                    cp      '"'               ;[M80] IS IT A QUOTE?
072D 072D : 28 F3                    jr      z,EXCHQT          ;[M80] IF SO TIME TO TRADE
072F 072F : 18 F4                    jr      REMER             ;
0731 0731  
0731 0731 : CD D1 10   [M80] LET:    call    PTRGET            ;[M80] GET POINTER TO VARIABLE INTO [D,E]
0734 0734 : CF                       rst     SYNCHK            ;[M80] 
0735 0735 : B0                       byte    EQUATK            ;[M80] CHECK FOR "="
0736 0736 : D5                       push    de                ;[M80] SAVE THE VARIABLE POINTER
0737 0737 : 3A AB 38                 ld      a,(VALTYP)        ;{M80} REMEMBER THE VARIABLE TYPE
073A 073A : F5                       push    af                ;
073B 073B : CD 85 09                 call    FRMEVL            ;[M80] GET THE VALUE OF THE FORMULA
073E 073E : F1                       pop     af                ;[M80] GET THE VALTYP OF THE VARIABLE INTO [A] INTO FAC
073F 073F : E3                       ex      (sp),hl           ;[M80] [H,L]=POINTER TO VARIABLE, TEXT POINTER ON TOP OF STACK
0740 0740 : 22 CE 38                 ld      (SAVTXT),hl       ;[???] PLACE TO SAVE THE VALUE
0743 0743 : 1F                       rra                       ;
0744 0744 : CD 77 09                 call    CHKVAL            ;[M65] MAKE SURE "VALTYP" MATCHES CARRY AND SET ZERO FLAG FOR NUMERIC
0747 0747 : CA 79 07                 jp      z,COPNUM          ;[M80] NUMERIC, SO FORCE IT AND COPY
074A 074A                      
074A 074A : E5         [M80] INPCOM: push    hl                ;
074B 074B : 2A E4 38                 ld      hl,(FACLO)        ;[M80] GET POINTER TO THE DESCRIPTOR OF THE RESULT
074E 074E : E5                       push    hl                ;[M80] SAVE THE POINTER AT THE DESCRIPTOR
074F 074F : 23                       inc     hl                ;
0750 0750 : 23                       inc     hl                ;
0751 0751 : 5E                       ld      e,(hl)            ;
0752 0752 : 23                       inc     hl                ;
0753 0753 : 56                       ld      d,(hl)            ;
0754 0754 : 2A 4F 38                 ld      hl,(TXTTAB)       ;[M80] IF THE DATA IS IN BUF, COPY
0757 0757 : E7                       rst     COMPAR            ;[M80] SINCE BUF CHANGES ALL THE TIME
0758 0758 : 30 0E                    jr      nc,INBUFC         ;[M80] GO COPY, IF DATA REALLY IS IN BUF
075A 075A : 2A DA 38                 ld      hl,(STREND)       ;[M80] SEE IF IT POINTS INTO STRING SPACE
075D 075D : E7                       rst     COMPAR            ;[M80] IF NOT DON'T COPY
075E 075E : D1                       pop     de                ;[M80] GET BACK THE POINTER AT THE DESCRIPTOR
075F 075F : 30 0F                    jr      nc,DNTCPY         ;[M80] DON'T COPY LITERALS
0761 0761 : 21 BD 38                 ld      hl,DSCTMP         ;[M80] NOW, SEE IF ITS A VARIABLE BY SEEING IF THE DESCRIPTOR
0764 0764 : E7                       rst     COMPAR            ;[M80] IS IN THE TEMPORARY STORAGE AREA (BELOW DSCTMP)
0765 0765 : 30 09                    jr      nc,DNTCPY         ;[M80] DON'T COPY IF ITS NOT A VARIABLE
0767 0767 : 3E                       byte    $3E               ;[M80] SKIP THE NEXT BYTE WITH A "MVI A,"
0768 0768 : D1         [M80] INBUFC: pop     de                ;[M80] GET THE POINTER TO THE DESCRIPTOR IN [D,E]
0769 0769 : CD E4 0F                 call    FRETMS            ;[M80] FREE UP A TEMORARY POINTING INTO BUF
076C 076C : EB                       ex      de,hl             ;[M80] STRCPY COPIES [H,L]
076D 076D : CD 39 0E                 call    STRCPY            ;[M80] COPY VARIABLES IN STRING SPACE OR STRINGS WITH DATA IN BUF
0770 0770 : CD E4 0F   (M80) DNTCPY: call    FRETMS            ;[M80] FREE UP TEMPORARY WITHOUT FREEING UP ANY STRING SPACE
0773 0773 : E1                       pop     hl                ;[M80] 
0774 0774 : CD 3D 15                 call    MOVE              ;[M80] COPY A DESCRIPTOR OR A VALUE
0777 0777 : E1                       pop     hl                ;[M80] GET THE TEXT POINTER BACK
0778 0778 : C9                       ret                       ;
0779 0779                    
0779 0779 : E5         [M80] COPNUM: push    hl
077A 077A : CD 3A 15                 call    MOVMF             ;COPY A DESCRIPTOR OR A VALUE
077D 077D : D1                       pop     de                ;FOR "FOR" POP OFF POINTER AT LOOP VARIABLE INTO [D,E]
077E 077E : E1                       pop     hl                ;GET THE TEXT POINTER BACK
077F 077F : C9                       ret
0780 0780 
0780 0780                    ;{M80} ON..GOTO, ON GOSUB CODE
0780 0780 : F7         [M80] ONGOTO: rst     HOOKDO            ;
0781 0781 : 19         {~~~} HOOK25: byte    25                ;
0782 0782 : CD 54 0B   {M80} NTOERR: call    GETBYT            ;[M80] GET VALUE INTO [E]
0785 0785 -                  ;;Execute ON..GOTO
0785 0785 = 7E               OMGOTO  ld      a,(hl)            ;[M80] GET THE TERMINATOR BACK
0786 0786 : 47                       ld      b,a               ;[M80] SAVE THIS CHARACTER FOR LATER
0787 0787 : FE 8C                    cp      GOSUTK            ;[M80] AN "ON ... GOSUB" PERHAPS?
0789 0789 : 28 03                    jr      z,ISGOSU          ;[M80] YES, SOME FEATURE USE
078B 078B : CF                       rst     SYNCHK            ;
078C 078C : 88                       byte    GOTOTK            ;[M80] OTHERWISE MUST BE "GOTO"
078D 078D : 2B                       dec     hl                ;[M80] BACK UP CHARACTER POINTER
078E 078E : 4B         (M80) ISGOSU: ld      c,e               ;[M80] GET COUNT INTO [C]
078F 078F : 0D         (M80) LOOPON: dec     c                 ;[M80] SEE IF ENOUGH SKIPS
0790 0790 : 78                       ld      a,b               ;[M80] PUT DISPATCH CHARACTER IN PLACE
0791 0791 : CA 51 06                 jp      z,GONE2           ;[M80] IF DONE, GO OFF
0794 0794 : CD 9D 06                 call    LINGET            ;[M80] SKIP OVER A LINE #
0797 0797 : FE 2C                    cp      ','               ;[M80] IS IT A COMMA?
0799 0799 : C0                       ret     nz                ;{M80} NO COMMA MUST BE THE END OF THE LINE
079A 079A : 18 F3                    jr      LOOPON            ;[M80] CONTINUE GOBBLING LINE #S
079C 079C
079C 079C                    ;[M80] IF ... THEN CODE
079C 079C : CD 85 09   [M80] IFS:    call    FRMEVL            ;[M80] EVALUATE A FORMULA
079F 079F : 7E                       ld      a,(hl)            ;[M80] GET TERMINATING CHARACTER OF FORMULA
07A0 07A0 : FE 88                    cp      GOTOTK            ;[M80] ALLOW "GOTO" AS WELL
07A2 07A2 : 28 03                    jr      z,OKGOTO          ;
07A4 07A4 : CF                       rst     SYNCHK            ;
07A5 07A5 : A5                       byte    THENTK            ;[M80] MUST HAVE A THEN
07A6 07A6 : 2B                       dec     hl                ;
07A7 07A7 : CD 75 09   [M80] OKGOTO: call    CHKNUM            ;[M65] 0=FALSE. ALL OTHERS TRUE
07AA 07AA : EF                       rst     FSIGN             ;
07AB 07AB : CA 1E 07                 jp      z,REM             ;[M65] SKIP REST OF STATEMENT
07AE 07AE : D7         {M80} DOCOND: rst     CHRGET            ;[M80] PICK UP THE FIRST LINE # CHARACTER
07AF 07AF : DA DC 06                 jp      c,GOTO            ;[M80] DO A "GOTO"
07B2 07B2 : C3 50 06                 jp      GONE3             ;[M80] EXECUTE STATEMENT, NOT GOTO
07B5 07B5 
07B5 07B5 : 3E 01      [M80] LPRINT: ld      a,1               ;SAY NON ZERO
07B7 07B7 : 32 47 38                 ld      (PRTFLG),a        ;SAVE AWAY
07BA 07BA : 2B         [M80] NEWCHR: dec     hl                ;
07BB 07BB : D7                       rst     CHRGET            ;[M80] GET ANOTHER CHARACTER
07BC 07BC : F7         [M80] PRINT:  rst     HOOKDO            ;
07BD 07BD : 06         {~~~} HOOK6:  byte    6                 ;
07BE 07BE : CC EA 19                 call    z,CRDO            ;[M80] PRINT CRLF IF END WITHOUT PUNCTUATION
07C1 07C1 : CA 66 08   (M80) PRINTC: jp      z,FINPRT          ;{M80} FINISH BY RESETTING FLAGS, TERMINATOR SHOULD NOY CRLF
07C4 07C4 : FE A0                    cp      TABTK             ;
07C6 07C6 : CA 3A 08                 jp      z,TABER           ;[M80] THE TAB FUNCTION?
07C9 07C9 : FE A3                    cp      SPCTK             ;
07CB 07CB : CA 3A 08                 jp      z,TABER           ;[M80] THE SPC FUNCTION?
07CE 07CE : E5                       push    hl                ;{M80} SAVE THE TEXT POINTER
07CF 07CF : FE 2C                    cp      ','               ;
07D1 07D1 : 28 44                    jr      z,COMPRT          ;[M80] IS IT A COMMA?
07D3 07D3 : FE 3B                    cp      $3B               ;{M80} IS IT A ";"
07D5 07D5 : CA 61 08                 jp      z,NOTABR          ;
07D8 07D8 : C1                       pop     bc                ;[M80] GET RID OF OLD TEXT POINTER
07D9 07D9 : CD 85 09                 call    FRMEVL            ;[M80] EVALUATE THE FORMULA
07DC 07DC : E5                       push    hl                ;[M80] SAVE TEXT POINTER
07DD 07DD : 3A AB 38                 ld      a,(VALTYP)        ;[M80] SEE IF WE HAVE A STRING
07E0 07E0 : B7                       or      a                 ;
07E1 07E1 : C2 11 08                 jp      nz,STRDON         ;[M80] IF SO, PRINT SPECIALY
07E4 07E4 : CD 80 16                 call    FOUT              ;[M80] MAKE A NUMBER INTO A STRING
07E7 07E7 : CD 5F 0E                 call    STRLIT            ;[M80] MAKE IT  A STRING
07EA 07EA : 36 20                    ld      (hl),' '          ;[M80] PUT A SPACE AT THE END
07EC 07EC : 2A E4 38                 ld      hl,(FACLO)        ;[M80] SIZE BYTE IS FIRST IN DESCRIPTOR
07EF 07EF : 3A 47 38                 ld      a,(PRTFLG)        ;
07F2 07F2 : B7                       or      a                 ;
07F3 07F3 : 28 08                    jr      z,ISTTY           ;[M80] LPT OR TTY?
07F5 07F5 : 3A 46 38                 ld      a,(LPTPOS)        ;
07F8 07F8 : 86                       add     a,(hl)            ;
07F9 07F9 : FE 84                    cp      LPTSIZ            ;[M80] CHECK FOR OVERLAP
07FB 07FB : 18 0D                    jr      LINCHK            ;[M80] START ON A NEW LINE
07FD 07FD : 3A 48 38   (M80) ISTTY:  ld      a,(LINLEN)        ;
0800 0800 : 47                       ld      b,a               ;
0801 0801 : 3C                       inc     a                 ;[M80] NO OVERFLOW LINE WIDTH?
0802 0802 : 28 09                    jr      z,LINCH2          ;[M80] YES
0804 0804 : 3A 00 38                 ld      a,(TTYPOS)        ;[M80] SEE WHERE WE ARE
0807 0807 : 86                       add     a,(hl)            ;
0808 0808 : 3D                       dec     a                 ;[M80] ACTUALLY EQUAL TO LINE LENGTH IS OK
0809 0809 : B8                       cp      b                 ;
080A 080A : D4 EA 19   (M80) LINCHK: call    nc,CRDO           ;[M80] IF SO CRLF
080D 080D : CD A0 0E   (M80) LINCH2: call    STRPRT            ;[M80] PRINT THE NUMBER
0810 0810 : AF                       xor     a                 ;
0811 0811 : C4 A0 0E   (M80) STRDON: call    nz,STRPRT         ;[M80] PRINT THE NUMBER
0814 0814 : E1                       pop     hl                ;
0815 0815 : 18 A3                    jr      NEWCHR            ;[M80[ PRINT SOME MORE
0817 0817 : 3A 47 38   (M80) COMPRT: ld      a,(PRTFLG)        ;[M80[ OUTPUT TO THE LINE PRINTER?
081A 081A : B7                       or      a                 ;[M80[ NON-ZERO MEANS YES
081B 081B : 28 08                    jr      z,ISCTTY          ;[M80[ NO, DO TELETYPE COMMA
081D 081D : 3A 46 38                 ld      a,(LPTPOS)        ;[M80[ ARE WE USING INFINITE WIDTH?
0820 0820 : FE 70                    cp      112               ;[M80[ CHECK IF NO MORE COMMA FIELDS
0822 0822 : C3 2D 08                 jp      CHKCOM            ;[M80[ USE TELETYPE CHECK
0825 0825 : 3A 49 38   (M80) ISCTTY: ld      a,(CLMLST)        ;[M80] POSITION OF LAST COMMA COLUMN
0828 0828 : 47                       ld      b,a               ;
0829 0829 : 3A 00 38                 ld      a,(TTYPOS)        ;[M80] GET TELETYPE POSITION
082C 082C : B8                       cp      b                 ;
082D 082D : D4 EA 19   (M80) CHKCOM: call    nc,CRDO           ;[M80] TYPE CRLF
0830 0830 : D2 61 08                 jp      nc,NOTABR         ;[M80] AND QUIT IF BEYOND THE LAST COMMA FIELD
0833 0833 : D6 0E      (M80) MORCOM: sub     CLMWID            ;[M80] GET [A] MODULUS CLMWID
0835 0835 : 30 FC                    jr      nc,MORCOM         ;
0837 0837 : 2F                       cpl                       ;[M80] FILL OUT TO AN EVEN CLMWID: CLMWID-[A] MOD CLMWID SPACES
0838 0838 : 18 20                    jr      ASPA2             ;[M80] GO PRINT [A]+1 SPACES
083A 083A : F5         (M80) TABER:  push    af                ;[M80] REMEMBER IF [A]=SPCTK OR TABTK
083B 083B : CD 53 0B                 call    GTBYTC            ;[M80] EVALUATE THE ARGUMENT
083E 083E : CF                       rst     SYNCHK            ;
083F 083F : 29                       byte    ')'               ;
0840 0840 : 2B                       dec     hl                ;
0841 0841 : F1                       pop     af                ;[M80] GET BACK SPCTK OR TABTK
0842 0842 : D6 A3                    sub     SPCTK             ;[M80] WAS IT SPCTK?
0844 0844 : E5                       push    hl                ;[M80] SAVE THE TEXT POINTER
0845 0845 : 28 0F                    jr      z,DOSIZT          ;[M80] VALUE IN [A]
0847 0847 : 3A 47 38                 ld      a,(PRTFLG)        ;[M80] LINE PRINTER OR TTY?
084A 084A : B7                       or      a                 ;[M80] NON-ZERO MEANS LPT
084B 084B : CA 53 08                 jp      z,TTYIST          ;
084E 084E : 3A 46 38                 ld      a,(LPTPOS)        ;[M80] GET LINE PRINTER POSITION
0851 0851 : 18 03                    jr      DOSIZT            ;
0853 0853 : 3A 00 38   (M80) TTYIST: ld      a,(TTYPOS)        ;[M80] GET TELETYPE PRINT POSITION
0856 0856 : 2F         (M80) DOSIZT: cpl                       ;[M80] PRINT [E]-[A] SPACES
0857 0857 : 83                       add     a,e               ;
0858 0858 : 30 07                    jr      nc,NOTABR         ;[M80] PRINT IF PAST CURRENT
085A 085A : 3C         (M80) ASPA2:  inc     a                 ;
085B 085B : 47                       ld      b,a               ;[M80] [B]=NUMBER OF SPACES TO PRINT
085C 085C : 3E 20                    ld      a,' '             ;[M80] [A]=SPACE
085E 085E : DF         (M80) REPOUT: rst     OUTCHR            ;[M80] PRINT [A]
085F 085F : 10 FD                    djnz    REPOUT            ;[M80] DECREMENT THE COUNT
0861 0861 : E1         (M80) NOTABR: pop     hl                ;[M80] PICK UP TEXT POINTER
0862 0862 : D7                       rst     CHRGET            ;[M80] AND THE NEXT CHARACTER
0863 0863 : C3 C1 07                 jp      PRINTC            ;{M80} WE JUST PRINTED SPACES, DON'T CALL CRDO IF END OF THE LINE
0866 0866 : F7         (M80) FINPRT: rst     HOOKDO            ;
0867 0867 : 07         {~~~} HOOK7:  byte    7                 ;
0868 0868 : AF                       xor     a                 ;
0869 0869 : 32 47 38                 ld      (PRTFLG),a        ;[M80] ZERO OUT PTRFIL
086C 086C : C9                       ret                       ;
086D 086D                    
086D 086D : 3F 52 65 64      TRYAGN: byte    "?Redo from start",13,10,0
0871 0871 : 6F 20 66 72                
0875 0875 : 6F 6D 20 73             
0879 0879 : 74 61 72 74                
087D 087D : 0D 0A 00                
0880 0880                    
0880 0880                  + ;[M80]  HERE WHEN THE DATA THAT WAS TYPED IN OR IN "DATA" STATEMENTS
0880 0880                  | ;[M80]  IS IMPROPERLY FORMATTED. FOR "INPUT" WE START AGAIN.
0880 0880                  | ;[M80]  FOR "READ" WE GIVE A SYNTAX ERROR AT THE DATA LINE.
0880 0880                  | ;
0880 0880 : F7               TRMNOK: rst     HOOKDO            ;
0881 0881 : 08         {~~~} HOOK8:  byte    8                 ;
0882 0882 : 3A CD 38                 ld      a,(FLGINP)        ;[M80] WAS IT READ OR INPUT?
0885 0885 : B7                       or      a                 ;[M80] ZERO=INPUT
0886 0886 : C2 BE 03                 jp      nz,DATSNE         ;[M80] GIVE ERROR AT DATA LINE
0889 0889 : C1                       pop     bc                ;[M80] GET RID OF THE POINTER INTO THE VARIABLE LIST
088A 088A : 21 6D 08                 ld      hl,TRYAGN         ;[M80] PRINT "?REDO FROM START"
088D 088D : CD 9D 0E                 call    STROUT            ;
0890 0890 : C3 01 0C                 jp      GTMPRT            ;          
0893 0893                                                      
0893 0893 : F7         [M80] INPUT:  rst     HOOKDO            ;
0894 0894 : 1A         {~~~} HOOK26: byte    26                ;
0895 0895 : CD 45 0B                 call    ERRDIR            ;[M65] DIRECT IS NOT OK 
0898 0898 : 7E                       ld      a,(hl)            ;
0899 0899 : FE 22      {M80} QTINP:  cp      '"'               ;[M80] IS IT A QUOTE?
089B 089B : 3E 00                    ld      a,0               ;[M80] BE TALKATIVE
089D 089D : C2 AA 08                 jp      nz,NOTQTI         ;[M65] NO MESSAGE
08A0 08A0 : CD 60 0E                 call    STRLTI            ;[M65] LITERALIZE THE STRING IN TEXT
08A3 08A3 : CF         {M80} NTICMA: rst     SYNCHK            ;
08A4 08A4 : 3B                       byte    ';'               ;[M80] MUST END WITH SEMICOLON
08A5 08A5 : E5         {M80} INPCMA: push    hl                ;[M80] REMEMBER WHERE IT ENDED
08A6 08A6 : CD A0 0E                 call    STRPRT            ;[M80] PRINT IT OUT
08A9 08A9 : 3E                       byte    $3E               ;;[LD A,] over next instruction
08AA 08AA : E5         (M80) NOTQTI: push    hl                ;{M80} SAVE TEXT POINTER
08AB 08AB : CD 5B 0D                 call    QINLIN            ;[M65] TYPE "?" AND INPUT A LINE OF TEXT.
08AE 08AE : C1                       pop     bc                ;{M80} GET BACK THE TEXT POINTER
08AF 08AF : DA 26 0C                 jp      c,STPEND          ;{M80} IF CONTROL-C, STOP
08B2 08B2 : 23                       inc     hl                ;
08B3 08B3 : 7E                       ld      a,(hl)            ;
08B4 08B4 : B7                       or      a                 ;
08B5 08B5 : 2B                       dec     hl                ;
08B6 08B6 : C5                       push    bc                ;
08B7 08B7 : CA 1B 07                 jp      z,DATAH           ;
08BA 08BA : 36 2C      {M80} INPCN3: ld      (hl),','          ;[M80] SETUP COMMA AT BUFMIN
08BC 08BC : 18 05                    jr      INPCON            ;
08BE 08BE
08BE 08BE                  + ;[M80] READ STATEMENT
08BE 08BE                  | ;[M80] IN THE PROCESSING OF DATA AND READ STATEMENTS:
08BE 08BE                  | ;[M80] ONE POINTER POINTS TO THE DATA (IE THE NUMBERS BEING FETCHED)
08BE 08BE                  | ;[M80] AND ANOTHER POINTS TO THE LIST OF VARIABLES
08BE 08BE                  | ;[M80]
08BE 08BE                  | ;[M80] THE POINTER INTO THE DATA ALWAYS STARTS POINTING TO A
08BE 08BE                  | ;[M80] TERMINATOR -- A , : OR END-OF-LINE
08BE 08BE : E5         [M80] READ:   push    hl                ;[M80] SAVE THE TEXT POINTER
08BF 08BF : 2A DC 38                 ld      hl,(DATPTR)       ;[M80] GET LAST DATA LOCATION
08C2 08C2 : F6                       byte    $F6               ;[M80] "ORI" TO SET [A] NON-ZERO
08C3 08C3 : AF         (M80) INPCON: xor     a                 ;[M80] SET FLAG THAT THIS IS AN INPUT
08C4 08C4 : 32 CD 38                 ld      (FLGINP),a        ;[M80] STORE THE FLAG
08C7 08C7 : E3                       ex      (sp),hl           ;[M80] [H,L]=VARIABLE LIST POINTER
08C8 08C8 : 01                       byte    $01               ;[M80] "LD BC," OVER THE NEXT 2
08C9 08C9 : CF         [M80] LOPDT2: rst     SYNCHK            
0BCA 0BCA : 2C                       byte    ','               ;[M80] MAKE SURE THERE IS A ","
08CB 08CB : CD D1 10   {M80} LOPDAT: call    PTRGET            ;[M80] GET THE POINTER TO A VARIABLE INTO [D,E]
08CE 08CE : E3                       ex      (sp),hl           ;;Swap with Data List Pointer
08CF 08CF                    ;[M80] NOTE AT THIS POINT WE HAVE A VARIABLE WHICH WANTS DATA
08CF 08CF                    ;[M80] AND SO WE MUST GET DATA OR COMPLAIN
08CF 08CF : D5                       push    de                ;[M80] SAVE THE POINTER TO THE VARIABLE
08D0 08D0 : 7E                       ld      a,(hl)            ;[M80] READ DATA LIST TERMINATOR
08D1 08D1 : FE 2C                    cp      ','               ;
08D3 08D3 : 28 1B                    jr      z,DATBK           ;[M80] A COMMA SO A VALUE MUST FOLLOW
08D5 08D5 : 3A CD 38                 ld      a,(FLGINP)        ;[M80] SEE WHAT TYPE OF STATEMENT THIS WAS
08D8 08D8 : B7                       or      a                 ;;???ZERO FOR INPUT, OTHERWISE READ
08D9 08D9 : C2 53 09                 jp      nz,DATLOP         ;[M80] SEARCH FOR ANOTHER DATA STATEMENT
08DC08DC                                                       
08DC 08DC : 3E 3F      {M80} GETAGN: ld      a,'?'             ;[M80] TYPE "?" AND INPUT A LINE OF TEXT
08DE 08DE : DF                       rst     OUTCHR            ;
08DF 08DF : CD 5B 0D                 call    QINLIN            ;
08E2 08E2 : D1                       pop     de                ;
08E3 08E3 : C1                       pop     bc                ;[M80] TAKE OFF SINCE MAYBE LEAVING
08E4 08E4 : DA 26 0C                 jp      c,STPEND          ;[M80] IF EMPTY LEAVE
08E7 08E7 : 23                       inc     hl                ;
08E8 08E8 : 7E                       ld      a,(hl)            ;
08E9 08E9 : 2B                       dec     hl                ;
08EA 08EA : B7                       or      a                 ;
08EB 08EB : C5                       push    bc                ;[M80] PUT BACK  SINCE DIDN'T LEAVE
08EC 08EC : CA 1B 07                 jp      z,DATAH           
08EF 08EF : D5                       push    de                ;{M80} SAVE THE POINTER TO THE VARIABLE
08F0 08F0                                                      
08F0 08F0 : F7         [M80] DATBK:  rst     HOOKDO            ;;Call Extended Hook 28
08F1 08F1 : 1C         {~~~} HOOK28: byte    28                ;
08F2 08F2 : 3A AB 38                 ld      a,(VALTYP)        ;[M80] IS IT A STRING?
08F5 08F5 : B7                       or      a                 ;
08F6 08F6 : 28 1F                    jr      z,NUMINS          ;[M80] IF NUMERIC, USE FIN TO GET IT
08F8 08F8 : D7                       rst     CHRGET            ;
08F9 08F9 : 57                       ld      d,a               ;[M80] ASSUME QUOTED STRING
08FA 08FA : 47                       ld      b,a               ;[M80] SETUP TERMINATORS
08FB 08FB : FE 22                    cp      '"'               ;[M80] QUOTE ?
08FD 08FD : 28 0C                    jr      z,NOWGET          ;[M80] TERMINATORS OK
08FF 08FF : 3A CD 38                 ld      a,(FLGINP)        ;[M80] INPUT SHOULDN'T TERMINATE ON ":"      
0902 0902 : B7                       or      a                 ;[M80] SEE IF READ OR INPUT
0903 0903 : 57                       ld      d,a               ;[M80] SET D TO ZERO FOR INPUT
0904 0904 : 28 02                    jr      z,NCOLST          ;
0906 0906 : 16 3A                    ld      d,':'             ;[M80] UNQUOTED STRING TERMINATORS
0908 0908 : 06 2C      (M80) NCOLST: ld      b,','             ;[M80] ARE COLON AND COMMA
090A 090A : 2B                       dec     hl                ;[M80] START CHARACTER MUST BE INCLUDED IN THE QUOTED STRING
090B 090B : CD 63 0E   (M80) NOWGET: call    STRLT2            ;[M80] MAKE STRING DESCRIPTOR FOR VALUE AND COPY IF NECESSARY
090E 090E : EB                       ex      de,hl             ;
090F 090F : 21 20 09                 ld      hl,STRDN2         ;[M80] RETURN LOC
0912 0912 : E3                       ex      (sp),hl           ;[M80] [H,L]=PLACE TO STORE VARIABLE VALUE
0913 0913 : D5                       push    de                ;[M80] TEXT POINTER GOES ON
0914 0914 : C3 4A 07                 jp      INPCOM            ;[M80] DO ASSIGNMENT
0917 0917 : D7         (M80) NUMINS: rst     CHRGET            ;
0918 0918 : CD E5 15                 call    FIN               ;[M80] CALL # INPUTTER
091B 091B : E3                       ex      (sp),hl           ;*** tail end of [M80] FIN?
091C 091C : CD 3A 15                 call    MOVMF             ;
091F 091F : E1                       pop     hl                ;
0920 0920 : 2B         (M80) STRDN2: dec     hl                ;
0921 0921 : D7                       rst     CHRGET            ;
0922 0922 : 28 05                    jr      z,TRMOK           ;
0924 0924 : FE 2C                    cp      ','               ;
0926 0926 : C2 80 08                 jp      nz,TRMNOK         ;[M80] ENDED PROPERLY?
0929 0929 : E3         [M80] TRMOK:  ex      (sp),hl           ;
092A 092A : 2B                       dec     hl                ;[M80] LOOK AT TERMINATOR
092B 092B : D7                       rst     CHRGET            ;[M80] AND SET UP CONDITION CODES
092C 092C : C2 C9 08                 jp      nz,LOPDT2         ;[M80] NOT ENDING, CHECK FOR COMMA AND GET ANOTHER VARIABLE
092F 092F : D1                       pop     de                ;[M80] POP OFF THE POINTER INTO DATA
0930 0930 : 3A CD 38                 ld      a,(FLGINP)        ;[M80] FETCH THE STATEMENT TYPE FLAG
0933 0933 : B7                       or      a                 ;
0934 0934 : EB                       ex      de,hl             ;[M80] INPUT STATEMENT
0935 0935 : C2 1A 0C                 jp      nz,RESFIN         ;[M80] UPDATE DATPTR
0938 0938 : D5                       push    de                ;[M80] SAVE THE TEXT POINTER
0939 0939 : B6                       or      (hl)              ;
093A 093A : 21 42 09                 ld      hl,EXIGNT         ;
093D 093D : C4 9D 0E                 call    nz,STROUT         ;[M65] TYPE "?EXTRA IGNORED"
0940 0940 : E1                       pop     hl                ;
0941 0941 : C9                       ret                       ;[M65[ DO NEXT STATEMENT
0942 0942
0942 0942 : 3F 45 78 74[M65] EXIGNT: byte    "?Extra ignored",13,10,0
0946 0946 : 72 61 20 69
094A 094A : 67 6E 6F 72
094E 094E : 65 64 0D 0A
0952 0952 : 00
0953 0953                    
0953 0953                  + ;[M80] THE SEARCH FOR DATA STATMENTS IS MADE BY USING THE EXECUTION CODE
0953 0953                  | ;[M80] FOR DATA TO SKIP OVER STATEMENTS. THE START WORD OF EACH STATEMENT
0953 0953                  | ;[M80] IS COMPARED WITH $DATA. EACH NEW LINE NUMBER
0953 0953                  | ;[M80] IS STORED IN DATLIN SO THAT IF AN ERROR OCCURS WHILE READING
0953 0953                  | ;[M80] DATA THE ERROR MESSAGE WILL GIVE THE LINE NUMBER OF THE 
0953 0953                  | ;[M80] ILL-FORMATTED DATA
0953 0953                  | ;
0953 0953 : CD 1C 07   [M80] DATLOP: call    DATA              ;
0956 0956 : B7                       or      a                 ;
0957 0957 : 20 11                    jr      nz,NOWLIN         ;
0959 0959 : 23                       inc     hl                ;
095A 095A : 7E                       ld      a,(hl)            ;
095B 095B : 23                       inc     hl                ;
095C 095C : B6                       or      (hl)              ;
095D 095D : 1E 06                    ld      e,ERROD           ;[M80] NO DATA IS ERROR ERROD
095F 095F : CA DB 03                 jp      z,ERROR           ;[M80] IF SO COMPLAIN
0962 0962 : 23                       inc     hl                ;[M80] SKIP PAST LINE #
0963 0963 : 5E                       ld      e,(hl)            ;[M80] GET DATA LINE #
0964 0964 : 23                       inc     hl                ;
0965 0965 : 56                       ld      d,(hl)            ;
0966 0966 : ED 53 C9 38              ld      (DATLIN),de       ;
096A 096A : D7               NOWLIN: rst     CHRGET            ;[M80] GET THE STATEMENT TYPE
096B 096B : FE 83                    cp      DATATK            ;[M80] IS IS "DATA"?
096D 096D : 20 E4                    jr      nz,DATLOP         ;[M80] NOT DATA SO LOOK SOME MORE
096F 096F : C3 F0 08                 jp      DATBK             ;[M80] CONTINUE READING
0972 0972                                                    
0972 0972                 +  ;[M65] THESE ROUTINES CHECK FOR CERTAIN "VALTYP".
0972 0972                 |  ;[M65] [C] IS NOT PRESERVED.
0972 0972                 |  ;                                
0972 0972 -                  ;;Evaluate a Number
0972 0972 = CD 85 09   [M65] FRMNUM: call    FRMEVL            ;{M80} EVALUATE A FORMULA
0975 0975 -                  ;;Issue "TM" Error if Not a Number
0975 0975 = F6         [M65] CHKNUM: byte    $F6               ;;"OR $37" to skip next instruction
0976 0976 : 37         [M65] CHKSTR: scf                       ;;Set Carry to match strings
0977 0977 : 3A AB 38   [M65] CHKVAL: ld      a,(VALTYP)        ;
097A 097A : 8F                       adc     a,a               ;;Shift Left and Copy in Cary
097B 097B : B7                       or      a                 ;;Set Flags
097C 097C : E8                       ret     pe                ;;Return if Overflow
097D 097D : C3 D9 03   [M65] CHKERR: jp      TMERR             ;;Else TYPE MISMATCH Error
0980 0980
0980 0980                  + ;[M80] THE FORMULA EVALUATOR STARTS WITH
0980 0980                  | ;[M80] [H,L] POINTING TO THE FIRST CHARACTER OF THE FORMULA.
0980 0980                  | ;[M80] AT THE END [H,L] POINTS TO THE TERMINATOR.
0980 0980                  | ;[M80] THE RESULT IS LEFT IN THE FAC.
0980 0980                  | ;[M80] ON RETURN [A] DOES NOT REFLECT THE TERMINATING CHARACTER
0980 0980                  | ;[M80]
0980 0980                  | ;[M80] THE FORMULA EVALUATOR USES THE OPERATOR TABLE (OPTAB)
0980 0980                  | ;[M80] TO DETERMINE PRECEDENCE AND DISPATCH ADDRESSES FOR
0980 0980                  | ;[M80] EACH OPERATOR.
0980 0980                  | ;[M80] A TEMPORARY RESULT ON THE STACK HAS THE FOLLOWING FORMAT
0980 0980                  | ;[M80]
0980 0980                  | ;[M80] THE ADDRESS OF 'RETAOP' -- THE PLACE TO RETURN ON COMPLETION
0980 0980                  | ;[M80] OF OPERATOR APPLICATION
0980 0980                  | ;[M80]
0980 0980                  | ;[M80] THE FLOATING POINT TEMPORARY RESULT
0980 0980                  | ;[M80]
0980 0980                  | ;[M80] THE ADDRESS OF THE OPERATOR ROUNTINE
0980 0980                  | ;[M80]
0980 0980                  | ;[M80] THE PRECEDENCE OF THE OPERATOR
0980 0980                  | ;[M80]
0980 0980                  | ;[M80] TOTAL 10 BYTES
0980 0980                  | ;
0980 0980 : CF         [M80] FRMEQL: rst     SYNCHK            ;
0981 0981 : B0                       byte    EQUATK            ;[M80] CHECK FOR EQUAL SIGN
0982 0982 : 01                       byte    $01               ;[M80] "LD BC," OVER THE NEXT 2
0983 0983 : CF         [M80] FRMPRN: rst     SYNCHK            ;[M80] GET PAREN BEFORE FORMULA
0984 0984 : 28                       byte    '('               ;
0985 0985
0985 0985 -                + ;;Evaluate Formula
0985 0985                  | ;[M65] THE FORMULA EVALUATOR STARTS WITH
0985 0985                  | ;[M65] [H,L] POINTING TO THE FIRST CHARACTER OF THE FORMULA.
0985 0985                  | ;[M65] AT THE END [H,L] POINTS TO THE TERMINATOR.
0985 0985                  | ;[M65] THE RESULT IS LEFT IN THE FAC.
0985 0985                  | ;[M65] ON RETURN [A] DOES NOT REFLECT THE TERMINATOR.
0985 0985                  | ;
0985 0985                  | ;[M65] THE FORMULA EVALUATOR USES THE OPERATOR LIST (OPTAB)
0985 0985                  | ;[M65] TO DETERMINE PRECEDENCE AND DISPATCH ADDRESSES FOR
0985 0985                  | ;[M65] EACH OPERATOR.
0985 0985                  | ;[M65] A TEMPORARY RESULT ON THE STACK HAS THE FOLLOWING FORMAT.
0985 0985                  | ;[M65]       THE ADDRESS OF THE OPERATOR ROUTINE.
0985 0985                  | ;[M65]       THE FLOATING POINT TEMPORARY RESULT.
0985 0985                  | ;[M65]       THE PRECEDENCE OF THE OPERATOR.
0985 0985                  | ;
0985 0985 = 2B         [M80] FRMEVL: dec     hl                ;[M80] BACK UP CHARACTER POINTER
0986 0986 : 16 00      [M80] FRMCHK: ld      d,0               ;[M80] INITIAL DUMMY PRECEDENCE IS 0
0988 0988 : D5         [M80] LPOPER: push    de                ;[M80] SAVE PRECEDENCE
0989 0989 : 0E 01                    ld      c,1               ;[M80] EXTRA SPACE NEEDED FOR RETURN ADDRESS
098B 098B : CD A0 0B                 call    GETSTK            ;[M80] MAKE SURE THERE IS ROOM FOR RECURSIVE CALLS
098E 098E : CD FD 09                 call    EVAL              ;[M80] EVALUATE SOMETHING
0991 0991 : 22 D0 38   [N80] TSTOP:  ld      (TENP2),hl        ;[M80] SAVE TEXT POINTER
0994 0994 : 2A D0 38   [M80] RETAOP: ld      hl,(TENP2)        ;[M80] RESTORE TEXT PTR
0997 0997 : C1                       pop     bc                ;[M80] POP OFF THE PRECEDENCE OF OLDOP
0998 0998 : 78                       ld      a,b               ;
0999 0999 : FE 78                    cp      $78               ;
099B 099B : D4 75 09                 call    nc,CHKNUM         ;
099E 099E : 7E         {M80} NOTSTV  ld      a,(hl)            ;[M80] GET NEXT CHARACTER
099F 099F : 22 C3 38                 ld      (TENP3),hl        ;[M80] SAVE UPDATED CHARACTER POINTER
09A2 09A2 : FE A8                    cp      PLUSTK            ;[M80] IS IT AN OPERATOR?
09A4 09A4 : D8                       ret     c                 ;
09A5 09A5 : FE B2                    cp      LESSTK+1          ;
09A7 09A7 : D0                       ret     nc                ;[M80] NO, ALL DONE
09A8 09A8 : FE AF                    cp      GREATK            ;[M80] SOME KIND OF RELATIONAL?
09AA 09AA : D2 E2 09                 jp      nc,DORELS         ;[M80] YES, DO IT
09AD 09AD : D6 A8                    sub     PLUSTK            ;[M80] SUBTRACT OFFSET FOR FIRST ARITHMETIC
09AF 09AF : 5F                       ld      e,a               ;[M80] MUST MULTIPLY BY 3
09B0 09B0 : 20 08                    jr      nz,NTPLUS         ;[M80] NOT ADDITION OP
09B2 09B2 : 3A AB 38                 ld      a,(VALTYP)        ;[M80] SEE IF LEFT PART IS STRING
09B5 09B5 : 3D                       dec     a                 ;[M80] SEE IF LEFT PART IS STRING
09B6 09B6 : 7B                       ld      a,e               ;[M80] REFETCH OP-VALUE
09B7 09B7 : CA 7C 0F                 jp      z,CAT             ;[M80] MUST BE CAT
09BA 09BA : 07         (M80) NTPLUS: rlca                      ;[M65] MULTIPLY BY 2
09BB 09BB : 83                       add     a,e               ;[M65] BY THREE.
09BC 09BC : 5F                       ld      e,a               ;[M65] SET UP FOR LATER
09BD 09BD : 21 4C 03   {M65} QPREC1: ld      hl,OPTAB          ;[M80] CREATE INDEX INTO OPTAB
09C0 09C0 : 16 00                    ld      d,0               ;[M80] MAKE HIGH BYTE OF OFFSET=0
09C2 09C2 : 19                       add     hl,de             ;[M80] ADD IN CALCULATED OFFSET
09C3 09C3 : 78                       ld      a,b               ;[M80] [A] GETS OLD PRECEDENCE
09C4 09C4 : 56                       ld      d,(hl)            ;[M80] REMEMBER NEW PRECEDENCE
09C5 09C5 : BA                       cp      d                 ;[M80] OLD-NEW
09C6 09C6 : D0                       ret     nc                ;[M80] APPLY OLD OP IF >= PRECEDENCE
09C7 09C7 : 23                       inc     hl                ;
09C8 09C8 : CD 75 09                 call    CHKNUM            ;
09CB 09CB                                                      
09CB 09CB : C5         [M80] FINTMP: push    bc                ;[M80] SAVE THESE THINGS FOR RETAOP
09CC 09CC : 01 94 09                 ld      bc,RETAOP         ;[M80] GENERAL OPERATOR APPLICATION ROUTINE -- DOES TYPE CONVERSIONS
09CF 09CF : C5                       push    bc                ;[M80] SAVE PLACE TO GO
09D0 09D0 : 43                       ld      b,e               ;;Save dispatch offset and precedence
09D1 09D1 : 4A                       ld      c,d               ;
09D2 09D2 : CD 13 15                 call    PUSHF             ;[M80] PUT FAC ON STACK
09D5 09D5 : 58                       ld      e,b               ;
09D6 09D6 : 51                       ld      d,c               ;;Restore dispatch offset and precedence
09D7 09D7 : 4E                       ld      c,(hl)            ;;Load FINRE2 address from FINREA into BC
09D8 09D8 : 23                       inc     hl                ;
09D9 09D9 : 46                       ld      b,(hl)            ;
09DA 09DA : 23                       inc     hl                ;;Now HL contains FINRE2 address
09DB 09DB : C5                       push    bc                ;;Push FINRE2 address
09DC 09DC : 2A C3 38                 ld      hl,(TENP3)        ;REGET THE TEXT POINTER
09DF 09DF : C3 88 09                 jp      LPOPER            ;PUSH ON THE PRECEDENCE AND READ MORE FORMULA
09E2 09E2                                                      
09E2 09E2                    ;;Evaluate Logical Operators      
09E2 09E2 : 16 00      [M80] DORELS: ld      d,0               ;{M80} ASSUME NO RELATION OPS, SETUP HIGH ORDER OF INDEX INTO OPTAB
09E4 09E4 : D6 AF      (M80) LOPREL: sub     GREATK            ;[M80] IS THIS ONE RELATION?
09E6 09E6 : DA D0 0A                 jp      c,FINREL          ;[M80] RELATIONS ALL THROUGH
09E9 09E9 : FE 03                    cp      LESSTK-GREATK+1   ;[M80] IS IT REALLY RELATIONAL?
09EB 09EB : D2 D0 0A                 jp      nc,FINREL         ;[M80] NO JUST BIG
09EE 09EE : FE 01                    cp      1                 ;[M80] SET UP BITS BY MAPPING
09F0 09F0 : 17                       rla                       ;[M80] 0 TO 1 1 TO 2 AND 2 TO 4
09F1 09F1 : AA                       xor     d                 ;[M80] BRING IN THE OLD BITS
09F2 09F2 : BA                       cp      d                 ;[M80] MAKE SURE RESULT IS BIGGER
09F3 09F3 : 57                       ld      d,a               ;[M80] SAVE THE MASK
09F4 09F4 : DA C4 03                 jp      c,SNERR           ;[M80] DON'T ALLOW TWO OF THE SAME
09F7 09F7 : 22 C3 38                 ld      (TENP3),hl        ;[M80] SAVE CHARACTER POINTER
09FA 09FA : D7                       rst     CHRGET            ;[M80] GET THE NEXT CANDIDATE
09FB 09FB : 18 E7                    jr      LOPREL            ;
09FD 09FD
09FD 09FD                    ;[M80] EVALUATE VARIABLE, CONSTANT, FUNCTION CALL
09FD 09FD : F7         [M80] EVAL:   rst     HOOKDO            ;
09FE 09FE : 09         {~~~} HOOK9:  byte    9                 ;
09FF 09FF : AF                       xor     a                 ;
0A00 0A00 : 32 AB 38                 ld      (VALTYP),a        ;[M65] ASSUME VALUE WILL BE NUMERIC
0A03 0A03 : D7                       rst     CHRGET            ;
0A04 0A04 : CA D6 03                 jp      z,MOERR           ;[M80] TEST FOR MISSING OPERAND - IF NONE GIVE ERROR
0A07 0A07 : DA E5 15                 jp      c,FIN             ;[M80] IF NUMERIC, INTERPRET CONSTANT
0A0A 0A0A : CD C6 0C                 call    ISLETC            ;[M80] VARIABLE NAME?
0A0D 0A0D : D2 4E 0A                 jp      nc,ISVAR          ;[M80] AN ALPHABETIC CHARACTER MEANS YES
0A10 0A10 : FE A8                    cp      PLUSTK            ;[M80] IGNORE "+"
0A12 0A12 : 28 E9                    jr      z,EVAL            ;
0A14 0A14 : FE 2E      {M65} QDOT:   cp      '.'               ;[M65] LEADING CHARACTER OF CONSTANT?
0A16 0A16 : CA E5 15                 jp      z,FIN             ;
0A19 0A19 : FE A9                    cp      MINUTK            ;[M80] NEGATION?
0A1B 0A1B : CA 3D 0A                 jp      z,DOMIN           ;[M65] SHO IS.
0A1E 0A1E : FE 22                    cp      '"'               ;[M80] STRING CONSTANT?
0A20 0A20 : CA 60 0E                 jp      z,STRLTI          ;[M80] IF SO BUILD A TEMPORARY DESCRIPTOR
0A23 0A23 : FE A6                    cp      NOTTK             ;[M80] CHECK FOR "NOT" OPERATOR
0A25 0A25 : CA 05 0B                 jp      z,NOTER           ;
0A28 0A28 : FE A4                    cp      INKETK            ;[M80] INKEY$ FUNCTION?
0A2A 0A2A : CA FB 19                 jp      z,INKEY           ;
0A2D 0A2D : FE A2                    cp      FNTK              ;
0A2F 0A2F : CA 40 0B                 jp      z,FNDOER          ;
0A32 0A32 : D6 B2                    sub     ONEFUN            ;[M80] IS IT A FUNCTION CALL
0A34 0A34 : D2 5F 0A                 jp      nc,ISFUN          ;[M80] YES, DO IT
0A37 0A37                    ;[M80] ONLY POSSIBILITY LEFT IS A FORMULA IN PARENTHESES
0A37 0A37 -                  ;;Recursively Evaluate Formula in Parentheses
0A37 0A37 = CD 83 09   [M80] PARCHK: call    FRMPRN            ;[M80] RECURSIVELY EVALUATE THE FORMULA
0A3A 0A3A : CF                       rst     SYNCHK            ;
0A3B 0A3B : 29                       byte    ')'               ;
0A3C 0A3C : C9                       ret                       ;
0A3D 0A3D                                                      
0A3D 0A3D : 16 7D      [M80] DOMIN:  ld      d,125             ;[M80] A PRECEDENCE BELOW ^ BUT ABOVE ALL ELSE
0A3F 0A3F : CD 88 09                 call    LPOPER            ;[M80] SO ^ GREATER THAN UNARY MINUS
0A42 0A42 : 2A D0 38                 ld      hl,(TENP2)        ;[M80] GET TEXT POINTER
0A45 0A45 : E5                       push    hl                ;
0A46 0A46 : CD 0B 15                 call    NEG               ;
0A49 0A49 : CD 75 09   [M80] LABBCK: call    CHKNUM            ;[M80] FUNCTIONS THAT DON'T RETURN
0A4C 0A4C : E1                       pop     hl                ;[M80] STRING VALUES COME BACK HERE
0A4D 0A4D : C9                       ret                       ;
0A4E 0A4E                    
0A4E 0A4E -                  ;;Get Variable Value or String Pointer
0A4E 0A4E = CD D1 10   [M80] ISVAR:  call    PTRGET            ;[M80] GET A POINTER TO THE VARIABLE IN [D,E]
0A51 0A51 : E5         [M80] RETVAR: push    hl                ;[M80] SAVE THE TEXT POINTER
0A52 0A52 : EB                       ex      de,hl             ;{M80} PUT THE POINTER TO THE VARIABLE OR STRING DESCRIPTOR
0A53 0A53 : 22 E4 38                 ld      (FACLO),hl        ;[M80]IN CASE IT'S STRING STORE POINTER TO THE DESCRIPTOR IN FACLO.
0A56 0A56 : 3A AB 38                 ld      a,(VALTYP)        ;[M80]FOR STRINGS WE JUST LEAVE
0A59 0A59 : B7                       or      a                 ;[M80]A POINTER IN THE FAC
0A5A 0A5A : CC 20 15                 call    z,MOVFM           ;[M80]THE FAC USING [H,L] AS THE POINTER.
0A5D 0A5D : E1                       pop     hl                ;[M80]RESTORE THE TEXT POINTER
0A5E 0A5E : C9                       ret                       ;
0A5F 0A5F                    
0A5F 0A5F                    ;[M80] MOST FUNCTIONS TAKE A SINGLE ARGUMENT.
0A5F 0A5F                    ;[M80] THE RETURN ADDRESS OF THESE FUNCTIONS IS A SMALL ROUTINE
0A5F 0A5F                    ;[M80] THAT CHECKS TO MAKE SURE VALTYP IS 0 (NUMERIC) AND POPS OFF
0A5F 0A5F                    ;[M80] THE TEXT POINTER. SO NORMAL FUNCTIONS THAT RETURN STRING RESULTS (I.E. CHR$)
0A5F 0A5F                    ;[M80] MUST POP OFF THE RETURN ADDRESS OF LABBCK, AND POP OFF THE
0A5F 0A5F                    ;[M80] TEXT POINTER AND THEN RETURN TO FRMEVL.
0A5F 0A5F                    ;[M80]
0A5F 0A5F                    ;[M80] THE SO CALLED "FUNNY" FUNCTIONS CAN TAKE MORE THAN ONE ARGUMENT.
0A5F 0A5F                    ;[M80] THE FIRST OF WHICH MUST BE STRING AND THE SECOND OF WHICH
0A5F 0A5F                    ;[M80] MUST BE A NUMBER BETWEEN 0 AND 256. THE TEXT POINTER IS
0A5F 0A5F                    ;[M80] PASSED TO THESE FUNCTIONS SO ADDITIONAL ARGUMENTS
0A5F 0A5F                    ;[M80] CAN BE READ. THE TEXT POINTER IS PASSED IN [D,E].
0A5F 0A5F                    ;[M80] THE CLOSE PARENTHESIS MUST BE CHECKED AND RETURN IS DIRECTLY
0A5F 0A5F                    ;[M80] TO FRMEVL WITH [H,L] SETUP AS THE TEXT POINTER POINTING BEYOND THE ")".
0A5F 0A5F                    ;[M80] THE POINTER TO THE DESCRIPTOR OF THE STRING ARGUMENT
0A5F 0A5F                    ;[M80] IS STORED ON THE STACK UNDERNEATH THE VALUE OF THE INTEGER
0A5F 0A5F                    ;[M80] ARGUMENT (2 BYTES)
0A5F 0A5F                    ;
0A5F 0A5F              [M80] NUMGFN  =       (CHRTK-ONEFUN)*2+1
0A5F 0A5F : F7         [M80] ISFUN:  rst     HOOKDO            ;
0A60 0A60 : 1B         {~~~} HOOK27  byte    27                ;
0A61 0A61 : FE 18                    cp      POINTK-ONEFUN     ;;Is it POINT()
0A63 0A63 : CA 68 1A                 jp      z,POINT           ;;Yes, go do it
0A66 0A66 : 06 00      {M80} NTMRND: ld      b,0               ;
0A68 0A68 : 07                       rlca                      ;[M80] MULTIPLY BY 2
0A69 0A69 : 4F                       ld      c,a               ;
0A6A 0A6A : C5                       push    bc                ;[M80] SAVE THE FUNCTION # ON THE STACK
0A6B 0A6B : D7                       rst     CHRGET            ;
0A6C 0A6C : 79                       ld      a,c               ;[M80] LOOK AT FUNCTION #
0A6D 0A6D : FE 29                    cp      NUMGFN            ;[M80] IS IT PAST LASNUM?
0A6F 0A6F : 38 16                    jr      c,OKNORM          ;[M80] NO, MUST BE A NORMAL FUNCTION
0A71 0A71 : CD 83 09                 call    FRMPRN            ;[M80] EAT OPEN PAREN AND FIRST ARG
0A74 0A74 : CF                       rst     SYNCHK            ;
0A75 0A75 : 2C                       byte    ','               ;[M80] TWO ARGS SO COMMA MUST DELIMIT
0A76 0A76 : CD 76 09                 call    CHKSTR            ;[M80] MAKE SURE THE FIRST ONE WAS STRING
0A79 0A79 : EB                       ex      de,hl             ;[M80] [D,E]=TXTPTR
0A7A 0A7A : 2A E4 38                 ld      hl,(FACLO)        ;[M80] GET PTR AT STRING DESCRIPTOR
0A7D 0A7D : E3                       ex      (sp),hl           ;[M80] GET FUNCTION #, SAVE THE STRING PTR
0A7E 0A7E : E5                       push    hl                ;[M80] PUT THE FUNCTION # ON
0A7F 0A7F : EB                       ex      de,hl             ;[M80] [H,L]=TXTPTR
0A80 0A80 : CD 54 0B                 call    GETBYT            ;[M80] [E]=VALUE OF FORMULA
0A83 0A83 : EB                       ex      de,hl             ;[M80] TEXT POINTER INTO [D,E], [H,L]=INT VALUE OF SECOND ARGUMENT
0A84 0A84 : E3                       ex      (sp),hl           ;[M80] SAVE INT VALUE OF SECOND ARG. [H,L]=FUNCTION NUMBER
0A85 0A85 : 18 08                    jr      FINGO             ;[M80] DISPATCH TO FUNCTION
0A87 0A87 : CD 37 0A   [M80] OKNORM: call    PARCHK            ;[M80] CHECK OUT THE ARGUMEN AND MAKE SURE ITS FOLLOWED BY ")"
0A8A 0A8A : E3                       ex      (sp),hl           ;[M80] [H,L]=FUNCTION # AND SAVE TEXT POINTER
0A8B 0A8B : 11 49 0A                 ld      de,LABBCK         ;[M80] RETURN ADDRESS
0A8E 0A8E : D5                       push    de                ;[M80] MAKE THEM REALLY COME BACK
0A8F 0A8F : 01 15 02   (M80) FINGO:  ld      bc,FUNDSP         ;[M80] FUNCTION DISPATCH TABLE       
0A92 0A92 : 09                       add     hl,bc             ;[M80] ADD ON THE OFFSET
0A93 0A93 : 4E                       ld      c,(hl)            ;{M80} FASTER THAN "PUSH HL"
0A94 0A94 : 23                       inc     hl                ;
0A95 0A95 : 66                       ld      h,(hl)            ;
0A96 0A96 : 69                       ld      l,c               ;
0A97 0A97 : E9                       jp      (hl)              ;[M80] GO PERFORM THE FUNCTION
0A98 0A98
0A98 0A98                    ;[M80] THE FOLOWING ROUTINE IS CALLED FROM FIN
0A98 0A98                    ;[M80] TO SCAN LEADING SIGNS FOR NUMBERS. 
0A98 0A98 : 15         [M80] MINPLS: dec     d                 ;[M80] SET SIGN OF EXPONENT FLAG
0A99 0A99 : FE A9                    cp      MINUTK            ;[M80] NEGATIVE EXPONENT?
0A9B 0A9B : C8                       ret     z                 ;
0A9C 0A9C : FE 2D                    cp      '-'               ;[M80] NO, RESET FLAG
0A9E 0A9E : C8                       ret     z                 ;
0A9F 0A9F : 14                       inc     d                 ;
0AA0 0AA0 : FE 2B                    cp      '+'               ;
0AA2 0AA2 : C8                       ret     z                 ;
0AA3 0AA3 : FE A8                    cp      PLUSTK            ;[M80] IGNORE "+"
0AA5 0AA5 : C8                       ret     z                 ;
0AA6 0AA6 : 2B                       dec     hl                ;[M80] CHECK IF LAST CHARACTER WAS A DIGIT
0AA7 0AA7 : C9                       ret                       ;[M80] RETURN WITH NON-ZERO SET
0AA8 0AA8
0AA8 0AA8                  + ;;AND and OR Operators
0AA8 0AA8                  | ;
0AA8 0AA8                  | ;[M80] DANDOR APPLIES THE "AND" AND "OR" OPERATOR
0AA8 0AA8                  | ;[M80] AND SHOULD BE USED TO IMPLEMENT ALL LOGICAL OPERATORS.
0AA8 0AA8                  | ;[M80] WHENEVER AN OPERATOR IS APPLIED, ITS PRECEDENCE IS IN [B].
0AA8 0AA8                  | ;[M80] THIS FACT IS USED TO DISTINGUISH BETWEEN "AND" AND "OR".
0AA8 0AA8                  | ;[M80] THE RIGHT HAND ARGUMENT IS COERCED TO INTEGER, JUST AS
0AA8 0AA8                  | ;[M80] THE LEFT HAND ONE WAS WHEN IT WAS PUSHED ON THE STACK.
0AA8 0AA8 : F6         [M65] OROP:   byte    $F6               ;[M80] OR $AF" TO SET THE PRECEDENCE "OR"=70
0AA9 0AA9 : AF         [M65] ANDOP:  xor     a                 ;;leave 0 in A for AND
0AAA 0AAA : F5         [M80] DANDOR: push    af                ;[M80] SAVE THE PRECEDENCE or Operator...
0AAB 0AAB : CD 75 09                 call    CHKNUM            ;[M65] MUST BE NUMBER
0AAE 0AAE : CD 82 06                 call    FRCINT            ;COERCE RIGHT HAND ARGUMENT TO INTEGER
0AB1 0AB1 : F1                       pop     af                ;GET BACK THE PRECEDENCE TO DISTINGUISH "AND" AND "OR"
0AB2 0AB2 : EB                       ex      de,hl             ;
0AB3 0AB3 : C1                       pop     bc                ;
0AB4 0AB4 : E3                       ex      (sp),hl           ;
0AB5 0AB5 : EB                       ex      de,hl             ;
0AB6 0AB6 : CD 23 15                 call    MOVFR             ;
0AB9 0AB9 : F5                       push    af                ;
0ABA 0ABA : CD 82 06                 call    FRCINT            ;
0ABD 0ABD : F1                       pop     af                ;
0ABE 0ABE : C1                       pop     bc                ;
0ABF 0ABF : 79                       ld      a,c               ;
0AC0 0AC0 : 21 21 0B                 ld      hl,GIVINT         ;{M80} PLACE TO JUMP WHEN DONE
0AC3 0AC3 : C2 CB 0A                 jp      nz,NOTAND         ;
0AC6 0AC6 : A3                       and     e                 ;
0AC7 0AC7 : 4F                       ld      c,a               ;
0AC8 0AC8 : 78                       ld      a,b               ;
0AC9 0AC9 : A2                       and     d                 ;
0ACA 0ACA : E9                       jp      (hl)              ;[M80] RETURN THE INTEGER [A,L]
0ACB 0ACB : B3         [M80] NOTAND: or      e                 ;
0ACC 0ACC : 4F                       ld      c,a               ;
0ACD 0ACD : 78                       ld      a,b               ;
0ACE 0ACE : B2                       or      d                 ;
0ACF 0ACF : E9                       jp      (hl)              ;[M80] RETURN THE INTEGER [A,L]
0AD0 0AD0                    
0AD0 0AD0                  + ;[M80] HERE TO BUILD AN ENTRY FOR A RELATIONAL OPERATOR
0AD0 0AD0                  | ;[M80] STRINGS ARE TREATED SPECIALLY. NUMERIC COMPARES ARE DIFFERENT
0AD0 0AD0                  | ;[M80] FROM MOST OPERATOR ENTRIES ONLY IN THE FACT THAT AT THE
0AD0 0AD0                  | ;[M80] BOTTOM INSTEAD OF HAVING RETAOP, DOCMP AND THE RELATIONAL
0AD0 0AD0                  | ;[M80] BITS ARE STORED. STRINGS HAVE STRCMP,THE POINTER AT THE STRING DESCRIPTOR,
0AD0 0AD0                  | ;[M80] DOCMP AND THE RELATIONAL BITS.
0AD0 0AD0                  | ;                   
0AD0 0AD0 : 21 E2 0A   [M80] FINREL: ld      hl,FINREA       
0AD3 0AD3 : 3A AB 38                 ld      a,(VALTYP)        ;[M80] SEE IF WE HAVE A NUMERIC COMPARE
0AD6 0AD6 : 1F                       rra                       ;{M65} GET VALUE TYPE INTO CARRY
0AD7 0AD7 : 7A                       ld      a,d               ;
0AD8 0AD8 : 17                       rla                       ;{M65} PUT VALTYP INTO LOW ORDER BIT OF MASK
0AD9 0AD9 : 5F                       ld      e,a               ;[M80] DISPATCH OFFSET FOR COMPARES IN APPLOP
0ADA 0ADA : 16 64                    ld      d,100             ;{MM80] [A]=OLD PRECEDENCE
0ADC 0ADC : 78                       ld      a,b               ;
0ADD 0ADD : BA                       cp      d                 ;[M80] RELATIONALS HAVE PRECEDENCE 100
0ADE 0ADE : D0                       ret     nc                ;[M80] APPLY EARLIER OPERATOR IF IT HAS HIGHER PRECEDENCE
0ADF 0ADF : C3 CB 09                 jp      FINTMP            ;
0AE2 0AE2
0AE2 0AE2 : E4 0A            FINREA: word    FINRE2
0AE4 0AE4 : 79         (M65) FINRE2: ld      a,c
0AE5 0AE5 : B7                       or      a
0AE6 0AE6 : 1F                       rra
0AE7 0AE7 : C1                       pop     bc
0AE8 0AE8 : D1                       pop     de
0AE9 0AE9 : F5                       push    af
0AEA 0AEA : CD 77 09                 call    CHKVAL            ;[M80] SEE IF WE HAVE A NUMERIC COMPARE
0AED 0AED : 21 FB 0A                 ld      hl,DOCMP          ;[M80] ROUTINE TO TAKE COMPARE ROUTINE RESULTAND RELATIONAL BITS AND RETURN THE ANSWER
0AF0 0AF0 : E5                       push    hl                
0AF1 0AF1 : CA 5B 15                 jp      z,FCOMP           ;{M89} COMPARE NUMBERS RETURNING $7F IF FAC IS LESS THAN THE REGISTERS
0AF4 0AF4 : AF                       xor     a
0AF5 0AF5 : 32 AB 38                 ld      (VALTYP),a
0AF8 0AF8 : C3 FC 0D                 jp      STRCMP
0AFB 0AFB
0AFB 0AFB : 3C         [M80] DOCMP:  inc     a                 ;[M80] SETUP BITS
0AFC 0AFC : 8F                       adc     a,a               ;[M80] 4=LESS 2=EQUAL 1=GREATER
0AFD 0AFD : C1                       pop     bc                ;[M80] WHAT DID HE WANT?
0AFE 0AFE : A0                       and     b                 ;[M80] ANY BITS MATCH?
0AFF 0AFF : C6 FF                    add     a,$FF             ;[M80] MAP 0 TO 0
0B01 0B01 : 9F                       sbc     a,a               ;[M80] AND ALL OTHERS TO 377
0B02 0B02 : C3 F6 14                 jp      FLOAT             ;[M80] CONVERT [A] TO AN INTEGER SIGNED
0B05 0B05                                                      
0B05 0B05 : 16 5A      [M80] NOTER:  ld      d,90              ;[M80] "NOT" HAS PRECEDENCE 90, SO FORMULA EVALUATION
0B07 0B07 : CD 88 09                 call    LPOPER            ;[M80] IS ENTERED WITH A DUMMY ENTRY OF 90 ON THE STACK
0B0A 0B0A : CD 75 09                 call    CHKNUM            ;[M65] MUST BE NUMBER
0B0D 0B0D : CD 82 06                 call    FRCINT            ;[M80] COERCE THE ARGUMENT TO INTEGER
0B10 0B10 : 7B                       ld      a,e               ;[M80] COMPLEMENT [D,E]
0B11 0B11 : 2F                       cpl                       ;
0B12 0B12 : 4F                       ld      c,a               ;
0B13 0B13 : 7A                       ld      a,d               ;
0B14 0B14 : 2F                       cpl                       ;
0B15 0B15 : CD 21 0B                 call    GIVINT            ;[M80] UPDATE THE FAC
0B18 0B18                            ;[M80] FRMEVL, AFTER SEEING THE PRECEDENCE OF 90 THINKS IT IS APPLYING AN OPERATOR
0B18 0B18                            ;[M80] SO IT HAS THE TEXT POINTER IN TEMP2 SO RETURN TO REFETCH IT
0B18 0B18 : C1                       pop     bc                ;
0B19 0B19 : C3 94 09                 jp      RETAOP            ; 
0B1C 0B1C                            
0B1C 0B1C                    ;{M80} SUBTRACTS [D,E] FROM [H,L] AND FLOAT THE RESULT LEAVING IT IN FAC
0B1C 0B1C                    ;;;Named GIVDBL in [M80] and [GWB] but Aquarius only supports floats
0B1C 0B1C : 7D               GIVFLT: ld      a,l               ;[M80] [H,L]=[H,L]-[D,E]
0B1D 0B1D : 93                       sub     e                 ;
0B1E 0B1E : 4F                       ld      c,a               ;
0B1F 0B1F : 7C                       ld      a,h               ;[M80] SAVE HIGH BYTE IN [H]
0B20 0B20 : 9A                       sbc     a,d               ;
0B21 0B21 : 41         [M80] GIVINT: ld      b,c               ;;Float Integer MSB=[A], LSB=[C]
0B22 0B22 : 50         [~~~] FLOATB: ld      d,b               ;;Float Integer MSB=[A], LSB=[B]
0B23 0B23 = 1E 00      [~~~] FLOATD: ld      e,0               ;;Float Integer MSB=[A], LSB=[D]
0B25 0B25 : 21 AB 38                 ld      hl,VALTYP         ;
0B28 0B28 : 73                       ld      (hl),e            ;[M80] SET VALTYP TO "FLOATING POINT"
0B29 0B29 : 06 90      {M80} INEGAD: ld      b,144             ;{M80} SET EXPONENT
0B2B 0B2B : C3 FB 14                 jp      FLOATR            ;[M80] GO FLOAT THE NUMBER
02BE 02BE                                                      
0B2E 0B2E : 3A 46 38   [M80] LPOS:   ld      a,(LPTPOS)        ;{M80} GET PRINT HEAD POSITION
0B31 0B31 : 18 03                    jr      SNGFLT            ;
0B33 0B33                                                      
0B33 0B33 : 3A 00 38   [M80] POS:    ld      a,(TTYPOS)        ;[M80] GET TELETYPE POSITION
0B36 0B36                                                      
0B36 0B36 : 47         [M80] SNGFLT: ld      b,a               ;[M80] MAKE [A] AN UNSIGNED INTEGER          
0B37 0B37 : AF                       xor     a                 ;
0B38 0B38 : C3 22 0B                 jp      FLOATB            ;
0B3B 0B3B                                                      
0B3B 0B3B                    ;;DEF FNx Stub                    
0B3B 0B3B : F7         [M80] DEF:    rst     HOOKDO            ;;If not hooked
0B3C 0B3C : 0F         {~~~} HOOK15: byte    15                
0B3D 0B3D : C3 C4 03                 jp      SNERR             ;;Syntax Error
0B40 0B40                                                      
0B40 0B40                    ;;FNx Stub                        
0B40 0B40 : F7         [M80] FNDOER: rst     HOOKDO            ;;If not hooked
0B41 0B41 : 10         {~~~} HOOK16: byte    16                
0B42 0B42 : C3 C4 03                 jp      SNERR             ;;Syntax Error
0B45 0B45
0B45 0B45 -                  ;[M65] SUBROUTINE TO SEE IF WE ARE IN DIRECT MODE AND COMPLAIN IF SO.
0B45 0B45 = E5         [M65] ERRDIR: push    hl                ;
0B46 0B46 : 2A 4D 38                 ld      hl,(CURLIN)       ;[M65] DIR MODE HAS [CURLIN]=$FFFF
0B49 0B49 : 23                       inc     hl                ;[M65] SO NOW, IS RESULT ZERO?
0B4A 0B4A : 7C                       ld      a,h               ;
0B4B 0B4B : B5                       or      l                 ;
0B4C 0B4C : E1                       pop     hl                ;
0B4D 0B4D : C0                       ret     nz                ;[M65] YES
0B4E 0B4E : 1E 16      {~~~} IDERR:  ld      e,ERRID           ;[M65] INPUT DIRECT ERROR CODE
0B50 0B50 : C3 DB 03                 jp      ERROR             ;
0B53 0B53                                                      
0B53 0B53 : D7         [M80] GTBYTC: rst     CHRGET            ;
0B54 0B54 -                  ;;Evaluate 8 bit Numeric Value    
0B54 0B54 = CD 72 09   [M80] GETBYT: call    FRMNUM            ;[M80] EVALUATE A FORMULA
0B57 0B57                    ;;Convert FAC to Byte in [A]      
0B57 0B57 : CD 7E 06   [M80] CONINT: call    INTFR2            ;[M80] CONVERT THE FAC TO AN INTEGER IN [D,E]
0B5A 0B5A : 7A                       ld      a,d               ;[M80] SET THE CONDITION CODES BASED ON THE HIGH ORDER
0B5B 0B5B : B7                       or      a                 ;
0B5C 0B5C : C2 97 06                 jp      nz,FCERR          ;[M80] WASN'T ERROR
0B5F 0B5F : 2B                       dec     hl                ;[M80] fUNCTIONS CAN GET HERE WITH BAD [H,L] BUT NOT SERIOUS
0B60 0B60 : D7                       rst     CHRGET            ;[M80] SET CONDITION CODES ON TERMINATOR
0B61 0B61 : 7B                       ld      a,e               ;[M80] RETURN THE RESULT IN [A] AND [E]
0B62 0B62 : C9                       ret                       ;
0B63 0B63                                                      
0B63 0B63 : CD 82 06   [M80] PEEK:   call    FRCINT            ;[M80] GET AN INTEGER IN [D,E]
0B66 0B66 : CD 88 0B                 call    PROMEM            ;{M80} DONT ALLOW IF PROTECTED MEMORY
0B69 0B69 : 1A                       ld      a,(de)            ;[M80] GET THE VALUE TO RETURN
0B6A 0B6A : C3 36 0B                 jp      SNGFLT            ;[M80] AND FLOAT IT
0B6D 0B6D                                                      
0B6D 0B6D : CD 72 09   [M80] POKE:   call    FRMNUM            ;[M80] READ A FORMULA
0B70 0B70 : CD 82 06                 call    FRCINT            ;{M80} FORCE VALUE INTO INT IN [D,E]
0B73 0B73 : CD 88 0B                 call    PROMEM            ;{M80} DONT ALLOW IF PROTECTED MEMORY
0B76 0B76 : D5                       push    de                ;[M80] PUT VALUE ON STACK
0B77 0B77 : CF                       rst     SYNCHK            ;
0B78 0B78 : 2C                       byte    ','               ;[M80] CHECK FOR A COMMA
0B79 0B79 : CD 54 0B                 call    GETBYT            
0B7C 0B7C : D1                       pop     de                ;[M80] GET THE ADDRESS BACK
0B7D 0B7D : 12                       ld      (de),a            ;[M80] STORE IT AWAY
0B7E 0B7E : C9                       ret                       ;[M80] SCANNED EVERYTHING
0B7F 0B7F                                                      
0B7F 0B7F : CD 85 09   {~~~} FRMINT: call    FRMEVL            ;;Orphan Code: 9 Bytes
0B82 0B82 : E5                       push    hl
0B83 0B83 : CD 82 06                 call    FRCINT
0B86 0B86 : E1                       pop     hl
0B87 0B87 : C9                       ret
0B88 0B88                            
0B88 0B88                  + ;;Check for illegal Address in PEEK and POKE
0B88 0B88                  | ;;;Label based on {M80] PRODIR
0B88 0B88 : E5               PROMEM: push    hl                ;
0B89 0B89 : 21 FF 2F                 ld      hl,$2FFF          ;   
0B8C 0B8C : E7                       rst     COMPAR            ;{M80} IS [D.E] LESS THAN 3000H?
0B8D 0B8D : E1                       pop     hl                ;
0B8E 0B8E : D2 97 06                 jp      nc,FCERR          ;{M80} YES, BLOW HIM UP NOW
0B91 0B91 : C9                       ret                       ;
0B92 0B92
0B92 0B92                  + ;[M80] THIS IS THE BLOCK TRANSFER ROUTINE
0B92 0B92                  | ;[M80] IT MAKES SPACE BY SHOVING EVERYTHING FORWARD
0B92 0B92                  | ;[M80]
0B92 0B92                  | ;[M80] [H,L] = DESTINATION OF HIGH ADDRESS
0B92 0B92                  | ;[M80] [D,E] = LOW ADDRESS TO BE TRANSFERRED
0B92 0B92                  | ;[M80] [B,C] = HIGH ADDRESS TO BE TRANSFERRED
0B92 0B92                  | ;[M80]
0B92 0B92                  | ;[M80] A CHECK IS MADE TO MAKE SURE A REASONABLE AMOUNT
0B92 0B92                  | ;[M80] OF SPACE REMAINS BETWEEN THE TOP OF THE STACK AND
0B92 0B92                  | ;[M80] THE HIGHEST LOCATION TRANSFERRED INTO
0B92 0B92                  | ;[M80]
0B92 0B92                  | ;[M80] ON EXIT [H,L]=[D,E]=LOW [B,C]=LOCATION LOW WAS MOVED INTO
0B92 0B92                  | ;
0B92 0B92 : CD A9 0B   [M80] BLTU:   call    REASON            ;[M80] CHECK DESTINATION TO MAKE SURE STACK WON'T BE OVERRUN
0B95 0B95 -                  ;Execute Block Transfer           
0B95 0B95 = C5         [M80] BLTUC:  push    bc                ;[M80] EXCHANGE [B,C] AND [H,L]
0B96 0B96 : E3                       ex      (sp),hl           ;
0B97 0B97 : C1                       pop     bc                ;
0B98 0B98 : E7         (M80) BLTLOP: rst     COMPAR            ;[M80] SEE IF WE ARE DONE
0B99 0B99 : 7E                       ld      a,(hl)            ;[M80] GET THE WORD TO TRANSFER
0B9A 0B9A : 02                       ld      (bc),a            ;[M80] TRANSFER IT
0B9B 0B9B : C8                       ret     z                 ;
0B9C 0B9C : 0B                       dec     bc                ;
0B9D 0B9D : 2B                       dec     hl                ;[M80] BACKUP FOR NEXT GUY
0B9E 0B9E : 18 F8                    jr      BLTLOP            ;
0BA0 0BA0
0BA0 0BA0 -                + ;;Check Stack Size
0BA0 0BA0                  | ;[M80] THIS ROUTINE IS USED TO MAKE SURE A CERTAIN NUMBER
0BA0 0BA0                  | ;[M80] OF LOCATIONS REMAIN AVAILABLE FOR THE
0BA0 0BA0                  | ;[M80] STACK. THE CALL IS :
0BA0 0BA0                  | ;[M80]       LD      C,number of 2 byte entries necessary
0BA0 0BA0                  | ;[M80]       CALL    GETSTK
0BA0 0BA0                  | ;
0BA0 0BA0                  | ;[M80] THIS ROUTINE MUST BE CALLED BY ANY ROUTINE WHICH PUTS
0BA0 0BA0                  | ;[M80] AN ARBITRARY AMOUNT OF STUFF ON THE STACK
0BA0 0BA0                  | ;[M80] (I.E. ANY RECURSIVE ROUTINE LIKE FRMEVL)
0BA0 0BA0                  | ;[M80] IT IS ALSO CALLED BY ROUTINES SUCH AS "GOSUB" AND "FOR"
0BA0 0BA0                  | ;[M80] WHICH MAKE PERMANENT ENTRIES ON THE STACK
0BA0 0BA0                  | ;[M80] ROUTINES WHICH MERELY USE AND FREE UP THE GUARANTEED
0BA0 0BA0                  | ;[M80] NUMLEV STACK LOCATIONS NEED NOT CALL THIS
0BA0 0BA0                  | ;
0BA0 0BA0 = E5               GETSTK: push    hl                ;[M80] SAVE [H,L]
0BA1 0BA1 : 2A DA 38                 ld      hl,(STREND)       ;
0BA4 0BA4 : 06 00                    ld      b,0               ;
0BA6 0BA6 : 09                       add     hl,bc             ;
0BA7 0BA7 : 09                       add     hl,bc             ;[M80] SEE IF WE CAN HAVE THIS MANY
0BA8 0BA8 : 3E                       byte    $3E               ;;"LD A," over next instruction
0BA9 0BA9 : E5               REASON: push    hl                ;;Save text pointer
0BAA 0BAA : 3E D0                    ld      a,208             ;[M80]  EXAMINE [H,L] TO MAKE SURE
0BAC 0BAC : 95                       sub     l                 ;[M80]  AT LEAST 104 LOCATIONS
0BAD 0BAD : 6F                       ld      l,a               ;[M80]  REMAIN BETWEEN IT AND THE
0BAE 0BAE : 3E FF                    ld      a,$FF             ;[M80]  TOP OF THE STACK
0BB0 0BB0 : 9C                       sbc     a,h               ;
0BB1 0BB1 : 67                       ld      h,a               ;[M80] NOW SEE IF [SP] IS LARGER
0BB2 0BB2 : 38 03                    jr      c,OMERR           ;[M80] IN CASE [H,L] WAS TOO BIG
0BB4 0BB4 : 39                       add     hl,sp             ;[M80] IF SO, CARRY WILL BE SET
0BB5 0BB5 : E1                       pop     hl                ;[M80] GET BACK ORIGINAL [H,L]
0BB6 0BB6 : D8                       ret     c                 ;[M80] WAS OK?
0BB7 0BB7                                                      
0BB7 0BB7 = 11 0C 00   [M80] OMERR:  ld      de,ERROM          ;;"OUT OF MEMORY" Error
0BBA 0BBA : C3 DB 03                 jp      ERROR             ;
0BBD 0BBD
0BBD 0BBD                    ;[M80] THE "NEW" COMMAND CLEARS THE PROGRAM TEXT AS WELL AS VARIABLE SPACE
0BBD 0BBD                    ;;SCRATH is the entry point from the Statement Dispatch Table for the NEW command
0BBD 0BBD                    ;;SCRTCH is the entry point from an aborted CLOAD command
0BBD 0BBD : C0         [M80] SCRATH: ret     nz                ;[M80] MAKE SURE THERE IS A TERMINATOR
0BBE 0BBE -                  ;;Execute NEW Command             
0BBE 0BBE = F7         [M80] SCRTCH: rst     HOOKDO            ;Call Hook Dispatch Routine        
0BBF 0BBF : 0C         {~~~} HOOK12: byte    12                ;
0BC0 0BC0 : 2A 4F 38                 ld      hl,(TXTTAB)       ;[M80] GET POINTER TO START OF TEXT
0BC3 0BC3 : AF                       xor     a                 ;[M80] SET [A]=0
0BC4 0BC4 : 77                       ld      (hl),a            ;[M80] SAVE AT END OFF TEXT
0BC5 0BC5 : 23                       inc     hl                ;[M80] BUMP POINTER
0BC6 0BC6 : 77                       ld      (hl),a            ;[M80] SAVE ZERO
0BC7 0BC7 : 23                       inc     hl                ;[M80] BUMP POINTER
0BC8 0BC8 : 22 D6 38                 ld      (VARTAB),hl       ;[M80] NEW START OF VARIABLES
0BC8 0BC8
0BC8 0BC8                  + ;;Clear Variablea, Reset Stack, and Reset Text Pointer
0BC8 0BC8                  | ;;Leaves BASIC program intact
0BC8 0BC8                  | ;;Entry Point from RUN and FINI
0BCB 0BCB : 2A 4F 38   [M80] RUNC:   ld      hl,(TXTTAB)     ;[M80] POINT AT THE START OF TEXT
0BCE 0BCE : 2B                       dec     hl              ;
0BCF 0BCF
0BCF 0BCF                  + ;[M80] CLEARC IS A SUBROUTINE WHICH INITIALIZES THE VARIABLE AND
0BCF 0BCF                  | ;[M80] ARRAY SPACE BY RESETING ARYTAB [THE END OF SIMPLE VARIABLE SPACE]
0BCF 0BCF                  | ;[M80] AND STREND [THE END OF ARRAY STORAGE]. IT FALLS INTO STKINI
0BCF 0BCF                  | ;[M80] WHICH RESETS THE STACK. [H,L] IS PRESERVED.
0BCF 0BCF                  | ;
0BCF 0BCF : 22 CE 38   [M80] CLEARC: ld      (SAVTXT),hl       ;
0BD2 0BD2 : 2A AD 38                 ld      hl,(MEMSIZ)       ;[M65] FREE UP STRING SPACE
0BD5 0BD5 : 22 C1 38                 ld      (FRETOP),hl       ;
0BD8 0BD8 : AF         {M80} GODFRE: xor     a                 ;
0BD9 0BD9 : CD 05 0C                 call    RESTOR            ;[M65] RESTOR DATA
0BDC 0BDC : 2A D6 38                 ld      hl,(VARTAB)       ;[M65] LIBERATE THE
0BDF 0BDF : 22 D8 38                 ld      (ARYTAB),hl       ;[M65] VARIABLES AND
0BE2 0BE2 : 22 DA 38                 ld      (STREND),hl       ;[M65] ARRAYS
0BE5 0BE5
0BE5 0BE5                  + ;; Reset Stack Pointer
0BE5 0BE5                  | ;[M80] STKINI RESETS THE STACK POINTER ELIMINATING
0BE5 0BE5                  | ;[M80] GOSUB & FOR CONTEXT.  STRING TEMPORARIES ARE FREED
0BE5 0BE5                  | ;[M80] UP, SUBFLG IS RESET, CONTINUING IS DISALLOWED,
0BE5 0BE5                  | ;[M80] AND A DUMMY ENTRY IS PUT ON THE STACK. THIS IS SO
0BE5 0BE5                  | ;[M80] FNDFOR WILL ALWAYS FIND A NON-"FOR" ENTRY AT THE BOTTOM
0BE5 0BE5                  | ;[M80] OF THE STACK. [A]=0 AND [D,E] IS PRESERVED.
0BE5 0BE5                  | ;
0BE5 0BE5 = C1         [M80] STKINI: pop     bc                ;[M80] GET RETURN ADDRESS HERE
0BE6 0BE6 : 2A 4B 38                 ld      hl,(TOPMEM)       ;
0BE9 0BE9 : F9                       ld      sp,hl             ;[M80] INITIALIZE STACK
0BEA      : 21 B1 38                 ld      hl,TEMPST         
0BED      : 22 AF 38                 ld      (TEMPPT),hl       
     0BEA : CD D8 1F                 call    STKSAV            ;[M80] MAKE SURE SAVSTK OK JUST IN CASE.
     0BED : 22 AF 38   {M80} STKERR: ld      (TEMPPT),hl       ;
0BF0 0BF0 : CD BE 19                 call    FINLPT            ;{M80] BACK TO NORMAL PRINT MODE
0BF3 0BF3 : AF                       xor     a                 ;[M80] ZERO OUT A
0BF4 0BF4 : 6F                       ld      l,a               ;[M80] ZERO OUT H
0BF5 0BF5 : 67                       ld      h,a               ;[M80] ZERO OUT L
0BF6 0BF6 : 22 D4 38                 ld      (OLDTXT),hl       ;
0BF9 0BF9 : 32 CB 38                 ld      (SUBFLG),a        ;[M80] ALLOW SUBSCRIPTS
0BFC 0BFC : 22 DE 38                 ld      (VARNAM),hl       ;
0BFF 0BFF : E5                       push    hl                ;[M80] PUT ZERO (NON $FOR,$GOSUB) ON THE STACK
0C00 0C00 : C5                       push    bc                ;[M80] PUT RETURN ADDRESS BACK ON
0C01 0C01 : 2A CE 38   [M80] GTMPRT: ld      hl,(SAVTXT)       ;[M80] GET SAVED [H,L]
0C04 0C04 : C9                       ret                       
0C05 0C05                                                      
0C05 0C05                    ;;The RESTORE Command             
0C05 0C05 : EB         [M80] RESTOR: ex      de,hl             ;[M80] SAVE [H,L] IN [D,E]
0C06 0C06 : 2A 4F 38                 ld      hl,(TXTTAB)       ;
0C09 0C09 : 28 0E                    jr      z,BGNRST          ;[M80] RESTORE DATA POINTER TO BEGINNING OF PROGRAM
0C0B 0C0B : EB                       ex      de,hl             ;[M80] TEXT POINTER BACK TO [H,L]
0C0C 0C0C : CD 9C 06                 call    SCNLIN            ;[M80] GET THE FOLLOWING LINE NUMBER
0C0F 0C0F : E5                       push    hl                ;[M80] SAVE TEXT POINTER
0C10 0C10 : CD 9F 04                 call    FNDLIN            ;[M80] FIND THE LINE NUMBER
0C13 0C13 : 60                       ld      h,b               ;[M80] GET POINTER TO LINE IN [H,L]
0C14 0C14 : 69                       ld      l,c               ;
0C15 0C15 : D1                       pop     de                ;[M80] TEXT POINTER BACK TO [D,E]
0C16 0C16 : D2 F3 06                 jp      nc,USERR          ;[M80] SHOULD HAVE FOUND LINE
0C19 0C19 : 2B         (M80) BGNRST: dec     hl                ;[M80] INITIALIZE DATPTR TO [TXTTAB]-1
0C1A 0C1A : 22 DC 38   [M80] RESFIN: ld      (DATPTR),hl       ;[M80] READ FINISHES COME TO RESFIN
0C1D 0C1D : EB                       ex      de,hl             ;[M80] GET THE TEXT POINTER BACK
0C1E 0C1E : C9                       ret
0C1F 0C1F
0C1F 0C1F                    ;;The STOP and END Statements
0C1F 0C1F                    ;;STOPC is entry point to END from WARMST
0C1F 0C1F : C0         [M80] STOP:   ret     nz                ;[M80] MAKE SURE "STOP" STATEMENTS HAVE A TERMINATOR
0C20 0C20 : F6         [M65] STOPC:  byte    $F6               ;;"OR" to skip next instruction
0C21 0C21 : C0         [M80] ENDS:   ret     nz                ;[M80] MAKE SURE "END" STATEMENTS HAVE A TERMINATOR
0C22 0C22 : 22 CE 38   {M80} CONSTP: ld      (SAVTXT),hl       ;
0C25 0C25 : 21                       byte    $21               ;{M80} SKIP OVER OR USING "LD H,"
0C26 0C26 : F6 FF      [M80] STPEND: or      $FF               ;[M80] SET NON-ZERO TO FORCE PRINTING OF BREAK MESSAGE
0C28 0C28 : C1                       pop     bc                ;[M80] POP OFF NEWSTT ADDRESS
0C29 0C29 : 2A 4D 38   [M80] ENDCON: ld      hl,(CURLIN)       ;[M80] SAVE CURLIN
0C2C 0C2C : F5                       push    af                ;{M80} SAVE MESSAGE FLAG, ZERO MEANS DON'T PRINT "BREAK"
0C2D 0C2D : 7D                       ld      a,l               ;
0C2E 0C2E : A4                       and     h                 ;[M80] SEE IF DIRECT
0C2F 0C2F : 3C                       inc     a                 ;
0C30 0C30 : 28 09                    jr      z,DIRIS           ;[M80] IF NOT SET UP FOR CONTINUE
0C32 0C32 : 22 D2 38                 ld      (OLDLIN),hl       ;[M80] SAVE OLD LINE #
0C35 0C35 : 2A CE 38                 ld      hl,(SAVTXT)       ;[M80] GET POINTER TO START OF STATEMENT
0C38 0C38 : 22 D4 38                 ld      (OLDTXT),hl       ;[M80] SAVE IT
0C3B 0C3B : CD BE 19   [M80] DIRIS:  call    FINLPT            ;{M80} BACK TO NORMAL PRINT MODE
0C3E 0C3E : CD DE 19                 call    CRDONZ            ;[M80] PRINT CR IF TTYPOS .NE. 0
0C41 0C41 : F1                       pop     af                ;[M80] GET BACK ^C FLAG
0C42 0C42 : 21 73 03                 ld      hl,BRKTXT         ;[M80] "BREAK"
0C45 0C45 : C2 F4 03                 jp      nz,ERRFN1         ;[M80] CALL STROUT AND FALL INTO READY
0C48 0C48 : C3 02 04                 jp      READY             ;
0C4B 0C4B                                                      
0C4B 0C4B                    ;;The CONT Command                
0C4B 0C4B : 2A D4 38   [M80] CONT:   ld      hl,(OLDTXT)       ;[M80] ZERO INDICATES THERE IS NOTHING TO CONTINUE
0C4E 0C4E : 7C                       ld      a,h               ;[M80] "STOP","END",TYPING CRLF
0C4F 0C4F : B5                       or      l                 ;[M80] TO "INPUT" AND ^C SETUP OLDTXT
0C50 0C50 : 11 20 00   {M80} RESERR: ld      de,ERRCN          ;[M80] "CAN'T CONTINUE"
0C53 0C53 : CA DB 03                 jp      z,ERROR           ;
0C56 0C56 : ED 5B D2 38              ld      de,(OLDLIN)       ;
0C5A 0C5A : ED 53 4D 38              ld      (CURLIN),de       ;[M80] SET UP OLD LINE # AS CURRENT LINE #
0C5E 0C5E : C9                       ret                       ;
0C5F 0C5F
0C5F 0C5F                    ;;This looks like orphan code
0C5F 0C5F : C3 97 06                 jp      FCERR
0C62 0C62
0C62 0C62                    ;;CSAVE* and CLOAD*
0C62 0C62   3E               CSARY:  byte    $3E               ;;"LD A," sets A = 62 for CSAVE*
0C63 0C63 : AF               CLARY:  xor     a                 ;;Set A = 0 for CLOAD*
0C64 0C64 : B7                       or      a                 ;;Set flags
0C65 0C65 : F5                       push    af                ;;and save them
0C66 0C66 : D7                       rst     CHRGET            ;;Skip '*'
0C67 0C67 : 3E 01                    ld      a,1               ;
0C69 0C69 : 32 CB 38                 ld      (SUBFLG),a        ;;Don't look for '(' after variable name
0C6C 0C6C : CD D1 10                 call    PTRGET            ;;Get pointer to variable
0C6F 0C6F : C2 97 06                 jp      nz,FCERR          ;;Doesn't exist? FC Error
0C72 0C72 : 32 CB 38                 ld      (SUBFLG),a        ;;Turn subscripts back on
0C75 0C75 : CD 75 09                 call    CHKNUM            ;;Must be numeric variable or TM Error
0C78 0C78 : F1                       pop     af                ;
0C79 0C79 : E5                       push    hl                ;;Text Pointer
0C7A 0C7A : F5                       push    af                ;;CSAVE/CLOAD flag
0C7B 0C7B : C5                       push    bc                ;;Pointer to Number of Dimensions
0C7C 0C7C : 06 23                    ld      b,'#'             ;
0C7E 0C7E : 28 12                    jr      z,CLARYP          ;;If flag is 0, do CLOAD
0C80 0C80                    ;;Write Array Header to Tape      
0C80 0C80 : CD 7F 1B   {~~~} CSARYH: call    PRECRD            ;;"Press <RECORD>" and wait for RETURN
0C83 0C83 : CD BC 1B                 call    WRSYNC            ;;Write SYNC to tape
0C86 0C86 : 78                       ld      a,b               ;;Write filename "######"
0C87 0C87 : CD 87 1B                 call    WRBYT2            ;
0C8A 0C8A : CD 87 1B                 call    WRBYT2            ;
0C8D 0C8D : CD 87 1B                 call    WRBYT2            ;
0C90 0C90 : 18 11                    jr      RWARY             ;;Write Array 
0C92 0C92                    ;;Read Array Header from Tape     
0C92 0C92 : CD 2E 1B   (~~~) CLARYP: call    PPLAY             ;;"Press <PLAY>", wait for RETURN
0C95 0C95 : CD CE 1B   {~~~} CLARYH: call    RDSYNC            ;;Wait for SYNC
0C98 0C98 : 0E 06      (~~~) CLARYF: ld      c,6               ;;Look for filename "@@@@@@"
0C9A 0C9A : CD 4D 1B   (~~~) CLARYL: call    RDBYTE
0C9D 0C9D : B8                       cp      b
0C9E 0C9E : 20 F8                    jr      nz,CLARYF
0CA0 0CA0 : 0D                       dec     c
0CA1 0CA1 : 20 F7                    jr      nz,CLARYL
0CA3 0CA3                    ;;Read Array from or Write Array to Tape
0CA3 0CA3                    ;;DE=End of Array+1, Stack: Array Pointer, CSAVE Flag, Text Pointer
0CA3 0CA3 : E1               RWARY:  pop     hl                ;;Restore Array Pointer
0CA4 0CA4 : EB                       ex      de,hl             ;;DE = Array Pointer, HL = Array Length
0CA5 0CA5 : 19                       add     hl,de             ;;HL = End of Array plus 1
0CA6 0CA6 : EB                       ex      de,hl             ;;HL = Array Pointer, DE = End of Array
0CA7 0CA7 : 4E                       ld      c,(hl)            ;
0CA8 0CA8 : 06 00                    ld      b,0               ;;BC = Number of Dimensions
0CAA 0CAA : 09                       add     hl,bc             ;;Each dimension size is two bytes
0CAB 0CAB : 09                       add     hl,bc             ;;So add twice
0CAC 0CAC : 23                       inc     hl                ;;Add one more for Number of Dimensions
0CAD 0CAD                    ;;HL=Start Address, DE=End Address+1, Stack: CSAVE Flag Z, Text Pointer
0CAD 0CAD : E7         (~~~) RWMEM:  rst     COMPAR            ;;Are we there yet?
0CAE 0CAE : 28 0D                    jr      z,RWARYD          ;;Yes, you can get out
0CB0 0CB0 : F1                       pop     af                ;;Get CSAVE/CLOAD flag
0CB1 0CB1 : F5                       push    af                ;;And save it again
0CB2 0CB2 : 7E                       ld      a,(hl)            ;;Read byte from array
0CB3 0CB3 : C4 8A 1B                 call    nz,WRBYTE         ;;If CSAVE* write to tape
0CB6 0CB6 : CC 4D 1B                 call    z,RDBYTE          ;;If CLOAD* read from tape
0CB9 0CB9 : 77                       ld      (hl),a            ;;Write byte into array
0CBA 0CBA : 23                       inc     hl                ;;Bump pointer
0CBB 0CBB : 18 F0                    jr      RWMEM             ;;and do next byte
0CBD 0CBD : F1         (~~~) RWARYD: pop     af                ;;Get CSAVE/CLOAD flag
0CBE 0CBE : C2 1C 1C                 jp      nz,WRTAIL         ;;If CSAVE* write trailer and return
0CC1 0CC1 : E1                       pop     hl                ;;Restore text pointer
0CC2 0CC2 : C3 7E 1B                 jp      RWARYR            ;;and Return
0CC5 0CC5                    ;
0CC5 0CC5                  + ;[M80] TEST FOR A LETTER / CARRY ON=NOT A LETTER
0CC5 0CC5                  | ;[M80]               CARRY OFF=A LETTER
0CC5 0CC5                  | ;
0CC5 0CC5 : 7E         [M80] ISLET:  ld      a,(hl)
0CC6 0CC6 -                  ;;Test if A is letter
0CC6 0CC6 = FE 41      [M65] ISLETC: cp      'A'
0CC8 0CC8 : D8                       ret     c               ;[M80] IF LESS THAN "A", RETURN EARLY
0CC9 0CC9 : FE 5B                    cp      'Z'+1
0CCB 0CCB : 3F                       ccf
0CCC 0CCC : C9                       ret
0CCD 0CCD                    ;
0CCD 0CCD                  + ;[M80] THIS CODE IS FOR THE "CLEAR" COMMAND WITH AN ARGUMENT
0CCD 0CCD                  | ;[M80] TO CHANGE THE AMOUNT OF STRING SPACE ALLOCATED.
0CCD 0CCD                  | ;[M80] IF NO FORMULA IS GIVEN THE AMOUNT OF STRING SPACE
0CCD 0CCD                  | ;[M80] REMAINS UNCHANGED.
0CCD 0CCD                  | ;
0CCD 0CCD                  | ;;Second Parameter is End of Basic Memory
0CCD 0CCD : F7         (M80) CLEAR:  rst     HOOKDO            ;;Call Hook Dispatch Routine
0CCE 0CCE : 0B         {~~~} HOOK11: byte    11                ;
0CCF 0CCF : CA CF 0B                 jp      z,CLEARC          ;[M80] IF NO FORMULA JUST CLEAR
0CD2 0CD2 : CD 7B 06                 call    INTID2            ;[M80] GET AN INTEGER INTO [D,E] 
0CD5 0CD5 : 2B                       dec     hl                ;;Back up text pointer
0CD6 0CD6 : D7                       rst     CHRGET            ;[M80] SEE IF ITS THE END
0CD7 0CD7 : E5                       push    hl                ;;Save text pointer
0CD8 0CD8 : 2A AD 38                 ld      hl,(MEMSIZ)       ;[M80] GET HIGHEST ADDRESS
0CDB 0CDB : 28 0E                    jr      z,CLEARS          ;[M80] SHOULD FINISH THERE
0CDD 0CDD : E1                       pop     hl                ;;Restore Text Pointer
0CDE 0CDE : CF                       rst     SYNCHK            ;;Require a Comma
0CDF 0CDF : 2C                       byte    ','               ;
0CE0 0CE0 : D5                       push    de                ;;Save String Size
0CE1 0CE1 : CD 7B 06                 call    INTID2            ;;Get Top of Memory
0CE4 0CE4 : 2B                       dec     hl                ;;Back up text pointer
0CE5 0CE5 : D7                       rst     CHRGET            ;;Check next character
0CE6 0CE6 : C2 C4 03                 jp      nz,SNERR          ;{M80} IF NOT TERMINATOR, GOOD BYE        
0CE9 0CE9 : E3                       ex      (sp),hl           ;;Get String Size, Save Text Pointer
0CEA 0CEA : EB                       ex      de,hl             ;;DE=String Size, HL=Top of Memory
0CEB 0CEB                    ;;Set VARTAB, TOPMEM, and MEMSIZ
0CEB 0CEB                    ;;On Entry HL = top of memory, from MEMSIZ or second parameter 
0CEB 0CEB                    ;;         DE = string space, from the first parameter
0CEB 0CEB : 7D         (M80) CLEARS: ld      a,l               ;[M80] SUBTRACT [H,L]-[D,E] INTO [D,E]
0CEC 0CEC : 93                       sub     e                 ;
0CED 0CED : 5F                       ld      e,a               ;;Leaving start of String Space in [D,E]
0CEE 0CEE : 7C                       ld      a,h               ;
0CEF 0CEF : 9A                       sbc     a,d               ;
0CF0 0CF0 : 57                       ld      d,a               ;
0CF1 0CF1 : DA B7 0B                 jp      c,OMERR           ;[M80] WANTED MORE THAN TOTAL!
0CF4 0CF4 : E5                       push    hl                ;[M80] SAVE MEMSIZ
0CF5 0CF5 : 2A D6 38                 ld      hl,(VARTAB)       ;[M80] TOP LOCATION IN USE
0CF8 0CF8 : 01 28 00                 ld      bc,40             ;[M80] TOP LOCATION IN USE
0CFB 0CFB : 09                       add     hl,bc             ;[M80] LEAVE BREATHING ROOM
0CFC 0CFC : E7                       rst     COMPAR            ;[M80] ROOM?
0CFD 0CFD : D2 B7 0B                 jp      nc,OMERR          ;[M80] NO, DON'T EVEN CLEAR
0D00 0D00 : EB                       ex      de,hl             ;[M80] NEW STACK LOCATION [H,L]
0D01 0D01 : 22 4B 38                 ld      (TOPMEM),hl       ;[M80] SET UP NEW STACK LOCATION
0D04 0D04 : E1                       pop     hl                ;[M80] GET BACK MEMSIZ
0D05 0D05 : 22 AD 38                 ld      (MEMSIZ),hl       ;[M80] SET IT UP, MUST BE OK
0D08 0D08 : E1                       pop     hl                ;[M80] REGAIN THE TEXT POINTER
0D09 0D09 : C3 CF 0B                 jp      CLEARC            ;[M80] GO CLEAR
0D0C 0D0C
0D0C 0D0C                    ;;DE = HL - DE  *** Orphan Code - 7 bytes                    
0D0C 0D0C : 7D                       ld      a,l 
0D0D 0D0D : 93                       sub     e
0D0E 0D0E : 5F                       ld      e,a
0D0F 0D0F : 7C                       ld      a,h
0D10 0D10 : 9A                       sbc     a,d
0D11 0D11 : 57                       ld      d,a
0D12 0D12 : C9                       ret
0D13 0D13
0D13 0D13                    ;;The NEXT STATEMENT
0D13 0D13                    ;;See FOR for description of the stack entry
0D13 0D13 : 11 00 00   [M80] NEXT:   ld      de,0              ;{M80} FOR "NEXT" WITHOUT ARGS CALL FNDFOR WITH [D,E]=0
0D16 0D16 : C4 D1 10   (M80) NEXTC:  call    nz,PTRGET         ;{M80} GET POINTER TO LOOP VARIABLE INTO [D,E]
0D19 0D19 : 22 CE 38                 ld      (SAVTXT),hl       ;{M80} SAVE TEXT POINTER IN CASE LOOP TERMINATES
0D1C 0D1C : CD 9F 03                 call    FNDFOR            ;{M80} LOOK FOR ENTRY WHOSE VARIABLE NAME MATCHES THIS ONES    
0D1F 0D1F : C2 CA 03                 jp      nz,NFERR          ;[M80] "NEXT WITHOUT FOR"
0D22 0D22 : F9                       ld      sp,hl             ;[M80] SETUP STACK POINTER BY CHOPPING AT THIS POINT
0D23 0D23 : D5                       push    de                ;[M80] PUT THE VARIABLE PTR BACK ON
0D24 0D24 : 7E                       ld      a,(hl)            ;
0D25 0D25 : F5                       push    af                ;
0D26 0D26 : 23                       inc     hl                ;
0D27 0D27 : D5                       push    de                ;{M80} PUT POINTER TO LOOP VARIABLE ONTO STACK
0D28 0D28 : CD 20 15                 call    MOVFM             ;[M80] STEP VALUE INTO THE FAC
0D2B 0D2B : E3                       ex      (sp),hl           ;{M80} PUT POINTER INTO FOR ENTRY ONTO STACK
0D2C 0D2C : E5                       push    hl                ;{M80} PUT POINTER TO LOOP VARIABLE BACK ONTO STACK
0D2D 0D2D : CD 53 12   {M80} NXTDO:  call    FADDS             ;
0D30 0D30 : E1                       pop     hl                ;{M80} POP OFF POINTER TO LOOP VARIABLE
0D31 0D31 : CD 3A 15                 call    MOVMF             ;[M80] MOV FAC INTO LOOP VARIABLE
0D34 0D34 : E1                       pop     hl                ;[M80] GET THE ENTRY POINTER
0D35 0D35 : CD 31 15                 call    MOVRM             ;[M80] GET THE FINAL INTO THE REGISTERS
0D38 0D38 : E5                       push    hl                ;[M80] SAVE THE ENTRY POINTER
0D39 0D39 : CD 5B 15                 call    FCOMP             ;{M80} RETURN 255 IF FAC < REGISTERS, 0 IF =, 1 IF >
0D3C 0D3C : E1         {M80} FINNXT: pop     hl                ;{M80} POP OFF "FOR" POINTER NOW POINTING PAST FINAL VALUE
0D3D 0D3D : C1                       pop     bc                ;[M80] GET THE SIGN OF THE INCREMENT
0D3E 0D3E : 90                       sub     b                 ;{M80} SUBTRACT SIGN FROM (CURRENT VALUE-FINAL VALUE)
0D3F 0D3F : CD 31 15                 call    MOVRM             ;{M80} "FOR" LINE # INTO [D,E], TEXT POINTER INTO [B,C]
0D42 0D42 : 28 09                    jr      z,LOOPDN          ;{M80} IF ZERO THEN THE LOOP IS FINISHED
0D44 0D44 : EB                       ex      de,hl             ;
0D45 0D45 : 22 4D 38                 ld      (CURLIN),hl       ;[M80] STORE THE LINE #
0D48 0D48 : 69                       ld      l,c               ;[M80] SETUP THE TEXT POINTER
0D49 0D49 : 60                       ld      h,b               ;
0D4A 0D4A : C3 28 06                 jp      NXTCON            ;
0D4D 0D4D                                                      
0D4D 0D4D : F9         (M80) LOOPDN: ld      sp,hl             ;{M80} ELIMINATE FOR ENTRY SINCE [H,L] MOVED ALL THE WAY THE ENTRY
0D4E 0D4E : 2A CE 38                 ld      hl,(SAVTXT)       ;UPDATE SAVED STACK
0D51 0D51 : 7E                       ld      a,(hl)            ;IS THERE A COMMA AT THE END
0D52 0D52 : FE 2C                    cp      ','               ;IF SO LOOK AT ANOTHER
0D54 0D54 : C2 2C 06                 jp      nz,NEWSTT         ;VARIABLE NAME TO "NEXT"
0D57 0D57 : D7                       rst     CHRGET            ;READ FIRST CHARCTER
0D58 0D58 : CD 16 0D                 call    NEXTC             ;DO NEXT, BUT DON'T ALLOW BLANK VARIABLE NAME
0D5B 0D5B
0D5B 0D5B                  + ;;Input Line
0D5B 0D5B                  | ;[M80] THIS IS THE LINE INPUT ROUTINE IT READS CHARACTERS INTO BUF
0D5B 0D5B                  | ;[M80] THE ROUTINE IS ENTERED AT INLIN, AT QINLIN TO TYPE A QUESTION MARK
0D5B 0D5B                  | ;[M80] AND A SPACE FIRST
0D5B 0D5B : 3E 3F      [M80] QINLIN: ld      a,'?'             ;
0D5D 0D5D : DF                       rst     OUTCHR            ;
0D5E 0D5E : 3E 20                    ld      a,' '             ;
0D60 0D60 : DF                       rst     OUTCHR            ;
0D61 0D61 : C3 85 0D   {M65} GINLIN: jp      INLIN             ;;;For relative jumps
0D64 0D64                                                      
0D64 0D64 : 3A 4A 38   [M80] RUBOUT: ld      a,(RUBSW)         ;[M80] ARE WE ALREADY RUBBING OUT?
0D67 0D67 : B7                       or      a                 ;[M80] SET CC'S
0D68 0D68 : 3E 5C                    ld      a,'\'             ;[M80] GET READY TO TYPE BACKSLASH
0D6A 0D6A : 32 4A 38                 ld      (RUBSW),a         ;[M80] MAKE RUBSW NON-ZERO IF NOT ALREADY
0D6D 0D6D : 20 05                    jr      nz,NOTBEG         ;[M80] NOT RUBBING BACK TO BEGGINING
0D6F 0D6F : 05                       dec     b                 ;[M80] AT BEGINNING OF LINE?
0D70 0D70 : 28 13                    jr      z,INLIN           ;[M80] SET FIRST BYTE IN BUF TO ZERO
0D72 0D72 : DF                       rst     OUTCHR            ;[M80] SEND BACKSLASH
0D73 0D73 : 04                       inc     b                 ;[M80] EFFECTIVELY SKIP NEXT INSTRUCTION
0D74 0D74 : 05         (M80) NOTBEG: dec     b                 ;[M80] BACK UP CHAR COUNT BY 1
0D75 0D75 : 2B                       dec     hl                ;[M80] AND LINE POSIT
0D76 0D76 : 28 09                    jr      z,INLINN          ;[M80] AND RE-SET UP INPUT
0D78 0D78 : 7E                       ld      a,(hl)            ;[M80] OTHERWISE GET CHAR TO ECHO
0D79 0D79 : DF                       rst     OUTCHR            ;[M80] SEND IT
0D7A 0D7A : 18 12                    jr      INLINC            ;[M80] AND GET NEXT CHAR
0D7C 0D7C                                                      
0D7C 0D7C : 05         [M65] LINLIN: dec     b                 ;[M80] AT START OF LINE?
0D7D 0D7D : 2B         {M80} LINLN2: dec     hl                ;[M65] BACKARROW SO BACKUP PNTR AND
0D7E 0D7E : DF                       rst     OUTCHR            ;[M80] SEND BACKSPACE
0D7F 0D7F : 20 0D                    jr      nz,INLINC         ;
0D81 0D81 : DF         (M80) INLINN: rst     OUTCHR            ;
0D82 0D82                                                      
0D82 0D82 : CD EA 19   [M80] INLINU: call    CRDO              ;[M80] TYPE A CRLF
0D85 0D85 : 21 60 38   [M80] INLIN:  ld      hl,BUF            ;
0D88 0D88 : 06 01                    ld      b,1               ;[M80] CHARACTER COUNT
0D8A 0D8A : AF                       xor     a                 ;[M80] CLEAR TYPE AHEAD CHAR
0D8B 0D8B : 32 4A 38                 ld      (RUBSW),a         ;[M80] LIKE SO
0D8E 0D8E : CD DA 19   [M80] INLINC: call    INCHR             ;[M80] GET A CHAR
0D91 0D91 : 4F         {M80} INLNC1: ld      c,a               ;[M80] SAVE CURRENT CHAR IN [C]
0D92 0D92 : FE 7F                    cp      127               ;[M80] CHARACTER DELETE?
0D94 0D94 : 28 CE                    jr      z,RUBOUT          ;[M80] DO IT
0D96 0D96 : 3A 4A 38                 ld      a,(RUBSW)         ;[M80] BEEN DOING A RUBOUT?
0D99 0D99 : B7                       or      a                 ;[M80] SET CC'S
0D9A 0D9A : 28 07                    jr      z,NOTRUB          ;[M80] NOPE.
0D9C 0D9C : 3E 5C                    ld      a,'\'             ;[M80] GET READY TO TYPE SLASH
0D9E 0D9E : DF                       rst     OUTCHR            ;[M80] SEND IT
0D9F 0D9F : AF                       xor     a                 ;[M80] CLEAR RUBSW
0DA0 0DA0 : 32 4A 38                 ld      (RUBSW),a         ;[M80] LIKE SO
0DA3 0DA3 : 79         (M80) NOTRUB: ld      a,c               ;[M80] GET BACK CURRENT CHAR
;;;The following comment is in both [M65] and [M80], so it likely ended up in the Aquarius
;;;source code as well. Bob Albrecht is a key figure in the early history of microcomputers.
;;;He founded the People's Computer Company, a newsletter that operated with a walk-in
;;;storefront to teach children "about having fun with computers" and later became
;;;Dr. Dobb's Journal of Computer Calisthenics and Orthodontia.  He brought the first
;;;Altair 8800 to the Homebrew Computer Club and was one of the main supporters
;;;of the effort to make Tiny BASIC a standard on many early machines.
0DA4 0DA4 : FE 07      {M80} CHKFUN: cp      7                 ;[M80] IS IT BOB ALBRECHT RINGING THE BELL
0DA6 0DA6 : 28 41                    jr      z,GOODCH          ;[M80] FOR SCHOOL KIDS?
0DA8 0DA8 : FE 03                    cp      3                 ;[M80] CONTROL-C?
0DAA 0DAA : CC EA 19                 call    z,CRDO            ;[M80] TYPE CHAR, AND CRLFT
0DAD 0DAD : 37                       scf                       ;[M80] RETURN WITH CARRY ON
0DAE 0DAE : C8                       ret     z                 ;[M80] IF IT WAS CONTROL-C
0DAF 0DAF : FE 0D                    cp      13                ;
0DB1 0DB1 : CA E5 19                 jp      z,FININL          ;[M80] IS IT A CARRIAGE RETURN?
0DB4 0DB4 : FE 15                    cp      21                ;[M80] ;LINE DELETE? (CONTROL-U)
0DB6 0DB6 : CA 82 0D                 jp      z,INLINU          ;[M80] GO DO IT
0DB9 0DB9 : 00                       nop                       ;;;Whatever was removed isn't in the
0DBA 0DBA : 00                       nop                       ;;;available source codes
0DBB 0DBB : 00                       nop                       ;
0DBC 0DBC : 00                       nop                       ;
0DBD 0DBD : 00                       nop                       ;
0DBE 0DBE : FE 08                    cp      8                 ;[M80] BACKSPACE? (CONTROL-H)?
0DC0 0DC0 : CA 7C 0D                 jp      z,LINLIN          ;[M65] YES
0DC3 0DC3 : FE 18                    cp      24                ;[M80] AT START OF LINE?
0DC5 0DC5 : 20 05                    jr      nz,NTCTLX         ;[M80] IS IT CONTROL-X (LINE DELETE)
0DC7 0DC7 : 3E 23                    ld      a,'#'             ;[M80] SEND NUMBER SIGN
0DC9 0DC9 : C3 81 0D                 jp      INLINN            ;[M80] SEND # SIGN AND ECHO
0DCC 0DCC                                                      
0DCC 0DCC : FE 12      (M80) NTCTLX: cp      18                ;[M80] CONTROL-R?
0DCE 0DCE : 20 14                    jr      nz,NTCTLR         ;[M80] NO
0DD0 0DD0 : C5                       push    bc                ;[M80] SAVE [B,C]
0DD1 0DD1 : D5                       push    de                ;[M80] SAVE [D,E]
0DD2 0DD2 : E5                       push    hl                ;[M80] SAVE [H,L]
0DD3 0DD3 : 36 00                    ld      (hl),0            ;[M80] STORE TERMINATOR
0DD5 0DD5 : CD EA 19                 call    CRDO              ;[M80] DO CRLF
0DD8 0DD8 : 21 60 38                 ld      hl,BUF            ;[M80] POINT TO START OF BUFFER
0DDB 0DDB : CD 9D 0E                 call    STROUT            ;;Print It
0DDE 0DDE : E1                       pop     hl                ;[M80] RESTORE [H,L]
0DDF 0DDF : D1                       pop     de                ;[M80] RESTORE [D,E]
0DE0 0DE0 : C1                       pop     bc                ;[M80] RESTORE [B,C]
0DE1 0DE1 : C3 8E 0D                 jp      INLINC            ;[M80] GET NEXT CHAR
0DE4 0DE4                                                      
0DE4 0DE4 : FE 20      (M80) NTCTLR: cp      ' '               ;[M80] CHECK FOR FUNNY CHARACTERS
0DE6 0DE6 : DA 8E 0D                 jp      c,INLINC          ;
0DE9 0DE9                                                      
0DE9 0DE9 : 78         (M80) GOODCH: ld      a,b               ;[M80] GET CURRENT LENGTH
0DEA 0DEA : FE 49                    cp      ENDBUF-BUF        ;[M80] ;Set Carry if longer than Buffer
0DEC 0DEC : 3E 07                    ld      a,7               ;[M80] GET BELL CHAR
0DEE 0DEE : D2 F8 0D                 jp      nc,OUTBEL         ;[M80] NO CAUSE FOR BELL
0DF1 0DF1 : 79         {M80} OUTBND: ld      a,c               ;[M80] RESTORE  CURRENT CHARACTER INTO [A]
0DF2 0DF2 : 71                       ld      (hl),c            ;[M80] STORE THIS CHARACTER
0DF3 0DF3 : 32 CC 38                 ld      (USFLG),a         ;[M80] FLAG THAT VALUE HAS BEEN PRINTED
0DF6 0DF6 : 23                       inc     hl                ;[M80] INCREMENT CHARACTER COUNT
0DF7 0DF7 : 04                       inc     b                 ;[M80] BUMP POINTER INTO BUF
0DF8 0DF8 : DF         (M80) OUTBEL: rst     OUTCHR            ;[M80] SEND THE CHAR
0DF9 0DF9 : C3 8E 0D                 jp      INLINC            ;{M80} GET NEXT CHAR
0DFC 0DFC 
0DFC 0DFC                  + ;[M80] THE FOLLOWING ROUTINE COMPARES TWO STRINGS
0DFC 0DFC                  | ;[M80] ONE WITH DESC IN [D,E] OTHER WITH DESC. IN [FACLO, FACLO+1]
0DFC 0DFC                  | ;[M80] A=0 IF STRINGS EQUAL
0DFC 0DFC                  | ;{M80} A=127 IF B,C,D,E .GT. FACLO
0DFC 0DFC                  | ;{M80} A=1 IF B,C,D,E .LT. FACLO
0DFC 0DFC                  | ;
0DFC 0DFC : D5         [M80] STRCMP: push    de              
0DFD 0DFD : CD C9 0F                 call    FREFAC            ;[M80] FREE UP FAC STRING, GET POINTER TO DESCRIPTOR IN [H,L]
0E00 0E00 : 7E                       ld      a,(hl)            ;[M80] SAVE THE LENGTH OF THE FAC STRING IN [A]
0E01 0E01 : 23                       inc     hl                ;
0E02 0E02 : 23                       inc     hl                ;
0E03 0E03 : 4E                       ld      c,(hl)            ;[M80] SAVE THE POINTER AT THE FAC STRING DATA IN [B,C]
0E04 0E04 : 23                       inc     hl                ;
0E05 0E05 : 46                       ld      b,(hl)            ;
0E06 0E06 : D1                       pop     de                ;[M80] GET THE STACK STRING POINTER
0E07 0E07 : C5                       push    bc                ;[M80] SAVE THE POINTER AT THE FAC STRING DATA
0E08 0E08 : F5                       push    af                ;[M80] SAVE THE FAC STRING LENGTH
0E09 0E09 : CD CD 0F                 call    FRETMP            ;[M80] FREE UP STACK STRING, RETURN POINTER TO DESCRIPTOR IN [H,L]
0E0C 0E0C : CD 31 15                 call    MOVRM             ;
0E0F 0E0F : F1                       pop     af                ;
0E10 0E10 : 57                       ld      d,a               ;
0E11 0E11 : E1                       pop     hl                ;[M80] GET BACK 2ND CHARACTER POINTER
0E12 0E12 : 7B         (M80) CSLOOP: ld      a,e               ;[M80] BOTH STRINGS ENDED
0E13 0E13 : B2                       or      d                 ;[M80] TEST BY OR'ING THE LENGTHS TOGETHER
0E14 0E14 : C8                       ret     z                 ;[M80] IF SO, RETURN WITH A ZERO
0E15 0E15 : 7A                       ld      a,d               ;[M80] GET FACLO STRING LENGTH
0E16 0E16 : D6 01                    sub     1                 ;[M80] SET CARRY AND MAKE [A]=255 IF [D]=0
0E18 0E18 : D8                       ret     c                 ;[M80] RETURN IF THAT STRING ENDED
0E19 0E19 : AF                       xor     a                 ;[M80] MUST NOT HAVE BEEN ZERO, TEST CASE
0E1A 0E1A : BB                       cp      e                 ;[M80] OF B,C,D,E STRING HAVING ENDED FIRST
0E1B 0E1B : 3C                       inc     a                 ;[M80] RETURN WITH A=1
0E1C 0E1C : D0                       ret     nc                ;[M80] TEST THE CONDITION
0E1D 0E1D                    ;[M80] HERE WHEN NEITHER STRING ENDED
0E1D 0E1D : 15                       dec     d                 ;[M80] DECREMENT BOTH CHARACTER COUNTS
0E1E 0E1E : 1D                       dec     e                 ;
0E1F 0E1F : 0A                       ld      a,(bc)            ;[M80] GET CHARACTER FROM B,C,D,E STRING
0E20 0E20 : 03                       inc     bc                ;
0E21 0E21 : BE                       cp      (hl)              ;[M80] COMPARE WITH FACLO STRING
0E22 0E22 : 23                       inc     hl                ;[M80] BUMP POINTERS (INX DOESNT CLOBBER CC'S)
0E23 0E23 : 28 ED                    jr      z,CSLOOP          ;[M80] IF BOTH THE SAME, MUST BE MORE TO STRINGS
0E25 0E25 : 3F                       ccf                       ;[M80] HERE WHEN STRINGS DIFFER
0E26 0E26 : C3 F1 14                 jp      SIGNS             ;[M80] SET [A] ACCORDING TO CARRY
0E29 0E29
0E29 0E29                  + ;;CONVERT NUMBER TO STRING
0E29 0E29                  | ;[M80] THE STR$ FUNCTION TAKES A NUMBER AND GIVES A STRING WITH
0E29 0E29                  | ;[M80] THE CHARACTERS THE OUTPUT OF THE NUMBER WOULD HAVE GIVEN
0E29 0E29                  | ;; TIMSTR can be used to return the string at [HL] from a function
0E29 0E29 : CD 75 09   [M65] STR:    call    CHKNUM            ;[M80] IS A NUMERIC
0E2C 0E2C : CD 80 16                 call    FOUT              ;[M80] DO ITS OUTPUT
0E2F 0E2F : CD 5F 0E   {M65} TIMSTR: call    STRLIT            ;[M80] SCAN IT AND TURN IT INTO A STRING
0E32 0E32 : CD C9 0F                 call    FREFAC            ;[M80] FREE UP THE TEMP
0E35 0E35 : 01 1D 10                 ld      bc,FINBCK         ;
0E38 0E38 : C5                       push    bc                ;[M80] SET UP ANSWER IN NEW TEMP
0E39 0E39
0E39 0E39                  + ;;COPY A STRING
0E39 0E39                  | ;[M80] STRCPY CREATES A COPY OF THE STRING
0E39 0E39                  | ;[M80] WHOSE DESCRIPTOR IS POINTED TO BY [H,L].
0E39 0E39                  | ;[M80] ON RETURN [D,E] POINTS TO DSCTMP
0E39 0E39                  | ;[M80] WHICH HAS THE STRING INFO (LENGTH,WHERE COPIED TO)
0E39 0E39                  | ;
0E39 0E39 : 7E         [M80] STRCPY: ld      a,(hl)            ;[M80] GET LENGTH
0E3A 0E3A : 23                       inc     hl                ;[M80] MOVE UP TO THE POINTER
0E3B 0E3B : 23                       inc     hl                ;[M80] GET POINTER TO POINTER OF ARG
0E3C 0E3C : E5                       push    hl                ;[M80] GET THE SPACE
0E3D 0E3D : CD B3 0E                 call    GETSPA            ;[M80] FIND OUT WHERE STRING TO COPY
0E40 0E40 : E1                       pop     hl                ;
0E41 0E41 : 4E                       ld      c,(hl)            ;
0E42 0E42 : 23                       inc     hl                ;
0E43 0E43 : 46                       ld      b,(hl)            ;
0E44 0E44 : CD 53 0E                 call    STRAD2            ;[M80] SETUP DSCTMP
0E47 0E47 : E5                       push    hl                ;[M80] SAVE POINTER TO DSCTMP
0E48 0E48 : 6F                       ld      l,a               ;[M80] GET CHARACTER COUNT INTO [L]
0E49 0E49 : CD BD 0F                 call    MOVSTR            ;[M80] MOVE THE CHARS IN
0E4C 0E4C : D1                       pop     de                ;[M80] RESTORE POINTER TO DSCTMP
0E4D 0E4D : C9                       ret                       ;[M80] RETURN
0E4E 0E4E
0E4E 0E4E                    ;[M65] "STRINI" GET STRING SPACE FOR THE CREATION OF A STRING AND 
0E4E 0E4E                    ;[M65] CREATES A DESCRIPTOR FOR IT IN "DSCTMP".
0E4E 0E4E                    ;;Returns String Text Address in [DE], Descriptor Address in [HL]
0E4E 0E4E : 3E 01      [M80] STRIN1: ld      a,1               ;[M80] MAKE ONE CHAR STRING (CHR$, INKEY$)
0E50 0E50 : CD B3 0E   [M80] STRINI: call    GETSPA            ;[M80] GET SOME STRING SPACE ([A] CHARS)
0E53 0E53 : 21 BD 38   [M80] STRAD2: ld      hl,DSCTMP         ;[M80] GET DESC. TEMP
0E56 0E56 : E5         {M80} STRADI: push    hl                ;[M80] SAVE DESC. POINTER
0E57 0E57 : 77                       ld      (hl),a            ;[M80] SAVE CHARACTER COUNT
0E58 0E58 : 23                       inc     hl                ;
0E59 0E59 = 23               STRADX: inc     hl                ;[M80] STORE [D,E]=POINTER TO FREE SPACE
0E5A 0E5A : 73                       ld      (hl),e            ;
0E5B 0E5B : 23                       inc     hl                ;
0E5C 0E5C : 72                       ld      (hl),d            ;
0E5D 0E5D : E1                       pop     hl                ;[M80] AND RESTORE [H,L] AS THE DESCRIPTOR POINTER
0E5E 0E5E : C9                       ret                       ;
0E5F 0E5F     
0E5F 0E5F                  + ;;Build Descriptor for String Litersl
0E5F 0E5F                  | ;[M80] STRLT2 TAKES THE STRING LITERAL WHOSE FIRST CHARACTER
0E5F 0E5F                  | ;[M80] IS POINTED BY [H,L]+1 AND BUILDS A DESCRIPTOR FOR IT.
0E5F 0E5F                  | ;[M80] THE DESCRIPTOR IS INITIALLY BUILT IN DSCTMP, BUT PUTNEW
0E5F 0E5F                  | ;[M80] TRANSFERS IT INTO A TEMPORARY AND LEAVES A POINTER
0E5F 0E5F                  | ;[M80] AT THE TEMPORARY IN FACLO. THE CHARACTERS OTHER THAN
0E5F 0E5F                  | ;[M80] ZERO THAT TERMINATE THE STRING SHOULD BE SET UP IN [B]
0E5F 0E5F                  | ;[M80] AND [D]. IT THE TERMINATOR IS A QUOTE, THE QUOTE IS SKIPPED
0E5F 0E5F                  | ;[M80] OVER. LEADING QUOTES SHOULD BE SKIPPED BEFORE CALL. ON RETURN
0E5F 0E5F                  | ;[M80] THE CHARACTER AFTER THE STRING LITERAL IS POINTED TO
0E5F 0E5F                  | ;[M80] BY [H,L] AND IS IN [A], BUT THE CONDITION CODES ARE
0E5F 0E5F                  | ;[M80] NOT SET UP.
0E5F 0E5F                  | ;; STRLIT accepts two delimiters in addition to a zero. These 
0E5F 0E5F                  | ;; delimiters are passed in B and D.
0E5F 0E5F                  | ;; READ calls STRLIT with ',' in B and ':' in D to parse unquoted
0E5F 0E5F                  | ;; strings in DATA statemts.
0E5F 0E5F                  | ;; STRLIT and STRLTI execute STRLT2 with '"' in both B and D.SSS
0E5F 0E5F                  | ;;
0E5F 0E5F : 2B         [M80] STRLIT: dec     hl                ;;Back up to '"'
0E60 0E60 : 06 22      [M80] STRLTI: ld      b,'"'             ;[M80] ASSUME STR ENDS ON QUOTE
0E62 0E62 : 50         {M80} STRLT3: ld      d,b               ;
0E63 0E63 : E5         [M80] STRLT2: push    hl                ;[M80] SAVE POINTER TO START OF LITERAL
0E64 0E64 : 0E FF                    ld      c,255             ;[M80] INITIALIZE CHARACTER COUNT
0E66 0E66 : 23         (M80) STRGET: inc     hl                ;;Move past '"'
0E67 0E67 : 7E                       ld      a,(hl)            ;[M80] GET CHAR
0E68 0E68 : 0C                       inc     c                 ;[M80] BUMP CHARACTER COUNT
0E69 0E69 : B7                       or      a                 ;[M80] IF 0, (END OF LINE) DONE
0E6A 0E6A : 28 06                    jr      z,STRFIN          ;[M80] TEST
0E6C 0E6C : BA                       cp      d                 ;
0E6D 0E6D : 28 03                    jr      z,STRFIN          ;
0E6F 0E6F : B8                       cp      b                 ;[M80] CLOSING QUOTE
0E70 0E70 : 20 F4                    jr      nz,STRGET         ;[M80] NO, GO BACK FOR MORE
0E72 0E72 : FE 22      (M80) STRFIN: cp      '"'               ;[M80] IF QUOTE TERMINATES THE STRING
0E74 0E74 : CC 6B 06                 call    z,CHRGTR          ;[M80] SKIP OVER THE QUOTE
0E77 0E77 : E3                       ex      (sp),hl           ;[M80] SAVE POINTER AT END OF STRING
0E78 0E78 : 23                       inc     hl                ;
0E79 0E79 : EB                       ex      de,hl             ;[M80] GET POINTER TO TEMP
0E7A 0E7A : 79                       ld      a,c               ;[M80] GET CHARACTER COUNT IN A
0E7B 0E7B : CD 53 0E                 call    STRAD2            ;[M80] SAVE STR INFO
0E7E 0E7E                    
0E7E 0E7E                  + ;;Set Pointer to Temporary String Descriptor
0E7E 0E7E                  | ;[M80] SOME STRING FUNCTION IS RETURNING A RESULT IN DSCTMP
0E7E 0E7E                  | ;[M80] WE WANT TO SETUP A TEMP DESCRIPTOR WITH DCSTMP IN IT
0E7E 0E7E                  | ;[M80] PUT A POINTER TO THE DESCRIPTOR IN FACLO AND FLAG THE
0E7E 0E7E                  | ;[M80] RESULT AS TYPE STRING
0E7E 0E7E                  |
0E7E 0E7E : 11 BD 38   [M80] PUTNEW: ld      de,DSCTMP         ;[M80] [D,E] POINT AT RESULT DESCRIPTOR
0E81 0E81 : 2A AF 38                 ld      hl,(TEMPPT)       ;[M80] [H,L]=POINTER TO FIRST FREE TEMP
0E84 0E84 : 22 E4 38                 ld      (FACLO),hl        ;[M80] POINTER AT WHERE RESULT DESCRIPTOR WILL BE
0E87 0E87 : 3E 01                    ld      a,1               ;
0E89 0E89 : 32 AB 38                 ld      (VALTYP),a        ;[M80] FLAG THIS AS A STRING
0E8C 0E8C : CD 3D 15                 call    MOVE              ;[M80] AND MOVE THE VALUE INTO A TEMPORARY
0E8F 0E8F : E7                       rst     COMPAR            ;;IF TEMPPT POINTS TO DSCTMP, THERE ARE NO FREE TEMPS
0E90 0E90 : 22 AF 38                 ld      (TEMPPT),hl       ;[M80] SAVE NEW TEMPORARY POINTER
0E93 0E93 : E1                       pop     hl                ;[M80] GET THE TEXT POINTER
0E94 0E94 : 7E                       ld      a,(hl)            ;[M80] GET CURRENT CHARACTER INTO [A]
0E95 0E95 : C0                       ret     nz                ;
0E96 0E96 : 11 1E 00                 ld      de,ERRST          ;[M80] "STRING TEMPORARY" ERROR
0E99 0E99 : C3 DB 03                 jp      ERROR             ;[M80] GO TELL HIM
0E9C 0E9C
0E9C 0E9C -                + ;;Output String
0E9C 0E9C                  | ;[M80] PRINT THE STRING POINTED TO BY [H,L] WHICH ENDS WITH A ZERO
0E9C 0E9C                  | ;[M80] IF THE STRING IS BELOW DSCTMP IT WILL BE COPIED INTO STRING SPACE
0E9C 0E9C                  | ;
0E9C 0E9C : 23               STROUI: inc     hl                ;[M80] POINT AT NEXT CHARACTER
0E9D 0E9D = CD 5F 0E   [M80] STROUT: call    STRLIT            ;[M80] GET A STRING LITERAL
0EA0 0EA0 -                  ; PRINT THE STRING WHOSE DESCRIPTOR IS POINTED TO BY FACLO.
0EA0 0EA0 = CD C9 0F   [M80] STRPRT: call    FREFAC            ;[M80] RETURN TEMP POINTER BY FACLO
0EA3 0EA3 : CD 31 15                 call    MOVRM             ;[M80] [D]=LENGTH [B,C]=POINTER AT DATA
0EA6 0EA6 : 1C                       inc     e                 ;[M80] CHECK FOR NULL STRING
0EA7 0EA7 : 1D         [M80] STRPR2: dec     e                 ;[M80] DECREMENT THE LENGTH
0EA8 0EA8 : C8                       ret     z                 ;[M80] ALL DONE
0EA9 0EA9 : 0A                       ld      a,(bc)            ;[M80] GET CHARACTER TO PRINT
0EAA 0EAA : DF                       rst     OUTCHR            ;
0EAB 0EAB : FE 0D                    cp      13                ;
0EAD 0EAD : CC F0 19                 call    z,CRFIN           ;[M65] TYPE REST OF CARRIAGE RETURN
0EB0 0EB0 : 03                       inc     bc                ;[M80] POINT TO THE NEXT CHARACTER
0EB1 0EB1 : 18 F4                    jr      STRPR2            ;[M80] AND PRINT IT...
0EB3 0EB3
0EB3 0EB3                  + ;[M80] GETSPA - GET SPACE FOR CHARACTER STRING
0EB3 0EB3                  | ;[M80] MAY FORCE GARBAGE COLLECTION.
0EB3 0EB3                  | ;[M80]
0EB3 0EB3                  | ;[M80] # OF CHARS (BYTES) IN [A]
0EB3 0EB3                  | ;[M80] RETURNS WITH POINTER IN [D,E] OTHERWISE IF CANT GET SPACE
0EB3 0EB3                  | ;[M80] BLOWS OFF TO "OUT OF STRING SPACE" TYPE ERROR.
0EB3 0EB3                  | ;
0EB3 0EB3 : B7         [M80] GETSPA: or      a                 ;[M80] MUST BE NON ZERO. SIGNAL NO GARBAG YET
0EB4 0EB4 : 0E                       byte    $0E               ;[M80] "MVI C" AROUND THE NEXT BYTE 
0EB5 0EB5 : F1         [M80] TRYGI2: pop     af                ;[M80] IN CASE COLLECTED WHAT WAS LENGTH?
0EB6 0EB6 : F5                       push    af                ;[M80] SAVE IT BACK
0EB7 0EB7 : 2A 4B 38                 ld      hl,(TOPMEM)       ;
0EBA 0EBA : EB                       ex      de,hl             ;[M80] IN [D,E]        
0EBB 0EBB : 2A C1 38                 ld      hl,(FRETOP)       ;[M80] GET TOP OF FREE SPACE IN [H,L]
0EBE 0EBE : 2F                       cpl                       ;[M80] -# OF CHARS
0EBF 0EBF : 4F                       ld      c,a               ;[M80] IN [B,C]
0EC0 0EC0 : 06 FF                    ld      b,$FF             ;
0EC2 0EC2 : 09                       add     hl,bc             ;[M80] SUBTRACT FROM TOP OF FREE
0EC3 0EC3 : 23                       inc     hl                ;
0EC4 0EC4 : E7                       rst     COMPAR            ;[M80] COMPARE THE TWO
0EC5 0EC5 : 38 07                    jr      c,GARBAG          ;[M80] NOT ENOUGH ROOM FOR STRING, OFFAL TIME
0EC7 0EC7 : 22 C1 38                 ld      (FRETOP),hl       ;[M80] SAVE NEW BOTTOM OF MEMORY
0ECA 0ECA : 23                       inc     hl                ;[M80] MOVE BACK TO POINT TO STRING
0ECB 0ECB : EB                       ex      de,hl             ;[M80] RETURN WITH POINTER IN [D,E]
0ECC 0ECC : F1                       pop     af                ;
0ECD 0ECD : C9                       ret                       ;
0ECE 0ECE
0ECE 0ECE                    ;Garbage Collector - Removes Orphaned Strings
0ECE 0ECE : F1         [M80] GARBAG: pop     af                ;[M80] HAVE WE COLLECTED BEFORE?
0ECF 0ECF : 11 1A 00                 ld      de,ERRSO          ;[M80] GET READY FOR OUT OF STRING SPACE ERROR
0ED2 0ED2 : CA DB 03                 jp      z,ERROR           ;[M80] GO TELL USER HE LOST
0ED5 0ED5 : BF                       cp      a                 ;[M80] SET ZERO FLAG TO SAY WEVE GARBAGED
0ED6 0ED6 : F5                       push    af                ;[M80] SAVE FLAG BACK ON STACK
0ED7 0ED7 : 01 B5 0E                 ld      bc,TRYGI2         ;[M80] PLACE FOR GARBAG TO RETURN TO.
0EDA 0EDA : C5                       push    bc                ;[M80] SAVE ON STACK
0EDB 0EDB : 2A AD 38   [M80] GARBA2: ld      hl,(MEMSIZ)       ;[M80] START FROM TOP DOWN
0EDE 0EDE : 22 C1 38   (M80) FNDVAR: ld      (FRETOP),hl       ;[M80] LIKE SO
0EE1 0EE1 : 21 00 00                 ld      hl,0              ;[M80] GET DOUBLE ZERO
0EE4 0EE4 : E5                       push    hl                ;[M80] SAY DIDNT SEE VARS THIS PASS
0EE5 0EE5 : 2A DA 38                 ld      hl,(STREND)       ;[M80] FORCE DVARS TO IGNORE STRINGS IN PROGRAM TEXT
0EE8 0EE8 : E5                       push    hl                ;[M80] FORCE FIND HIGH ADDRESS
0EE9 0EE9 : 21 B1 38                 ld      hl,TEMPST         ;[M80] GET START OF STRING TEMPS
0EEC 0EEC : ED 5B AF 38(M80) TVAR:   ld      de,(TEMPPT)       ;[M80] SEE IF DONE
0EF0 0EF0 : E7                       rst     COMPAR            ;[M80] TEST
0EF1 0EF1 : 01 EC 0E                 ld      bc,TVAR           ;[M80] FORCE JUMP TO TVAR
0EF4 0EF4 : C2 32 0F                 jp      nz,DVAR2          ;[M80] DO TEMP VAR GARBAGE COLLECT
0EF7 0EF7 : 2A D6 38                 ld      hl,(VARTAB)       ;[M80] GET STARTING POINT IN [H,L]
0EFA 0EFA                                                      
0EFA 0EFA : ED 5B D8 38(M80) SVAR:   ld      de,(ARYTAB)       ;[M80] GET STOPPING LOCATION
0EFE 0EFE : E7                       rst     COMPAR            ;[M80] SEE IF AT END OF SIMPS
0EFF 0EFF : 28 0A                    jr      z,ARYVA4          ;
0F01 0F01 : 23                       inc     hl                ;{M80} BUMP POINTER
0F02 0F02 : 7E                       ld      a,(hl)            ;[M80] GET VALTYP
0F03 0F03 : 23                       inc     hl                ;[M80] POINT AT THE VALUE
0F04 0F04 : B7                       or      a                 ;
0F05 0F05 : CD 35 0F                 call    DVARS             ;
0F08 0F08 : 18 F0                    jr      SVAR              ;
0F0A 0F0A                    ;;;Subsection of [M80] ARYVAR     
0F0A 0F0A : C1         (M80) ARYVA2: pop     bc                ;[M80] GET RID OF STACK GARBAGE
0F0B 0F0B : ED 5B DA 38(M80) ARYVA4: ld      de,(STREND)       ;[M80] GET RID OF STACK GARBAGE
0F0F 0F0F : E7                       rst     COMPAR            ;[M80] SEE IF DONE WITH ARRAYS
0F10 0F10 : CA 57 0F                 jp      z,GRBPAS          ;[M80] YES, SEE IF DONE COLLECTING
0F13 0F13 : CD 31 15                 call    MOVRM             ;
0F16 0F16 : 7A                       ld      a,d               ;
0F17 0F17 : E5                       push    hl                ;
0F18 0F18 : 09                       add     hl,bc             ;[M80] ADDING BASE TO LENGTH
0F19 0F19 : B7                       or      a                 ;[M80] 
0F1A 0F1A : F2 0A 0F                 jp      p,ARYVA2          ;;Loop
0F1D 0F1D : 22 C5 38                 ld      (TEMP8),hl        ;[M80] SAVE END OF ARRAY 
0F20 0F20 : E1                       pop     hl                ;[M80] GET BACK CURRENT POSITION
0F21 0F21 : 4E                       ld      c,(hl)            ;[M80] PICK UP NUMBER OF DIMS
0F22 0F22 : 06 00                    ld      b,0               ;[M80] MAKE DOUBLE WITH HIGH ZERO
0F24 0F24 : 09                       add     hl,bc             ;[M80] GO PAST DIMS
0F25 0F25 : 09                       add     hl,bc             ;[M80] BY ADDING ON TWICE #DIMS (2 BYTE GUYS)
0F26 0F26 : 23                       inc     hl                ;[M80] ONE MORE TO ACCOUNT FOR #DIMS.
0F27 0F27 : EB         (M80) ARYSTR: ex      de,hl             ;[M80] SAVE CURRENT POSIT IN [D,E]
0F28 0F28 : 2A C5 38                 ld      hl,(TEMP8)        ;[M80] GET END OF ARRAY
0F2B 0F2B : EB                       ex      de,hl             ;[M80] FIX [H,L] BACK TO CURRENT
0F2C 0F2C : E7                       rst     COMPAR            ;[M80] SEE IF AT END OF ARRAY
0F2D 0F2D : 28 DC                    jr      z,ARYVA4          ;[M80] END OF ARRAY, TRY NEXT ARRAY
0F2F 0F2F : 01 27 0F                 ld      bc,ARYSTR         ;[M80] ADDR OF WHERE TO RETURN TO
0F32 0F32 : C5         (M80) DVAR2:  push    bc                ;[M80] GOES ON STACK
0F33 0F33 : F6 80                    or      $80               ;;Set Flags
0F35 0F35 : 7E         [M80] DVARS:  ld      a,(hl)            ;[M80] GET VALTYP
0F36 0F36 : 23                       inc     hl                ;[M80] BUMP POINTER TWICE
0F37 0F37 : 23                       inc     hl                ;
0F38 0F38 : 5E                       ld      e,(hl)            ;[M80] [D,E]=AMOUNT TO SKIP
0F39 0F39 : 23                       inc     hl                ;
0F3A 0F3A : 56                       ld      d,(hl)            ;
0F3B 0F3B : 23                       inc     hl                ;
0F3C 0F3C : F0                       ret     p                 ;
0F3D 0F3D : B7                       or      a                 ;
0F3E 0F3E : C8                       ret     z                 ;[M80] NULL STRING, RETURN
0F3F 0F3F : 44                       ld      b,h               ;[M80] MOVE [B,C] BACK TO [H,L]
0F40 0F40 : 4D                       ld      c,l               ;
0F41 0F41 : 2A C1 38                 ld      hl,(FRETOP)       ;[M80] GET POINTER TO TOP OF STRING FREE SPACE
0F44 0F44 : E7                       rst     COMPAR            ;[M80] IS THIS STRINGS POINTER .LT. FRETOP
0F45 0F45 : 60                       ld      h,b               ;[M80] MOVE [B,C] BACK TO [H,L]
0F46 0F46 : 69                       ld      l,c               ;
0F47 0F47 : D8                       ret     c                 ;[M80] IF NOT, NO NEED TO MESS WITH IT FURTHUR
0F48 0F48 : E1                       pop     hl                ;[M80] GET RETURN ADDRESS OFF STACK
0F49 0F49 : E3                       ex      (sp),hl           ;[M80] GET MAX SEEN SO FAR & SAVE RETURN ADDRESS
0F4A 0F4A : E7                       rst     COMPAR            ;[M80] LETS SEE
0F4B 0F4B : E3                       ex      (sp),hl           ;[M80] SAVE MAX SEEN & GET RETURN ADDRESS OFF STACK
0F4C 0F4C : E5                       push    hl                ;[M80] SAVE RETURN ADDRESS BACK
0F4D 0F4D : 60                       ld      h,b               ;[M80] MOVE [B,C] BACK TO [H,L]
0F4E 0F4E : 69                       ld      l,c               ;[
0F4F 0F4F : D0                       ret     nc                ;[M80] IF NOT, LETS LOOK AT NEXT VAR
0F50 0F50 : C1                       pop     bc                ;[M80] GET RETURN ADDR OFF STACK
0F51 0F51 : F1                       pop     af                ;[M80] POP OFF MAX SEEN
0F52 0F52 : F1                       pop     af                ;[M80] AND VARIABLE POINTER
0F53 0F53 : E5                       push    hl                ;[M80] SAVE NEW VARIABLE POINTER
0F54 0F54 : D5                       push    de                ;[M80] AND NEW MAX POINTER
0F55 0F55 : C5                       push    bc                ;[M80] SAVE RETURN ADDRESS BACK
0F56 0F56 : C9                       ret                       ;[M80] AND RETURN
0F57 0F57                  
0F57 0F57                    ;[M80] HERE WHEN MADE ONE COMPLETE PASS THRU STRING VARS
0F57 0F57 : D1         [M80] GRBPAS: pop     de                ;[M80] POP OFF MAX POINTER
0F58 0F58 : E1                       pop     hl                ;[M80] AND GET VARIABLE POINTER
0F59 0F59 : 7C                       ld      a,h               ;[M80] GET LOW IN
0F5A 0F5A : B5                       or      l                 ;[M80] SEE IF ZERO POINTER
0F5B 0F5B : C8                       ret     z                 ;[M80] IF END OF COLLECTION, THEN MAYBE RETURN TO GETSPA
0F5C 0F5C : 2B                       dec     hl                ;[M80] CURRENTLY JUST PAST THE DESCRIPTOR
0F5D 0F5D : 46                       ld      b,(hl)            ;[M80] [B]=HIGH BYTE OF DATA POINTER
0F5E 0F5E : 2B                       dec     hl                ;
0F5F 0F5F : 4E                       ld      c,(hl)            ;[M80] [B,C]=POINTER AT STRING DATA
0F60 0F60 : E5                       push    hl                ;[M80] SAVE LOCATION TO UPDTE POINTER AFTER STRING IS MOVED
0F61 0F61 : 2B                       dec     hl                ;
0F62 0F62 : 2B                       dec     hl                ;
0F63 0F63 : 6E                       ld      l,(hl)            ;[M80] [L]=STRING LENGTH
0F64 0F64 : 26 00                    ld      h,0               ;[M80] [H,L] GET CHARACTER COUNT
0F66 0F66 : 09                       add     hl,bc             ;[M80] [H,L]=POINTER BEYOND STRING
0F67 0F67 : 50                       ld      d,b               ;
0F68 0F68 : 59                       ld      e,c               ;[M80] [D,E]=ORIGINAL POINTER
0F69 0F69 : 2B                       dec     hl                ;[M80] DON'T MOVE ONE BEYOND STRING
0F6A 0F6A : 44                       ld      b,h               ;[M80] GET TOP OF STRING IN [B,C]
0F6B 0F6B : 4D                       ld      c,l               ;
0F6C 0F6C : 2A C1 38                 ld      hl,(FRETOP)       ;[M80] GET TOP OF FREE SPACE
0F6F 0F6F : CD 95 0B                 call    BLTUC             ;[M80] MOVE STRING
0F72 0F72 : E1                       pop     hl                ;[M80] GET BACK POINTER TO DESC.
0F73 0F73 : 71                       ld      (hl),c            ;[M80] SAVE FIXED ADDR
0F74 0F74 : 23                       inc     hl                ;[M80] MOVE POINTER
0F75 0F75 : 70                       ld      (hl),b            ;[M80] HIGH PART
0F76 0F76 : 60                       ld      h,b               ;
0F77 0F77 : 69                       ld      l,c               ;[M80] [H,L]=NEW POINTER
0F78 0F78 : 2B                       dec     hl                ;[M80] FIX UP FRETOP
0F79 0F79 : C3 DE 0E                 jp      FNDVAR            ;[M80] AND TRY TO FIND HIGH AGAIN
0FC7 0FC7                    ;
0FC7 0FC7                    ;[M80] STRING CONCATENATION
0FC7 0FC7                    ;[M80] THE FOLLOWING ROUTINE CONCATENATES TWO STRINGS
0FC7 0FC7                    ;[M80] THE FACLO CONTAINS THE FIRST ONE AT THIS POINT,
0FC7 0FC7                    ;[M80] [H,L] POINTS  BEYOND THE + SIGN AFTER IT
0FC7 0FC7                    ;
0F7C 0F7C : C5         [M80] CAT:    push    bc                ;[M80] PUT OLD PRECEDENCE BACK ON
0F7D 0F7D : E5                       push    hl                ;[M80] SAVE TEXT POINTER
0F7E 0F7E : 2A E4 38                 ld      hl,(FACLO)        ;[M80] GET POINTER TO STRING DESC.
0F81 0F81 : E3                       ex      (sp),hl           ;[M80] SAVE ON STACK & GET TEXT POINTER BACK
0F82 0F82 : CD FD 09                 call    EVAL              ;[M80] EVALUATE REST OF FORMULA
0F85 0F85 : E3                       ex      (sp),hl           ;[M80] SAVE TEXT POINTER, GET BACK DESC.
0F86 0F86 : CD 76 09                 call    CHKSTR            ;
0F89 0F89 : 7E                       ld      a,(hl)            ;
0F8A 0F8A : E5                       push    hl                ;[M80] SAVE DESC. POINTER.
0F8B 0F8B : 2A E4 38                 ld      hl,(FACLO)        ;[M80] GET POINTER TO 2ND DESC.
0F8E 0F8E : E5                       push    hl                ;[M80] SAVE IT
0F8F 0F8F : 86                       add     a,(hl)            ;[M80] ADD TWO LENGTHS TOGETHER
0F90 0F90 : 11 1C 00                 ld      de,ERRLS          ;[M80] SEE IF RESULT .LT. 256
0F93 0F93 : DA DB 03                 jp      c,ERROR           ;[M80] ERROR "LONG STRING"
0F96 0F96 : CD 50 0E                 call    STRINI            ;[M80] GET INITIAL STRING
0F99 0F99 : D1                       pop     de                ;[M80] GET 2ND DESC.
0F9A 0F9A : CD CD 0F                 call    FRETMP            ;
0F9D 0F9D : E3                       ex      (sp),hl           ;[M80] SAVE POINTER TO IT
0F9E 0F9E : CD CC 0F                 call    FRETM2            ;[M80] FREE UP 1ST TEMP
0FA1 0FA1 : E5                       push    hl                ;[M80] SAVE DESC. POINTER (FIRST)
0FA2 0FA2 : 2A BF 38                 ld      hl,(DSCTMP+2)     ;[M80] GET POINTER TO FIRST
0FA5 0FA5 : EB                       ex      de,hl             ;[M80] IN [D,E]
0FA6 0FA6 : CD B4 0F                 call    MOVINS            ;[M80] MOVE IN THE FIRST STRING
0FA9 0FA9 : CD B4 0F                 call    MOVINS            ;[M80] AND THE SECOND
0FAC 0FAC : 21 91 09                 ld      hl,TSTOP          ;[M80] CAT REENTERS FORMULA EVALUATION AT TSTOP
0FAF 0FAF : E3                       ex      (sp),hl           ;
0FB0 0FB0 : E5                       push    hl                ;[M80] TEXT POINTER OFF FIRST
0FB1 0FB1 : C3 7E 0E                 jp      PUTNEW            ;[M80] THEN RETURN ADDRESS OF TSTOP
0FB4 0FB4                                                      
0FB4 0FB4 : E1         [M80] MOVINS: pop     hl                ;[M80] GET RETURN ADDR
0FB5 0FB5 : E3                       ex      (sp),hl           ;[M80] PUT BACK, BUT GET DESC.
0FB6 0FB6 : 7E                       ld      a,(hl)            ;[M80] [A]=STRING LENGTH
0FB7 0FB7 : 23                       inc     hl                ;
0FB8 0FB8 : 23                       inc     hl                ;
0FB9 0FB9 : 4E                       ld      c,(hl)            ;[M80] [B,C]=POINTER AT STRING DATA
0FBA 0FBA : 23                       inc     hl                ;
0FBB 0FBB : 46                       ld      b,(hl)            ;
0FBC 0FBC : 6F                       ld      l,a               ;[M80] [L]=STRING LENGTH
0FBD 0FBD : 2C         [M80] MOVSTR: inc     l                 ;;Copying [L] Bytes from [BC] to [DE]
0FBE 0FBE : 2D         (M80) MOVLP:  dec     l                 ;[M80] SET CC'S
0FBF 0FBF : C8                       ret     z                 ;[M80] 0, NO BYTE TO MOVE
0FC0 0FC0 : 0A                       ld      a,(bc)            ;[M80] GET CHAR
0FC1 0FC1 : 12                       ld      (de),a            ;[M80] SAVE IT
0FC2 0FC2 : 03                       inc     bc                ;[M80] MOVE POINTERS
0FC3 0FC3 : 13                       inc     de                ;
0FC4 0FC4 : 18 F8                    jr      MOVLP             ;[M80] KEEP DOING IT
0FC6 0FC6   
0FC6 0FC6 -                + ;[M80] FREE UP STRING TEMPORARY 
0FC6 0FC6                  + ;[M80] FRESTR, FREFAC, FRETMP, FRETMS
0FC6 0FC6                  | ;[M80] FRETMP IS PASSED A POINTER TO A STRING DESCRIPTOR IN [D,E]
0FC6 0FC6                  | ;[M80] THIS VALUE IS RETURNED IN [H,L]. ALL THE OTHER REGISTERS ARE MODIFIED.
0FC6 0FC6                  | ;[M80] A CHECK TO IS MADE TO SEE IF THE STRING DESCRIPTOR [D,E] POINTS
0FC6 0FC6                  | ;[M80] TO IS THE LAST TEMPORARY DESCRIPTOR ALLOCATED BY PUTNEW.
0FC6 0FC6                  | ;[M80] IF SO, THE TEMPORARY IS FREED UP BY THE UPDATING OF TEMPPT.
0FC6 0FC6                  | ;[M80] IF A TEMPORARY IS FREED UP, A FURTHER CHECK IS MADE TO SEE IF THE
0FC6 0FC6                  | ;[M80] STRING DATA THAT THAT STRING TEMPORARY POINTED TO IS THE
0FC6 0FC6                  | ;[M80] THE LOWEST PART OF STRING SPACE IN USE.
0FC6 0FC6                  | ;[M80] IF SO, FRETMP IS UPDATED TO REFLECT THE FACT THAT THAT SPACE IS NO
0FC6 0FC6                  | ;[M80] LONGER IN USE.
0FC6 0FC6                  | ;
0FC6 0FC6 = CD 76 09   [M80] FRESTR: call    CHKSTR            ;[M80] MAKE SURE ITS A STRING
0FC9 0FC9 : 2A E4 38   [M80] FREFAC: ld      hl,(FACLO)        ;
0FCC 0FCC : EB         [M80] FRETM2: ex      de,hl             ;[M80] FREE UP THE TEMP IN THE FACLO
0FCD 0FCD : CD E4 0F   [M80] FRETMP: call    FRETMS            ;[M80] FREE UP THE TEMPORARY
0FD0 0FD0 : EB                       ex      de,hl             ;[M80] PUT THE STRING POINTER INTO [H,L]
0FD1 0FD1 : C0                       ret     nz                ;
0FD2 0FD2 : D5                       push    de                ;[M80] SAVE [D,E] TO RETURN IN [H,L]
0FD3 0FD3 : 50                       ld      d,b               ;[M80] [D,E]=POINTER AT STRING
0FD4 0FD4 : 59                       ld      e,c               ;
0FD5 0FD5 : 1B                       dec     de                ;[M80] SUBTRACT ONE
0FD6 0FD6 : 4E                       ld      c,(hl)            ;[M80] [C]=LENGTH OF THE STRING FREED UP
0FD7 0FD7 : 2A C1 38                 ld      hl,(FRETOP)       ;[M80] SEE IF ITS THE FIRST ONE IN STRING SPACE
0FDA 0FDA : E7                       rst     COMPAR            ;
0FDB 0FDB : 20 05                    jr      nz,NOTLST         ;[M80] NO SO DON'T ADD
0FDD 0FDD : 47                       ld      b,a               ;[M80] MAKE [B]=0
0FDE 0FDE : 09                       add     hl,bc             ;[M80] ADD
0FDF 0FDF : 22 C1 38                 ld      (FRETOP),hl       ;[M80] AND UPDATE FRETOP
0FE2 0FE2 : E1         (M80) NOTLST: pop     hl                ;[M80] GET POINTER AT CURRENT DESCRIPTOR
0FE3 0FE3 : C9                       ret                       
0FE4 0FE4                                                      
0FE4 0FE4 : 2A AF 38   [M80] FRETMS: ld      hl,(TEMPPT)       ;[M80] GET TEMP POINTER
0FE7 0FE7 : 2B                       dec     hl                ;[M80] LOOK AT WHAT IS IN THE LAST TEMP
0FE8 0FE8 : 46                       ld      b,(hl)            ;[M80] [B,C]=POINTER AT STRING
0FE9 0FE9 : 2B                       dec     hl                ;[M80] DECREMENT TEMPPT BY STRSIZ
0FEA 0FEA : 4E                       ld      c,(hl)            ;
0FEB 0FEB : 2B                       dec     hl                ;
0FEC 0FEC : 2B                       dec     hl                ;
0FED 0FED : E7                       rst     COMPAR            ;[M80] SEE IF [D,E] POINT AT THE LAST
0FEE 0FEE : C0                       ret     nz                ;[M80] RETURN NOW IF NOW FREEING DONE
0FEF 0FEF : 22 AF 38                 ld      (TEMPPT),hl       ;[M80] UPDATE THE TEMP POINTER SINCE
0FF2 0FF2 : C9                       ret                       ;
0FF3 0FF3                    
0FF3 0FF3                  + ;[M80] THE FUNCTION LEN($) 
0FF3 0FF3                  | ;[M80] RETURNS THE LENGTH OF THE STRING PASSED AS AN ARGUMENT
0FF3 0FF3 : 01 36 0B   [M80] LEN:    ld      bc,SNGFLT         ;[M80] CALL SNGFLT WHEN DONE
0FF6 0FF6 : C5                       push    bc                ;[M80] LIKE SO
0FF7 0FF7                    ;Return Length of String pointed to by FAC in [A]
0FF7 0FF7 : CD C6 0F   [M80] LEN1:   call    FRESTR            ;[M80] FREE UP TEMP POINTED TO BY FACLO
0FFA 0FFA : AF                       xor     a                 ;[M80] FORCE NUMERIC FLAG
0FFB 0FFB : 57                       ld      d,a               ;[M80] SET HIGH OF [D,E] TO ZERO FOR VAL
0FFC 0FFC : 32 AB 38                 ld      (VALTYP),a        ;
0FFF 0FFF : 7E                       ld      a,(hl)            ;
1000 1000 : B7                       or      a                 ;[M80] SET CONDITION CODES ON LENGTH
1001 1001 : C9                       ret                       ;[M80] RETURN
1002 1002
1002 1002                    ;[M80] THE FOLLOWING IS THE ASC($) FUNCTION. 
1002 1002                    ;[M80] IT RETURNS AN INTEGER WHICH IS THE DECIMAL ASCII EQUIVALENT
1002 1002 : 01 36 0B   [M80] ASC:    ld      bc,SNGFLT         ;[M80] WHERE TO GO WHEN DONE
1005 1005 : C5                       push    bc                ;[M80] SAVE RETURN ADDR ON STACK
1006 1006 :                  ;;Return [DE] = Pointer to String Text, [A]=First Character 
1006 1006 : CD F7 0F   [M80] ASC2:   call    LEN1              ;[M80] SET UP ORIGINAL STR
1009 1009 : CA 97 06                 jp      z,FCERR           ;[M80] NULL STR, BAD ARG.
100C 100C : 23                       inc     hl                ;[M80] BUMP POINTER
100D 100D : 23                       inc     hl                ;
100E 100E : 5E                       ld      e,(hl)            ;[M80] [D,E]=POINTER AT STRING DATA
100F 100F : 23                       inc     hl                ;
1010 1010 : 56                       ld      d,(hl)            ;
1011 1011 : 1A                       ld      a,(de)            ;[M80] [A]=FIRST CHARACTER
1012 1012 : C9                       ret                       ;
1013 1013                    
1013 1013                  + ;;CHR$ Function
1013 1013                  | ;[M80] CHR$(#) CREATES A STRING WHICH CONTAINS AS ITS ONLY
1013 1013                  | ;[M80] CHARACTER THE ASCII EQUIVALENT OF THE INTEGER ARG (#)
1013 1013                  | ;[M80] WHICH MUST BE .LE. 255.
1013 1013 : CD 4E 0E   [M65] CHR:    call    STRIN1            ;[M80] GET STRING IN DSCTMP
1016 1016 : CD 57 0B                 call    CONINT            ;[M80] GET INTEGER IN RANGE
1019 1019 : 2A BF 38   [M80] SETSTR: ld      hl,(DSCTMP+2)     ;[M80] GET ADDR OF STR
101C 101C : 73                       ld      (hl),e            ;[M80] SAVE ASCII BYTE
101D 101D : C1         [M80] FINBCK: pop     bc                ;[M80] RETURN TO HIGHER LEVEL & SKIP THE CHKNUM CALL
101E 101E : C3 7E 0E                 jp      PUTNEW            ;[M80] GO CALL PUTNEW
1021 1021                    
1021 1021                  + ;[M80] THE FOLLOWING IS THE LEFT$($,#) FUNCTION.
1021 1021                  | ;[M80] IT TAKES THE LEFTMOST # CHARS OF THE STR.
1021 1021                  | ;[M80] IF # IS .GT. THAN THE LEN OF THE STR, IT RETURNS THE WHOLE STR.
1021 1021 : CD A0 10   [M65] LEFT:   call    PREAM             ;[M80] TEST THE PARAMETERS
1024 1024 : AF                       xor     a                 ;[M80] LEFT NEVER CHANGES STRING POINTER
1025 1025 : E3         [M80] LEFT3:  ex      (sp),hl           ;[M80] SAVE TEXT POINTER
1026 1026 : 4F                       ld      c,a               ;[M80] OFFSET NOW IN [C]
1027 1027 : E5         [M80] LEFT2:  push    hl                ;[M80] SAVE DESC. FOR  FRETMP
1028 1028 : 7E                       ld      a,(hl)            ;[M80] GET STRING LENGTH
1029 1029 : B8                       cp      b                 ;[M80] ENTIRE STRING WANTED?
102A 102A : 38 02                    jr      c,ALLSTR          ;[M80] IF #CHARS ASKED FOR.GE.LENGTH,YES
102C 102C : 78                       ld      a,b               ;[M80] GET TRUNCATED LENGTH OF STRING
102D 102D : 11                       byte    $11               ;[M80] SKIP OVER MVI USING "LD D,"
102E 102E : 0E 00      [M80] ALLSTR: ld      c,0               ;[M80] MAKE OFFSET ZERO
1030 1030 : C5                       push    bc                ;[M80] SAVE OFFSET ON STACK
1031 1031 : CD B3 0E                 call    GETSPA            ;[M80] GET SPACE FOR NEW STRING
1034 1034 : C1                       pop     bc                ;[M80] GET BACK OFFSET
1035 1035 : E1                       pop     hl                ;[M80] GET BACK DESC POINTER.
1036 1036 : E5                       push    hl                ;[M80] BUT KEEP ON STACK
1037 1037 : 23                       inc     hl                ;[M80] MOVE TO STRING POINTER FIELD
1038 1038 : 23                       inc     hl                ;
1039 1039 : 46                       ld      b,(hl)            ;[M80] GET POINTER LOW
103A 103A : 23                       inc     hl                ;
103B 103B : 66                       ld      h,(hl)            ;[M80] POINTER HIGH
103C 103C : 68                       ld      l,b               ;[M80] GET LOW IN  L
103D 103D : 06 00                    ld      b,0               ;[M80] GET READY TO ADD OFFSET TO POINTER
103F 103F : 09                       add     hl,bc             ;[M80] ADD  IT
1040 1040 : 44                       ld      b,h               ;[M80] GET OFFSET POINTER IN [B,C]
1041 1041 : 4D                       ld      c,l               ;
1042 1042 : CD 53 0E                 call    STRAD2            ;[M80] SAVE INFO IN DSCTMP
1045 1045 : 6F                       ld      l,a               ;[M80] GET#  OF CHARS TO  MOVE IN L
1046 1046 : CD BD 0F                 call    MOVSTR            ;[M80] MOVE THEM IN
1049 1049 : D1                       pop     de                ;[M80] GET BACK DESC. POINTER
104A 104A : CD CD 0F                 call    FRETMP            ;[M80] FREE IT UP.
104D 104D : C3 7E 0E                 jp      PUTNEW            ;[M80] PUT TEMP IN TEMP LIST
1050 1050                                                      
1050 1050 : CD A0 10   [M80] RIGHT:  call    PREAM             ;[M80] CHECK ARG
1053 1053 : D1                       pop     de                ;[M80] GET DESC. POINTER
1054 1054 : D5                       push    de                ;[M80] SAVE BACK FOR LEFT
1055 1055 : 1A                       ld      a,(de)            ;[M80] GET PRESENT LEN OF STR
1056 1056 : 90                       sub     b                 ;[M80] SUBTRACT 2ND PARM
1057 1057 : 18 CC                    jr      LEFT3             ;[M80] CONTINUE WITH LEFT CODE
1059 1059                            
1059 1059                  + ;[M80] MID ($,#) RETURNS STR WITH CHARS FROM # POSITION ONWARD.
1059 1059                  | ;[M80] IF # IS GT LEN($) THEN RETURN NULL STRING.
1059 1059                  | ;[M80] MID ($,#,#) RETURNS STR WITH CHARS FROM # POSITION
1059 1059                  | ;[M80] FOR #2 CHARS. IF #2 GOES PAST END OF STRING, RETURN
1059 1059                  | ;[M80] AS MUCH AS POSSIBLE.
1059 1059 : EB         [M80] MID:    ex      de,hl             ;[M80] PUT THE TEXT POINTER IN [H,L]
105A 105A : 7E                       ld      a,(hl)            ;[M80] GET THE FIRST CHARACTER
105B 105B : CD A3 10                 call    PREAM2            ;[M80] GET OFFSET OFF STACK AND MAKE
105E 105E : 04                       inc     b                 ;
105F 105F : 05                       dec     b                 ;[M80] SEE IF EQUAL TO ZERO
1060 1060 : CA 97 06                 jp      z,FCERR           ;[M80] IT MUST NOT BE 0
1063 1063 : C5                       push    bc                ;
1064 1064 : 1E FF      {M80} MIDRST: ld      e,$FF             ;[M80] IF TWO ARG GUY, TRUNCATE
1066 1066 : FE 29                    cp      ')'               ;[M80] [E] SAYS USE ALL CHARS
1068 1068 : 28 05                    jr      z,MID2            ;[M80] IF ONE ARGUMENT THIS IS CORRECT
106A 106A : CF                       rst     SYNCHK            ;
106B 106B : 2C                       byte    ','               ;[M80] COMMA? MUST DELINEATE 3RD ARG
106C 106C : CD 54 0B                 call    GETBYT            ;[M80] GET ARGUMENT  IN  [E]
106F 106F : CF         [M80] MID2:   rst     SYNCHK            ;
1070 1070 : 29                       byte    ')'               ;[M80] MUST BE FOLLOWED BY )
1071 1071 : F1                       pop     af                ;[M80] GET OFFSET BACK IN A
1072 1072 : E3                       ex      (sp),hl           ;[M80] SAVE TEXT POINTER, GET DESC.
1073 1073 : 01 27 10                 ld      bc,LEFT2          ;[M80] WHERE TO RETURN TO.
1076 1076 : C5                       push    bc                ;[M80] GOES ON STACK
1077 1077 : 3D                       dec     a                 ;[M80] SUB ONE FROM OFFSET
1078 1078 : BE                       cp      (hl)              ;[M80] POINTER PAST END OF STR?
1079 1079 : 06 00                    ld      b,0               ;[M80] ASSUME NULL LENGTH STR
107B 107B : D0                       ret     nc                ;[M80] YES, JUST USE NULL STR
107C 107C : 4F                       ld      c,a               ;[M80] SAVE OFFSET OF CHARACTER POINTER
107D 107D : 7E                       ld      a,(hl)            ;[M80] GET PRESENT LEN OF STR
107E 107E : 91                       sub     c                 ;[M80] SUBTRACT INDEX (2ND ARG)
107F 107F : BB                       cp      e                 ;[M80] IS IT TRUNCATION
1080 1080 : 47                       ld      b,a               ;[M80] GET CALCED LENGTH IN B
1081 1081 : D8                       ret     c                 ;[M80] IF NOT USE PARTIAL STR
1082 1082 : 43                       ld      b,e               ;[M80] USE TRUNCATED LENGTH
1083 1083 : C9                       ret                       ;[M80] RETURN TO LEFT2
1084 1084
1084 1084                  + ;[M80] THE VAL FUNCTION TAKES A STRING AND TURN IT INTO A NUMBER
1084 1084                  | ;[M80] BY INTERPRETING THE ASCII DIGITS. ETC..
1084 1084                  | ;[M80] EXCEPT FOR THE PROBLEM THAT A TERMINATOR MUST BE SUPPLIED
1084 1084                  | ;[M80] BY REPLACING THE CHARACTER BEYOND THE STRING, VAL
1084 1084                  | ;[M80] IS MERELY A CALL TO FLOATING INPUT (FIN).
1084 1084                  | ;
1084 1084                  | ;[M80] IF STRING IS HIGHEST IN STRING SPACE WE ARE MODIFYING [MEMSIZ]
1084 1084                  | ;[M80] AND THIS IS WHY [MEMSIZ] CAN'T BE USED TO STORE STRING DATA 
1084 1084                  | ;[M80] BECAUSE WHAT IF THE USER TOOK VAL OFF THAT HIGH STRING
1084 1084 : CD F7 0F   [M80] VAL:    call    LEN1              ;[M80] DO SETUP, SET RESULT=REAL
1087 1087 : CA C3 12                 jp      z,ZERO            ;[M80] MAKE SURE TYPE SET UP OK IN EXTENDED
108A 108A : 5F                       ld      e,a               ;[M80] GET LENGTH OF STR
108B 108B : 23                       inc     hl                ;[M80] TO HANDLE THE FACT THE IF
108C 108C : 23                       inc     hl                ;
108D 108D : 7E                       ld      a,(hl)            ;
108E 108E : 23                       inc     hl                ;
108F 108F : 66                       ld      h,(hl)            ;[M80] TWO STRINGS "1" AND "2"
1090 1090 : 6F                       ld      l,a               ;[M80] ARE STORED NEXT TO EACH OTHER
1091 1091 : E5                       push    hl                ;[M80] AND FIN IS CALLED POINTING TO
1092 1092 : 19                       add     hl,de             ;[M80] THE FIRST TWELVE WILL BE RETURNED
1093 1093 : 46                       ld      b,(hl)            ;[M80] THE IDEA IS TO STORE 0 IN THE
1094 1094 : 72                       ld      (hl),d            ;[M80] STRING BEYOND THE ONE VAL
1095 1095 : E3                       ex      (sp),hl           ;[M80] IS BEING CALLED ON
1096 1096 : C5                       push    bc                ;[M80] THE FIRST CHARACTER OF THE NEXT STRING
1097 1097 : 2B                       dec     hl                ;[M80] ***CALL CHRGET TO MAKE SURE
1098 1098 : D7                       rst     CHRGET            ;[M80] VAL(" -3")=-3
1099 1099 : CD E5 15                 call    FIN               ;[M80] IN EXTENDED, GET ALL THE PRECISION WE CAN
109C 109C : C1                       pop     bc                ;[M80] GET THE MODIFIED CHARACTER OF THE NEXT STRING INTO [B]
109D 109D : E1                       pop     hl                ;[M80] GET THE POINTER TO THE MODIFIED CHARACTER
109E 109E : 70                       ld      (hl),b            ;[M80] RESTORE THE CHARACTER
109F 109F : C9                       ret                       ;
10A0 10A0
10A0 10A0                    ;[M80] USED BY RIGHT$ AND LEFT$ FOR PARAMETER CHECKING AND SETUP
10A0 10A0 : EB         [M80] PREAM:  ex      de,hl             ;[M80] PUT THE TEXT POINTER IN [H,L]
10A1 10A1 : CF                       rst     SYNCHK            ;
10A2 10A2 : 29                       byte    ')'               ;[M80] PARAM LIST SHOULD END
10A3 10A3                    ;[M80] USED BY MID$ FOR PARAMETER CHECKING AND SETUP
10A3 10A3 : C1         [M80] PREAM2: pop     bc                ;[M80] GET RETURN ADDR OFF STACK
10A4 10A4 : D1                       pop     de                ;[M80] GET LENGTH OF ARG OFF STACK
10A5 10A5 : C5                       push    bc                ;[M80] SAVE RETURN ADDR BACK ON
10A6 10A6 : 43                       ld      b,e               ;[M80] SAVE INIT LENGTH
10A7 10A7 : C9                       ret
10A8 10A8
10A8 10A8 :                  ;[M65] FRE FUNCTION AND INTEGER TO FLOATING ROUTINES
10A8 10A8 : 2A DA 38   [M80] FRE:    ld      hl,(STREND)       ;    
10AB 10AB : EB                       ex      de,hl             ;
10AC 10AC : 21 00 00                 ld      hl,0              ;
10AF 10AF : 39                       add     hl,sp             ;
10B0 10B0 : 3A AB 38                 ld      a,(VALTYP)        ;
10B3 10B3 : B7                       or      a                 ;
10B4 10B4 : CA 1C 0B                 jp      z,GIVFLT          ;
10B7 10B7 : CD C9 0F                 call    FREFAC            ;[M80] FREE UP ARGUMENT AND SETUP TO GIVE FREE STRING SPACE
10BA 10BA : CD DB 0E                 call    GARBA2            ;[M80] DO GARBAGE COLLECTION
10BD 10BD : ED 5B 4B 38              ld      de,(TOPMEM)       ;
10C1 10C1 : 2A C1 38                 ld      hl,(FRETOP)       ;[M80] TOP OF FREE AREA
10C4 10C4 : C3 1C 0B                 jp      GIVFLT            ;[M80] RETURN [H,L]-[D,E]
10C7 10C7                                                      
10C7 10C7 : 2B         [M80] DIMCON: dec     hl                ;[M80] SEE IF COMMA ENDED THIS VARIABLE
10C8 10C8 : D7                       rst     CHRGET            ;
10C9 10C9 : C8                       ret     z                 ;[M80] IF TERMINATOR, GOOD BYE
10CA 10CA : CF                       rst     SYNCHK            ;
10CB 10CB : 2C                       byte    ','               ;[M80] MUST BE COMMA
10CC 10CC  
10CC 10CC                  + ;{M80} DIMENSION
10CC 10CC                  | ;[M80] THE "DIM" CODE SETS DIMFLG AND THEN FALLS INTO THE VARIABLE
10CC 10CC                  | ;[M80] SEARCH ROUTINE. THE VARIABLE SEARCH ROUTINE LOOKS AT
10CC 10CC                  | ;[M80] DIMFLG AT THREE DIFFERENT POINTS:
10CC 10CC                  | ;[M80]
10CC 10CC                  | ;[M80]  1) IF AN ENTRY IS FOUND, DIMFLG BEING ON INDICATES
10CC 10CC                  | ;[M80]          A "DOUBLY DIMENSIONED" VARIABLE
10CC 10CC                  | ;[M80]  2) WHEN A NEW ENTRY IS BEING BUILT DIMFLG'S BEING ON
10CC 10CC                  | ;[M80]          INDICATES THE INDICES SHOULD BE USED FOR
10CC 10CC                  | ;[M80]          THE SIZE OF EACH INDICE. OTHERWISE THE DEFAULT
10CC 10CC                  | ;[M80]          OF TEN IS USED.
10CC 10CC                  | ;[M80]  3) WHEN THE BUILD ENTRY CODE FINISHES, ONLY IF DIMFLG IS
10CC 10CC                  | ;[M80]          OFF WILL INDEXING BE DONE
10CC 10CC                  | ;
10CC 10CC : 01 C7 10   [M80] DIM:    ld      bc,DIMCON       ;[M80] PLACE TO COME BACK TO
10CF 10CF : C5                       push    bc              ;
10D0 10D0 : F6                       byte    $F6             ;;"OR" to skip next instruction
10D1 10D1
10D1 10D1                  + ;{M80} VARIABLE SEARCHING
10D1 10D1                  | ;[M80] ROUTINE TO READ THE VARIABLE NAME AT THE CURRENT TEXT POSITION
10D1 10D1                  | ;[M80] AND PUT A POINTER TO ITS VALUE IN [D,E]. [H,L] IS UPDATED
10D1 10D1                  | ;[M80] TO POINT TO THE CHARACTER AFTER THE VARIABLE NAME.
10D1 10D1                  | ;[M80] VALTYP IS SETUP. NOTE THAT EVALUATING SUBSCRIPTS IN
10D1 10D1                  | ;[M80] A VARIABLE NAME CAN CAUSE RECURSIVE CALLS TO PTRGET SO AT
10D1 10D1                  | ;[M80] THAT POINT ALL VALUES MUST BE STORED ON THE STACK.
10D1 10D1                  | ;[M80] ON RETURN, [A] DOES NOT REFLECT THE VALUE OF THE TERMINATING CHARACTER
10D1 10D1                  | ;;VALTYP is set to 1 if a '$' follows the variable name, or 0 if one doesn't.
10D1 10D1                  | ;;  A pointer to the variable contents is returned in DE. The contents are a
10D1 10D1                  | ;;  four byte floating point number for numeric variables and a two byte
10D1 10D1                  | ;;  pointer to the string data for a string variable.
10D1 10D1                  | ;;If SUBFLG = 0 and a '(' follows the variable name, the array table is searched.
10D1 10D1                  | ;;  If the array is found, the indexes are evaluated and a pointer to the array
10D1 10D1                  | ;;  element is returned in DE.
10D1 10D1                  | ;;If SUBFLG = 1, the array table is searched for the variable name.
10D1 10D1                  | ;;  If found, the pointer to the next array entry is returned in DE, and
10D1 10D1                  | ;;  a pointer to the number of dimensions is returned in BC.
10D1 10D1 -                - ;;Get Pointer to Variable
10D1 10D1 = AF         [M80] PTRGET: xor      a                ;[M80] MAKE [A]=0
10D2 10D2 : 32 AA 38                 ld      (DIMFLG),a        ;[M80] FLAG IT AS SUCH
10D5 10D5 : 4E                       ld      c,(hl)            ;[M80] GET FIRST CHARACTER IN [C]
10D1 10D1 -                - ;;Get Pointer to Variable after Reading First Character
10D6 10D6 = CD C5 0C   [M80] PTRGT2: call    ISLET             ;[M80] CHECK FOR LETTER
10D9 10D9 : DA C4 03                 jp      c,SNERR           ;[M80] MUST HAVE A LETTER
10DC 10DC : AF                       xor     a                 ;
10DD 10DD : 47                       ld      b,a               ;[M80] ASSUME NO SECOND CHARACTER
10DE 10DE : 32 AB 38                 ld      (VALTYP),a        ;[M80] ZERO NAMCNT
10E1 10E1 : D7                       rst     CHRGET            ;[M80] GET CHAR
10E2 10E2 : 38 05                    jr      c,ISSEC           ;[M80] YES, WAS NUMERIC
10E4 10E4 : CD C6 0C                 call    ISLETC            ;[M80] SET CARRY IF NOT ALPHABETIC
10E7 10E7 : 38 09                    jr      c,NOSEC           ;[M80] ALLOW ALPHABETICS
10E9 10E9 : 47         (M80) ISSEC:  ld      b,a               ;[M80] IT IS A NUMBER--SAVE IN B
10EA 10EA : D7         (M80) EATEM:  rst     CHRGET            ;[M80] GET CHAR
10EB 10EB : 38 FD                    jr      c,EATEM           ;[M65] SKIP NUMERICS
10ED 10ED : CD C6 0C   {M80} VMORC1: call    ISLETC            ;
10F0 10F0 : 30 F8                    jr      nc,EATEM          ;[M65] SKIP ALPHABETICS
10F2 10F2 : D6 24      (M80) NOSEC:  sub     '$'               ;[M65] IS IT A STRING?
10F4 10F4 : 20 08                    jr      nz,NOTSTR         ;[M65] IF NOT, [VALTYP]=0.
10F6 10F6 : 3C                       inc     a                 ;[M65] SET [VALTYP]=1 (STRING !)
10F7 10F7 : 32 AB 38                 ld      (VALTYP),a        ;
10FA 10FA : 0F                       rrca                      ;
10FB 10FB : 80                       add     a,b               ;
10FC 10FC : 47                       ld      b,a               ;
10FD 10FD : D7                       rst     CHRGET            ;[M80] READ PAST TYPE MARKER
10FE 10FE : 3A CB 38   (M65) NOTSTR: ld      a,(SUBFLG)        ;[M80] GET FLAG WHETHER TO ALLOW ARRAYS
1101 1101 : 3D                       dec     a                 ;[M80] IF SUBFLG=1, "ERASE" HAS CALLED
1102 1102 : CA A0 11                 jp      z,ERSFIN          ;[M80] PTRGET, AND SPECIAL HANDLING MUST BE DONE
1105 1105 : F2 0E 11                 jp      p,NOARYS          ;[M80] NO ARRAYS ALLOWED
1108 1108 : 7E                       ld      a,(hl)            ;[M80] GET CHAR BACK
1109 1109 : D6 28                    sub     '('               ;[M80] (CHECK FOR "(") WON'T MATCH IF SUBFLG SET
110B 110B : CA 7A 11                 jp      z,ISARY           ;[M80] IT IS!
110E 110E    
110E 110E : AF         (M80) NOARYS: xor     a                 ;[M80]ALLOW PARENS AGAIN
110F 110F : 32 CB 38                 ld      (SUBFLG),a        ;[M80]SAVE IN FLAG LOCATION
1112 1112 : E5                       push    hl                ;[M80] SAVE THE TEXT POINTER
1113 1113 : 50                       ld      d,b               ;;???Variable Name
1114 1114 : 59                       ld      e,c               
1115 1115 : 2A DE 38                 ld      hl,(VARNAM)       
1118 1118 : E7                       rst     COMPAR            
1119 1119 : 11 E0 38                 ld      de,VARPNT         
111C 111C : CA 1A 14                 jp      z,POPHRT          
111F 111F : 2A D8 38                 ld      hl,(ARYTAB)       
1122 1122 : EB                       ex      de,hl             ;{M80} [D,E]=POINTER INTO ARRAYS
1123 1123 : 2A D6 38                 ld      hl,(VARTAB)       ;{M80} [H,L]=POINTER INTO SIMPLE VARIABLES
1126 1126 : E7         (M80) LOPFND: rst     COMPAR            ;
1127 1127 : CA 3D 11                 jp      z,SMKVAR          ;[M80] IF SO, CREATE VARIABLE
112A 112A : 79                       ld      a,c               ;[M80] ARE LOW BYTES DIFFERENT
112B 112B : 96                       sub     (hl)              ;[M80] TEST
112C 112C : 23                       inc     hl                ;
112D 112D : C2 32 11                 jp      nz,LOPFN2         ;{M80} NO
1130 1130 : 78                       ld      a,b               ;[M80] ARE HIGH BYTES DIFFERENT
1131 1131 : 96                       sub     (hl)              ;[M80] THE SAME?
1132 1132 : 23         (~~~) LOPFN2: inc     hl                ;
1133 1133 : CA 6C 11                 jp      z,NTFPRT          ;{M80} YES
1136 1136 : 23                       inc     hl                ;
1137 1137 : 23                       inc     hl                ;
1138 1138 : 23                       inc     hl                ;
1139 1139 : 23                       inc     hl                ;;Skip past variable
113A 113A : C3 26 11                 jp      LOPFND            ;
113D 113D                                                      
113D 113D                                                      
113D 113D : E1         (M80) SMKVAR: pop     hl                ;
113E 113E : E3                       ex      (sp),hl           ;
113F 113F : D5                       push    de                ;
1140 1140 : 11 51 0A                 ld      de,RETVAR         ;[M80] DID EVAL CALL US?
1143 1143 : E7                       rst     COMPAR            ;[M80] IF SO, DON'T MAKE A NEW VARIABLE
1144 1144 : D1                       pop     de                ;[M80] RESTORE THE POSITION
1145 1145 : CA 6F 11                 jp      z,FINZER          ;[M80] MAKE FAC ZERO (ALL TYPES) AND SKIP RETURN
1148 1148 : E3                       ex      (sp),hl           ;[M80] PUT RETURN ADDRESS BACK
1149 1149 : E5                       push    hl                ;[M80] PUT THE TEXT POINTER BACK
114A 114A : C5                       push    bc                ;[M80] SAVE THE LOOKS
114B 114B : 01 06 00                 ld      bc,6              ;[M80] MAKE THE LENGTH INCLUDE EVERYTHING UP BY
114E 114E : 2A DA 38                 ld      hl,(STREND)       ;[M80] THE CURRENT END OF STORAGE
1151 1151 : E5                       push    hl                ;[M80] SAVE THIS #
1152 1152 : 09                       add     hl,bc             ;[M80] ADD ON THE AMOUNT OF SPACE EXTRA NOW BEING USED
1153 1153 : C1                       pop     bc                ;[M80] POP OFF HIGH ADDRESS TO MOVE
1154 1154 : E5                       push    hl                ;[M80] SAVE NEW CANDIDATE FOR STREND
1155 1155 : CD 92 0B                 call    BLTU              ;{M80} BLOCK TRANSFER AND CHECK FOR STACK OVERFLOW
1158 1158 : E1                       pop     hl                ;[M80] [H,L]=NEW STREND
1159 1159 : 22 DA 38                 ld      (STREND),hl       ;[M80] BLOCK TRANSFER WAS DONE, SO UPDATE POINTERS
115C 115C : 60                       ld      h,b               ;[M80] GET BACK [H,L] POINTING AT THE END
115D 115D : 69                       ld      l,c               ;[M80] OF THE NEW VARIABLE
115E 115E : 22 D8 38                 ld      (ARYTAB),hl       ;[M80] UPDATE THE ARRAY TABLE POINTER
1161 1161 : 2B         (M80) ZEROER: dec     hl                ;[M80] [H,L] IS RETURNED POINTING TO THE
1162 1162 : 36 00                    ld      (hl),0            ;[M80] END OF THE VARIABLE SO WE
1164 1164 : E7                       rst     COMPAR            ;[M80] ZERO BACKWARDS TO [D,E] WHICH
1165 1165 : 20 FA                    jr      nz,ZEROER         ;[M80] POINTS TO THE START OF THE VARIABLE
1167 1167 : D1                       pop     de                ;
1168 1168 : 73                       ld      (hl),e            ;[M80] PUT DESCRIPTION
1169 1169 : 23                       inc     hl                ;
116A 116A : 72                       ld      (hl),d            ;[M80] OF THIS VARIABLE INTO MEMORY
116B 116B : 23                       inc     hl                ;
116C 116C : EB         (M80) NTFPRT: ex      de,hl             ;[M80] TABLE POINTER BACK INTO [D,E]
116D 116D : E1                       pop     hl                ;[M80] GET BACK THE TEXT POINTER
116E 116E : C9                       ret                       ;
116F116F
116F 116F                    ; MAKE ALL TYPES ZERO AND SKIP RETURN
116F 116F : 32 E7 38   [M80] FINZER: ld      (FAC),a           ;[M80] MAKE FLOATS ZERO
1172 1172 : 21 6D 03                 ld      hl,REDDY-1        ;[M80] MAKE IT A NULL STRING BY
1175 1175 : 22 E4 38                 ld      (FACLO),hl        ;[M80] POINTING AT A ZERO
1178 1178 : E1         {M80} POPHR2: pop     hl                ;[M80] GET THE TEXT POINTER
1179 1179 : C9                       ret                       ;[M80] RETURN FROM EVAL
117A 117A                    
117A 117A                  + ;[M80] FORMAT OF ARRAYS IN CORE
117A 117A                  | ;[M80]
117A 117A                  | ;[M80] DESCRIPTOR 
117A 117A                  | ;[M80]       LOW BYTE = SECOND CHARCTER (200 BIT IS STRING FLAG)
117A 117A                  | ;[M80]       HIGH BYTE = FIRST CHARACTER
117A 117A                  | ;[M80] LENGTH OF ARRAY IN CORE IN BYTES (DOES NOT INCLUDE DESCRIPTOR)
117A 117A                  | ;[M80] NUMBER OF DIMENSIONS 1 BYTE
117A 117A                  | ;[M80] FOR EACH DIMENSION STARTING WITH THE FIRST A LIST
117A 117A                  | ;[M80] (2 BYTES EACH) OF THE MAX INDICE+1
117A 117A                  | ;[M80] THE VALUES
117A 117A                  | ;
117A 117A : E5         [M80] ISARY:  push    hl                ;[M80] SAVE DIMFLG AND VALTYP FOR RECURSION
117B 117B : 2A AA 38                 ld      hl,(DIMFLG)       ;
117E 117E : E3                       ex      (sp),hl           ;[M80] TEXT POINTER BACK INTO [H,L]
117F 117F : 57                       ld      d,a               ;[M80] SET # DIMENSIONS =0
1180 1180 : D5         [M80] INDLOP: push    de                ;[M80] SAVE NUMBER OF DIMENSIONS
1181 1181 : C5                       push    bc                ;[M80] SAVE LOOKS
1182 1182 : CD 7A 06                 call    INTIDX            ;[M80] EVALUATE INDICE INTO [D,E]
1185 1185 : C1         {M80} OPTB0:  pop     bc                ;[M80] POP OFF THE LOOKS
1186 1186 : F1                       pop     af                ;[M80] [A] = NUMBER OF DIMENSIONS SO FAR;
1187 1187 : EB                       ex      de,hl             ;[M80] [D,E]=TEXT POINTER, [H,L]=INDICE
1188 1188 : E3                       ex      (sp),hl           ;[M80] PUT NDICE ON STACK, [H,L]=VALTYP & DIMFLG
1189 1189 : E5                       push    hl                ;[M80] RESAVE VALTYP AND DIMFLG
118A 118A : EB                       ex      de,hl             ;[M80] [H,L]=TEXT POINTER
118B 118B : 3C                       inc     a                 ;[M80] INCREMENT # OF DIMENSIONS
118C 118C : 57                       ld      d,a               ;[M80] [D]=NUMBER OF DIMENSIONS
118D 118D : 7E                       ld      a,(hl)            ;[M80] GET TERMINATING CHARACTER
118E 118E : FE 2C                    cp      ','               ;[M80] A COMMA SO MORE INDICES FOLLOW?
1190 1190 : CA 80 11                 jp      z,INDLOP          ;[M80] IF SO, READ MORE
1193 1193 : CF                       rst     SYNCHK            ;
1194 1194 : 29                       byte    ')'               ;{M80} MAKE SURE THERE IS A BRACKET
1195 1195 : 22 D0 38   {M80} SUBSOK: ld      (TENP2),hl        ;[M80 ]SAVE THE TEXT POINTER
1198 1198 : E1                       pop     hl                ;[M80 ][H,L]= VALTYP & DIMFLG
1199 1199 : 22 AA 38                 ld      (DIMFLG),hl       ;[M80 ]SAVE VALTYP AND DIMFLG
119C 119C : 1E 00                    ld      e,0               ;{M80 }WHEN [D,E] IS POPPED INTO PSW, ZERO FLAG WON'T BE SET
119E 119E : D5                       push    de                ;[M80 ]SAVE NUMBER OF DIMENSIONS
119F 119F : 11                       byte    $11               ;[M80] "LD H," OVER THE NEXT TWO BYTES
11A0 11A0
11A0 11A0                    ;;Get Pointer to Array
11A0 11A0                    ;;BC = Array Variable Name on Entry
11A0 11A0                    ;;     Pointer to Number of Dimensions on Exit 
11A0 11A0 : E5         [M80] ERSFIN: push    hl                ;[M80] SAVE THE TEXT POINTER
11A1 11A1 : F5                       push    af                ;[M80] SAVE A DUMMY NUMBER OF DIMENSIONS WITH THE ZERO FLAG SET
11A2 11A2
11A2 11A2                    ;[M80] AT THIS POINT [B,C]=LOOKS. THE TEXT POINTER IS IN TEMP2.
11A2 11A2                    ;[M80] THE INDICES ARE ALL ON THE STACK, FOLLOWED BY THE NUMBER OF DIMENSIONS.
11A2 11A2 : 2A D8 38                 ld      hl,(ARYTAB)       ;[M80] [H,L]=PLACE TO START THE SEARCH
11A5 11A5 : 3E                       byte    $3E               ;[M80] "LD A," AROUND THE NEXT BYTE 
11A6 11A6 : 19         (M80) LOPFDA: add     hl,de             ;[M80] SKIP OVER THIS ARRAY SINCE IT'S NOT THE ONE
11A7 11A7 : ED 5B DA 38              ld      de,(STREND)       ;[M80] GET THE PLACE TO STOP INTO [H,L]     
11AB 11AB : E7                       rst     COMPAR            ;[M80] STOPPING TIME?
11AC 11AC : 28 25                    jr      z,NOTFDD          ;[M80] YES, COULDN'T FIND THIS ARRAY
11AE 11AE : 7E                       ld      a,(hl)            ;[M80] GET FIRST CHARACTER
11AF 11AF : 23                       inc     hl                
11B0 11B0 : B9                       cp      c                 ;[M80] SEE IF IT MATCHES
11B1 11B1 : 20 02                    jr      nz,NMARY1         ;[M80] NOT THIS ONE
11B3 11B3 : 7E                       ld      a,(hl)            ;[M80] GET SECOND CHARACTER
11B4 11B4 : B8                       cp      b                 ;[M80] ANOTHER MATCH?
11B5 11B5 : 23         (M80) NMARY1: inc     hl                ;[M80] POINT TO SIZE ENTRY
11B6 11B6 : 5E         {M80} CNOMAT: ld      e,(hl)            ;[M80] [D,E]=LENGTH
11B7 11B7 : 23                       inc     hl                ;[M80] OF THE ARRAY BEING LOOKED AT
11B8 11B8 : 56                       ld      d,(hl)            
11B9 11B9 : 23                       inc     hl                
11BA 11BA : 20 EA                    jr      nz,LOPFDA         ;[M80] IF NO MATCH, SKIP THIS ONE AND TRY AGAIN
11BC 11BC : 3A AA 38                 ld      a,(DIMFLG)        ;[M80] SEE IF CALLED BY "DIM"
11BF 11BF : B7                       or      a                 ;[M80] ZERO MEANS NO
11C0 11C0 : C2 CD 03                 jp      nz,DDERR          ;[M80] "REDIMENSIONED VARIABLE" IF "DIM" CALLING PTRGET
11C3 11C3
11C3 11C3                  + ;[M80] TEMP2=THE TEXT POINTER
11C3 11C3                  | ;[M80] WE HAVE LOCATED THE VARIABLE WE WERE LOOKING FOR
11C3 11C3                  | ;[M80] AT THIS POINT [H,L] POINTS BEYOND THE SIZE TO THE NUMBER OF DIMENSIONS
11C3 11C3                  | ;[M80] THE INDICES ARE ON THE STACK FOLLOWED BY THE NUMBER OF DIMENSIONS
11C3 11C3                  | ;
11C3 11C3 : F1                       pop     af                ;[M80] [A]=NUMBER OF DIMENSIONS
11C4 11C4 : 44                       ld      b,h               ;[M80] SET [B,C] TO POINT AT NUMBER OF DIMENSIONS
11C5 11C5 : 4D                       ld      c,l               
11C6 11C6 : CA 1A 14                 jp      z,POPHRT          ;[M80] "ERASE" IS DONE, SO RETURN TO DO THE ACTUAL ERASURE
11C9 11C9 : 96                       sub     (hl)              ;{M80} MAKE SURE DIMENSIONS MATCH
11CA 11CA : CA 2B 12                 jp      z,GETDEF          ;[M80] JUMP OFF AND READ E INDICES....
11CD 11CD : 11 10 00   [M80] BSERR:  ld      de,ERRBS          ;[M80] "SUBSCRIPT OUT OF RANGE"
11D0 11D0 : C3 DB 03                 jp      ERROR
11D3 11D3
11D3 11D3                  + ;[M80] HERE WHEN VARIABLE IS NOT FOUND IN THE ARRAY TABLE
11D3 11D3                  | ;[M80]
11D3 11D3                  | ;[M80] BUILDING AN ENTRY:
11D3 11D3                  | ;[M80] 
11D3 11D3                  | ;[M80]  PUT DOWN THE DESCRIPTOR 
11D3 11D3                  | ;[M80]  SETUP NUMER OF DIMENSIONS
11D3 11D3                  | ;[M80]  MAKE SURE THERE IS ROOM FOR THE NEW ENTRY
11D3 11D3                  | ;[M80]  REMEMBER VARPTR
11D3 11D3                  | ;[M80]  TALLY=4 (VALTYP FOR THE EXTENDED)
11D3 11D3                  | ;[M80]  SKIP 2 LOCS FOR LATER FILL IN -- THE SIZE
11D3 11D3                  | ;[M80] LOOP:    GET AN INDICE
11D3 11D3                  | ;[M80]  PUT NUMBER +1 DOWN AT VARPTR AND INCREMENT VARPTR
11D3 11D3                  | ;[M80]  TALLY= TALLY * NUMBER+1
11D3 11D3                  | ;[M80]  DECREMENT NUMBER-DIMS
11D3 11D3                  | ;[M80]  JNZ     LOOP
11D3 11D3                  | ;[M80]  CALL REASON WITH [H,L] REFLECTING LAST LOC OF VARIABLE
11D3 11D3                  | ;[M80]  UPDATE STREND
11D3 11D3                  | ;[M80]  ZERO BACKWARDS
11D3 11D3                  | ;[M80]  MAKE TALLY INCLUDE MAXDIMS
11D3 11D3                  | ;[M80]  PUT DOWN TALLY
11D3 11D3                  | ;[M80]  IF CALLED BY DIMENSION, RETURN
11D3 11D3                  | ;[M80]  OTHERWISE INDEX INTO THE VARIABLE AS IF IT
11D3 11D3                  | ;[M80]  WERE FOUND ON THE INITIAL SEARCH
11D3 11D3                  | ;
11D3 11D3 : 11 04 00   [M80] NOTFDD: ld      de,4              ;[M80] [D,E]=SIZE OF ONE VALUE (VALTYP)
11D6 11D6 : F1                       pop     af                ;[M80] [A]=NUMBER OF DIMENSIONS
11D7 11D7 : CA 97 06                 jp      z,FCERR           ;[M80] "ILLEGAL FUNCTION CALL"
11DA 11DA : 71                       ld      (hl),c            ;[M80] PUT DOWN THE DESCRIPTOR
11DB 11DB : 23                       inc     hl
11DC 11DC : 70                       ld      (hl),b
11DD 11DD : 23                       inc     hl
11DE 11DE : 4F                       ld      c,a               ;{M80} [C]=ENTRIES NEEDED TO STORE SIZE OF EACH DIMENSION
11DF 11DF : CD A0 0B                 call    GETSTK            ;[M80] GET SPACE FOR DIMENSION ENTRIES
11E2 11E2 : 23                       inc     hl                ;[M80] SKIP OVER THE SIZE LOCATIONS
11E3 11E3 : 23                       inc     hl                
11E4 11E4 : 22 C3 38                 ld      (TENP3),hl        ;[M80] SAVE THE LOCATION TO PUT THE SIZE IN
11E7 11E7 : 71                       ld      (hl),c            ;[M80] STORE THE NUMBER OF DIMENSIONS
11E8 11E8 : 23                       inc     hl                
11E9 11E9 : 3A AA 38                 ld      a,(DIMFLG)        ;{M80} CALLED BY DIMENSION?
11EC 11EC : 17                       rla                       ;[M80] SET CARRY IF SO
11ED 11ED : 79                       ld      a,c               ;[M80] [A]=NUMBER OF DIMENSIONS
11EE 11EE : 01 0B 00   (M80) LOPPTA: ld      bc,11             ;[M80] MAP 0 TO 11 AND 1 TO 10
11F1 11F1 : 30 02                    jr      nc,NOTDIM         ;[M80] DEFAULT DIMENSIONS TO TEN
11F3 11F3 : C1         (M80) POPDIM: pop     bc                ;[M80] POP OFF AN INDICE INTO [B,C]
11F4 11F4 : 03                       inc     bc                ;[M80] ADD ONE TO IT FOR THE ZERO ENTRY
11F5 11F5 : 71         (M80) NOTDIM: ld      (hl),c            ;[M80] PUT THE MAXIMUM DOWN
11F6 11F6 : F5                       push    af                ;[M80] SAVE NUMBER OF DIMENSIONS AND DIMFLG (CARRY)
11F7 11F7 : 23                       inc     hl
11F8 11F8 : 70                       ld      (hl),b
11F9 11F9 : 23                       inc     hl
11FA 11FA : E5                       push    hl
11FB 11FB : CD CA 15                 call    UMULT             ;[M80] MULTIPLY [B,C]=NEWMAX BY CURTOL=[D,E]
11FE 11FE : EB                       ex      de,hl             
11FF 11FF : E1                       pop     hl                
1200 1200 : F1                       pop     af                ;[M80] GET NUMBER OF DIMENSIONS AND DIMFLG (CARRY) BACK
1201 1201 : 3D                       dec     a                 ;[M80] DECREMENT THE NUMBER OF DIMENSIONS LEFT
1202 1202 : 20 EA                    jr      nz,LOPPTA         ;[M80] HANDLE THE OTHER INDICES
1204 1204 : F5                       push    af                ;[M80] SAVE DIMFLG (CARRY)
1205 1205 : 42                       ld      b,d               ;[M80] [B,C]=SIZE
1206 1206 : 4B                       ld      c,e               
1207 1207 : EB                       ex      de,hl             ;[M80] [D,E]=START OF VALUES
1208 1208 : 19                       add     hl,de             ;[M80] [H,L]=END OF VALUES
1209 1209 : DA B7 0B                 jp      c,OMERR           ;[M80] OUT OF MEMORY POINTER BEING GENERATED?
120C 120C : CD A9 0B                 call    REASON            ;[M80] SEE IF THERE IS ROOM FOR THE VALUES
120F 120F : 22 DA 38                 ld      (STREND),hl       ;[M80] UPDATE THE END OF STORAGE
1212 1212 : 2B         (M80) ZERITA: dec     hl                ;[M80] ZERO THE NEW ARRAY
1213 1213 : 36 00                    ld      (hl),000H         
1215 1215 : E7                       rst     COMPAR            ;[M80] BACK AT THE BEGINNING?
1216 1216 : 20 FA                    jr      nz,ZERITA         ;[M80] NO, ZERO MORE
1218 1218 : 03                       inc     bc                ;(M80) ADD ONE TO INCLUDE BYTE FOR NUMBER OF DIMENSIONS
1219 1219 : 57                       ld      d,a               ;[M80[ [D]=ZERO
121A 121A : 2A C3 38                 ld      hl,(TENP3)        ;[M80[ GET A POINTER AT THE NUMBER OF DIMENSIONS
121D 121D : 5E                       ld      e,(hl)            ;[M80[ [E]=NUMBER OF DIMENSIONS
121E 121E : EB                       ex      de,hl             ;[M80[ [H,L]=NUMBER OF DIMENSIONS
121F 121F : 29                       add     hl,hl             ;[M80[ [H,L]=NUMBER OF DIMENSIONS TIMES TWO
1220 1220 : 09                       add     hl,bc             ;[M80[ ADD ON THE SIZE TO GET THE TOTAL NUMBER OF BYTES USED
1221 1221 : EB                       ex      de,hl             ;[M80[ [D,E]=TOTAL SIZE
1222 1222 : 2B                       dec     hl                ;[M80[ BACK UP TO POINT TO LOCATION TO PUT
1223 1223 : 2B                       dec     hl                ;[M80[ THE SIZE OF THE ARRAY IN BYTES IN.
1224 1224 : 73                       ld      (hl),e            ;[M80[ PUT DOWN THE SIZE
1225 1225 : 23                       inc     hl                
1226 1226 : 72                       ld      (hl),d            
1227 1227 : 23                       inc     hl                
1228 1228 : F1                       pop     af                ;[M80] GET BACK DIMFLG (CARRY) AND SET [A]=0
1229 1229 : 38 21                    jr      c,FINNOW
122B 122B
122B 122B                    ;[M80] AT THIS POINT [H,L] POINTS BEYOND THE SIZE TO THE NUMBER OF DIMENSIONS
122B 122B                    ;[M80] STRATEGY:
122B 122B                    ;[M80]  NUMDIM=NUMBER OF DIMENSIONS
122B 122B                    ;[M80]  CURTOL=0
122B 122B                    ;[M80] INLPNM:GET A NEW INDICE
122B 122B                    ;[M80]  POP NEW MAX INTO CURMAX
122B 122B                    ;[M80]  MAKE SURE INDICE IS NOT TOO BIG
122B 122B                    ;[M80]  MUTLIPLY CURTOL BY CURMAX
122B 122B                    ;[M80]  ADD INDICE TO CURTOL
122B 122B                    ;[M80]  NUMDIM=NUMDIM-1
122B 122B                    ;[M80]  JNZ     INLPNM
122B 122B                    ;[M80]  USE CURTOL*4 (VALTYP FOR EXTENDED) AS OFFSET
122B 122B                    ;
122B 122B : 47         [M80] GETDEF: ld      b,a               ;[M80] [B,C]=CURTOL=ZERO
122C 122C : 4F                       ld      c,a               
122D 122D : 7E                       ld      a,(hl)            ;[M80] [A]=NUMBER OF DIMENSIONS
122E 122E : 23                       inc     hl                ;[M80] POINT PAST THE NUMBER OF DIMENSIONS
122F 122F : 16                       byte    $16               ;[M80] "LD D," AROUND THE NEXT BYTE
1230 1230 : E1         [M80] INLPNM: pop     hl                ;[M80] [H,L]= POINTER INTO VARIABLE ENTRY
1231 1231 : 5E                       ld      e,(hl)            ;[M80] [D,E]=MAXIMUM FOR THE CURRENT INDICE
1232 1232 : 23                       inc     hl                
1233 1233 : 56                       ld      d,(hl)            
1234 1234 : 23                       inc     hl                ;[M80] [H,L]=CURRENT INDICE
1235 1235 : E3                       ex      (sp),hl           ;[M80] POINTER INTO THE VARIABLE GOES ON THE STACK
1236 1236 : F5                       push    af                ;[M80] SAVE THE NUMBER OF DIMENSIONS
1237 1237 : E7                       rst     COMPAR            ;[M80] SEE IF THE CURRENT INDICE IS TOO BIG
1238 1238 : D2 CD 11                 jp      nc,BSERR          ;[M80] IF SO "BAD SUBSCRIPT" ERROR
123B 123B : E5                       push    hl                
123C 123C : CD CA 15                 call    UMULT             ;[M80] CURTOL=CURTOL*CURRENT MAXIMUM
123F 123F : D1                       pop     de                
1240 1240 : 19                       add     hl,de             ;[M80] ADD THE INDICE TO CURTOL
1241 1241 : F1                       pop     af                ;[M80] GET THE NUMBER OF DIMENSIONS IN [A]
1242 1242 : 3D                       dec     a                 ;[M80] SEE IF ALL THE INDICES HAVE BEEN PROCESSED
1243 1243 : 44                       ld      b,h               ;[M80] [B,C]=CURTOL IN CASE WE LOOP BACK
1244 1244 : 4D                       ld      c,l               
1245 1245 : 20 E9                    jr      nz,INLPNM         ;[M80] PROCESS THE REST OF THE INDICES
1247 1247 : 29                       add     hl,hl             ;[M80] MULTIPLY BY TWO
1248 1248 : 29                       add     hl,hl             ;[M80] NOW MULTIPLIED BY FOUR
1249 1249 : C1         {M80} DONMUL: pop     bc                ;[M80] POP OFF THE ADDRESS OF WHERE THE VALUES BEGIN
124A 124A : 09                       add     hl,bc             ;[M80] ADD IT ONTO CURTOL TO GET PLACE VALUE IS STORED
124B 124B : EB                       ex      de,hl             ;[M80] RETURN THE POINTER IN [D,E]
124C 124C : 2A D0 38   (M80) FINNOW: ld      hl,(TENP2)        ;[M80] REGET THE TEXT POINTER
124F 124F : C9                       ret
1250 1250
1250 1250                  + ;[M80] MATHPK FOR BASIC MCS 8080  GATES/ALLEN/DAVIDOFF
1250 1250                  | ;
1250 1250                  | ;[M80] EXTERNAL LOCATIONS USED BY THE MATH-PACKAGE
1250 1250                  | ;
1250 1250                  | ;[M80] THE FLOATING ACCUMULATOR
1250 1250                  | ;(M80) FACLO:   [LOW ORDER OF MANTISSA (LO)]
1250 1250                  | ;(M80) FACMO:   [MIDDLE ORDER OF MANTISSA (MO)]
1250 1250                  | ;(M80) FACHO:   [HIGH ORDER OF MANTISSA (HO)]
1250 1250                  | ;(M80) FAC:     [EXPONENT]
1250 1250                  | ;(M80)          [TEMPORARY COMPLEMENT OF SIGN IN MSB]
1250 1250                  | ;(M80] ARGLO:           [LOCATION OF SECOND ARGUMENT]
1250 1250                  | ;(M80] ARG:     
1250 1250                  | ;(M80] FBUFFR:  BUFFER FOR FOUT
1250 1250                  | ;[M80]
1250 1250                  | ;[M80] THE FLOATING POINT FORMAT IS AS FOLLOWS:
1250 1250                  | ;[M80]
1250 1250                  | ;[M80] THE SIGN IS THE FIRST BIT OF THE MANTISSA
1250 1250                  | ;[M80] THE MANTISSA IS 24 BITS LONG
1250 1250                  | ;[M80] THE BINARY POINT IS TO THE LEFT OF THE MSB
1250 1250                  | ;[M80] NUMBER = MANTISSA * 2 ^ EXPONENT
1250 1250                  | ;[M80] THE MANTISSA IS POSITIVE, WITH A ONE ASSUMED TO BE WHERE THE SIGN BIT IS
1250 1250                  | ;[M80] THE SIGN OF THE EXPONENT IS THE FIRST BIT OF THE EXPONENT
1250 1250                  | ;[M80] THE EXPONENT IS STORED IN EXCESS 200 I.E. WITH A BIAS OF 200
1250 1250                  | ;[M80] SO, THE EXPONENT IS A SIGNED 8-BIT NUMBER WITH 200 ADDED TO IT
1250 1250                  | ;[M80] AN EXPONENT OF ZERO MEANS THE NUMBER IS ZERO, THE OTHER BYTES ARE IGNORED
1250 1250                  | ;[M80] TO KEEP THE SAME NUMBER IN THE FAC WHILE SHIFTING:
1250 1250                  | ;[M80]  TO SHIFT RIGHT, EXP:=EXP+1
1250 1250                  | ;[M80]  TO SHIFT LEFT,  EXP:=EXP-1
1250 1250                  | ;[M80]
1250 1250                  | ;[M80] SO, IN MEMORY THE NUMBER LOOKS LIKE THIS:
1250 1250                  | ;[M80]  [BITS 17-24 OF THE MANTISSA]
1250 1250                  | ;[M80]  [BITS 9-16 OF THE MANTISSA]
1250 1250                  | ;[M80]  [THE SIGN IN BIT 7, BITS 2-8 OF THE MANTISSA ARE IN BITS 6-0]
1250 1250                  | ;[M80]  [THE EXPONENT AS A SIGNED NUMBER + 200]
1250 1250                  | ;[M80] (REMEMBER THAT BIT 1 OF THE MANTISSA IS ALWAYS A ONE)
1250 1250                  | ;[M80]
1250 1250                  | ;[M80] ARITHMETIC ROUTINE CALLING CONVENTIONS:
1250 1250                  | ;[M80]
1250 1250                  | ;[M80] FOR ONE ARGUMENT FUNCTIONS:
1250 1250                  | ;[M80]  THE ARGUMENT IS IN THE FAC, THE RESULT IS LEFT IN THE FAC
1250 1250                  | ;[M80] FOR TWO ARGUMENT OPERATIONS:
1250 1250                  | ;[M80]  THE FIRST ARGUMENT IS IN B,C,D,E I.E. THE "REGISTERS"
1250 1250                  | ;[M80]  THE SECOND ARGUMENT IS IN THE FAC
1250 1250                  | ;[M80]  THE RESULT IS LEFT IN THE FAC
1250 1250                  | ;[M80] 
1250 1250                  | ;[M80] THE "S" ENTRY POINTS TO THE TWO ARGUMENT OPERATIONS HAVE (HL) POINTING TO
1250 1250                  | ;[M80] THE FIRST ARGUMENT INSTEAD OF THE FIRST ARGUMENT BEING IN THE REGISTERS.
1250 1250                  | ;[M80] MOVRM IS CALLED TO GET THE ARGUMENT IN THE REGISTERS.
1250 1250                  | ;[M80] THE "T" ENTRY POINTS ASSUME THE FIRST ARGUMENT IS ON THE STACK.
1250 1250                  | ;[M80] POPR IS USED TO GET THE ARGUMENT IN THE REGISTERS.
1250 1250                  | ;[M80] NOTE: THE "T" ENTRY POINTS SHOULD ALWAYS BE JUMPED TO AND NEVER CALLED
1250 1250                  | ;[M80] BECAUSE THE RETURN ADDRESS ON THE STACK WILL BE CONFUSED WITH THE NUMBER.
1250 1250                  | ;[M80] 
1250 1250                  | ;[M80] ON THE STACK, THE TWO LO'S ARE PUSHED ON FIRST AND THEN THE HO AND SIGN.
1250 1250                  | ;[M80] THIS IS DONE SO IF A NUMBER IS STORED IN MEMORY, IT CAN BE PUSHED ON THE
1250 1250                  | ;[M80] STACK WITH TWO PUSHM'S.  THE LOWER BYTE OF EACH PART IS IN THE LOWER
1250 1250                  | ;[M80] MEMORY ADDRESS SO WHEN THE NUMBER IS POPPED INTO THE REGISTERS, THE HIGHER
1250 1250                  | ;[M80] ORDER BYTE WILL BE IN THE HIGHER ORDER REGISTER OF THE REGISTER PAIR, I.E.
1250 1250                  | ;[M80] THE HIGHER ORDER BYTE WILL BE POPPED INTO B, D OR H.
12501250
1250 1250                    ;[M80] FLOATING POINT ADDITION AND SUBTRACTION                    
1250 1250 : 21 57 17   [M80] FADDH:  ld      hl,FHALF          ;[M80] ENTRY TO ADD 1/2
1253 1253 : CD 31 15   [M80] FADDS:  call    MOVRM             ;[M80] GET ARGUMENT INTO THE REGISTERS
1256 1256 : 18 09                    jr      FADD              ;[M80] DO THE ADDITION
12581258
1258 1258 -                  ;[M80] SUBTRACTION      FAC:=ARG-FAC
1258 1258 = CD 31 15   [M80] FSUBS:  call    MOVRM             ;[M80] ENTRY IF POINTER TO ARG IS IN (HL)
125B 125B : 21                       byte    $21               ;;"LD HL," to skip next instruction
125C 125C : C1         [M80] FSUBT:  pop     bc                ;;ENTRY TO FSUB IF ARGUMENT IS ON STACK
125D 125D : D1                       pop     de                
125E 125E : CD 0B 15   [M80] FSUB:   call    NEG               ;[M80] NEGATE SECOND ARGUMENT
12611261
1261 1261 :                  ;[M80] ADDITION FAC:=ARG+FAC
1261 1261 : 78         [M80] FADD:   ld      a,b               ;[M80] CHECK IF FIRST ARGUMENT IS ZERO    
1262 1262 : B7                       or      a                 ;[M80] GET EXPONENT
1263 1263 : C8                       ret     z                 ;[M80] IT IS, RESULT IS NUMBER IN FAC
1264 1264 : 3A E7 38                 ld      a,(FAC)           ;[M80] GET EXPONENT
1267 1267 : B7                       or      a                 ;[M80] SEE IF THE NUMBER IS ZERO
1268 1268 : CA 23 15                 jp      z,MOVFR           ;[M80] IT IS, ANSWER IS IN REGISTERS
126B 126B
126B 126B                  + ;;Align Numbers
126B 126B                  | ;[M80] WE WANT TO GET THE SMALLER NUMBER IN THE REGISTERS SO WE CAN SHIFT IT RIGHT
126B 126B                  | ;[M80] AND ALIGN THE BINARY POINTS OF THE TWO NUMBERS.  THEN WE CAN JUST ADD OR
126B 126B                  | ;[M80] SUBTRACT THEM (DEPENDING ON THEIR SIGNS) BYTEWISE.
126B 126B : 90                       sub     b                 ;[M80] CHECK RELATIVE SIZES
126C 126C : 30 0C                    jr      nc,FADD1          ;[M80] IS FAC SMALLER?
126E 126E : 2F                       cpl                       ;[M80] YES, NEGATE SHIFT COUNT
126F 126F : 3C                       inc     a                 
1270 1270 : EB                       ex      de,hl             ;[M80] SWITCH FAC AND REGISTERS, SAVE (DE)
1271 1271 : CD 13 15                 call    PUSHF             ;[M80] PUT FAC ON STACK
1274 1274 : EB                       ex      de,hl             ;[M80] GET (DE) BACK WHERE IT BELONGS
1275 1275 : CD 23 15                 call    MOVFR             ;[M80] PUT REGISTERS IN THE FAC
1278 1278 : C1                       pop     bc                
1279 1279 : D1                       pop     de                ;[M80] GET THE OLD FAC IN THE REGISTERS
127A 127A                                                      
127A 127A : FE 19      [M80] FADD1:  cp      25                ;ARE WE WITHIN 24 BITS?
127C 127C : D0                       ret     nc                
127D 127D : F5                       push    af                ;SAVE SHIFT COUNT
127E 127E : CD 46 15                 call    UNPACK            ;UNPACK THE NUMBERS
1281 1281 : 67                       ld      h,a               ;SAVE SUBTRACTION FLAG
1282 1282 : F1                       pop     af                ;GET SHIFT COUNT BACK
1283 1283 : CD 30 13                 call    SHIFTR            ;SHIFT REGISTERS RIGHT THE RIGHT AMOUNT
1286 1286
1286 1286                  + ;;Add or Subtract Numbers
1286 1286                  | ;[M80] IF THE NUMBERS HAVE THE SAME SIGN, THEN WE ADD THEM.  IF THE SIGNS ARE
1286 1286                  | ;[M80] DIFFERENT, THEN WE HAVE TO SUBTRACT THEM.  WE HAVE TO DO THIS BECAUSE THE      
1286 1286                  | ;[M80] MANTISSAS ARE POSITIVE.  JUDGING BY THE EXPONENTS, THE LARGER NUMBER IS IN
1286 1286                  | ;[M80] THE FAC, SO IF WE SUBTRACT, THE SIGN OF THE RESULT SHOULD BE THE SIGN OF THE
1286 1286                  | ;[M80] FAC; HOWEVER, IF THE EXPONENTS ARE THE SAME, THE NUMBER IN THE REGISTERS
1286 1286                  | ;[M80] COULD BE BIGGER, SO AFTER WE SUBTRACT THEM, WE HAVE TO CHECK IF THE RESULT
1286 1286                  | ;[M80] WAS NEGATIVE.  IF IT WAS, WE NEGATE THE NUMBER IN THE REGISTERS AND
1286 1286                  | ;[M80] COMPLEMENT THE SIGN OF THE FAC.  (HERE THE FAC IS UNPACKED)
1286 1286                  | ;[M80] IF WE HAVE TO ADD THE NUMBERS, THE SIGN OF THE RESULT IS THE SIGN OF THE
1286 1286                  | ;[M80] FAC.  SO, IN EITHER CASE, WHEN WE ARE ALL DONE, THE SIGN OF THE RESULT
1286 1286                  | ;[M80] WILL BE THE SIGN OF THE FAC.
1286 1286 : 7C                       ld      a,h               ;[M80] GET SUBTRACTION FLAG
1287 1287 : B7                       or      a                 
1288 1288 : 21 E4 38                 ld      hl,FACLO          ;[M80] SET POINTER TO LO'S
128B 128B : F2 9F 12                 jp      p,FADD3           ;[M80] SUBTRACT IF THE SIGNS WERE DIFFERENT
128E 128E : CD 10 13                 call    FADDA             ;[M80] ADD THE NUMBERS
1291 1291 : 30 5E                    jr      nc,ROUND          ;[M80] ROUND RESULT IF THERE WAS NO OVERFLOW
1293 1293 : 23                       inc     hl                ;[M80] THERE WAS OVERFLOW
1294 1294 : 34                       inc     (hl)              ;[M80] INCREMENT EXPONENT
1295 1295 : CA D3 03                 jp      z,OVERR           
1298 1298 : 2E 01                    ld      l,1               ;[M80] SHIFT RESULT RIGHT ONE, SHIFT CARRY IN
129A 129A : CD 52 13                 call    SHRADD            
129D 129D : 18 52                    jr      ROUND             ;[M80] ROUND RESULT AND WE ARE DONE
129F 129F                    
129F 129F                    ;[M80] HERE TO SUBTRACT C,D,E,B FROM ((HL)+0,1,2),0
129F 129F : AF         [M80] FADD3:  xor     a                 ;[M80] SUBTRACT NUMBERS, NEGATE UNDERFLOW BYTE
12A0 12A0 : 90                       sub     b                 
12A1 12A1 : 47                       ld      b,a               ;[M80] SAVE IT
12A2 12A2 : 7E                       ld      a,(hl)            ;[M80] SUBTRACT LOW ORDERS
12A3 12A3 : 9B                       sbc     a,e               
12A4 12A4 : 5F                       ld      e,a               
12A5 12A5 : 23                       inc     hl                ;[M80] UPDATE POINTER TO NEXT BYTE
12A6 12A6 : 7E                       ld      a,(hl)            ;[M80] SUBTRACT MIDDLE ORDERS
12A7 12A7 : 9A                       sbc     a,d               
12A8 12A8 : 57                       ld      d,a               
12A9 12A9 : 23                       inc     hl                ;[M80] UPDATE POINTER TO HIGH ORDERS
12AA 12AA : 7E                       ld      a,(hl)            ;[M80] SUBTRACT HIGH ORDERS
12AB 12AB : 99                       sbc     a,c
12AC 12AC : 4F                       ld      c,a
12AD 12AD
12AD 12AD                    ;[M80] BECAUSE WE WANT A POSITIVE MANTISSA, CHECK IF WE HAVE TO NEGATE THE NUMBER
12AD 12AD : DC 1C 13   [M80] FADFLT: call    c,NEGR
12B0 1280
12B0 12B0                  + ;NORMALIZE C,D,E,B
12B0 12B0                  | ;ALTERS A,B,C,D,E,H,L
12B0 12B0                  | ;HERE WE SHIFT THE MANTISSA LEFT UNTIL THE MSB IS A ONE.
12B0 12B0                  | ;EXCEPT IN 4K, THE IDEA IS TO SHIFT LEFT BY 8 AS MANY TIMES AS
12B0 12B0                  | ;POSSIBLE.
12B0 12B0                  | ;
12B0 12B0 : 68         [M80] NORMAL: ld      l,b               ;[M80] PUT LOWEST 2 BYTES IN (HL)
12B1 12B1 : 63                       ld      h,e               
12B2 12B2 : AF                       xor     a                 ;[M80] ZERO SHIFT COUNT
12B3 12B3 : 47         (M80) NORM1:  ld      b,a               ;[M80] SAVE SHIFT COUNT
12B4 12B4 : 79                       ld      a,c               ;[M80] DO WE HAVE 1 BYTE OF ZEROS
12B5 12B5 : B7                       or      a                 
12B6 12B6 : 20 27                    jr      nz,NORM3          ;[M80] NO, SHIFT ONE PLACE AT A TIME
12B8 12B8                  - ;[M80] THIS LOOP SPEEDS THINGS UP BY SHIFTING 8 PLACES AT ONE TIME
12B8 12B8 : 4A                       ld      c,d               ;[M80] YES, SHIFT OVER 1 BYTE
12B9 12B9 : 54                       ld      d,h             
12BA 12BA : 65                       ld      h,l             
12BB 12BB : 6F                       ld      l,a               ;[M80] SHIFT IN 8 aS FOR THE LOW ORDER
12BC 12BC : 78                       ld      a,b               ;[M80] UPDATE SHIFT COUNT
12BD 12BD : D6 08                    sub     8                 
12BF 12BF : FE E0                    cp      224               ;[M80] DID WE SHIFT IN 4 BYTES OF ZEROS?
12C1 12C1 : 20 F0                    jr      nz,NORM1          ;[M80] NO, TRY TO SHIFT OVER 8 MORE
12C3 12C3  
12C3 12C3                  + ;[M80] ZERO FAC
12C3 12C3                  | ;[M80] ALTERS A ONLY
12C3 12C3                  | ;[M80] EXITS WITH A=0
12C3 12C3                  | ;[M80] BY OUR FLOATING POINT FORMAT, THE NUMBER IS ZERO IF THE EXPONENT IS ZERO
12C3 12C3                  | ;
12C3 12C3 : AF               ZERO:   xor     a                  ;[M80] ZERO A
12C4 12C4 : 32 E7 38         ZERO0:  ld      (FAC),a            ;[M80] ZERO THE FAC'S EXPONENT, ENTRY IF A=0
12C7 12C7 : C9                       ret                        ;[M80] ALL DONE
12C8 12C8                    
12C8 12C8 : 7C         [M80] NORM2:  ld      a,h                ;[M80] CHECK FOR CASE OF NORMALIZING A SMALL INT
12C9 12C9 : B5                       or      l                  
12CA 12CA : B2                       or      d                  
12CB 12CB : 20 0A                    jr      nz,NORM2U          ;[M80] DO USUAL THING
12CD 12CD : 79                       ld      a,c                ;[M80] GET BYTE TO SHIFT
12CE 12CE : 05         (M80) NORM2F: dec     b                  ;[M80] DECRMENT SHIFT COUNT
12CF 12CF : 17                       rla                        ;[M80] SHIFT LEFT
12D0 12D0 : 30 FC                    jr      nc,NORM2F          ;[M80] NORMALIZE LIKE SOB
12D2 12D2 : 04                       inc     b                  ;[M80] CORRECT SHIFT COUNT
12D3 12D3 : 1F                       rra                        ;[M80] WE DID IT ONE TOO MANY TIMES
12D4 12D4 : 4F                       ld      c,a                ;[M80] RESULT TO [C]
12D5 12D5 : 18 0B                    jr      NORM3A             ;[M80] ALL DONE
12D7 12D7 : 05         (M80) NORM2U: dec     b                  ;[M80] DECREMENT SHIFT COUNT
12D8 12D8 : 29                       add     hl,hl              ;[M80] ROTATE (HL) LEFT ONE, SHIFT IN A ZERO
12D9 12D9 : 7A                       ld      a,d                ;[M80] ROTATE NEXT HIGHER ORDER LEFT ONE
12DA 12DA : 17                       rla                        ;
12DB 12DB : 57                       ld      d,a                ;
12DC 12DC : 79                       ld      a,c                ;[M80] ROTATE HIGH ORDER LEFT ONE
12DD 12DD : 8F                       adc     a,a                ;[M80] SET CONDITION CODES
12DE 12DE : 4F                       ld      c,a                ;
12DF 12DF : F2 C8 12   (M80) NORM3:  jp      p,NORM2           ;[M80] WE HAVE MORE NORMALIZATION TO DO
12E2 12E2 : 78         (M80) NORM3A: ld      a,b               ;[M80] ALL NORMALIZED, GET SHIFT COUNT
12E3 12E3 : 5C                       ld      e,h               ;[M80] PUT LO'S BACK IN E,B
12E4 12E4 : 45                       ld      b,l               ;
12E5 12E5 : B7                       or      a                 ;[M80] CHECK IF WE DID NO SHIFTING
12E6 12E6 : 28 09                    jr      z,ROUND           ;
12E8 12E8 : 21 E7 38                 ld      hl,FAC            ;[M80] LOOK AT FAC'S EXPONENT
12EB 12EB : 86                       add     a,(hl)            ;[M80] UPDATE EXPONENT
12EC 12EC : 77                       ld      (hl),a            ;
12ED 12ED : 30 D4                    jr      nc,ZERO           ;[M80] CHECK FOR UNDERFLOW
12EF 12EF : 28 D2                    jr      z,ZERO            ;[M80] NUMBER IS ZERO, ALL DONE
12F1 12F1                                                    
12F1 12F1                  + ;[M80] ROUND RESULT IN C,D,E,B AND PUT NUMBER IN THE FAC
12F1 12F1                  | ;[M80] ALTERS A,B,C,D,E,H,L
12F1 12F1                  | ;[M80] WE ROUND C,D,E UP OR DOWN DEPENDING UPON THE MSB OF B
12F1 12F1                  | ;
12F1 12F1 : 78         [M80] ROUND:  ld      a,b               ;[M80] SEE IF WE SHOULD ROUND UP
12F2 12F2 : 21 E7 38   [M80] ROUNDB: ld      hl,FAC            ;[M80] ENTRY FROM FDIV, GET POINTER TO EXPONENT
12F5 12F5 : B7                       or      a                 
12F6 12F6 : FC 03 13                 call    m,ROUNDA          ;[M80] DO IT IF NECESSARY
12F9 12F9 : 46                       ld      b,(hl)            ;[M80] PUT EXPONENT IN B
12FA 12FA                  - ;[80] HERE WE PACK THE HO AND SIGN        
12FA 12FA : 23                       inc     hl                ;[M80]  POINT TO SIGN
12FB 12FB : 7E                       ld      a,(hl)            ;[M80]  GET SIGN
12FC 12FC : E6 80                    and     $80               ;[M80]  GET RID OF UNWANTED BITS
12FE 12FE : A9                       xor     c                 ;[M80]  PACK SIGN AND HO
12FF 12FF : 4F                       ld      c,a               ;[M80]  SAVE IT IN C
1300 1300 : C3 23 15                 jp      MOVFR             ;[M80]  SAVE NUMBER IN FAC
1303 1303
1303 1303                    ;[M80] SUBROUTNE FOR ROUND:  ADD ONE TO C,D,E                  
1303 1303 : 1C               ROUNDA: inc     e                 ;[M80] ADD ONE TO THE LOW ORDER, ENTRY FROM QINT
1304 1304 : C0                       ret     nz                ;[M80] ALL DONE IF IT IS NOT ZERO
1305 1305 : 14                       inc     d                 ;[M80] ADD ONE TO NEXT HIGHER ORDER
1306 1306 : C0                       ret     nz                ;[M80] ALL DONE IF NO OVERFLOW
1307 1307 : 0C                       inc     c                 ;[M80] ADD ONE TO THE HIGHEST ORDER
1308 1308 : C0                       ret     nz                ;[M80] RETURN IF NO OVEFLOW
1309 1309 : 0E 80                    ld      c,$80             ;[M80] THE NUMBER OVERFLOWED, SET NEW HIGH ORDER
130B 130B : 34                       inc     (hl)              ;[M80] UPDATE EXPONENT
130C 130C : C0                       ret     nz                ;[M80] RETURN IF IT DID NOT OVERFLOW
130D 130D : C3 D3 03                 jp      OVERR             ;[M80] OVERFLOW
1310 1310                    
1310 1310                  + ;[M80] ADD (HL)+2,1,0 TO C,D,E
1310 1310                  | ;[M80] THIS CODE IS USED BY FADD, FOUT
1310 1310 : 7E         [M80] FADDA:  ld      a,(hl)            ;[M80] GET LOWEST ORDER
1311 1311 : 83                       add     a,e               ;[M80] ADD IN OTHER LOWEST ORDER
1312 1312 : 5F                       ld      e,a               ;[M80] SAVE IT
1313 1313 : 23                       inc     hl                ;[M80] UPDATE POINTER TO NEXT BYTE
1314 1314 : 7E                       ld      a,(hl)            ;[M80] ADD MIDDLE ORDERS
1315 1315 : 8A                       adc     a,d               
1316 1316 : 57                       ld      d,a               
1317 1317 : 23                       inc     hl                ;[M80] UPDATE POINTER TO HIGH ORDER
1318 1318 : 7E                       ld      a,(hl)            ;[M80] ADD HIGH ORDERS
1319 1319 : 89                       adc     a,c               
131A 131A : 4F                       ld      c,a               
131B 131B : C9                       ret                       ;[M80] ALL DONE
131C 131C
131C 131C                  + ;[M80] NEGATE NUMBER IN C,D,E,B
131C 131C                  | ;[M80] THIS CODE IS USED BY FADD, QINT
131C 131C                  | ;[M80] ALTERS A,B,C,D,E,L
131C 131C                  | ;
131C 131C : 21 E8 38   [M80] NEGR:   ld      hl,FAC+1          ;[M80] NEGATE FAC
131F 131F : 7E                       ld      a,(hl)            ;[M80] GET SIGN
1320 1320 : 2F                       cpl                       ;[M80] COMPLEMENT IT
1321 1321 : 77                       ld      (hl),a            ;[M80] SAVE IT AGAIN
1322 1322 : AF                       xor     a                 ;[M80] ZERO A
1323 1323 : 6F                       ld      l,a               ;[M80] SAVE ZERO IN L
1324 1324 : 90                       sub     b                 ;[M80] NEGATE LOWEST ORDER
1325 1325 : 47                       ld      b,a               ;[M80] SAVE IT
1326 1326 : 7D                       ld      a,l               ;[M80] GET A ZERO
1327 1327 : 9B                       sbc     a,e               ;[M80] NEGATE NEXT HIGHEST ORDER
1328 1328 : 5F                       ld      e,a               ;[M80] SAVE IT
1329 1329 : 7D                       ld      a,l               ;[M80] GET A ZERO
132A 132A : 9A                       sbc     a,d               ;[M80] NEGATE NEXT HIGHEST ORDER
132B 132B : 57                       ld      d,a               ;[M80] SAVE IT
132C 132C : 7D                       ld      a,l               ;[M80] GET ZERO BACK
132D 132D : 99                       sbc     a,c               ;[M80] NEGATE HIGHEST ORDER
132E 132E : 4F                       ld      c,a               ;[M80] SAVE IT
132F 132F : C9                       ret                       ;[M80] ALL DONE
1330 1330                    
1330 1330                  + ;[M80] SHIFT C,D,E RIGHT
1330 1330                  | ;[M80] A = SHIFT COUNT
1330 1330                  | ;[M80] ALTERS A,B,C,D,E,L
1330 1330                  | ;[M80] THE IDEA (EXCEPT IN 4K) IS TO SHIFT RIGHT 8 PLACES AS MANY TIMES AS
1330 1330                  | ;[M80]  POSSIBLE
1330 1330                  | ;
1330 1330 : 06 00      [M80] SHIFTR: ld      b,0               ;[M80] ZERO OVERFLOW BYTE
1332 1332 : D6 08      (M80) SHFTR1: sub     8                 ;[M80] CAN WE SHIFT IT 8 RIGHT?
1334 1334 : 38 07                    jr      c,SHFTR2          ;[M80] NO, SHIFT IT ONE PLACE AT A TIME
1334 1334                  - ;[M80] THIS LOOP SPEEDS THINGS UP BY SHIFTING 8 PLACES AT ONE TIME
1336 1336 : 43                       ld      b,e               ;[M80] SHIFT NUMBER 1 BYTE RIGHT
1337 1337 : 5A                       ld      e,d             
1338 1338 : 51                       ld      d,c             
1339 1339 : 0E 00                    ld      c,0               ;[M80 PUT 0 IN HO
133B 133B : 18 F5                    jr      SHFTR1            ;[M80 TRY TO SHIFT 8 RIGHT AGAIN
133D 133D : C6 09      (M80) SHFTR2: add     a,9               ;[M80 CORRECT SHIFT COUNT
133F 133F : 6F                       ld      l,a               ;[M80 SAVE SHIFT COUNT
1340 1340                  - ;[M80] TEST FOR CASE (VERY COMMON) WHERE SHIFTING SMALL INTEGER RIGHT.
1340 1340                  - ;[M80] THIS HAPPENS IN FOR LOOPS, ETC.
1340 1340 : 7A                       ld      a,d               ;[M80] SEE IF THREE LOWS ARE ZERO.
1341 1341 : B3                       or      e                 
1342 1342 : B0                       or      b                 
1343 1343 : 20 09                    jr      nz,SHFTR3         ;[M80] IF SO, DO USUAL.
1345 1345 : 79                       ld      a,c               ;[M80] GET HIGH BYTE TO SHIFT
1346 1346 : 2D         (M80) SHFTRF: dec     l                 ;[M80] DONE SHIFTING?
1347 1347 : C8                       ret     z                 ;[M80] YES, DONE
1348 1348 : 1F                       rra                       ;[M80] ROTATE ONE RIGHT
1349 1349 : 4F                       ld      c,a               ;[M80] SAVE RESULT
134A 134A : 30 FA                    jr      nc,SHFTRF         ;[M80] ZAP BACK AND DO NEXT ONE IF NONE
134C 134C : 18 06                    jr      SHFTC             ;[M80] CONTINUE SHIFTING
134E 134E : AF         (M80) SHFTR3: xor     a                 ;[M80] CLEAR CARRY
134F 134F : 2D                       dec     l                 ;[M80] ARE WE DONE SHIFTING?
1350 1350 : C8                       ret     z                 ;[M80] RETURN IF WE ARE
1351 1351 : 79                       ld      a,c               ;[M80] GET HO
1352 1352 : 1F         [M80] SHRADD: rra                       ;[M80] ENTRY FROM FADD, SHIFT IT RIGHT             
1353 1353 : 4F                       ld      c,a               ;[M80] SAVE IT
1354 1354 : 7A         (M80) SHFTC:  ld      a,d               ;[M80] SHIFT NEXT BYTE RIGHT
1355 1355 : 1F                       rra                       
1356 1356 : 57                       ld      d,a               
1357 1357 : 7B                       ld      a,e               ;[M80] SHIFT LOW ORDER RIGHT
1358 1358 : 1F                       rra                       
1359 1359 : 5F                       ld      e,a               
135A 135A : 78                       ld      a,b               ;[M80] SHIFT OVERFLOW BYTE RIGHT
135B 135B : 1F                       rra                       
135C 135C : 47                       ld      b,a               
135D 135D : 18 EF                    jr      SHFTR3            ;[M80] SEE IF WE ARE DONE
135F 135F
135F 135F :                  ;[M80] CONSTANTS USED BY LOG 
135F 135F : 00 00 00 81(M80) FONE:   byte    $00,$00,$00,$81 ;1
1363 1363 : 04         [M80] LOGP:   byte    4                  ;[M80] HART 2524 COEFFICIENTS
1364 1364 : 9A F7 19 83              byte    $9A,$F7,$19,$83    ;[M80] 4.8114746
1368 1368 : 24 63 43 83              byte    $24,$63,$43,$83    ;[M80] 6.105852
136C 136C : 75 CD 8D 84              byte    $75,$CD,$8D,$84    ;[M80] -8.86266
1370 1370 : A9 7F 83 82              byte    $A9,$7F,$83,$82    ;[M80] -2.054667
1374 1374 : 04         [M80] LOGQ:   byte    4                  
1375 1375 : 00 00 00 81              byte    $00,$00,$00,$81    ;[M80] 1.0
1379 1379 : E2 B0 4D 83              byte    $E2,$B0,$4D,$83    ;[M80] 6.427842
137D 137D : 0A 72 11 83              byte    $0A,$72,$11,$83    ;[M80] 4.545171
1381 1381 : F4 04 35 7F              byte    $F4,$04,$35,$7F    ;[M80] .3535534
1385 1385
1385 1385 :                + ;[M80] NATURAL LOG FUNCTION
1385 1385 :                | ;[M80] CALCULATION IS BY:
1385 1385 :                | ;[M80]  LN(F*2^N)=(N+LOG2(F))*LN(2)
1385 1385 :                | ;[M80] AN APPROXIMATION POLYNOMIAL IS USED TO CALCULATE LOG2(F)
1385 1385 : EF         [M80] LOG:    rst     FSIGN             ;[M80] CHECK FOR A NEGATIVE OR ZERO ARGUMENT
1386 1386 : B7                       or      a                 ;[M80] SET CC'S PROPERLY
1387 1387 : EA 97 06                 jp      pe,FCERR          ;[M80] FAC .LE. 0, BLOW HIM OUT OF THE WATER
138A 138A : CD 95 13                 call    LOG2              
138D 138D : 01 31 80                 ld      bc,$8031          
1390 1390 : 11 18 72                 ld      de,$7218          ;[M80] GET LN(2)
1393 1393 : 18 36                    jr      FMULT             ;[M80] COMPLETE LOG CALCULATION: USE HART 2524 CALCULATION
1395 1395                                                      
1395 1395                    ;[M80] USE HART 2524 CALCULATION  
1395 1395 : CD 2E 15   [M80] LOG2:   call    MOVRF             ;[M80] MOVE FAC TO REGISTERS TOO
1398 1398 : 3E 80                    ld      a,080H            
139A 139A : 32 E7 38                 ld      (FAC),a           ;[M80] ZERO THE EXPONENT
139D 139D : A8                       xor     b                 ;[M80] REMOVE 200 EXCESS FROM X
139E 139E : F5                       push    af                ;[M80] SAVE EXPONENT
139F 139F : CD 13 15                 call    PUSHF             ;[M80] SAVE THE FAC (X)
13A2 13A2 : 21 63 13                 ld      hl,LOGP           ;[M80] POINT TO P CONSTANTS
13A5 13A5 : CD 46 18                 call    POLY              ;[M80] CALCULATE P(X)
13A8 13A8 : C1                       pop     bc                ;[M80] FETCH X
13A9 13A9 : E1                       pop     hl                ;[M80] PUSHF WOULD ALTER DE
13AA 13AA : CD 13 15                 call    PUSHF             ;[M80] PUSH P(X) ON THE STACK
13AD 13AD : EB                       ex      de,hl             ;[M80] GET LOW BYTES OF X TO (DE)
13AE 13AE : CD 23 15                 call    MOVFR             ;[M80] AND MOVE TO FAC
13B1 13B1 : 21 74 13                 ld      hl,LOGQ           ;[M80] POINT TO Q COEFFICIENTS
13B4 13B4 : CD 46 18                 call    POLY              ;[M80] COMPUTE Q(X)
13B7 13B7 : C1                       pop     bc                ;[M80] FETCH P(X) TO REGISTERS
13B8 13B8 : D1                       pop     de                ;
13B9 13B9 : CD 2F 14                 call    FDIV              ;[M80] CALCULATE P(X)/Q(X)
13BC 13BC : F1                       pop     af                ;[M80] RE-FETCH EXPONENT
13BD 13BD : CD 13 15                 call    PUSHF             ;[M80] SAVE EVALUATION
13C0 13C0 : CD F6 14                 call    FLOAT             ;[M80] FLOAT THE EXPONENT
13C3 13C3 : C1                       pop     bc                ;
13C4 13C4 : D1                       pop     de                ;
13C5 13C5 : C3 61 12                 jp      FADD              ;[M80] GET EVAL. BACK
13C8 13C8                                                      
13C8 13C8                    ;;***Unused code?                 
13C8 13C8                    ;;;IMULT in [M80] fell into here  
13C8 13C8 : 21                       byte    $21               ;;[LD HL.] to skip next two instructions
13C9 13C9 : C1         (M80) FMULTT: pop     bc                ;[M80] GET FIRST ARGUMENT OFF STACK, ENTRY FROM POLYX
13CA 13CA : D1                       pop     de              
13CB 13CB
13CB 13CB -                + ;[M80] MULTIPLICATION           FAC:=ARG*FAC
13CB 13CB                  | ;[M80] ALTERS A,B,C,D,E,H,L
13CB 13CB                  | ;
13CB 13CB                  | ;[M80] THE PRODUCT WILL BE FORMED IN C,D,E,B. THIS WILL BE IN C,H,L,B PART OF THE
13CB 13CB                  | ;[M80] TIME IN ORDER TO USE THE "DAD" INSTRUCTION.  AT FMULT2, WE GET THE NEXT
13CB 13CB                  | ;[M80] BYTE OF THE MANTISSA IN THE FAC TO MULTIPLY BY.  ((HL) POINTS TO IT)
13CB 13CB                  | ;[M80] (THE FMULT2 SUBROUTINE PRESERVES (HL))  IN 8K, IF THE BYTE IS ZERO, WE JUST
13CB 13CB                  | ;[M80] SHIFT THE PRODUCT 8 RIGHT.  THIS BYTE IS THEN SHIFTED RIGHT AND SAVED IN D
13CB 13CB                  | ;[M80] (H IN 4K).  THE CARRY DETERMINES IF WE SHOULD ADD IN THE SECOND FACTOR
13CB 13CB                  | ;[M80] IF WE DO, WE ADD IT TO C,H,L.  B IS ONLY USED TO DETERMINE WHICH WAY WE
13CB 13CB                  | ;[M80] ROUND.  WE THEN SHIFT C,H,L,B (C,D,E,B) IN 4K RIGHT ONE TO GET READY FOR THE
13CB 13CB                  | ;[M80] NEXT TIME THROUGH THE LOOP.  NOTE THAT THE CARRY IS SHIFTED INTO THE MSB OF
13CB 13CB                  | ;[M80] C.  E HAS A COUNT (L IN 4K) TO DETERMINE WHEN WE HAVE LOOKED AT ALL THE BITS
13CB 13CB                  | ;[M80] OF D (H IN 4K).
13CB 13CB                  | ;                   
13CB 13CB = EF         [M80] FMULT:  rst     FSIGN             ;[M80] CHECK IF FAC IS ZERO
13CC 13CC : C8                       ret     z                 ;[M80] IF IT IS, RESULT IS ZERO
13CD 13CD : 2E 00                    ld      l,0               ;[M80] ADD THE TWO EXPONENTS, L IS A FLAG
13CF 13CF : CD AC 14                 call    MULDIV            ;[M80] FIX UP THE EXPONENTS
13D2 13D2                  - ;[M80] SAVE THE NUMBER IN THE REGISTERS SO WE CAN ADD IT FAST
13D2 13D2 : 79                       ld      a,c               ;[M80] GET HO
13D3 13D3 : 32 F6 38                 ld      (RESHO),a         ;[M80] STORE HO OF REGISTERS
13D6 13D6 : EB                       ex      de,hl             ;[M80] STORE THE TWO LO'S OF THE REGISTERS
13D7 13D7 : 22 F7 38                 ld      (RESMO),hl        ;
13DA 13DA : 01 00 00                 ld      bc,0              ;[M80] ZERO THE PRODUCT REGISTERS
13DD 13DD : 50                       ld      d,b               ;
13DE 13DE : 58                       ld      e,b               ;
13DF 13DF : 21 B0 12                 ld      hl,NORMAL         ;
13E2 13E2 : E5                       push    hl                ;[M80]  ON THE STACK
13E3 13E3 : 21 EB 13                 ld      hl,FMULT2         ;[M80] PUT FMULT2 ON THE STACK TWICE, SO AFTER
13E6 13E6 : E5                       push    hl                ;[M80]  WE MULTIPLY BY THE LO BYTE, WE WILL
13E7 13E7 : E5                       push    hl                ;[M80]  MULTIPLY BY THE MO AND HO
13E8 13E8 : 21 E4 38                 ld      hl,FACLO          ;[M80] GET ADDRESS OF LO OF FAC
13EB 13EB : 7E         (M80) FMULT2: ld      a,(hl)            ;[M80] GET BYTE TO MULTIPLY BY
13EC 13EC : 23                       inc     hl                ;[M80] MOVE POINTER TO NEXT BYTE
13ED 13ED : B7                       or      a                 ;
13EE 13EE : 28 2C                    jr      z,FMULT3          ;[M80] ARE WE MULTIPLYING BY ZERO?
13F0 13F0 : E5                       push    hl                ;[M80] SAVE POINTER
13F1 13F1 : 2E 08                    ld      l,8               ;[M80] SET UP A COUNT
13F3 13F3 : 1F         (M80) FMULT4: rra                       ;[M80] ROTATE BYTE RIGHT
13F4 13F4 : 67                       ld      h,a               ;[M80] SAVE IT
13F5 13F5 : 79                       ld      a,c               ;[M80] GET HO
13F6 13F6 : 30 0B                    jr      nc,FMULT5         ;[M80] DON'T ADD IN NUMBER IF BIT WAS ZERO
13F8 13F8 : E5                       push    hl                ;[M80] SAVE COUNTERS
13F9 13F9 : 2A F7 38                 ld      hl,(RESMO)
13FC 13FC : 19                       add     hl,de
13FD 13FD : EB                       ex      de,hl
13FE 13FE : E1                       pop     hl
13FF 13FF : 3A F6 38                 ld      a,(RESHO)
1402 1402 : 89                       adc     a,c
1403 1403 : 1F         (M80) FMULT5: rra                       ;[M80] ROTATE RESULT RIGHT ONE
1404 1404 : 4F                       ld      c,a               ;
1405 1405 : 7A                       ld      a,d               ;[M80] ROTATE NEXT BYTE
1406 1406 : 1F                       rra                       ;
1407 1407 : 57                       ld      d,a               ;
1408 1408 : 7B                       ld      a,e               ;[M80] ROTATE NEXT LOWER ORDER
1409 1409 : 1F                       rra                       ;
140A 140A : 5F                       ld      e,a               ;
140B 140B : 78                       ld      a,b               ;[M80] ROTATE LO
140C 140C : 1F                       rra                       ;
140D 140D : 47                       ld      b,a               ;
140E 140E : E6 10                    and     010H              ;[M80] SEE IF WE ROTATED THRU ST
1410 1410 : 28 04                    jr      z,FML5B1          ;[M80] IF NOT DON'T WORRY
1412 1412 : 78                       ld      a,b               ;[M80] RE FETCH LO
1413 1413 : F6 20                    or      020H              ;[M80] "OR" IN STICKY
1415 1415 : 47                       ld      b,a               ;[M80] BACK TO LO
1416 1416 : 2D               FML5B1: dec     l                 ;[M80] ARE WE DONE?
1417 1417 : 7C                       ld      a,h               ;[M80] GET NUMBER WE ARE MULTIPLYING BY
1418 1418 : 20 D9                    jr      nz,FMULT4         ;[M80] MULTIPLY AGAIN IF WE ARE NOT DONE
141A 141A -                  ;;Pop [HL] and Return             
141A 141A = E1         [M80] POPHRT: pop     hl                ;[M80] GET POINTER TO NUMBER TO MULTIPLY BY
141B 141B : C9                       ret                       ;[M80] ALL DONE
141C 141C : 43         [M80] FMULT3: ld      b,e               ;[M80] MULTIPLY BY ZERO: SHIFT EVERYTHING 8 RIGHT
141D 141D : 5A                       ld      e,d               ;
141E 141E : 51                       ld      d,c               ;
141F 141F : 4F                       ld      c,a               ;[M80] SHIFT IN 8 ZEROS ON THE LEFT
1420 1420 : C9                       ret                       ;[M80] ALL DONE
1421 1421                                                      
1421 1421                  + ;[M80]  DIVIDE FAC BY 10          
1421 1421                  - ;[M80]  ALTERS A,B,C,D,E,H,L      
1421 1421 : CD 13 15   [M80] DIV10:  call    PUSHF             ;[M80] WE HAVE TO DIVIDE -- SAVE COUNT
1424 1424 : 01 20 84                 ld      bc,$8420          ;[M80] 10.0
1427 1427 : 11 00 00                 ld      de,$0000          
142A 142A : CD 23 15                 call    MOVFR             ;[M80] MOVE TEN INTO THE FAC
142D 142D : C1         [M80] FDIVT:  pop     bc                ;[F80] GET NUMBER BACK IN REGISTERS
142E 142E : D1                       pop     de                ;[F80] FALL INTO DIVIDE AND WE ARE DONE
142F 142F
142F 142F -                  ;[M80] DIVISION       FAC:=ARG/FAC
142F 142F                    ;[M80] ALTERS A,B,C,D,E,H,L
142F 142F = EF         [M80] FDIV:   rst     FSIGN             ;[M80] CHECK FOR DIVISION BY ZERO
1430 1430 : CA C7 03                 jp      z,DV0ERR          ;[M80] DON'T ALLOW DIVIDE BY ZERO
1433 1433 : 2E FF                    ld      l,255             ;[M80] SUBTRACT THE TWO EXPONENTS, L IS A FLAG
1435 1435 : CD AC 14                 call    MULDIV            ;[M80] FIX UP THE EXPONENTS AND THINGS
1438 1438 : 34                       inc     (hl)              
1439 1439 : CA D3 03                 jp      z,OVERR           ;[M80] OVERFLOW
143C 143C : 34                       inc     (hl)              
143D 143D : CA D3 03                 jp      z,OVERR           ;[M80] OVERFLOW
1440 1440                  - ;[M80] HERE WE SAVE THE FAC IN MEMORY SO WE CAN SUBTRACT IT FROM THE NUMBER
1440 1440                  - ;[M80] IN THE REGISTERS QUICKLY.
1440 1440 : 2B                       dec     hl                ;[M80] POINT TO HO
1441 1441 : 7E                       ld      a,(hl)            ;[M80] GET HO
1442 1442 : 32 19 38                 ld      (FDIVA+1),a       ;[M80] SAVE IT
1445 1445 : 2B                       dec     hl                ;[M80] SAVE MIDDLE ORDER
1446 1446 : 7E                       ld      a,(hl)            
1447 1447 : 32 15 38                 ld      (FDIVB+1),a       ;[M80] PUT IT WHERE NOTHING WILL HURT IT
144A 144A : 2B                       dec     hl                ;[M80] SAVE LO
144B 144B : 7E                       ld      a,(hl)
144C 144C : 32 11 38                 ld      (FDIVC+1),a
144F 144F                  - ;[M80] THE NUMERATOR WILL BE KEPT IN B,H,L.  THE QUOTIENT WILL BE FORMED IN C,D,E.
144F 144F                  | ;[M80] TO GET A BIT OF THE QUOTIENT, WE FIRST SAVE B,H,L ON THE STACK, THEN
144F 144F                  | ;[M80] SUBTRACT THE DENOMINATOR THAT WE SAVED IN MEMORY.  THE CARRY INDICATES
144F 144F                  | ;[M80] WHETHER OR NOT B,H,L WAS BIGGER THAN THE DENOMINATOR.  IF B,H,L WAS BIGGER,
144F 144F                  | ;[M80] THE NEXT BIT OF THE QUOTIENT IS A ONE.  TO GET THE OLD B,H,L OFF THE STACK,
144F 144F                  | ;[M80] WE POP THEM INTO THE PSW.  IF THE DENOMINATOR WAS BIGGER, THE NEXT BIT OF
144F 144F                  | ;[M80] THE QUOTIENT IS ZERO, AND WE GET THE OLD B,H,L BACK BY POPPING IT OFF THE
144F 144F                  | ;[M80] STACK.  WE HAVE TO KEEP AN EXTRA BIT OF THE QUOTIENT IN FDIVG+1 IN CASE THE
144F 144F                  | ;[M80] DENOMINATOR WAS BIGGER,  THEN B,H,L WILL GET SHIFTED LEFT.  IF THE MSB  OF
144F 144F                  | ;[M80] B WAS ONE, IT HAS TO BE STORED SOMEWHERE, SO WE STORE IT IN FDIVG+1.  THEN
144F 144F                  | ;[M80] THE NEXT TIME THROUGH THE LOOP B,H,L WILL LOOK BIGGER BECAUSE IT HAS AN
144F 144F                  | ;[M80] EXTRA HO BIT IN FDIVG+1. WE ARE DONE DIVIDING WHEN THE MSB OF C IS A ONE.
144F 144F                  | ;[M80] THIS OCCURS WHEN WE HAVE CALCULATED 24 BITS OF THE QUOTIENT.  WHEN WE JUMP
144F 144F                  | ;[M80] TO ROUND, THE 25TH BIT OF THE QUOTIENT DETERMINES WHETHER WE ROUND OR NOT.
144F 144F                  | ;[M80] IT IS IN THE MSB OF A.  IF INITIALLY THE DENOMINATOR IS BIGGER THAN THE
144F 144F                  | ;[M80] NUMERATOR, THE FIRST BIT OF THE QUOTIENT WILL BE ZERO.  THIS MEANS WE
144F 144F                  | ;[M80] WILL GO THROUGH THE DIVIDE LOOP 26 TIMES, SINCE IT STOPS ON THE 25TH BIT
144F 144F                  | ;[M80] AFTER THE FIRST NON-ZERO BIT OF THE QUOTIENT.  SO, THIS QUOTIENT WILL LOOK
144F 144F                  | ;[M80] SHIFTED LEFT ONE FROM THE QUOTIENT OF TWO NUMBERS IN WHICH THE NUMERATOR IS
144F 144F                  | ;[M80] BIGGER.  THIS CAN ONLY OCCUR ON THE FIRST TIME THROUGH THE LOOP, SO C,D,E
144F 144F                  | ;[M80] ARE ALL ZERO.  SO, IF WE FINISH THE LOOP AND C,D,E ARE ALL ZERO, THEN WE
144F 144F                  | ;[M80] MUST DECREMENT THE EXPONENT TO CORRECT FOR THIS.
144F 144F : 41                       ld      b,c               ;[M80] GET NUMBER IN B,H,L
1450 1450 : EB                       ex      de,hl             
1451 1451 : AF                       xor     a                 ;[M80] ZERO C,D,E AND HIGHEST ORDER
1452 1452 : 4F                       ld      c,a               
1453 1453 : 57                       ld      d,a               
1454 1454 : 5F                       ld      e,a               
1455 1455 : 32 1C 38                 ld      (FDIVG+1),a       
1458 1458 : E5         [M80] FDIV1:  push    hl                ;[M80] SAVE LO'S OF NUMBER              
1459 1459 : C5                       push    bc                ;[M80] SAVE HO OF NUMBER
145A 145A : 7D                       ld      a,l               ;[M80] SUBTRACT NUMBER THAT WAS IN FAC
145B 145B : CD 10 38                 call    FDIVC             ;;Call Divide Routine in RAM for apeed
145E 145E : DE 00                    sbc     a,0               ;[M80] SUBTRACT LO
1460 1460 : 3F                       ccf                       ;[M80] SET CARRY TO CORESPOND TO NEXT QUOTIENT BIT
1461 1461 : 30 07                    jr      nc,FDIV2          ;[M80] GET OLD NUMBER BACK IF WE SUBTRACTED TOO MUCH
1463 1463 : 32 1C 38                 ld      (FDIVG+1),a       ;[M80] UPDATE HIGHEST ORDER
1466 1466 : F1                       pop     af                ;[M80] THE SUBTRACTION WAS GOOD
1467 1467 : F1                       pop     af                ;[M80] GET PREVIOUS NUMBER OFF STACK
1468 1468 : 37                       scf                       ;[M80] NEXT BIT IN QUOTIENT IS A ONE
1469 1469 : D2                       byte    $D2               ;[M80] "JNC" AROUND NEXT 2 BYTES
146A 146A : C1         (M80) FDIV2:  pop     bc                ;[M80] WE SUBTRACTED TOO MUCH
146B 146B : E1                       pop     hl                ;[M80] GET OLD NUMBER BACK
146C 146C : 79                       ld      a,c               ;[M80] ARE WE DONE?
146D 146D : 3C                       inc     a                 ;[M80] SET SIGN FLAG WITHOUT AFFECTING CARRY
146E 146E : 3D                       dec     a                 
146F 146F : 1F                       rra                       ;[M80]PUT CARRY IN MSB
1470 1470 : F2 87 14                 jp      p,DIV2A           ;[M80]NOT READY TO ROUND YET
1473 1473 : 17                       rla                       ;[M80]BIT BACK TO CARRY
1474 1474 : 3A 1C 38                 ld      a,(FDIVG+1)       ;[M80]FETCH EXTRA BIT
1477 1477 : 1F                       rra                       ;[M80]BOTH NOW IN A
1478 1478 : E6 C0                    and     $C0               ;[M80]CLEAR SUPERFLUOUS BITS
147A 147A : F5                       push    af                ;[M80]SAVE FOR LATER
147B 147B : 78                       ld      a,b               ;[M80]FETCH HO OF REMAINDER
147C 147C : B4                       or      h                 ;[M80]FETCH HO
147D 147D : B5                       or      l                 ;[M80]SEE IF OTHER REMAINDER BITS AND IF SO SET ST
147E 147E : 28 02                    jr      z,DIV2AA          ;[M80]IF NOT IGNORE
1480 1480 : 3E 20                    ld      a,$20             ;[M80]ST BIT
1482 1482 : E1         (M80) DIV2AA: pop     hl                ;[M80]AND THE REST OF REMAINDER
1483 1483 : B4                       or      h                 ;[M80]"OR" IN REST
1484 1484 : C3 F2 12                 jp      ROUNDB            ;[M80]USE REMAINDER
1487 1487 : 17         (M80) DIV2A:  rla                       ;[M80]WE AREN'T, GET OLD CARRY BACK
1488 1488 : 7B                       ld      a,e               ;[M80]ROTATE EVERYTHING LEFT ONE
1489 1489 : 17                       rla                       ;[M80]ROTATE NEXT BIT OF QUOTIENT IN
148A 148A : 5F                       ld      e,a               
148B 148B : 7A                       ld      a,d               
148C 148C : 17                       rla                       
148D 148D : 57                       ld      d,a               
148E 148E : 79                       ld      a,c               
148F 148F : 17                       rla                       
1490 1490 : 4F                       ld      c,a               
1491 1491 : 29                       add     hl,hl             ;[M80] ROTATE A ZERO INTO RIGHT END OF NUMBER
1492 1492 : 78                       ld      a,b               ;[M80] THE HO BYTE, FINALLY!
1493 1493 : 17         {M80} FDIV2A: rla                       
1494 1494 : 47                       ld      b,a               
1495 1495 : 3A 1C 38   {M80} FDIV2B: ld      a,(FDIVG+1)       
1498 1498 : 17                       rla                       
1499 1499 : 32 1C 38                 ld      (FDIVG+1),a       
149C 149C : 79                       ld      a,c               ;[M80] ADD ONE TO EXPONENT IF THE FIRST SUBTRACTION
149D 149D : B2                       or      d                 ;[M80]  DID NOT WORK
149E 149E : B3                       or      e                 
149F 149F : 20 B7                    jr      nz,FDIV1          ;[M80] THIS ISN'T THE CASE        
14A1 14A1 : E5                       push    hl                ;[M80] SAVE PART OF NUMBER
14A2 14A2 : 21 E7 38                 ld      hl,FAC            ;[M80] GET POINTER TO FAC
14A5 14A5 : 35                       dec     (hl)              ;[M80] DECREMENT EXPONENT
14A6 14A6 : E1                       pop     hl                ;[M80] GET NUMBER BACK
14A7 14A7 : 20 AF                    jr      nz,FDIV1          ;[M80] DIVIDE MORE IF NO OVERFLOW OCCURED
14A9 14A9 : C3 C3 12                 jp      ZERO              ;[M80] UNDERFLOW!!
14AC 14AC
14AC 14AC                  + ;[M80] CHECK SPECIAL CASES AND ADD EXPONENTS FOR FMULT, FDIV
14AC 14AC                  | ;[M80] ALTERS A,B,H,L
14AC 14AC                  | ;
14AC 14AC : 78         [M80] MULDIV: ld      a,b               ;[M80] IS NUMBER IN REGISTERS ZERO?
14AD 14AD : B7                       or      a                 
14AE 14AE : 28 1D                    jr      z,MULDV2          ;[M80] IT IS, ZERO FAC AND WE ARE DONE
14B0 14B0 : 7D                       ld      a,l               ;[M80] GET ADD OR SUBTRACT FLAG
14B1 14B1 : 21 E7 38                 ld      hl,FAC            ;[M80] GET POINTER TO EXPONENT
14B4 14B4 : AE                       xor     (hl)              ;[M80] GET EXPONENT
14B5 14B5 : 80                       add     a,b               ;[M80] ADD IN REGISTER EXPONENT
14B6 14B6 : 47                       ld      b,a               ;[M80] SAVE IT
14B7 14B7 : 1F                       rra                       ;[M80] CHECK FOR OVERFLOW
14B8 14B8 : A8                       xor     b                 ;[M80] OVERFLOW IF SIGN IS THE SAME AS CARRY
14B9 14B9 : 78                       ld      a,b               ;[M80] GET SUM
14BA 14BA : F2 CC 14                 jp      p,MULDV1          ;[M80] WE HAVE OVERFLOW!!
14BD 14BD : C6 80                    add     a,$80             ;{M80} PUT EXPONENT IN EXCESS 128
14BF 14BF : 77                       ld      (hl),a            ;[M80] SAVE IT IN THE FAC
14C0 14C0 : CA 1A 14                 jp      z,POPHRT          ;[M80] WE HAVE UNDEFLOW!! RETURN.
14C3 14C3 : CD 46 15                 call    UNPACK            ;[M80] UNPACK THE ARGUMENTS
14C6 14C6 : 77                       ld      (hl),a            ;[M80] SAVE THE NEW SIGN
14C7 14C7 : 2B         {M80} DCXHRT: dec     hl                ;[M80] POINT TO EXPONENT
14C8 14C8 : C9                       ret                       ;[M80] ALL DONE, LEAVE HO IN A
14C8 14C8                                                      
14C9 14C9 : EF         {M80} MLDVEX: rst     FSIGN             ;[M80] ENTRY FROM EXP, PICK UNDERFLOW IF NEGATIVE
14CA 14CA : 2F                       cpl                       ;[M80] PICK OVERFLOW IF POSITIVE
14CB 14CB : E1                       pop     hl                ;[M80] DON'T SCREW UP STACK
14CC 14CC : B7         [M80] MULDV1: or      a                 ;[M80] IS ERROR OVERFLOW OR UNDEFLOW?
14CD 14CD : E1         [M80] MULDV2: pop     hl                ;[M80] GET OLD RETURN ADDRESS OFF STACK
14CE 14CE : F2 C3 12                 jp      p,ZERO            
14D1 14D1 : C3 D3 03                 jp      OVERR             ;[M80] OVERFLOW
14D4 14D4                                                      
14D4 14D4                  + ;[M80] MULTIPLY FAC BY 10         
14D4 14D4                  | ;[M80] ALTERS A,B,C,D,E,H,L       
14D4 14D4 : CD 2E 15   [M80] MUL10:  call    MOVRF             ;[M80] GET NUMBER IN REGISTERS
14D7 14D7 : 78                       ld      a,b               ;[M80] GET EXPONENT
14D8 14D8 : B7                       or      a                 ;[M80] RESULT IS ZERO IF ARG IS ZERO
14D9 14D9 : C8                       ret     z                 ;[M80] IT IS
14DA 14DA : C6 02                    add     a,2               ;[M80] MULTIPLY BY 4 BY ADDING 2 TO EXPONENT
14DC 14DC : DA D3 03                 jp      c,OVERR           ;{M80} OVERFLOW
14DF 14DF : 47                       ld      b,a               ;[M80] RESTORE EXPONENT
14E0 14E0 : CD 61 12                 call    FADD              ;[M80] ADD IN ORIGINAL NUMBER TO GET 5 TIMES IT
14E3 14E3 : 21 E7 38                 ld      hl,FAC            ;[M80] ADD 1 TO EXPONENT TO MULTIPLY NUMBER BY
14E6 14E6 : 34                       inc     (hl)              ;[M80]  2 TO GET 10 TIMES ORIGINAL NUMBER
14E7 14E7 : C0                       ret     nz                ;[M80] ALL DONE IF NO OVERFLOW
14E8 14E8 : C3 D3 03                 jp      OVERR             ;{M80} OVERFLOW
14EB 14EB                                                      
14EB 14EB                    ;;Jumped to from FSIGN            
14EB 14EB : 3A E6 38   [M80] SIGNC:  ld      a,(FACHO)         ;[M80] GET SIGN OF FACHO, IT IS NON-ZERO
14EE 14EE : FE                       byte    $FE               ;"CP" AROUND NEXT BYTE
14EF 14EF : 2F         [M80] FCOMPS: cpl                       ;ENTRY FROM FCOMP, COMPLEMENT SIGN
14F0 14F0 : 17         (M80) ICOMPS: rla                       ;ENTRY FROM ICOMP, PUT SIGN BIT IN CARRY
14F1 14F1 : 9F         [M80] SIGNS:  sbc     a,a               ;A=0 IF CARRY WAS 0, A=377 IF CARRY WAS 1
14F2 14F2 : C0                       ret     nz                ;RETURN IF NUMBER WAS NEGATIVE
14F3 14F3 : 3C         (M80) INRART: inc     a                 ;PUT ONE IN A IF NUMBER WAS POSITIVE
14F4 14F4 : C9                       ret                       ;ALL DONE
14F5 14F5                                                      
14F5 14F5                    ;;The SGN() Function              
14F5 14F5 : EF               SGN:    rst     FSIGN             ;;Get sign of FAC
14F614F6
14F6 14F6                  + ;[M80] FLOAT THE SIGNED INTEGER IN A
14F6 14F6                  | ;[M80] ALTERS A,B,C,D,E,H,L
14F6 14F6 : 06 88      [M80] FLOAT:  ld      b,$88             ;[M80] SET EXPONENT CORRECTLY
14F8 14F8 : 11 00 00                 ld      de,0              ;[M80] ZERO D,E
14FB14FB
14FB 14FB                  + ;[M80] FLOAT THE SIGNED NUMBER IN B,A,D,E
14FB 14FB                  | ;[M80] ALTERS A,B,C,D,E,H,L
14FB 14FB : 21 E7 38   [M80] FLOATR: ld      hl,FAC            ;[M80] GET POINTER TO FAC
14FE 14FE : 4F                       ld      c,a               ;[M80] PUT HO IN C
14FF 14FF : 70                       ld      (hl),b            ;[M80] PUT EXPONENT IN THE FAC
1500 1500 : 06 00                    ld      b,0               ;[M80] ZERO OVERFLOW BYTE
1502 1502 : 23                       inc     hl                ;[M80] POINT TO SIGN
1503 1503 : 36 80                    ld      (hl),128          ;[M80] ASSUME A POSITIVE NUMBER
1505 1505 : 17                       rla                       ;[M80] PUT SIGN IN CARRY
1506 1506 : C3 AD 12                 jp      FADFLT            ;[M80] GO AND FLOAT THE NUMBER
1509 1509
1509 1509                    ;[M80] ABSOLUTE VALUE OF FAC
1509 1509 : EF         [M80] ABS:    rst     FSIGN             ;[M80] GET THE SIGN OF THE FAC IN A
150A 150A : F0                       ret     p                 ;[M80] IF IT IS POSITIVE, WE ARE DONE
150B 150B
150B 150B -                  ;[M80] NEGATE ANY TYPE VALUE IN THE FAC             
150B 150B = 21 E6 38   [M80] NEG:    ld      hl,FACHO          ;[M80[ GET POINTER TO SIGN
150E 150E : 7E                       ld      a,(hl)            ;[M80[ GET SIGN
150F 150F : EE 80                    xor     $80               ;[M80[ COMPLEMENT SIGN BIT
1511 1511 : 77                       ld      (hl),a            ;[M80[ SAVE IT
1512 1512 : C9                       ret                       ;[M80[ ALL DONE
1513 1513
1513 1513 -                  ;[M80] PUT FAC ON STACK, ALTERS D,E 
1513 1513 = EB         [M80] PUSHF:  ex      de,hl             ;[M80] SAVE (HL)
1514 1514 : 2A E4 38                 ld      hl,(FACLO)        ;[M80] GET LO'S
1517 1517 : E3                       ex      (sp),hl           ;[M80] SWITCH LO'S AND RET ADDR
1518 1518 : E5                       push    hl                ;[M80] PUT RET ADDR BACK ON STACK
1519 1519 : 2A E6 38                 ld      hl,(FACHO)        ;[M80] GET HO'S
151C 151C : E3                       ex      (sp),hl           ;[M80] SWITCH HO'S AND RET ADDR
151D 151D : E5                       push    hl                ;[M80] PUT RET ADDR BACK ON STACK
151E 151E : EB                       ex      de,hl             ;[M80] GET OLD (HL) BACK
151F 151F : C9                       ret                       ;[M80] ALL DONE
1520 1520                                                      
1520 1520 : CD 31 15   [M80] MOVFM:  call    MOVRM             ;[M80] MOVE NUMBER FROM MEMORY [(HL)] TO FAC
1523 1523 : EB         [M80] MOVFR:  ex      de,hl             ;[M80] MOVE REGISTERS (B,C,D,E) TO FAC
1524 1524 : 22 E4 38                 ld      (FACLO),hl        ;[M80] PUT THEM WHERE THEY BELONG
1527 1527 : 60                       ld      h,b               ;[M80] GET HO'S IN (HL)
1528 1528 : 69                       ld      l,c               ;
1529 1529 : 22 E6 38                 ld      (FACHO),hl        ;[M80] PUT HO'S WHERE THEY BELONG
152C 152C : EB                       ex      de,hl             ;[M80] GET OLD (HL) BACK
152D 152D : C9                       ret                       ;[M80] ALL DONE
152E 152E                                                      
152E 152E : 21 E4 38   [M80] MOVRF:  ld      hl,FACLO          ;[M80] MOVE FAC TO REGISTERS (B,C,D,E)
1531 1531 = 5E         [M80] MOVRM:  ld      e,(hl)            ;[M80] GET NUMBER IN REGISTERS (B,C,D,E) FROM MEMORY [(HL)]
1532 1532 : 23                       inc     hl                ;[M80] POINT TO MO
1533 1533 : 56                       ld      d,(hl)            ;[M80] GET MO, ENTRY FOR BILL
1534 1534 : 23                       inc     hl                ;[M80] POINT TO HO
1535 1535 : 4E                       ld      c,(hl)            ;[M80] GET HO
1536 1536 : 23                       inc     hl                ;[M80] POINT TO EXPONENT
1537 1537 : 46                       ld      b,(hl)            ;[M80] GET EXPONENT
1538 1538 : 23         [M80] INXHRT: inc     hl                ;[M80] INC POINTER TO BEGINNING OF NEXT NUMBER
1539 1539 : C9                       ret                       ;[M80] ALL DONE
153A 153A
153A 153A -                + ;[M80] MOVE NUMBER FROM FAC TO MEMORY [(HL)]
153A 153A                  | ;[M80] ALTERS A,B,D,E,H,L
153A 153A = 11 E4 38   [M80] MOVMF:  ld      de,FACLO          ;GET POINTER TO FAC
153D 153D
153D 153D                  + ;[M80] MOVE NUMBER FROM (DE) TO (HL)
153D 153D                  | ;[M80] ALTERS A,B,D,E,H,L
153D 153D                  | ;[M80] EXITS WITH (DE):=(DE)+4, (HL):=(HL)+4
153D 153D : 06 04      [M80] MOVE:   ld      b,4               ;[M80] SET COUNTER
153F 153F : 1A         (M80) MOVE1:  ld      a,(de)            ;[M80] GET WORD
1540 1540 : 77                       ld      (hl),a            ;[M80] PUT IT WHERE IT BELONGS
1541 1541 : 13                       inc     de                ;[M80] INCREMENT POINTERS TO NEXT WORD
1542 1542 : 23                       inc     hl
1543 1543 : 10 FA                    djnz    MOVE1
1545 1545 : C9                       ret
1546 1546
1546 1546                  + ;[M80] UNPACK THE FAC AND THE REGISTERS
1546 1546                  | ;[M80] ALTERS A,C,H,L
1546 1546                  | ;[M80] WHEN THE NUMBER IN THE FAC IS UNACKED, THE ASSUMED ONE IN THE
1546 1546                  | ;[M80] MANTISSA IS RESTORED, AND THE COMPLEMENT OF THE SIGN IS PLACED
1546 1546                  | ;[M80] IN FAC+1
1546 1546 : 21 E6 38   [M80] UNPACK: ld      hl,FACHO          ;[M80] POINT TO HO AND SIGN
1549 1549 : 7E                       ld      a,(hl)            ;[M80] GET HO AND SIGN
154A 154A : 07                       rlca                      ;[M80] DUPLICATE THE SIGN IN CARRY AND THE LSB
154B 154B : 37                       scf                       ;[M80] RESTORE THE HIDDEN ONE
154C 154C : 1F                       rra                       ;[M80] RESTORE THE NUMBER IN A
154D 154D : 77                       ld      (hl),a            ;[M80] SAVE HO
154E 154E : 3F                       ccf                       ;[M80] GET THE COMPLEMENT OF THE SIGN
154F 154F : 1F                       rra                       ;[M80] GET IT IN THE SIGN BIT
1550 1550 : 23                       inc     hl                ;[M80] POINT TO TEMPORARY SIGN BYTE
1551 1551 : 23                       inc     hl                
1552 1552 : 77                       ld      (hl),a            ;[M80] SAVE COMPLEMENT OF SIGN
1553 1553 : 79                       ld      a,c               ;[M80] GET HO AND SIGN OF THE REGISTERS
1554 1554 : 07                       rlca                      ;[M80] DUPLICATE THE SIGN IN CARRY AND THE LSB
1555 1555 : 37                       scf                       ;[M80] RESTORE THE HIDDEN ONE
1556 1556 : 1F                       rra                       ;[M80] RESTORE THE HO IN A
1557 1557 : 4F                       ld      c,a               ;[M80] SAVE THE HO
1558 1558 : 1F                       rra                       ;[M80] GET THE SIGN BACK
1559 1559 : AE                       xor     (hl)              ;[M80] COMPARE SIGN OF FAC AND SIGN OF REGISTERS
155A 155A : C9                       ret                       ;[M80] ALL DONE
155B 155B
155B 155B -                + ;[M80] COMPARE TWO NUMBERS
155B 155B                  | ;[M80] A=1 IF ARG .LT. FAC
155B 155B                  | ;[M80] A=0 IF ARG=FAC
155B 155B                  | ;[M80] A=-1 IF ARG .GT. FAC
155B 155B                  | ;[M80] DOREL DEPENDS UPON THE FACT THAT FCOMP RETURNS WITH CARRY ON
155B 155B                  | ;{M80}  IFF A HAS $7F
155B 155B                  | ;[M80] ALTERS A,H,L
155B 155B                  | ;
155B 155B = 78         [M80] FCOMP:  ld      a,b               ;[M80] CHECK IF ARG IS ZERO
155C 155C : B7                       or      a                 ;
155D 155D : CA 28 00                 jp      z,FSIGN           ;
1560 1560 : 21 EF 14                 ld      hl,FCOMPS         ;[M80] WE JUMP TO FCOMPS WHEN WE ARE DONE
1563 1563 : E5                       push    hl                ;[M80] PUT THE ADDRESS ON THE STACK
1564 1564 : EF                       rst     FSIGN             ;[M80] CHECK IF FAC IS ZERO
1565 1565 : 79                       ld      a,c               ;[M80] IF IT IS, RESULT IS MINUS THE SIGN OF ARG
1566 1566 : C8                       ret     z                 ;[M80] IT IS
1567 1567 : 21 E6 38                 ld      hl,FACHO          ;[M80] POINT TO SIGN OF FAC
156A 156A : AE                       xor     (hl)              ;[M80] SEE IF THE SIGNS ARE THE SAME
156B 156B : 79                       ld      a,c               ;[M80] IF THEY ARE DIFFERENT, RESULT IS SIGN OF ARG
156C 156C : F8                       ret     m                 ;[M80] THEY ARE DIFFERENT
156D 156D : CD 73 15                 call    FCOMP2            ;[M80] CHECK THE REST OF THE NUMBER
1570 1570 : 1F         {M80} FCOMPD: rra                       ;[M80] NUMBERS ARE DIFFERENT, CHANGE SIGN IF
1571 1571 : A9                       xor     c                 ;[M80]  BOTH NUMBERS ARE NEGATIVE
1572 1572 : C9                       ret                       ;[M80] GO SET UP A
1573 1573 : 23         (M80) FCOMP2: inc     hl                ;POINT TO EXPONENT
1574 1574 : 78                       ld      a,b               ;GET EXPONENT OF ARG
1575 1575 : BE                       cp      (hl)              ;COMPARE THE TWO
1576 1576 : C0                       ret     nz                ;NUMBERS ARE DIFFERENT
1577 1577 : 2B                       dec     hl                ;POINT TO HO
1578 1578 : 79                       ld      a,c               ;GET HO OF ARG
1579 1579 : BE                       cp      (hl)              ;COMPARE WITH HO OF FAC
157A 157A : C0                       ret     nz                ;THEY ARE DIFFERENT
157B 157B : 2B                       dec     hl                ;POINT TO MO OF FAC
157C 157C : 7A                       ld      a,d               ;GET MO OF ARG
157D 157D : BE                       cp      (hl)              ;COMPARE WITH MO OF FAC
157E 157E : C0                       ret     nz                ;THE NUMBERS ARE DIFFERENT
157F 157F : 2B                       dec     hl                ;POINT TO LO OF FAC
1580 1580 : 7B                       ld      a,e               ;GET LO OF ARG
1581 1581 : 96                       sub     (hl)              ;SUBTRACT LO OF FAC
1582 1582 : C0                       ret     nz                ;NUMBERS ARE DIFFERENT
1583 1583 : E1                       pop     hl                ;NUMBERS ARE THE SAME, DON'T SCREW UP STACK
1584 1584 : E1                       pop     hl                ;
1585 1585 : C9                       ret                       ;ALL DONE
1586 1586
1586 1586                  + ;[M80] QUICK GREATEST INTEGER FUNCTION 
1586 1586                  | ;[M80] LEAVES INT(FAC) IN C,D,E (SIGNED) ALTERS A,B,C,D,E 
1586 1586                  | ;[M80] ASSUMES THE EXPONENT OF FAC IS IN A AND FAC .LT. 2^23 = 8388608
1586 1586                  | ;[M80] 
1586 1586                  | ;[M80] THE HARD CASE IN QINT IS NEGATIVE NON-INTEGERS.  TO HANDLE THIS, IF THE
1586 1586                  | ;[M80] NUMBER IS NEGATIVE, WE REGARD THE 3-BYTE MANTISSA AS A 3-BYTE INTEGER AND
1586 1586                  | ;[M80] SUBTARCT ONE.  THEN ALL THE FRACTIONAL BITS ARE SHIFTED OUT BY SHIFTING THE
1586 1586                  | ;[M80] MANTISSA RIGHT.  THEN, IF THE NUMBER WAS NEGATIVE, WE ADD ONE.  SO, IF WE
1586 1586                  | ;[M80] HAD A NEGATIVE INTEGER, ALL THE BITS TO THE RIGHT OF THE BINARY POINT WERE
1586 1586                  | ;[M80] ZERO.  SO THE NET EFFECT IS WE HAVE THE ORIGINAL NUMBER IN C,D,E.  IF THE
1586 1586                  | ;[M80] NUMBER WAS A NEGATIVE NON-INTEGER, THERE IS AT LEAST ONE NON-ZERO BIT TO THE
1586 1586                  | ;[M80] RIGHT OF THE BINARY POINT.  SO THE NET EFFECT IS THAT WE GET THE ABSOLUTE
1586 1586                  | ;[M80] VALUE OF INT(FAC) IN C,D,E.  C,D,E IS THEN NEGATED IF THE ORIGINAL NUMBER WAS
1586 1586                  | ;[M80] NEGATIVE SO THE RESULT WILL BE SIGNED.
1586 1586                  | ;
1586 1586 : 47         [M80] QINT:   ld      b,a               ;[M80] ZERO B,C,D,E IN CASE THE NUMBER IS ZERO
1587 1587 : 4F                       ld      c,a               
1588 1588 : 57                       ld      d,a               
1589 1589 : 5F                       ld      e,a               
158A 158A : B7                       or      a                 ;[M80] SET CONDITION CODES
158B 158B : C8                       ret     z                 ;[M80] IT IS ZERO, WE ARE DONE
158C 158C : E5                       push    hl                ;[M80] SAVE (HL)
158D 158D : CD 2E 15                 call    MOVRF             ;[M80] GET NUMBER IN THE REGISTERS
1590 1590 : CD 46 15                 call    UNPACK            ;[M80] UNPACK THE NUMBER
1593 1593 : AE                       xor     (hl)              ;[M80] GET SIGN OF NUMBER
1594 1594 : 67                       ld      h,a               ;[M80] DON'T LOSE IT
1595 1595 : FC AA 15                 call    m,QINTA           ;[M80] SUBTRACT 1 FROM LO IF NUMBER IS NEGATIVE
1598 1598 : 3E 98                    ld      a,$98             ;[M80] SEE HOW MANY WE HAVE TO SHIFT TO CHANGE
159A 159A : 90                       sub     b                 ;[M80]  NUMBER TO AN INTEGER
159B 159B : CD 30 13                 call    SHIFTR            ;[M80] SHIFT NUMBER TO GET RID OF FRACTIONAL BITS           
159E 159E : 7C                       ld      a,h               ;[M80] GET SIGN
159F 159F : 17                       rla                       ;[M80] PUT SIGN IN CARRY SO IT WILL NOT BE CHANGED
15A0 15A0 : DC 03 13                 call    c,ROUNDA          ;[M80] IF NUMBER WAS NEGATIVE, ADD ONE
15A3 15A3 : 06 00                    ld      b,0               ;[M80] FORGET THE BITS WE SHIFTED OUT
15A5 15A5 : DC 1C 13                 call    c,NEGR            ;[M80] NEGATE NUMBER IF IT WAS NEGATIVE
15A8 15A8 : E1                       pop     hl                ;[M80] GET OLD (HL) BACK
15A9 15A9 : C9                       ret                       ;[M80] ALL DONE
;;;The last comment seems to be directed to Bill Gates, most likely from Monte Davidoff,
;;;who wrote the floating point math routines for Altair Basic. 
15AA 15AA : 1B         [M80] QINTA:  dec     de                ;[M80] SUBTRACT ONE FROM C,D,E
15AB 15AB : 7A                       ld      a,d               ;[M80] WE HAVE TO SUBTRACT ONE FROM C IF
15AC 15AC : A3                       and     e                 ;[M80]  D AND E ARE BOTH ALL ONES
15AD 15AD : 3C                       inc     a                 ;[M80] SEE IF BOTH WERE -1
15AE 15AE : C0                       ret     nz                ;[M80] THEY WERE NOT, WE ARE DONE
15AF 15AF : 0B                       dec     bc                ;[M80] THIS IS FOR BILL.  C WILL NEVER BE ZERO
15B0 15B0 : C9                       ret                       ;[M80]  (THE MSB WILL ALWAYS BE ONE) SO "DCX    B"
15B1 15B1                                                      ;[M80] z AND "DCR       C" ARE FUNCTIONALLY EQUIVALENT
15B1 15B1                    ;[M80] GREATEST INTEGER FUNCTION
15B1 15B1 : 21 E7 38   [M80] INT:    ld      hl,FAC            ;[M80] GET EXPONENT
15B4 15B4 : 7E                       ld      a,(hl)            
15B5 15B5 : FE 98                    cp      $98               ;[M80] SEE IF NUMBER HAS ANY FRACTIONAL BITS
15B7 15B7 : 3A E4 38                 ld      a,(FACLO)         ;[M80] THE ONLY GUY WHO NEEDS THIS DOESN'T CARE ABOUT THE SIGN
15BA 15BA : D0                       ret     nc                ;[M80] IT DOES NOT
15BB 15BB : 7E                       ld      a,(hl)            ;[M80] GET EXPONENT BACK
15BC 15BC : CD 86 15                 call    QINT              ;[M80] IT DOES, SHIFT THEM OUT
15BF 15BF : 36 98                    ld      (hl),$98          ;[M80] CHANGE EXPONENT SO IT WILL BE CORRECT
15C1 15C1 : 7B                       ld      a,e               ;[M80] GET LO
15C2 15C2 : F5                       push    af                ;[M80] SAVE IT
15C3 15C3 : 79                       ld      a,c               ;[M80] NEGATE NUMBER IF IT IS NEGATIVE
15C4 15C4 : 17                       rla                       ;[M80] PUT SIGN IN CARRY
15C5 15C5 : CD AD 12                 call    FADFLT            ;[M80] REFLOAT NUMBER
15C8 15C8 : F1                       pop     af                ;[M80] GET LO BACK
15C9 15C9 : C9                       ret                       ;[M80] ALL DONE
15CA 15CA
15CA 15CA                  # ;[M80] INTEGER ARITHMETIC ROUTINES
15CA 15CA                    
15CA 15CA -                + ;[M80] INTEGER MULTIPLY FOR MULTIPLY DIMENSIONED ARRAYS
15CA 15CA                  | ;[M80]  (DE):=(BC)*(DE)
15CA 15CA                  | ;[M80] OVERFLOW CAUSES A BS ERROR
15CA 15CA                  | ;[M80] ALTERS A,B,C,D,E
15CA 15CA = 21 00 00   [M80] UMULT:  ld      hl,0              ;[M80] ZERO PRODUCT REGISTERS
15CD 15CD : 78                       ld      a,b               ;[M80] CHECK IF (BC) IS ZERO
15CE 15CE : B1                       or      c                 ;[M80] IF SO, JUST RETURN, (HL) IS ALREADY ZERO
15CF 15CF : C8                       ret     z                 ;[M80] THIS IS DONE FOR SPEED
15D0 15D0 : 3E 10                    ld      a,16              ;[M80] THIS IS DONE FOR SPEED
15D2 15D2 : 29         (M80) UMULT1: add     hl,hl             ;[M80] ROTATE (HL) LEFT ONE
15D3 15D3 : DA CD 11                 jp      c,BSERR           ;{M80} IF OVERFLOW, BAD SUBSCRIPT ERROR
15D6 15D6 : EB                       ex      de,hl             
15D7 15D7 : 29                       add     hl,hl             ;[M80] ROTATE (DE) LEFT ONE
15D8 15D8 : EB                       ex      de,hl             
15D9 15D9 : D2 E0 15                 jp      nc,UMULT2         ;[M80] ADD IN (BC) IF HO WAS 1
15DC 15DC : 09                       add     hl,bc             
15DD 15DD : DA CD 11                 jp      c,BSERR           
15E0 15E0 : 3D         (M80) UMULT2: dec     a                 ;[M80] CHECK FOR OVERFLOW
15E1 15E1 : C2 D2 15                 jp      nz,UMULT1         ;[M80] SEE IF DONE
15E4 15E4 : C9                       ret
15E5 15E5
15E5 15E5                  + ;[M80] FLOATING POINT INPUT ROUTINE
15E5 15E5                  | ;[M80] ALTERS ALL REGISTERS
15E5 15E5                  | ;[M80] THE NUMBER IS LEFT IN FAC
15E5 15E5                  | ;[M80] AT ENTRY, (HL) POINTS TO THE FIRST CHARACTER IN A TEXT BUFFER.
15E5 15E5                  | ;[M80] THE FIRST CHARACTER IS ALSO IN A.  WE PACK THE DIGITS INTO THE FAC
15E5 15E5                  | ;[M80] AS AN INTEGER AND KEEP TRACK OF WHERE THE DECIMAL POINT IS.
15E5 15E5                  | ;[M80] C IS 377 IF WE HAVE NOT SEEN A DECIMAL POINT, 0 IF WE HAVE.
15E5 15E5                  | ;[M80] B IS THE NUMBER OF DIGITS AFTER THE DECIMAL POINT.
15E5 15E5                  | ;[M80] AT THE END, B AND THE EXPONENT (IN E) ARE USED TO DETERMINE HOW MANY
15E5 15E5                  | ;[M80] TIMES WE MULTIPLY OR DIVIDE BY TEN TO GET THE CORRECT NUMBER.
15E5 15E5 : FE 2D      [M80] FIN:    cp      '-'               ;[M80] SEE IF NUMBER IS NEGATIVE
15E7 15E7 : F5                       push    af                ;[M80] SAVE SIGN
15E8 15E8 : 28 05                    jr      z,FIN1            
15EA 15EA : FE 2B                    cp      '+'               ;[M80] IGNORE MINUS SIGN
15EC 15EC : 28 01                    jr      z,FIN1            ;[M80] IGNORE A LEADING SIGN
15EE 15EE : 2B                       dec     hl                ;[M80] SET CHARACTER POINTER BACK ONE
15EF 15EF : CD C3 12   (M80) FIN1:   call    ZERO              ;{M80} GO ZERO THE FAC
15F2 15F2 : 47                       ld      b,a               
15F3 15F3 : 57                       ld      d,a               ;;[D,E] = $0000
15F4 15F4 : 5F                       ld      e,a
15F5 15F5 : 2F                       cpl
15F6 15F6 : 4F                       ld      c,a               ;;[B,C] = $00FF 
15F7 15F7                  - ;[M80] HERE TO CHECK FOR A DIGIT, A DECIMAL POINT, "E" OR "D"
15F7 15F7 : D7         [M80] FINC:   rst     CHRGET            ;[M80] GET THE NEXT CHARACTER OF THE NUMBER
15F8 15F8 : DA 3F 16                 jp      c,FINDIG          ;[M80] WE HAVE A DIGIT
15FB 15FB : FE 2E                    cp      '.'               ;[M80] CHECK FOR A DECIMAL POINT
15FD 15FD : CA 1A 16                 jp      z,FINDP           ;[M80] WE HAVE ONE, I GUESS
1600 1600 : FE 65                    cp      'e'               
1602 1602 : CA 0A 16                 jp      z,FINC1           
1605 1605 : FE 45                    cp      'E'               ;[M80] CHECK FOR A SINGLE PRECISION EXPONENT
1607 1607 : C2 1E 16                 jp      nz,FINE           
160A 160A : D7         (M80) FINC1:  rst     CHRGET            
160B 160B : CD 98 0A                 call    MINPLS            
160E 160E : D7         (M80) FINEC:  rst     CHRGET            ;[M80] GET THE NEXT CHARATER
160F 160F : DA 61 16                 jp      c,FINEDG          ;[M80] PACK THE NEXT DIGIT INTO THE EXPONENT
1612 1612 : 14                       inc     d                 ;[M80] IT WAS NOT A DIGIT, PUT THE CORRECT SIGN ON
1613 1613 : C2 1E 16                 jp      nz,FINE           ;[M80]  THE EXPONENT, IT IS POSITIVE
1616 1616 : AF                       xor     a                 ;[M80] THE EXPONENT IS NEGATIVE
1617 1617 : 93                       sub     e                 ;[M80] NEGATE IT
1618 1618 : 5F                       ld      e,a               ;[M80] SAVE IT AGAIN
1619 1619 : 0C                       inc     c
161A 161A                    ;[M80] HERE TO SET THE DECIMAL POINT FLAG
161A 161A : 0C         (M80) FINDP:  inc     c                 ;[M80] SET THE FLAG
161B 161B : CA F7 15                 jp      z,FINC            ;[M80] CONTINUE LOOKING FOR DIGITS
161E 161E                    ;[M80] HERE TO FINISH UP THE NUMBER
161E 161E : E5         (M80) FINE:   push    hl                ;[M80] SAVE THE TEXT POINTER
161F 161F : 7B                       ld      a,e               ;[M80] FIND OUT HOW MANY TIMES WE HAVE TO MULTIPLY
1620 1620 : 90                       sub     b                 ;[M80]  OR DIVIDE BY TEN
1621 1621                    ;[M80] HERE TO MULTIPLY OR DIVIDE BY TEN THE CORRECT NUMBER OF TIMES                    
1621 1621 : F4 37 16   [M80] FINE2:  call    p,FINMUL          ;[M80] MULTIPLY IF WE HAVE TO
1624 1624 : F2 2D 16                 jp      p,FINE3
1627 1627 : F5                       push    af
1628 1628 : CD 21 14                 call    DIV10             ;[M80] DIVIDE IF WE HAVE TO
162B 162B : F1                       pop     af                ;[M80] GET THE SIGN
162C 162C : 3C                       inc     a
162D 162D : C2 21 16   (~~~) FINE3:  jp      nz,FINE2          ;[M80] MULTIPLY OR DIVIDE AGAIN IF WE ARE NOT DONE
1630 1630                    ;[M80] HERE TO PUT THE CORRECT SIGN ON THE NUMBER
1630 1630 : D1                       pop     de                ;[M80] GET THE TEXT POINTER
1631 1631 : F1                       pop     af                ;[M80] GET THE SIGN
1632 1632 : CC 0B 15                 call    z,NEG             ;[M80] NEGATE IF NECESSARY
1635 1635 : EB                       ex      de,hl             ;[M80] GET THE TEXT POINTER IN (HL)
1636 1636 : C9                       ret
1637 1637
1637 1637                  + ;[M80] THIS SUBROUTINE MULIPLIES BY TEN ONCE.
1637 1637                  | ;[M80] IT IS A SUBROUTINE BECAUSE IT SAVES BYTES WHEN WE CHECK IF A IS ZERO
1637 1637                  | ;[M80] ALTERS ALL REGISTERS
1637 1637 : C8         [M80] FINMUL: ret     z                 ;[M80] RETURN IF EXPONENT IS ZERO, ENTRY FROM FOUT
1638 1638 : F5         [M80] FINMLT: push    af                
1639 1639 : CD D4 14                 call    MUL10             ;[M80] MULTIPLY BY 10.0
163C 163C : F1                       pop     af                
163D 163D : 3D         {M80} DCRART: dec     a                 ;[M80] DECREASE IT
163E 163E : C9                       ret                       ;[M80] ALL DONE
163F 163F
163F 163F                    ;[M80] HERE TO PACK THE NEXT DIGIT OF THE NUMBER INTO THE FAC
163F 163F                    ;[M80] WE MULTIPLY THE FAC BY TEN AND ADD IN THE NEXT DIGIT
163F 163F : D5         [M80] FINDIG: push    de                ;[M80] SAVE EXPONENT INFORMATION
1640 1640 : 57                       ld      d,a               ;[M80] INCREMENT DECIMAL PLACE COUNT IF WE ARE
1641 1641 : 78                       ld      a,b               ;[M80]  PAST THE DECIMAL POINT
1642 1642 : 89                       adc     a,c               ;
1643 1643 : 47                       ld      b,a               ;
1644 1644 : C5                       push    bc                ;[M80] SAVE DECIMAL POINT INFORMATION
1645 1645 : E5                       push    hl                ;[M80] SAVE TEXT POINTER
1646 1646 : D5                       push    de                ;
1647 1647 : CD D4 14                 call    MUL10             ;
164A 164A : F1                       pop     af                ;[M80] GET THE DIGIT
164B 164B : D6 30                    sub     '0'               ;[M80] CONVERT IT TO ASCII
164D 164D : CD 56 16                 call    FINLOG            ;[M65] ADD IT IN
1650 1650 : E1                       pop     hl                ;
1651 1651 : C1                       pop     bc                ;
1652 1652 : D1                       pop     de                ;
1653 1653 : C3 F7 15                 jp      FINC              ;
1656 1656                                                      
1656 1656 : CD 13 15   [M65] FINLOG: call    PUSHF             ;[M65] SAVE FAC FOR LATER
1659 1659 : CD F6 14                 call    FLOAT             ;[M65] FLOAT THE VALUE IN ACCA
165C 165C : C1         [M80] FADDT:  pop     bc                ;[M80] GET ARG IN REGISTERS, ENTRY TO FADD IF
165D 165D : D1                       pop     de                ;[M80]  ARGUMENT IS ON STACK.  JUMP TO FADD
165E 165E : C3 61 12                 jp      FADD              ;[M80] ADD IT IN
1661 1661                                                      
1661 1661 : 7B         [M80] FINEDG: ld      a,e               ;EXPONENT DIGIT -- MULTIPLY EXPONENT BY 10
1662 1662 : 07                       rlca                      ;FIRST BY 4
1663 1663 : 07                       rlca                      
1664 1664 : 83                       add     a,e               ;ADD 1 TO MAKE 5
1665 1665 : 07                       rlca                      ;NOW DOUBLE TO GET 10
1666 1666 : 86                       add     a,(hl)            ;ADD IT IN
1667 1667 : D6 30                    sub     '0'               ;SUBTRACT OFF ASCII CODE
1669 1669 : 5F                       ld      e,a               ;STORE EXPONENT
166A 166A : C3 0E 16                 jp      FINEC
166D 166D
166D 166D                    ;[M80] FLOATING POINT OUTPUT ROUTINE
166D 166D : E5         [M80] INPRT:  push    hl                ;[M80] ENTRY TO LINPRT
166E 166E : 21 69 03                 ld      hl,INTXT          ;[M80] SAVE LINE NUMBER
1671 1671 : CD 9D 0E                 call    STROUT            ;[M80] PRINT MESSAGE
1674 1674 : E1                       pop     hl
1675 1675                    
1675 1675 -                + ;[M80] PRINT THE 2 BYTE NUMBER IN H,L
1675 1675                  | ;[M80] ALTERS ALL REGISTERS
1675 1675 = 11 9C 0E   [M80] LINPRT: ld      de,STROUI       
1678 1678 : D5                       push    de
1679 1679                    ;; Convert Unsigned Word in [HL] to String
1679 1679 : EB         {M80} LINOUT: ex      de,hl
167A 167A : AF                       xor     a
167B 167B : 06 98                    ld      b,$98
167D 167D : CD FB 14                 call    FLOATR
1680 1680
1680 1680                  + ;[M80] FLOATING OUTPUT OF FAC
1680 1680                  | ;[M80] ALTERS ALL REGISTERS
1680 1680                  | ;[M80] THE ORIGINAL CONTENTS OF THE FAC IS LOST
1680 1680                  | ;[M80] 
1680 1680 : 21 E9 38   [M80] FOUT:   ld      hl,FBUFFR+1       ;[M80] GET A POINTER INTO FBUFFR
1683 1683 : E5                       push    hl                ;{M80} SAVE IT
1684 1684 : EF                       rst     FSIGN             
1685 1685 : 36 20                    ld      (hl),' '          ;[M80] PUT A SPACE FOR POSITIVE NUMBERS IN THE BUFFER
1687 1687 : F2 8C 16                 jp      p,FOUT2           ;[M80] IF WE HAVE A NEGATIVE NUMBER, NEGATE IT
168A 168A : 36 2D                    ld      (hl),'-'          ;[M80]  AND PUT A MINUS SIGN IN THE BUFFER
168C 168C : 23               FOUT2:  inc     hl                ;[M80] POINT TO WHERE THE NEXT CHARACTER GOES
168D 168D : 36 30                    ld      (hl),'0'          ;[M80] PUT A ZERO IN THE BUFFER IN CASE THE NUMBER IS ZERO
168F 168F : CA 42 17                 jp      z,FOUTZR          ;[M80] IF THE NUMBER IS ZERO, FINISH IT UP
1692 1692 : E5                       push    hl                ;[M80] SAVE THE BUFFER POINTER
1693 1693 : FC 0B 15                 call    m,NEG             ;[M80] NEGATE THE NUMBER
1696 1696 : AF                       xor     a                 ;[M80] ZERO THE EXPONENT              
1697 1697 : F5                       push    af                ;[M80] SAVE IT
1698 1698 : CD 48 17                 call    FOUNVC            ;[M80] IS THE FAC TOO BIG OR TOO SMALL?
169B 169B : 01 43 91   [M80] FOUNV1: ld      bc,$9143          ;
169E 169E : 11 F8 4F                 ld      de,$4FF8          ;[M80] GET 99999.95 TO SEE IF THE FAC IS BIG
16A1 16A1 : CD 5B 15                 call    FCOMP             ;[M80]  ENOUGH YET
16A4 16A4 : B7                       or      a                 ;[M80] GO DO THE CHECK
16A5 16A5 : E2 B9 16   {M80} FOUNV5: jp      po,FOUTCS         ;[M80] IT ISN'T ANY MORE, WE ARE DONE 
16A8 16A8 : F1                       pop     af                ;[M80] IT IS, MULTIPLY BY TEN
16A9 16A9 : CD 38 16                 call    FINMLT            ;
16AC 16AC : F5                       push    af                ;[M80] SAVE THE EXPONENT AGAIN
16AD 16AD : C3 9B 16                 jp      FOUNV1            ;[M80] NOW SEE IF IT IS BIG ENOUGH
16B0 16B0 : CD 21 14   (M80) FOUNV2: call    DIV10             ;[M80] THE FAC IS TOO BIG, DIVIDE IT BY TEN
16B3 16B3 : F1                       pop     af                ;
16B4 16B4 : 3C                       inc     a                 ;
16B5 16B5 : F5                       push    af                ;
16B6 16B6 : CD 48 17                 call    FOUNVC            ;[M80] SEE IF THE FAC IS SMALL ENOUGH
16B9 16B9 : CD 50 12   (M80) FOUTCS: call    FADDH             ;[M80] ROUND NUMBER TO NEAREST INTEGER
16BC 16BC : 3C                       inc     a                 ;[M80] MAKE A NON-ZERO, SINCE NUMBER IS POSITIVE AND NON-ZERO
16BD 16BD : CD 86 15                 call    QINT              ;[M80] GET INTEGER PART IN C,D,E
16C0 16C0 : CD 23 15                 call    MOVFR             ;[M80] SAVE NUMBER IN FAC
16C3 16C3 : 01 06 03                 ld      bc,$0306          ;;[B] = 3, [C] = 6        
16C6 16C6 : F1                       pop     af                ;
16C7 16C7 : 81                       add     a,c               ;
16C8 16C8 : 3C                       inc     a                 ;
16C9 16C9 : FA D5 16                 jp      m,FOUCDC          ;
16CC 16CC : FE 08                    cp      8                 ;
16CE 16CE : D2 D5 16                 jp      nc,FOUCDC         ;
16D1 16D1 : 3C                       inc     a                 ;
16D2 16D2 : 47                       ld      b,a               ;
16D3 16D3 : 3E 02                    ld      a,2               ;
16D5 16D5 : 3D         (M80) FOUCDC: dec     a                 ;
16D6 16D6 : 3D                       dec     a                 ;
16D7 16D7 : E1                       pop     hl                ;[M80] GET THE BUFFER POINTER BACK
16D8 16D8 : F5                       push    af                ;
16D9 16D9 : 11 5E 17                 ld      de,FOSTBL         ;
16DC 16DC : 05         {M80} FOUTAN: dec     b                 ;
16DD 16DD : C2 E6 16                 jp      nz,FOUTED         ;
16E0 16E0 : 36 2E                    ld      (hl),'.'          ;[M80] PUT IN D.P.
16E2 16E2 : 23                       inc     hl                ;[M80] POINT TO NEXT BUFFER POSTION
16E3 16E3 : 36 30                    ld      (hl),'0'          ;
16E5 16E5 : 23                       inc     hl                ;
16E6 16E6 : 05         (M80) FOUTED: dec     b                 ;[M80] ENTRY TO PUT A DECIMAL POINT IN THE BUFFER
16E7 16E7 : 36 2E      {M80} FOUTDP: ld      (hl),'.'          ;{M80} PUT THE DECIMAL POINT IN
16E9 16E9 : CC 38 15                 call    z,INXHRT          ;
16EC 16EC : C5         {M80} FOUTCV: push    bc                ;[M80[ SAVE THE DECIMAL POINT AND COMMA COUNTS
16ED 16ED : E5                       push    hl                ;[M80[ SAVE THE BUFFER POINTER
16EE 16EE : D5                       push    de                ;[M80[ SAVE (DE)
16EF 16EF : CD 2E 15                 call    MOVRF             ;{M80} GET NUMBER IN THE REGISTERS
16F2 16F2 : E1                       pop     hl                ;[M80] GET THE BUFFER POINTER BACK
16F3 16F3 : 06 2F      {M80} FOUCD1: ld      b,'0'-1           ;[M80] SET UP THE COUNT FOR THE DIGIT        
16F5 16F5 : 04         (M80) FOUCD2: inc     b                 ;[M80] INCREMENT THE DIGIT COUNT
16F6 16F6 : 7B                       ld      a,e               ;{M80} SUBTRACT THE TWO NUMBERS
16F7 16F7 : 96                       sub     (hl)              ;;Subtract LO
16F8 16F8 : 5F                       ld      e,a               ;
16F9 16F9 : 23                       inc     hl                ;
16FA 16FA : 7A                       ld      a,d               ;
16FB 16FB : 9E                       sbc     a,(hl)            ;;Subtract MO
16FC 16FC : 57                       ld      d,a               ;
16FD 16FD : 23                       inc     hl                ;
16FE 16FE : 79                       ld      a,c               ;
16FF 16FF : 9E                       sbc     a,(hl)            ;;Subtract HO
1700 1700 : 4F                       ld      c,a               ;
1701 1701 : 2B                       dec     hl                ;
1702 1702 : 2B                       dec     hl                ;;Backup Pointer
1703 1703 : D2 F5 16                 jp      nc,FOUCD2         ;[M80] IF NOT LESS THAN THE POWER OF TEN, SUBTRACT AGAIN
1706 1706 : CD 10 13                 call    FADDA             ;[M80] ADD THE TWO NUMBERS
1709 1709 : 23                       inc     hl                
170A 170A : CD 23 15                 call    MOVFR             ;{M80} PUT REGISTERS IN THE FAC
170D 170D : EB                       ex      de,hl             ;[M80] PUT THE POWER OF TEN POINTER IN (DE).
170E 170E : E1                       pop     hl                ;[M80] GET THE BUFFER POINTER BACK
170F 170F : 70                       ld      (hl),b            ;[M80] PUT THE DIGIT INTO THE BUFFER
1710 1710 : 23                       inc     hl                ;[M80] INCREMENT THE BUFFER POINTER
1711 1711 : C1                       pop     bc                ;[M80] GET THE DECIMAL POINT AND COMMA COUNTS
1712 1712 : 0D                       dec     c                 ;[M80] HAVE WE PRINTED THE LAST DIGIT?
1713 1713 : C2 E6 16                 jp      nz,FOUTED         ;[M80] NO, GO DO THE NEXT ONE
1716 1716 : 05                       dec     b                 ;
1717 1717 : CA 26 17                 jp      z,FOFLDN          ;
171A 171A : 2B         (M80) FOFRS2: dec     hl                ;[M80] MOVE BACK TO THE LAST CHARACTER
171B 171B : 7E                       ld      a,(hl)            ;[M80] GET IT AND SEE IF IT WAS ZERO
171C 171C : FE 30                    cp      '0'               ;
171E 171E : CA 1A 17                 jp      z,FOFRS2          ;[M80] IT WAS, CONTINUE SUPPRESSING
1721 1721 : FE 2E                    cp      '.'               ;[M80] HAVE WE SUPPRESSED ALL THE FRACTIONAL DIGITS?
1723 1723 : C4 38 15                 call    nz,INXHRT         ;[M80] YES, IGNORE THE DECIMAL POINT ALSO
1726 1726 : F1         (M80) FOFLDN: pop     af                ;[M80] GET THE EXPONENT BACK
1727 1727 : CA 45 17                 jp      z,FOUTDN          ;[M80] WE ARE DONE IF WE ARE IN FIXED POINT NOTATION
172A 172A : 36 45                    ld      (hl),'E'          ;
172C 172C : 23                       inc     hl                ;
172D 172D : 36 2B                    ld      (hl),'+'          ;[M80] A PLUS IF POSITIVE
172F 172F : F2 36 17                 jp      p,FOUCE1          ;
1732 1732 : 36 2D                    ld      (hl),'-'          ;[M80] A MINUS IF NEGATIVE
1734 1734 : 2F                       cpl                       ;[M80] NEGATE EXPONENT
1735 1735 : 3C                       inc     a                 ;
1736 1736                    ;[M80] CALCULATE THE TWO DIGIT EXPONENT
1736 1736 : 06 2F      (M80) FOUCE1: ld      b,'0'-1           ;[M80] INITIALIZE TEN'S DIGIT COUNT
1738 1738 : 04         (M80) FOUCE2: inc     b                 ;[M80] INCREMENT DIGIT
1739 1739 : D6 0A                    sub     10                ;[M80] SUBTRACT TEN
173B 173B : D2 38 17                 jp      nc,FOUCE2         ;[M80] DO IT AGAIN IF RESULT WAS POSITIVE
173E 173E : C6 3A                    add     a,'0'+10          ;[M80] ADD BACK IN TEN AND CONVERT TO ASCII
1740 1740 : 23                       inc     hl                ;[M80] PUT THE EXPONENT IN THE BUFFER
1741 1741 : 70                       ld      (hl),b            ;[M80] PUT TEN'S DIGIT OF EXPONENT IN BUFFER
1742 1742 : 23         (M80) FOUTZR: inc     hl                ;[M80] WHEN WE JUMP TO HERE, A IS ZERO
1743 1743 : 77                       ld      (hl),a            ;[M80] PUT ONE'S DIGIT IN BUFFER
1744 1744 : 23                       inc     hl                ;[M80] INCREMENT POINTER
1745 1745                    ;HERE TO FINISH UP PRINTING A FREE FORMAT ZERO
1745 1745 : 71         (M80) FOUTDN: ld      (hl),c            ;[M80] PUT A ZERO AT THE END OF THE NUMBER
1746 1746 : E1                       pop     hl                ;
1747 1747 : C9                       ret                       ;
1748 1748                                                      
1748 1748 : 01 74 94   [M80] FOUNVC: ld      bc,$9474          ;
174B 174B : 11 F7 23                 ld      de,$23F7          ;[M80] GET 999999.5 TO SEE IF THE FAC IS TOO BIG
174E 174E : CD 5B 15                 call    FCOMP             ;
1751 1751 : B7                       or      a                 ;
1752 1752 : E1         {M80} FONVC2: pop     hl                ;
1753 1753 : E2 B0 16                 jp      po,FOUNV2         ;[M80] GO DO THE CHECK
1756 1756 : E9                       jp      (hl)              ;[M80] IT ISN'T TOO BIG, JUST RETURN
1757 1757                                                      
1757 1757 : 00 00 00 80      FHALF:  byte    $00,$00,$00,$80   ;[M65] 1/2
175B 175B : 40                       ld      b,b               ;;Orphan Code or Remnants of Unused Constant?
175C 175C : 42                       ld      b,d
175D 175D : 0F                       rrca
175E 175E
175E 175E                    ;[M80] SINGLE PRECISION POWER OF TEN TABLE
175E 175E : A0 86 01   [M80] FOSTBL: byte    $A0,$86,$01       ;[M80] 1E5
1761 1761 : 10 27 00                 byte    $10,$27,$00       ;[M80] 1E4
1764 1764 : E8 03 00                 byte    $E8,$03,$00       ;[M80] 1000
1767 1767 : 64 00 00                 byte    $64,$00,$00       ;[M80] 100
176A 176A : 0A 00 00                 byte    $0A,$00,$00       ;[M80] 10
176E 176E : 01 00 00                 byte    $01,$00,$00       ;[M80] 1
1770 1770
1770 1770 -                + ;;Push Address of NEG Routine on to Stack
1770 1770                  | ;[M80] SUBROUTINE FOR FPWR, ATN
1770 1770 = 21 0B 15         PSHNEG: ld      hl,NEG            ;[M80] GET THE ADDRESS OF NEG
1773 1773 : E3                       ex      (sp),hl           ;[M80] SWITCH RET ADDR AND ADDR OF NEG
1774 1774 : E9                       jp      (hl)              ;[M80] RETURN, THE ADDRESS OF NEG IS ON THE STACK
1775 1775
1775 1775 :                  ;[M80] SQUARE ROOT FUNCTION: WE USE SQR(X)=X^.5
1775 1775 : CD 13 15   [M80] SQR:    call    PUSHF             ;[M80] SAVE ARG X
1778 1778 : 21 57 17                 ld      hl,FHALF          ;[M80] GET 1/2
177B 177B : CD 20 15                 call    MOVFM             ;[M80] SQR(X)=X^.5
177E 177E                                                      
177E 177E : C1         [M80] FPWRT:  pop     bc                ;[M80] GET ARG IN REGISTERS, ENTRY TO FPWR IF
177F 177F : D1                       pop     de                ;[M80]  ARGUMENT IS ON STACK.  FALL INTO FPWR
1780 1780
1780 1780                  + ;[M80] EXPONENTIATION    ---    X^Y
1780 1780                  | ;[M80] N.B.  0^0=1
1780 1780                  | ;[M80] FIRST WE CHECK IF Y=0, IF SO, THE RESULT IS 1.
1780 1780                  | ;[M80] NEXT, WE CHECK IF X=0, IF SO, THE RESULT IS 0.
1780 1780                  | ;[M80] THEN WE CHECK IF X IS POSITIVE, IF NOT, WE CHECK THAT Y IS A
1780 1780                  | ;[M80] NEGATIVE INTEGER, AND WHETHER IT IS EVEN OR ODD.  IF Y IS A NEGATIVE
1780 1780                  | ;[M80] INTEGER, WE NEGATE X.  IF NOT, LOG WILL GIVE AN FC ERROR WHEN WE CALL
1780 1780                  | ;[M80] IT.  IF X IS NEGATIVE AND Y IS ODD, WE PUSH THE ADDRESS OF NEG ON THE
1780 1780                  | ;[M80] STACK SO WE WILL RETURN TO IT AND GET A NEGATIVE RESULT.  TO COMPUTE
1780 1780                  | ;[M80] THE RESULT WE USE X^Y=EXP(Y*LOG(X))
1780 1780 : EF         [M80] FPWR:   rst     FSIGN             ;[M80] SEE IF Y IS ZERO
1781 1781 : 78                       ld      a,b               ;[M80] SEE IF X IS ZERO
1782 1782 : CA CD 17                 jp      z,EXP             ;[M80] IT IS, RESULT IS ONE
1785 1785 : F2 8C 17                 jp      p,POSEXP          ;[M80] POSITIVE EXPONENT
1788 1788 : B7                       or      a                 ;[M80] IS IT ZERO TO MINUS POWER?
1789 1789 : CA C7 03                 jp      z,DV0ERR          ;[M80] GIVE DIV BY ZERO AND CONTINUE
178C 178C : B7         [M80] POSEXP: or      a                 ;
178D 178D : CA C4 12                 jp      z,ZERO0           ;[M80]IT IS, RESULT IS ZERO
1790 1790 : D5                       push    de                ;[M80] SAVE X ON STACK
1791 1791 : C5                       push    bc                ;
1792 1792 : 79                       ld      a,c               ;[M80] CHECK THE SIGN OF X
1793 1793 : F6 7F                    or      $7F               ;[M80] TURN THE ZERO FLAG OFF
1795 1795 : CD 2E 15                 call    MOVRF             ;[M80] GET Y IN THE REGISTERS
1798 1798 : F2 B5 17                 jp      p,FPWR1           ;[M80] NO PROBLEMS IF X IS POSITIVE
179B 179B : F5                       push    af                ;
179C 179C : 3A E7 38                 ld      a,(FAC)           ;
179F 179F : FE 99                    cp      $99               ;
17A1 17A1 : 38 03                    jr      c,FPWRT1          ;
17A3 17A3 : F1                       pop     af                ;
17A4 17A4 : 18 0F                    jr      FPWR1             ;
17A6 17A6 : F1         (M65) FPWRT1: pop     af                ;
17A7 17A7 : D5                       push    de                ;
17A8 17A8 : C5                       push    bc                ;[M80] SAVE Y
17A9 17A9 : CD B1 15                 call    INT               ;[M80] SEE IF Y IS AN INTEGER
17AC 17AC : C1                       pop     bc                ;
17AD 17AD : D1                       pop     de                ;[M80] GET Y BACK
17AE 17AE : F5                       push    af                ;[M80] SAVE LO OF INT FOR EVEN AND ODD INFORMATION
17AF 17AF : CD 5B 15                 call    FCOMP             ;[M80] SEE IF WE HAVE AN INTEGER
17B2 17B2 : E1                       pop     hl                ;[M80] GET EVEN-ODD INFORMATION
17B3 17B3 : 7C                       ld      a,h               ;[M80] PUT EVEN-ODD FLAG IN CARRY
17B4 17B4 : 1F                       rra                       ;
17B5 17B5 : E1         (M80) FPWR1:  pop     hl                ;[M80] GET X BACK IN FAC
17B6 17B6 : 22 E6 38                 ld      (FACHO),hl        ;[M80] STORE HO'S
17B9 17B9 : E1                       pop     hl                ;[M80] GET LO'S OFF STACK
17BA 17BA : 22 E4 38                 ld      (FACLO),hl        ;[M80] STORE THEM IN FAC
17BD 17BD : DC 70 17                 call    c,PSHNEG          ;[M80] NEGATE NUMBER AT END IF Y WAS ODD
17C0 17C0 : CC 0B 15                 call    z,NEG             ;[M80] NEGATE THE NEGATIVE NUMBER
17C3 17C3 : D5                       push    de                ;[M80] SAVE Y AGAIN
17C4 17C4 : C5                       push    bc                ;
17C5 17C5 : CD 85 13                 call    LOG               ;[M80] COMPUTE  EXP(Y*LOG(X))
17C8 17C8 : C1                       pop     bc                ;
17C9 17C9 : D1                       pop     de                ;[M80] IF X WAS NEGATIVE AND Y NOT AN INTEGER THEN
17CA 17CA : CD CB 13                 call    FMULT             ;[M80]  LOG WILL BLOW HIM OUT OF THE WATER
17CD 17CD
17CD 17CD                  + ;[M80] THE FUNCTION EXP(X) CALCULATES e^X WHERE e=2.718282
17CD 17CD                  | ;[M80]        THE TECHNIQUE USED IS TO EMPLOY A COUPLE
17CD 17CD                  | ;[M80]        OF FUNDAMENTAL IDENTITIES THAT ALLOWS US TO
17CD 17CD                  | ;[M80]        USE THE BASE 2 THROUGH THE DIFFICULT PORTIONS OF
17CD 17CD                  | ;[M80]        THE CALCULATION:
17CD 17CD                  | ;[M80]
17CD 17CD                  | ;[M80]          (1)e^X=2^y  WHERE y=X*LOG2(e) [LOG2(e) IS
17CD 17CD                  | ;[M80]                                          LOG BASE 2
17CD 17CD                  | ;[M80]                                          OF e ]
17CD 17CD                  | ;[M80]          
17CD 17CD                  | ;[M80]          (2) 2^y=2^[ INT(y)+(y-INT(y)]
17CD 17CD                  | ;[M80]          (3) IF Ny=INT(y) THEN
17CD 17CD                  | ;[M80]              2^(Ny+y-Ny)=[2^Ny]*[2^(y-Ny)]
17CD 17CD                  | ;[M80]
17CD 17CD                  | ;[M80]        NOW, SINCE 2^Ny IS EASY TO COMPUTE (AN EXPONENT
17CD 17CD                  | ;[M80]        CALCULATION WITH MANTISSA BITS OF ZERO) THE DIFFICULT
17CD 17CD                  | ;[M80]        PORTION IS TO COMPUTE 2^(Y-Ny) WHERE 0.LE.(Y-Ny).LT.1
17CD 17CD                  | ;[M80]        THIS IS ACCOMPLISHED WITH A POLYNOMIAL APPROXIMATION
17CD 17CD                  | ;[M80]        TO 2^Z WHERE 0.LE.Z.LT.1  . ONCE THIS IS COMPUTED WE
17CD 17CD                  | ;[M80]        HAVE TO EFFECT THE MULTIPLY BY 2^Ny .
17CD 17CD : 01 38 81   [M80] EXP:    ld      bc,$8138          ;[M65] LOG(e) BASE 2
17D0 17D0 : 11 3B AA                 ld      de,$AA3B          ;[M80] GET LOG2(e)
17D3 17D3 : CD CB 13                 call    FMULT             ;[M80] y=FAC*LOG2(e)
17D6 17D6 : 3A E7 38                 ld      a,(FAC)           ;[M80] MUST SEE IF TOO LARGE
17D9 17D9 : FE 88                    cp      $88               ;[M80] ABS .GT. 128?
17DB 17DB : 30 22                    jr      nc,EXP100         ;[M80] IF SO OVERFLOW
17DD 17DD : FE 68                    cp      $68               ;[M80] IF TOO SMALL ANSWER IS 1
17DF 17DF : 38 30                    jr      c,EXP200          ;
17E1 17E1 : CD 13 15                 call    PUSHF             ;[M80] SAVE y
17E4 17E4 : CD B1 15                 call    INT               ;[M80] DETERMINE INTEGER POWER OF 2
17E7 17E7 : C6 81                    add     a,$81             ;[M80] INTEGER WAS RETURNED IN A, BIAS IS 201
17E9 17E9 : C1                       pop     bc                ;
17EA 17EA : D1                       pop     de                ;[M80] RECALL y
17EB 17EB : 28 15                    jr      z,EXP110          ;[M80] OVERFLOW
17ED 17ED : F5                       push    af                ;[M80] SAVE EXPONENT
17EE 17EE : CD 5E 12                 call    FSUB              ;[M80] FAC=y-INT(y)
17F1 17F1 : 21 1A 18                 ld      hl,EXPBCN         ;[M80] WILL USE HART 1302 POLY. EVAL NOW
17F4 17F4 : CD 46 18                 call    POLY              ;[M80] COMPUTE 2^[y-INT(y)]
17F7 17F7 : C1                       pop     bc                ;[M80] INTEGER POWER OF 2 EXPONENT
17F8 17F8 : 11 00 00                 ld      de,0              ;[M80] NOW HAVE FLOATING REPRESENTATION 
17FB 17FB : 4A                       ld      c,d               ;[M80] OF INT(y) IN (BCDE)
17FC 17FC : C3 CB 13                 jp      FMULT             ;[M80] MULTIPLY BY 2^[y-INT(y)] AND RETURN
17FF 17FF                                                      
17FF 17FF : CD 13 15   (M80) EXP100: call    PUSHF             ;[M80] IF NEG. THEN JUMP TO ZERO
1802 1802 : 3A E6 38   (M80) EXP110: ld      a,(FACHO)         ;
1805 1805 : B7                       or      a                 ;[M80] OVERFLOW IF PLUS
1806 1806 : F2 0E 18                 jp      p,EXP115          ;[M80] NEED STACK RIGHT
1809 1809 : F1                       pop     af                ;
180A 180A : F1                       pop     af                ;
180B 180B : C3 C3 12                 jp      ZERO              ;[M80] GO ZERO THE FAC
180E 180E : C3 D3 03   (M80) EXP115: jp      OVERR             ;[M80] OVERFLOW
1811 1811 : 01 00 81   (M80) EXP200: ld      bc,$8100          ;
1814 1814 : 11 00 00                 ld      de,$0000          ;[M80] 1.
1817 1817 : C3 23 15                 jp      MOVFR             ;
181A 181A
181A 181A              [M80] ;*************************************************************
181A 181A              [M80] ;       Hart 1302 polynomial coefficients
181A 181A              [M80] ;*************************************************************
181A 181A : 07         [M80] EXPBCN  byte    7                 ;[M80] DEGREE + 1
181B 181B : 7C 88 59 74              byte    $7C,$88,$59,$74   ;[M80] .00020745577403-
181F 181F : E0 97 26 77              byte    $E0,$97,$26,$77   ;[M80] .037100574569-
1823 1823 : C4 1D 1E 7A              byte    $C4,$1D,$1E,$7A   ;[M80] .00965065093202+
1827 1827 : 5E 50 63 7C              byte    $5E,$50,$63,$7C   ;[M80] .05549656508324+
182B 182B : 1A FE 75 7E              byte    $1A,$FE,$75,$7E   ;[M80] .24022713817633-
182F 182F : 18 72 31 80              byte    $18,$72,$31,$80   ;[M80] .69314717213716+
1833 1833 : 00 00 00 81              byte    $00,$00,$00,$81   ;[M80] 1.0
1837 1837                    
1837 1837                 +  ;[M80] POLYNOMIAL EVALUATOR AND THE RANDOM NUMBER GENERATOR
1837 1837 -               |  ;[M80] EVALUATE P(X^2)*X
1837 1837                 |  ;[M80] POINTER TO DEGREE+1 IS IN (HL)
1837 1837                 |  ;[M80] THE CONSTANTS FOLLOW THE DEGREE
1837 1837                 |  ;[M80] CONSTANTS SHOULD BE STORED IN REVERSE ORDER, FAC HAS X
1837 1837                 |  ;[M80] WE COMPUTE:
1837 1837                 |  ;[M80]  C0*X+C1*X^3+C2*X^5+C3*X^7+...+C(N)*X^(2*N+1)
1837 1837                    
1837 1837 = CD 13 15   [M80] POLYX:  call    PUSHF             ;SAVE X
183A 183A : 11 C9 13                 ld      de,FMULTT         ;PUT ADDRESS OF FMULTT ON STACK SO WHEN WE
183D 183D : D5                       push    de                ; RETURN WE WILL MULTIPLY BY X
183E 183E : E5         {M80} POLYX2: push    hl                ;SAVE CONSTANT POINTER
183F 183F : CD 2E 15                 call    MOVRF             ;SQUARE X
1842 1842 : CD CB 13                 call    FMULT             ;
1845 1845 : E1                       pop     hl                ;GET CONSTANT POINTER
1846 1846                   
1846 1846                  + ;[M80] POLYNOMIAL EVALUATOR
1846 1846                  | ;[M80] POINTER TO DEGREE+1 IS IN (HL), IT IS UPDATED
1846 1846                  | ;[M80] THE CONSTANTS FOLLOW THE DEGREE
1846 1846                  | ;[M80] CONSTANTS SHOULD BE STORED IN REVERSE ORDER, FAC HAS X
1846 1846                  | ;[M80] WE COMPUTE:
1846 1846                  | ;[M80]  C0+C1*X+C2*X^2+C3*X^3+...+C(N-1)*X^(N-1)+C(N)*X^N
1846 1846 : CD 13 15   [M80] POLY:   call    PUSHF             ;[M80] SAVE X
1849 1849 : 7E                       ld      a,(hl)            ;[M80] GET DEGREE
184A 184A : 23                       inc     hl                ;[M80] INCREMENT POINTER TO FIRST CONSTANT
184B 184B : CD 20 15                 call    MOVFM             ;[M80] MOVE FIRST CONSTANT TO FAC
184E 184E : 06                       byte    $06               ;[M80] "MVI  B" OVER NEXT BYTE
184F 184F : F1         (M80) POLY1:  pop     af                ;[M80] GET DEGREE
1850 1850 : C1                       pop     bc                ;
1851 1851 : D1                       pop     de                ;[M80] GET X
1852 1852 : 3D                       dec     a                 ;[M80] ARE WE DONE?
1853 1853 : C8                       ret     z                 ;[M80] YES, RETURN
1854 1854 : D5                       push    de                ;
1855 1855 : C5                       push    bc                ;[M80] NO, SAVE X
1856 1856 : F5                       push    af                ;[M80] SAVE DEGREE
1857 1857 : E5                       push    hl                ;[M80] SAVE CONSTANT POINTER
1858 1858 : CD CB 13                 call    FMULT             ;[M80] EVALUATE THE POLY, MULTIPLY BY X
185B 185B : E1                       pop     hl                ;[M80] GET LOCATION OF CONSTANTS
185C 185C : CD 31 15                 call    MOVRM             ;[M80] GET CONSTANT
185F 185F : E5                       push    hl                ;[M80] STORE LOCATION OF CONSTANTS SO FADD AND FMULT
1860 1860 : CD 61 12                 call    FADD              ;[M80]  WILL NOT SCREW THEM UP, ADD IN CONSTANT
1863 1863 : E1                       pop     hl                ;[M80] MOVE CONSTANT POINTER TO NEXT CONSTANT
1864 1864 : 18 E9                    jr      POLY1             ;[M80] SEE IF DONE
1866 1866
1866 1866                  | ;[M80] PSUEDO-RANDOM NUMBER GENERATOR
1866 1866                  | ;[M80] IF ARG=0, THE LAST RANDOM NUMBER GENERATED IS RETURNED
1866 1866                  | ;[M80] IF ARG .LT. 0, A NEW SEQUENCE OF RANDOM NUMBERS IS STARTED
1866 1866                  | ;[M80]  USING THE ARGUMENT
1866 1866                  | ;[M80] TO FORM THE NEXT RANDOM NUMBER IN THE SEQUENCE, WE MULTIPLY THE
1866 1866                  | ;[M80] PREVIOUS RANDOM NUMBER BY A RANDOM CONSTANT, AND ADD IN ANOTHER
1866 1866                  | ;[M80] RANDOM CONSTANT.  THEN THE HO AND LO BYTES ARE SWITCHED, THE
1866 1866                  | ;[M80] EXPONENT IS PUT WHERE IT WILL BE SHIFTED IN BY NORMAL, AND THE
1866 1866                  | ;[M80] EXPONENT IN THE FAC SET TO 200 SO THE RESULT WILL BE LESS THAN 1.
1866 1866                  | ;[M80] THIS IS THEN NORMALIZED AND SAVED FOR THE NEXT TIME.
1866 1866                  | ;[M80] THE HO AND LO BYTES WERE SWITCHED SO WE HAVE A RANDOM CHANCE OF
1866 1866                  | ;[M80] GETTING A NUMBER LESS THAN OR GREATER THAN .5
1866 1866                  | ;
1866 1866 : EF         [M80] RND:    rst     FSIGN             ;[M80] GET SIGN OF ARG
1867 1867 : 21 20 38                 ld      hl,RNDCNT+1       ;
186A 186A : FA C4 18                 jp      m,RNDSTR          ;[M80] START NEW SEQUENCE IF NEGATIVE
186D 186D : 21 41 38                 ld      hl,RNDX           ;[M80] GET LAST NUMBER GENERATED
1870 1870 : CD 20 15                 call    MOVFM             ;
1873 1873 : 21 20 38                 ld      hl,RNDCNT+1       ;
1876 1876 : C8                       ret     z                 ;[M80] RETURN LAST NUMBER GENERATED IF ZERO
1877 1877 : 86                       add     a,(hl)            ;[M80] GET COUNTER INTO CONSTANTS AND ADD ONE
1878 1878 : E6 07                    and     7                 ;
187A 187A : 06 00                    ld      b,0               ;
187C 187C : 77                       ld      (hl),a            ;
187D 187D : 23                       inc     hl                ;
187E 187E : 87                       add     a,a               ;
187F 187F : 87                       add     a,a               ;
1880 1880 : 4F                       ld      c,a               ;
1881 1881 : 09                       add     hl,bc             ;
1882 1882 : CD 31 15                 call    MOVRM             ;
1885 1885 : CD CB 13                 call    FMULT             ;
1888 1888 : 3A 1F 38                 ld      a,(RNDCNT)        ;
188B 188B : 3C                       inc     a                 ;
188C 188C : E6 03                    and     3                 ;
188E 188E : 06 00                    ld      b,0               ;
1890 1890 : FE 01                    cp      1                 ;
1892 1892 : 88                       adc     a,b               ;
1893 1893 : 32 1F 38                 ld      (RNDCNT),a        ;
1896 1896 : 21 C7 18                 ld      hl,RNDTB2-4       ;
1899 1899 : 87                       add     a,a               ;
189A 189A : 87                       add     a,a               ;
189B 189B : 4F                       ld      c,a               ;
189C 189C : 09                       add     hl,bc             ;
189D 189D : CD 53 12                 call    FADDS             ;
18A0 18A0 : CD 2E 15   [M80] RND1:   call    MOVRF             ;[M80] SWITCH HO AND LO BYTES,
18A3 18A3 : 7B                       ld      a,e               ;[M80] GET LO
18A4 18A4 : 59                       ld      e,c               ;[M80] PUT HO IN LO BYTE
18A5 18A5 : EE 4F                    xor     $4F               ;
18A7 18A7 : 4F                       ld      c,a               ;[M80] PUT LO IN HO BYTE
18A8 18A8 : 36 80                    ld      (hl),128          ;[M80] MAKE RESULT POSITIVE
18AA 18AA : 2B                       dec     hl                ;[M80] GET POINTER TO EXPONENT
18AB 18AB : 46                       ld      b,(hl)            ;[M80] PUT EXPONENT IN OVERFLOW POSITION
18AC 18AC : 36 80                    ld      (hl),128          ;[M80] SET EXP SO RESULT WILL BE BETWEEN 0 AND 1
18AE 18AE : 21 1E 38                 ld      hl,RNDCNT-1       ;
18B1 18B1 : 34                       inc     (hl)              ;[M80] INCREMENT THE PERTUBATION COUNT
18B2 18B2 : 7E                       ld      a,(hl)            ;[M80] SEE IF ITS TIME
18B3 18B3 : D6 AB                    sub     $AB               ;
18B5 18B5 : 20 04                    jr      nz,NTPTRB         ;
18B7 18B7 : 77                       ld      (hl),a            ;[M80] ZERO THE COUNTER
18B8 18B8 : 0C                       inc     c                 ;
18B9 18B9 : 15                       dec     d                 ;
18BA 18BA : 1C                       inc     e                 ;
18BB 18BB : CD B0 12   (M80) NTPTRB: call    NORMAL            ;[M80] NORMALIZE THE RESULT
18BE 18BE : 21 41 38                 ld      hl,RNDX           ;[M80] SAVE RANDOM NUMBER GENERATED FOR NEXT
18C1 18C1 : C3 3A 15                 jp      MOVMF             ;[M80]  TIME
18C4 18C4 : 77         (M80) RNDSTR: ld      (hl),a            ;[M80] ZERO THE COUNTERS
18C5 18C5 : 2B                       dec     hl                ;
18C6 18C6 : 77                       ld      (hl),a            ;
18C7 18C7 : 2B                       dec     hl                ;
18C8 18C8 : 77                       ld      (hl),a            ;
18C9 18C9 : 18 D5                    jr      RND1              ;
18CB 18CB
18CB 18CB : 68 B1 46 68[M80] RNDTB2: byte    $68,$B1,$46,$68
18CF 18CF : 99 E9 92 69              byte    $99,$E9,$92,$69
18D3 18D3 : 10 D1 75 68              byte    $10,$D1,$75,$68
18D7 18D7
18D7 18D7                  + ;[M80] COSINE FUNCTION
18D7 18D7                  | ;[M80] IDEA: USE COS(X)=SIN(X+PI/2)
18D7 18D7 : 21 53 19   [M80] COS:    ld      hl,PI2            ;[M80] ADD PI/2 TO FAC
18DA 18DA : CD 53 12                 call    FADDS             ;
18DD 18DD
18DD 18DD                  + ;[M80] SINE FUNCTION
18DD 18DD                  | ;[M80] IDEA: USE IDENTITIES TO GET FAC IN QUADRANTS I OR IV
18DD 18DD                  | ;[M80] THE FAC IS DIVIDED BY 2*PI AND THE INTEGER PART IS IGNORED BECAUSE
18DD 18DD                  | ;[M80] SIN(X+2*PI)=SIN(X).  THEN THE ARGUMENT CAN BE COMPARED WITH PI/2 BY
18DD 18DD                  | ;[M80] COMPARING THE RESULT OF THE DIVISION WITH PI/2/(2*PI)=1/4.
18DD 18DD                  | ;[M80] IDENTITIES ARE THEN USED TO GET THE RESULT IN QUADRANTS I OR IV.
18DD 18DD                  | ;[M80] AN APPROXIMATION POLYNOMIAL IS THEN USED TO COMPUTE SIN(X).
18DD 18DD : 3A E7 38   [M80] SIN:    ld      a,(FAC)           ;[M80] WILL SEE IF .LT.2^-10
18E0 18E0 : FE 77                    cp      $77               ;[M80] AND IF SO SIN(X)=X
18E2 18E2 : D8                       ret     c                 ;
18E3 18E3 : 3A E6 38                 ld      a,(FACHO)         ;
18E6 18E6 : B7                       or      a                 ;
18E7 18E7 : F2 F3 18                 jp      p,SIN1            ;[M65] FIRST QUADRANT
18EA 18EA : E6 7F                    and     07FH              ;
18EC 18EC : 32 E6 38                 ld      (FACHO),a         ;
18EF 18EF : 11 0B 15                 ld      de,NEG            ;;Return to NEG
18F2 18F2 : D5                       push    de                ;
18F3 18F3 : 01 22 7E   [M65] SIN1:   ld      bc,$7E22          ;
18F6 18F6 : 11 83 F9                 ld      de,$F983          ;[M80] WILL CALCULATE X=FAC/(2*PI)
18F9 18F9 : CD CB 13                 call    FMULT             ;
18FC 18FC : CD 13 15                 call    PUSHF             ;[M80] SAVE X
18FF 18FF : CD B1 15                 call    INT               ;[M80] FAC=INT(X)
1902 1902 : C1                       pop     bc                ;
1903 1903 : D1                       pop     de                ;[M80] FETCH X TO REGISTERS
1904 1904 : CD 5E 12                 call    FSUB              ;[M80] FAC=X-INT(X)
1907 1907 : 01 00 7F                 ld      bc,$7F00          ;
190A 190A : 11 00 00                 ld      de,$0000          ;[M80] GET 1/4
190D 190D : CD 5B 15                 call    FCOMP             ;[M80] FAC=FAC-1/4
1910 1910 : FA 35 19                 jp      m,SIN2A           ;
1913 1913 : 01 80 7F                 ld      bc,$7F80          ;
1916 1916 : 11 00 00                 ld      de,$0000          ;[M80] -1/4
1919 1919 : CD 61 12                 call    FADD              ;
191C 191C : 01 80 80                 ld      bc,$8080          ;[M80] -1/2
191F 191F : 11 00 00                 ld      de,$0000          ;
1922 1922 : CD 61 12                 call    FADD              ;[M80] X=X-1/2
1925 1925 : EF                       rst     FSIGN             ;[M80] MAKE SURE IF QUADRANTS II,IV
1926 1926 : F4 0B 15                 call    p,NEG             ;[M80] WE WORK WITH 1/4-X
1929 1929 : 01 00 7F                 ld      bc,$7F00          ;
192C 192C : 11 00 00                 ld      de,$0000          ;[M80] 1/4
192F 192F : CD 61 12                 call    FADD              ;
1932 1932 : CD 0B 15                 call    NEG               ;
1935 1935 : 3A E6 38   [M80] SIN2A:  ld      a,(FACHO)         ;[M80] MUST REDUCE TO [0,1/4]
1938 1938 : B7                       or      a                 ;[M80] SIGN IN PSW
1939 1939 : F5                       push    af                ;[M80] SAVE FOR POSSIBLE NEG. AFTER CALC
193A 193A : F2 42 19                 jp      p,SIN3            ;
193D 193D : EE 80                    xor     $80               ;
193F 193F : 32 E6 38                 ld      (FACHO),a         ;[M80] NOW IN [0,1/4]
1942 1942 : 21 5B 19   [M80] SIN3:   ld      hl,SINCON         ;[M80] POINT TO HART COEFFICIENTS
1945 1945 : CD 37 18                 call    POLYX             ;[M80] DO POLY EVAL
1948 1948 : F1                       pop     af                ;[M80] NOW TO DO SIGN
1949 1949 : F0                       ret     p                 ;[M80] OK IF POS
194A 194A : 3A E6 38                 ld      a,(FACHO)         ;[M80] FETCH SIGN BYTE
194D 194D : EE 80                    xor     080H              ;[M80] MAKE NEG
194F 194F : 32 E6 38                 ld      (FACHO),a         ;[M80] REPLACE SIGN
1952 1952 : C9                       ret
1953 1953                        
1953 1953 = DB 0F 49 81[M80] PI2:    byte    $DB,$0F,$49,$81   ;[M80] PI/2
1957 1957 : 00 00 00 7F{M80} FR4:    byte    $00,$00,$00,$7F   ;[M80] 1/4
195B 195B
195B 195B                  + ;[M80] HART ALGORITHM 3341 CONSTANTS
195B 195B                  | ;[M80] NOTE THAT HART CONSTANTS HAVE BEEN SCALED BY A POWER OF 2
195B 195B                  | ;[M80] THIS IS DUE TO RANGE REDUCTION AS A % OF 2*PI RATHER THAN PI/2
195B 195B                  | ;[M80] WOULD NEED TO MULTIPLY ARGUMENT BY 4 BUT INSTEAD WE FACTOR THIS
195B 195B                  | ;[M80] THRU THE CONSTANTS.
195B 195B : 05               SINCON: byte    5                 ;[M80] DEGREE
195C 195C : FB D7 1E 86              byte    $FB,$D7,$1E,$86   ;[M80] .1514851E-3
1960 1960 : 65 26 99 87              byte    $65,$26,$99,$87   ;[M80] -.4673767E-2
1964 1964 : 58 34 23 87              byte    $58,$34,$23,$87   ;[M80] .7968968E-1
1968 1968 : E1 5D A5 86              byte    $E1,$5D,$A5,$86   ;[M80] -.6459637
196C 196C : DB 0F 49 83              byte    $DB,$0F,$49,$83   ;[M80] 1.570796
1970 1970
1970 1970                  + ;[M80] TANGENT FUNCTION
1970 1970                  | ;[M80] TAN(X)=SIN(X)/COS(X)
1970 1970 : CD 13 15   [M80] TAN:    call    PUSHF             ;[M80] SAVE ARG
1973 1973 : CD DD 18                 call    SIN               ;[M80]    TAN(X)=SIN(X)/COS(X)
1976 1976 : C1                       pop     bc                ;[M80] GET X OFF STACK
1977 1977 : E1                       pop     hl                ;[M80] PUSHF SMASHES (DE)
1978 1978 : CD 13 15                 call    PUSHF             ;
197B 197B : EB                       ex      de,hl             ;[M80] GET LO'S WHERE THEY BELONG
197C 197C : CD 23 15                 call    MOVFR             ;
197F 197F : CD D7 18                 call    COS               ;
1982 1982 : C3 2D 14                 jp      FDIVT             ;
1985 1985                                                      
1985 1985                  + ;ARCTANGENT FUNCTION              
1985 1985                  | ;;Not Implemented                 
1985 1985 : F7         [M80] ATN:    rst     HOOKDO            ;;execute hook routine 15 (ATN)
1986 1986 : 0E         {~~~} HOOK14: byte    14                ;;if not implemented
1988 1988 : C3 C4 03                 jp      SNERR             ;;  generate SYNTAX error
198A 198A                                                      
198A 198A -                  ;;Execute OUTCHR                  
198A 198A = F7         [M80] OUTDO:  rst     HOOKDO            ;;execute hook routine 13 (OUTDOX)
198B 198B : 0D         {~~~} HOOK13: byte    13                ;
198C 198C : F5         {M80} OUTCON: push    af                ;
198D 198D : 3A 47 38   {M80} LPTCOD: ld      a,(PRTFLG)        ;[M80] SEE IF WE WANT TO TALK TO LPT
1990 1990 : B7                       or      a                 ;[M80] TEST BITS
1991 1991 : CA D6 19                 jp      z,TTYPOP          ;[M80] IF ZERO THEN NOT
1994 1994                    ;;Print character in [A] to printer
1994 1994 : F1                       pop     af                ;
1995 1995 : F5                       push    af                ;
1996 1996 : FE 09                    cp      9                 ;[M80] TAB
1998 1998 : 20 0C                    jr      nz,NOTABL         ;[M80] NO
199A 199A                    ;;Print spaces until next Tab Stop is reached
199A 199A : 3E 20      (M80) MORSPL: ld      a,' '             ;[M80] GET SPACE
199C 199C : DF                       rst     OUTCHR            ;[M80] SEND IT
199D 199D : 3A 46 38                 ld      a,(LPTPOS)        ;[M80] GET CURRENT PRINT POSIT
19A0 19A0 : E6 07                    and     7                 ;[M80] AT TAB STOP?
19A2 19A2 : 20 F6                    jr      nz,MORSPL         ;[M80] GO BACK IF MORE TO PRINT
19A4 19A4 : F1                       pop     af                ;[M80] POP OFF CHAR
19A5 19A5 : C9                       ret                       ;[M80] RETURN
19A6 19A6                                                      
19A6 19A6 : F1         (M80) NOTABL: pop     af                ;[M80] GET CHAR BACK
19A7 19A7 : F5                       push    af                ;[M80] SAVE AGAIN
19A8 19A8 : D6 0D                    sub     13                ;[M80] IF FUNNY CONTROL CHAR, (LF) DO NOTHING
19AA 19AA : 28 0B                    jr      z,ZERLP1          ;
19AC 19AC : 38 0C                    jr      c,LPTPOP          ;[M80] JUST PRINT CHAR
19AE 19AE : 3A 46 38                 ld      a,(LPTPOS)        ;[M80] GET POSIT
19B1 19B1 : 3C                       inc     a                 ;
19B2 19B2 : FE 84                    cp      132               ;
19B4 19B4 : CC C7 19                 call    z,PRINTW          ;
19B7 19B7 : 32 46 38   (M80) ZERLP1: ld      (LPTPOS),a        ;;Save print pos
19BA 19BA : F1         (~~~) LPTPOP: pop     af                ;;Print character on stack
19BB 19BB : C3 E8 1A   (M80) LPTCHR: jp      LPTOUT            ;;Print raw character to printer
19BE 19BE : AF         [M80] FINLPT: xor     a                 ;[M80] RESET PRINT FLAG SO
19BF 19BF : 32 47 38                 ld      (PRTFLG),a        ;[M80] OUTPUT GOES TO TERMINAL
19C2 19C2 : 3A 46 38                 ld      a,(LPTPOS)        ;[M80] GET CURRENT LPT POSIT
19C5 19C5 : B7                       or      a                 ;[M80] ON LEFT HAND MARGIN ALREADY?
19C6 19C6 : C8                       ret     z                 ;[M80] YES, RETURN
19C719C7                                                       
19C7 19C7 : 3E 0D      (M80) PRINTW: ld      a,13              ;[M80] PUT OUT CRLF
19C9 19C9 : CD BB 19                 call    LPTCHR            ;
19CC 19CC : 3E 0A                    ld      a,10              ;
19CE 19CE : CD BB 19                 call    LPTCHR            ;
19D1 19D1 : AF                       xor     a                 ;[M80] ZERO LPTPOS
19D2 19D2 : 32 46 38                 ld      (LPTPOS),a        ;
19D5 19D5 : C9                       ret                       ;[M80] DONE
19D6 19D6                                                      
19D6 19D6 : F1         [M80] TTYPOP: pop     af                ;Print character on stack to screen
19D7 19D7 : C3 72 1D                 jp      TTYCHR            ;
19DA 19DA
19DA 19DA                    ;[M80] INCHR, TRYIN - CHARACTER INPUT ROUTINES
19DA 19DA = CD 2F 1A   [M80] INCHR:  call    TRYIN             ;;Get Character from Keyboard
19DD 19DD : C9                       ret                       ;
19DE 19DE
19DE 19DE                  + ;;CRDONZ Only does a CR if TTYPOS is not Zero.
19DE 19DE                  | ;;In other words, only print a carriage return when not at left margin.
19DE 19DE : 3A 00 38   [M80] CRDONZ: ld      a,(TTYPOS)        ;[M80] GET CURRENT TTYPOS
19E1 19E1 : B7                       or      a                 ;[M80] SET CC'S
19E2 19E2 : C8                       ret     z                 ;[M80] IF ALREADY ZERO, RETURN
19E3 19E3 : 18 05                    jr      CRDO              ;[M80] DO CR
19E5 19E5 -                  ;;Terminate BUF and Print CR      
19E5 19E5 = 36 00      [M80] FININL: ld      (hl),0            ;[M80] PUT A ZERO AT THE END OF BUF
19E7 19E7 : 21 5F 38                 ld      hl,BUFMIN         ;[M80] SETUP POINTER
19EA 19EA = 3E 0D      [M80] CRDO:   ld      a,13              ;;Print Carriage Return
19EC 19EC : DF                       rst     OUTCHR            ;
19ED 19ED : 3E 0A                    ld      a,10              ;;Print Line Feed
19EF 19EF : DF         {M80} CRFINO: rst     OUTCHR            ;
19F0 19F0 : 3A 47 38   [M80] CRFIN:  ld      a,(PRTFLG)        ;[M80] SEE IF OUTPUTTING TO PRINTER
19F3 19F3 : B7                       or      a                 ;
19F4 19F4 : 28 04                    jr      z,CRCONT          ;[M80] NOT PRINTER, CONTINUE
19F6 19F6 : AF                       xor     a                 ;[M80] CRFIN MUST ALWAYS RETURN WITH A=0
19F7 19F7 : 32 46 38                 ld      (LPTPOS),a        ;;Set Print Head position to 0
19FA 19FA : C9         (M80) CRCONT: ret                       ;
19FB 19FB                                                      
19FB 19FB                    ;;The INKEY$ function             
19FB 19FB : D7         [M80] INKEY:  rst     CHRGET            ;
19FC 19FC : E5                       push    hl                ;[M80] SAVE THE TEXT POINTER
19FD 19FD : CD 18 1A                 call    CHARCG            ;[M80] GET CHARC AND CLEAR IF SET
1A00 1A00 : 28 09                    jr      z,NULRT           ;{M80} NO CHAR, RETURN NULL STRING
1A02 1A02 : F5         {M80} BUFCIN: push    af                ;
1A03 1A03 : CD 4E 0E                 call    STRIN1            ;[M80] MAKE ONE CHAR STRING
1A06 1A06 : F1                       pop     af                ;
1A07 1A07 : 5F                       ld      e,a               ;[M80] CHAR TO [D]
1A08 1A08 : CD 19 10                 call    SETSTR            ;[M80] STUFF IN DESCRIPTOR AND GOTO PUTNEW
1A0B 1A0B : 21 6D 03   (M80) NULRT:  ld      hl,REDDY-1        ;
1A0E 1A0E : 22 E4 38                 ld      (FACLO),hl        ;
1A11 1A11 : 3E 01                    ld      a,1               ;
1A13 1A13 : 32 AB 38                 ld      (VALTYP),a        ;;Set Type to String
1A16 1A16 : E1                       pop     hl                ;
1A17 1A17 : C9                       ret                       ;
1A18 1A18                                                      
1A18 1A18 : E5         [M80] CHARCG: push    hl                ;
1A19 1A19 : 21 0A 38                 ld      hl,CHARC          ;
1A1C 1A1C : 7E                       ld      a,(hl)            ;[M80] GET SAVED CHAR
1A1D 1A1D : 36 00                    ld      (hl),0            ;[M80] CLEAR IT
1A1F 1A1F : B7                       or      a                 ;[M80] IS THERE ONE?
1A20 1A20 : CC 39 1A                 call    z,CNTCCN          ;{M80} SEE IF ITS CONTROL-C          
1A23 1A23 : E1                       pop     hl                ;
1A24 1A24 : C9                       ret                       ; 
1A25 1A25                                                      
1A25 1A25 -                  ;;Check for ^C and ^S             
1A25 1A25 = CD 39 1A   [M80] ISCNTC: call    CNTCCN            ;{M80} SEE IF ITS CONTROL-C          
1A28 1A28 : C8                       ret     z                 ;[M80] IF NONE, RETURN
1A29 1A29 : 32 0A 38                 ld      (CHARC),a         ;{M80} SAVE CHAR
1A2C 1A2C : FE 13                    cp      $13               ;[M80] PAUSE? (^S)
1A2E 1A2E : C0                       ret     nz                ;{M80} IF PAUSE, READ NEXT CHAR
1A2F 1A2F                                                      
1A2F 1A2F = AF         [M80] TRYIN:  xor     a                 ;;Wait for character from keyboard
1A30 1A30 : 32 0A 38                 ld      (CHARC),a         ;{M80} CLEAR SAVED CHAR
1A33 1A33 : CD 39 1A   (~~~) CONIN:  call    CNTCCN            ;
1A36 1A36 : 28 FB                    jr      z,CONIN           ;
1A38 1A38 : C9                       ret                       ;
1A39 1A39                                                      
1A39 1A39 : CD 7E 1E   (~~~) CNTCCN: call    INCHRH            ;{M80} READ THE CHARACTER THAT WAS PRESSED
1A3C 1A3C : FE 03                    cp      3                 ;[M80] ^C?
1A3E 1A3E : 20 0A                    jr      nz,CNTCCR         ;;No, set flags and return
1A40 1A40 -                  ; Check CLOAD Status and Enter Direct Mode
1A40 1A40 = 3A 5E 38         WRMCON: ld      a,(CLFLAG)        ;;Get CLOAD Status
1A43 1A43 : B7                       or      a                 ;;Is it 0?
1A44 1A44 : CC BE 0B                 call    z,SCRTCH          ;;Bad CLOAD, do a NEW
;;;                          Bug Fix: STOPC does not reset Stack Pointer and Text Pointer
1A47      : C3 20 0C                 jp      STOPC             ;;Enter Direct Mode 
     1A47 : C3 CE 1F                 jp      WRMFIN            ;;Finish Warm Start
1A4A 1A4A : B7         (~~~) CNTCCR: or      a                 ;;Set flags
1A4B 1A4B : C9                       ret                       ;
1A4C 1A4C
1A4C 1A4C :                + ;;Pixel Graphics Routines - PSET, PRESET, and POINT
1A4C 1A4C :                | ;;Pixel Graphics are rendered using Semigraphic characters in the
1A4C 1A4C :                | ;;ranges $A0 through $BF and $E0 through $FF of the character set.
1A4C 1A4C :                | ;;
1A4C 1A4C :                | ;;Semigraphic characters are split into a 2 wide by 3 high matrix
1A4C 1A4C :                | ;;of rectangles which are treated as pixels. The pixels inside the 
1A4C 1A4C :                | ;;characters are numbered as follows:
1A4C 1A4C :                | ;;
1A4C 1A4C :                | ;;  0  1
1A4C 1A4C :                | ;;  2  3
1A4C 1A4C :                | ;;  4  5
1A4C 1A4C :                | ;;
1A4C 1A4C :                | ;;All pixel combinations where pixel 5 is off are in range $A0 - $BF
1A4C 1A4C :                | ;;while all combinations where pixel 5 is on are in range $E0 - $FF
1A4C 1A4C :                | ;;
1A4C 1A4C :                | ;;The bit pattern for $A0 - $BF is %101x xxxx, where x is 0 or 1,
1A4C 1A4C :                | ;;and the pattern for $E0 - $FF is %111x xxxx, therefore the ASCII
1A4C 1A4C :                | ;;code for a given bit combination can be represented as:
1A4C 1A4C :                | ;;
1A4C 1A4C :                | ;;  %X5X4321
1A4C 1A4C :                | ;;
1A4C 1A4C :                | ;;where 1-5 is the state of that pixel (1 for on) and X is always 1.
1A4C 1A4C :                | ;;
1A4C 1A4C :                | ;;Semigraphics are the only characters with the bit pattern %1x1x xxxx,
1A4C 1A4C :                | ;;therefore ANDing the character code with $A0 will result in zero
1A4C 1A4C :                | ;;if it is not a semigraphic character.
1A4C 1A4C :                | ;;
1A4C 1A4C :                | ;;
1A4C 1A4C :                | ;;The six pixels in each character cell are displayed in the same
1A4C 1A4C :                | ;;foreground color. The backround color is always black.
1A4C 1A4C :                | ;;
1A4C 1A4C :                | ;;Because a screen character is 8 by 8 screen pixels, the semigraphic
1A4C 1A4C :                | ;;pixels, while all 4 screen pixels wide, vary in height, whith the
1A4C 1A4C :                | ;;top and bottom pixels (0,1,4,5) being 3 screen pixels tall and the
1A4C 1A4C :                | ;;middle pixels (2,3) being 2 screen pixels tall.
1A4C 1A4C :                | ;;
1A4C 1A4C : 
1A4C 1A4C : AF               PRESET: xor     a                 ;[EBU] PRESET FLAG
1A4D 1A4D : 18 02                    jr      PPRSET            ;
1A4F 1A4F : 3E 01            PSET:   ld      a,1               ;[EBU] PSET FLAG
1A51 1A51 : 08               PPRSET: ex      af,af'            ;;Save PSET/PRESET flag
1A52 1A52 : CD 7F 1A                 call    SCAND             ;;Parse (X,Y)
1A55 1A55 -                  ;;Execute PSET/PRESET
1A55 1A55                    ;;Arguments: BC = X-coord, DE = Y-coord, A = 0 for PRESET, else PSET
1A55 1A55 = CD 8E 1A   (~~~) PPRSDO: call    SCALXY            ;;Convert X,Y
1A58 1A58 : 28 02                    jr      z,RSETC           ;;Semigraphics at screen location?
1A5A 1A5A : 36 A0                    ld      (hl),$A0          ;;No, store base semigraphic
1A5C 1A5C : 08         (~~~) RSETC:  ex      af,af'            ;;Restore PSET/PRESET flag 
1A5D 1A5D : B7                       or      a                 ;;Set flags
1A5E 1A5E : 1A                       ld      a,(de)            ;;Get semigraphic offset
1A5F 1A5F : 20 03                    jr      nz,PSETC          ;;PRESET?
1A61 1A61 : 2F                       cpl                       ;;Invert to create mask
1A62 1A62 : A6                       and     (hl)              ;;and clear offset bit
1A63 1A63 : 06                       byte    $06               ;;"LD B," around next instruction
1A64 1A64 : B6         (~~~) PSETC:  or      (hl)              ;;If PRESET, set offset bit
1A65 1A65 : 77                       ld      (hl),a            ;;Store at screen location
1A66 1A66 : E1                       pop     hl                ;;Restore text pointer
1A67 1A67 : C9                       ret                       ;
1A68 1A68
1A68 1A68                    ;;The PPOINT function
1A68 1A68 : D7               POINT:  rst     CHRGET            ;;Eat character
1A69 1A69 : CD 7F 1A                 call    SCAND             ;;Parse (X,Y)
1A6C 1A6C : CD 8E 1A                 call    SCALXY            ;;Convert X,Y
1A6F 1A6F : 20 06                    jr      nz,POINTZ         ;;Not semigraphics? Return 0
1A71 1A71 : 1A                       ld      a,(de)            ;;Get bit offset
1A72 1A72 : A6                       and     (hl)              ;;Mask with screen character
1A73 1A73 : 16 01                    ld      d,1               ;
1A75 1A75 : 20 02                    jr      nz,POINTR         ;;Bit set? Return 1
1A77 1A77 : 16 00            POINTZ: ld      d,0               ;
1A79 1A79 : AF               POINTR: xor     a                 ;;Clear Accumulator 
1A7A 1A7A : CD 23 0B                 call    FLOATD             ;
1A7D 1A7D : E1                       pop     hl                ;;Restore text pointer
1A7E 1A7E : C9                       ret                       ;
1A7F 1A7F
1A7F 1A7F                    ;;Get parameters for PSET, PRESET, POINT, and SOUND
1A7F 1A7F                    ;;Scans program text in the format (x-coord,y-coord)
1A7F 1A7F                    ;;Returns x-coord in BC, y-coord in DE
1A7F 1A7F : CF         [GWB] SCAND:  rst     SYNCHK
1A80 1A80 : 28                       byte    '('               ;[GWB] SKIP OVER OPEN PAREN
1A81 1A81 : CD D0 1A                 call    GETINT            ;[GWB] SCAN X INTO [D,E]
1A84 1A84 : D5                       push    de                ;[GWB] SAVE WHILE SCANNING Y
1A85 1A85 : CF                       rst     SYNCHK            ;
1A86 1A86 : 2C                       byte    ','               ;[GWB] SCAN COMMA
1A87 1A87 : CD D0 1A                 call    GETINT            ;[GWB] GET Y INTO [D,E]
1A8A 1A8A : CF                       rst     SYNCHK            ;
1A8B 1A8B : 29                       byte    ')'               ;{GWB} SKIP OVER CLOSE PAREN
1A8C 1A8C : C1                       pop     bc                ;[GWB] GET BACK X INTO [B,C]
1A8D 1A8D : C9                       ret                       ;
1A8E1A8E
1A8E 1A8E                  + ;;Convert PSET Coordinates to Screen Position and Character Mask
1A8E 1A8E                  | ;;On entry: BC = X-Coordinate 
1A8E 1A8E                  | ;;          DE = Y-Coordinate
1A8E 1A8E                  | ;;If BC > 71 or DE > 79, generates an FC error
1A8E 1A8E                  | ;;On exit: A = Masked Character at Screen Offset
1A8E 1A8E                  | ;;        DE = Address of Character Offset
1A8E 1A8E                  | ;;        HL = Offset into Screen
1A8E 1A8E : E3         [GWB] SCALXY: ex      (sp),hl           ;;Save Registers
1A8F 1A8F : E5                       push    hl                
1A90 1A90 : C5                       push    bc                ;;BC=X Coordinate
1A91 1A91 : D5                       push    de                ;;DE=Y Coordinate
1A92 1A92 : 21 47 00                 ld      hl,71             
1A95 1A95 : E7                       rst     COMPAR            ;;If Y greater than 71
1A96 1A96 : DA 97 06   (~~~) FCERRP: jp      c,FCERR           ;;Function Call error
1A99 1A99 : 21 4F 00                 ld      hl,79             
1A9C 1A9C : C5                       push    bc                
1A9D 1A9D : D1                       pop     de                
1A9E 1A9E : E7                       rst     COMPAR            ;;If X greater than 79
1A9F 1A9F : 38 F5                    jr      c,FCERRP          ;;Function Call error
1AA1 1AA1 : D1                       pop     de                
1AA2 1AA2 : C1                       pop     bc                
1AA3 1AA3 : 21 28 30                 ld      hl,SCREEN+40      ;;Starting screen offset
1AA6 1AA6 : 7B                       ld      a,e               ;;A=Y Coordinate
1AA7 1AA7 : 11 28 00                 ld      de,40             ;;Screen width
1AAA 1AAA : FE 03            SCALPY: cp      3                 ;;Less than 3?
1AAC 1AAC : 38 06                    jr      c,SCALEX          ;;Convert X
1AAE 1AAE : 19                       add     hl,de             ;;Add a line to offset
1AAF 1AAF : 3D                       dec     a                 ;;Subtract 3
1AB0 1AB0 : 3D                       dec     a                 ;
1AB1 1AB1 : 3D                       dec     a                 ;
1AB2 1AB2 : 18 F6                    jr      SCALPY            ;;Repeat
1AB4 1AB4 : 07               SCALEX: rlca                      ;;Multiply remainder by 2
1AB5 1AB5 : CB 29                    sra     c                 ;;Column = X-Coordinate / 2 
1AB7 1AB7 : 30 01                    jr      nc,SCALES         ;;Was it odd?
1AB9 1AB9 : 3C                       inc     a                 ;;Yes, add one to remainder
1ABA 1ABA : 09               SCALES: add     hl,bc             ;;Add column to screen offset
1ABB 1ABB : 11 CA 1A                 ld      de,BITTAB         ;
1ABE 1ABE : B7               SCALEB: or      a                 ;;Check bit#
1ABF 1ABF : 28 04                    jr      z,SCALEC          ;;If not 0
1AC1 1AC1 : 13                       inc     de                ;;  Bump table pointer
1AC2 1AC2 : 3D                       dec     a                 ;;  Decrement bit#
1AC3 1AC3 : 18 F9                    jr      SCALEB            ;;  and repeat
1AC5 1AC5 : 7E               SCALEC: ld      a,(hl)            ;;Get character at screen offset
1AC6 1AC6 : F6 A0                    or      $A0               ;;and return it with
1AC8 1AC8 : AE                       xor     (hl)              ;;bits 5 and 7 cleared
1AC9 1AC9 : C9                       ret                       ;
1ACA 1ACA :
1ACA 1ACA -                  ;;Semigraphic Pixel Index to Bit Mask Table
1ACA 1ACA =  01 02 04        BITTAB: byte    %00000001,%00000010,%00000100
1ACE 1ACE : 08 10 40                 byte    %00001000,%00010000,%01000000
1AD0 1AD0                    
1AD0 1AD0                    ;;Parse an Integer                     
1AD0 1AD0 : CD 85 09         GETINT: call    FRMEVL            ;;Get a number
1AD3 1AD3 : C3 82 06                 jp      FRCINT            ;;Convert to an Integer
1AD6 1AD6
1AD6 1AD6 : D5               SOUND:  push    de
1AD7 1AD7 : CD 7F 1A                 call    SCAND
1ADA 1ADA : E5                       push    hl
1ADB 1ADB : CD 64 1E                 call    SOUNDS
1ADE 1ADE : E1                       pop     hl
1ADF 1ADF : D1                       pop     de
1AE0 1AE0 : C9                       ret
1AE1 1AE1
1AE1 1AE1                    ;;Print CR/LF to printer
1AE1 1AE1 : 3E 0D            LPCRLF: ld      a,13              ;;Send CR to printer
1AE3 1AE3 : CD E8 1A                 call    LPTOUT            ;
1AE6 1AE6 : 3E 0A                    ld      a,10              ;;Send LF to printer
1AE8 1AE8              [M80] LPTOUT: ;Primitive print character to printer routine
1AE8 1AE8 : F7                       rst     HOOKDO            ;;Call Extended ROM Hook Routine
1AE9 1AE9 : 11         {~~~} HOOK17: byte    17                ;
1AEA 1AEA : F5                       push    af                ;;Save character
1AEB 1AEB : F5                       push    af                ;;Save Registers
1AEC 1AEC : D9                       exx                       ;
1AED 1AED : DB FE            LPTRDY: in      a,($FE)           ;;Wait for printer to be ready
1AEF 1AEF : E6 01                    and     1                 ;
1AF1 1AF1 : 28 FA                    jr      z,LPTRDY          ;
1AF3 1AF3                    ;;Send framed byte to printer port
1AF3 1AF3 : CD 08 1B   {~~~} OUTBYT: call    OUTBIZ            ;;Send Start Bit
1AF6 1AF6 : 1E 08                    ld      e,8               ;;Send 8 bits to printer
1AF8 1AF8 : F1                       pop     af                ;;Restore character
1AF9 1AF9 : CD 0A 1B         OUTBTS: call    OUTBIT            ;;Send bit 0 to printer
1AFC 1AFC : 0F                       rrca                      ;;Rotate bits
1AFD 1AFD : 1D                       dec     e                 ;;Decrement counter and loop
1AFE 1AFE : 20 F9                    jr      nz,OUTBTS         ;
1B00 1B00 : 3E 01                    ld      a,1               ;;Send Stop Bit
1B02 1B02 : CD 0A 1B                 call    OUTBIT            ;
1B05 1B05 : D9                       exx                       ;;Restore Registers
1B06 1B06 : F1                       pop     af                ;
1B07 1B07 : C9                       ret                       ;
1B08 1B08
1B08 1B08                    ;;Send zero bit to printer port
1B08 1B08 : 3E 00            OUTBIZ: ld      a,0               ;Write zero bit to printer port
1B0A 1B0A                    ;;Send bit 0 of A to printer port
1B0A 1B0A : D3 FE            OUTBIT: out     ($FE),a           ;;Write bit to printer port
1B0C 1B0C : 26 B1                    ld      h,177             ;;Wait 2,849 cycles (700 microseconds)
1B0E 1B0E : 25               OUTDLY: dec     h                 ;;Wait [HL]*16+17 cycles
1B0F 1B0F : 20 FD                    jr      nz,OUTDLY         ;
1B11 1B11 : 00                       nop                       ;
1B12 1B12 : 00                       nop                       ;
1B13 1B13 : 00                       nop                       ;
1B14 1B14 : C9                       ret                       ;
1B15 1B15
1B15 1B15                    ;;Copy Screen Contents to Printer
1B15 1B15                    ;;Assumes printer line width is 40
1B15 1B15 : E5               COPY:   push    hl                ;;Save Text Pointer
1B16 1B16 : D5                       push    de                ;
1B17 1B17 : CD E1 1A                 call    LPCRLF            ;;Print CR/LF
1B1A 1B1A : 21 28 30                 ld      hl,SCREEN+40      ;;Row 1, Column 0
1B1D 1B1D : 11 E8 33                 ld      de,SCREEN+1000    ;;End of Screen
1B20 1B20 : 7E         (~~~) COPY1:  ld      a,(hl)            ;;Get Screen Character
1B21 1B21 : CD E8 1A                 call    LPTOUT            ;;Print it
1B24 1B24 : 23                       inc     hl                ;;Bump pointer
1B25 1B25 : E7                       rst     COMPAR            ;;Are we there yet?
1B26 1B26 : 38 F8                    jr      c,COPY1           ;;No, do it again
1B28 1B28 : CD E1 1A                 call    LPCRLF            ;;Print CR/LF
1B2B 1B2B : D1                       pop     de                ;
1B2C 1B2C : E1                       pop     hl                ;;Restore Text Pointer
1B2D 1B2D : C9                       ret                       ;
182E 182E
1B2E 1B2E                  + ;;Display Tape Control Messages
1B2E 1B2E                  | ;;Displays control messages, then waits for RETURN key
1B2E 1B2E                  | ;;PPLAY displays CLOAD message
1B2E 1B2E                  | ;;PRECRD displays CSAVE message
1B2E 1B2E                  | ;;Preserves all registers
1B2E 1B2E : E5               PPLAY:  push    hl                ;;Save all Registers
1B2F 1B2F : D5                       push    de                ;
1B30 1B30 : C5                       push    bc                ;
1B31 1B31 : 21 E8 1B                 ld      hl,PLAYT          ;;"Press <PLAY>" 
1B34 1B34 : F5               PRETRN: push    af                ;;Entry point for "Press <RECORD>"
1B35 1B35 : CD 9D 0E                 call    STROUT            ;
1B38 1B38 : 21 B5 00                 ld      hl,STARTT         ;
1B3B 1B3B : CD 9D 0E                 call    STROUT            ;;Print "Press RETURN key to start"
1B3E 1B3E : CD 7E 1E   (~~~) PRETRL: call    INCHRH            ;
1B41 1B41 : FE 0D                    cp      13                ;
1B43 1B43 : 20 F9                    jr      nz,PRETRL         ;;Wait for RETURN key
1B45 1B45 : CD EA 19                 call    CRDO              ;Print CR/LF
1B48 1B48 : F1                       pop     af                ;
1B49 1B49 : C1                       pop     bc                ;
1B4A 1B4A : D1                       pop     de                ;
1B4B 1B4B : E1                       pop     hl                ;;Restore all Registers
1B4C 1B4C : C9                       ret                       ;
1B4D 1B4D
1B4D 1B4D                  + ;;Read Byte from Tape
1B4D 1B4D                  | ;;Returns Byte in A
1B4D 1B4D                  | ;;All other registers preserved
1B4D 1B4D : D9               RDBYTE: exx                       ;;Save index registers
1B4E 1B4E : 0E FC                    ld      c,252             ;;Tape I/O Port
1B50 1B50 : CD 62 1B   (~~~) RDBYT2: call    RDBIT             ;;Wait for Start Bit (0)
1B53 1B53 : 38 FB                    jr      c,RDBYT2          ;
1B55 1B55 : 26 08                    ld      h,8               ;;Now read 8 bits
1B57 1B57 : CD 62 1B         RDBYT3: call    RDBIT             ;;Read next bit
1B5A 1B5A : CB 15                    rl      l                 ;;Rotate into L
1B5C 1B5C : 25                       dec     h                 ;
1B5D 1B5D : 20 F8                    jr      nz,RDBYT3         ;;Loop until done
1B5F 1B5F : 7D                       ld      a,l               ;;Copy byte into A
1B60 1B60 : D9                       exx                       ;;Restore index registers
1B61 1B61 : C9                       ret                       ;
1B62 1B62
1B62 1B62                  + ;;Read Bit from Tape
1B62 1B62                  | ;;Looks for a pulse train of two square waves with leading
1B62 1B62                  | ;;negative halves, then measures the total length of the
1B62 1B62                  | ;;square waves in cycles and compares it to a threshold
1B62 1B62                  | ;;of 2633 cycles, which (at a clock speed of 3.579545 MHz)
1B62 1B62                  | ;;equates to 1369 microseconds, about halfway between the
1B62 1B62                  | ;;1723 and 868 microseconds for a mark and space, respectively.
1B62 1B62                  | ;
1B62 1B62                    ;;First wait for the leading negative half of the pulse train
1B62 1B62 : ED 78            RDBIT:  in      a,(c)             ;;Read tape port
1B64 1B64 : 1F                       rra                       ;;Rotate low bit into Carry
1B65 1B65 : 38 FB                    jr      c,RDBIT           ;;If 1, do it again
1B66 1B66                  + ;;Then wait for the start of the positive half of the square wave
1B67 1B67                  | ;;Ends 15 cycles after detection
1B67 1B67 : ED 78      (~~~) RDBIT2: in      a,(c)             ;;Read tape port
1B69 1B69 : 1F                       rra                       ;;Rotate low bit into Carry     
1B6A 1B6A : 30 FB                    jr      nc,RDBIT2         ;;If 0, do it again             
1B6C 1B6C : AF                       xor     a                 ;;Start counter at 0            
1B6D 1B6D                  + ;;Now measure length of positive half
1B6D 1B6D                  | ;;Total cycles is iterations * 36 - 5
1B6D 1B6D : 3C         (~~~) RDBIT3: inc     a                 ;;Increment counter            
1B6E 1B6E : ED 40                    in      b,(c)             ;;Read tape port               
1B70 1B70 : CB 18                    rr      b                 ;;Rotate low bit into Carry    
1B72 1B72 : 38 F9                    jr      c,RDBIT3          ;;If 1, do it again            
1B74 1B74                  + ;;Add length of negative half
1B74 1B74                  | ;;Total cycles is iterations * 36 - 5
1B74 1B74 : 3C         (~~~) RDBIT4: inc     a                 ;;Increment counter             
1B75 1B75 : ED 40                    in      b,(c)             ;;Read tape port
1B77 1B77 : CB 18                    rr      b                 ;;Rotate low bit into Carry
1B79 1B79 : 30 F9                    jr      nc,RDBIT4         ;;If 0, do it again
1B7B 1B7B                  + ;;Check Total Length
1B7B 1B7B                  | ;;Total length in cycles is A*36+5. 
1B7B 1B7B : FE 49                    cp      73                ;;Set Carry if at least 2633 cycles
1B7D 1B7D : C9                       ret                       ;
1B7E 1B7E                                                      
1B7E 1B7E : C9         (~~~) RWARYR: ret                       ;;Return from RWARYD
1B7F 1B7F
1B7F 1B7F                    ;;CSAVE tape control
1B7F 1B7F : E5               PRECRD: push    hl                ;;Save Registers
1B80 1B80 : D5                       push    de                ;
1B81 1B81 : C5                       push    bc                ;
1B82 1B82 : 21 F7 1B                 ld      hl,RECORT         ;;"Press <RECORD>"
1B85 1B85 : 18 AD                    jr      PRETRN            ;;Wait for RETURN  
1B87 1B87                                                      
1B87 1B87                    ;;Write byte to tape twice        
1B87 1B87 : CD 8A 1B         WRBYT2: call    WRBYTE            ;;Call WRBYTE, then drop into it
1B8A 1B8A                    
1B8A 1B8A                    ;;Write framed byte to tape                    
1B8A 1B8A                    ;;Writes a start bit (0) , the bits of the byte, then two stop bits (1)
1B8A 1B8A : F5               WRBYTE: push    af                ;;Save all registers
1B8B 1B8B : D9                       exx                       ;
1B8C 1B8C : 0E FC                    ld      c,252             ;;Tape I/O Port           
1B8E 1B8E : F5                       push    af                ;;Save byte
1B8F 1B8F : AF                       xor     a                 ;
1B90 1B90 : 1E 01                    ld      e,1               ;
1B92 1B92 : CD A5 1B                 call    WRBITS            ;;Write start bit ($00) 
1B95 1B95 : F1                       pop     af                ;;Restore byte
1B96 1B96 : 1E 08                    ld      e,8               ;
1B98 1B98 : CD A5 1B                 call    WRBITS            ;;Write 8 bits of byte
1B9B 1B9B : 3E FF                    ld      a,$FF             ;
1B9D 1B9D : 1E 02                    ld      e,2               ;
1B9F 1B9F : CD A5 1B                 call    WRBITS            ;;Write stop bits (2 x $FF)
1BA2 1BA2 : D9                       exx                       ;
1BA3 1BA3 : F1                       pop     af                ;;Restore all registers
1BA4 1BA4 : C9                       ret                       ;
1BA5 1BA5
1BA5 1BA5                  + ;;Write E most significant bits of A to Tape
1BA5 1BA5                  | ;;Each bit is written as two full square waves, negative half first
1BA5 1BA5                  | ;;The leading negative half and trailing positive half frame the
1BA5 1BA5                  | ;;(positive half first) square wave (that RDBITS looks for 
1BA5 1BA5                  | ;;A mark (1) and space (0) have wave lengths of 2078 and 4126 cycles,
1BA5 1BA5                  | ;;respectively. At a clock speed of 3.579545 MHz, these equate to
1BA5 1BA5                  | ;;1723 and 868 microseconds, resulting in approximate frequencies
1BA5 1BA5                  | ;;of 1723 Hz for a mark and 868 Hz for a space. 
1BA5 1BA5 : 17               WRBITS: rla                       ;;Rotate MSB into Carry
1BA6 1BA6 : 2E 40                    ld      l,64              ;;Preset Pulse Length 1,039 cycles for a 1
1BA8 1BA8 : 38 02                    jr      c,WRBIT2          ;;Was bit a 1?
1BAA 1BAA : 2E 80                    ld      l,128             ;;No, set Pulse Length 2,063 cycles for a 0
1BAC 1BAC                    ;;Write Bit with Pulse Length L   ;
1BAC 1BAC : 06 04            WRBIT2: ld      b,4               ;;Countdown - + - +                  
1BAE 1BAE : ED 41            WRBIT3: out     (c),b             ;;Writing 0, 1, 0, 1  
1BB0 1BB0 : 65                       ld      h,l               ;;Each pulse is L*16+15 cycles      
1BB1 1BB1 : 25               WRBIT4: dec     h                 ;                4     
1BB2 1BB2 : 20 FD                    jr      nz,WRBIT4         ;                                   
1BB4 1BB4 : 05                       dec     b                 ;                                   
1BB5 1BB5 : 20 F7                    jr      nz,WRBIT3         ;;Write next pulse                  
1BB7 1BB7 : 1D                       dec     e                 ;
1BB8 1BB8 : 20 EB                    jr      nz,WRBITS         ;;Write next bit
1BBA 1BBA : C9                       ret                       ;
1BBB 1BBB : C9                       ret                       ;;Orphan instruction
1BBC 1BBC                                                      
1BBC 1BBC                  + ;;Write SYNC to tape              
1BBC 1BBC                  | ;;Writes 12 $FF then a $00        
1BBC 1BBC                  | ;;All registers preserved         
1BBC 1BBC : F5               WRSYNC: push    af                ;;Save registers
1BBD 1BBD : C5                       push    bc                ;
1BBE 1BBE : 06 0C                    ld      b,12              ;
1BC0 1BC0 : 3E FF            WRSYN2: ld      a,$FF             ;
1BC2 1BC2 : CD 8A 1B                 call    WRBYTE            ;;Write $FF to tape
1BC5 1BC5 : 10 F9                    djnz    WRSYN2            ;;Do it 11 more times
1BC7 1BC7 : AF                       xor     a                 ;
1BC8 1BC8 : CD 8A 1B                 call    WRBYTE            ;;Write $00 to tape
1BCB 1BCB : C1                       pop     bc                ;
1BCC 1BCC : F1                       pop     af                ;;Restore registers
1BCD 1BCD : C9                       ret                       ;
1BCE 1BCE
1BCE 1BCE                  + ;;Read SYNC from tape
1BCE 1BCE                  | ;;Reads bytes until it gets 6 $FF followed by a $00
1BCE 1BCE                  | ;;All registers preserved
1BCE 1BCE : F5               RDSYNC: push    af                ;;Save registers
1BCF 1BCF : C5                       push    bc                ;
1BD0 1BD0 : 06 06      (~~~) RDSYN1: ld      b,6               ;;Do 6 times
1BD2 1BD2 : CD 4D 1B   (~~~) RDSYN2: call    RDBYTE            ;
1BD5 1BD5 : 3C                       inc     a                 ;
1BD6 1BD6 : 20 F8                    jr      nz,RDSYN1         ;;If not $FF, start all over
1BD8 1BD8 : 10 F8                    djnz    RDSYN2            ;;Repeat until 6 $FF read
1BDA 1BDA : CD 4D 1B   (~~~) RDSYN3: call    RDBYTE            ;
1BDD 1BDD : B7                       or      a                 ;
1BDE 1BDE : 28 05                    jr      z,RDSYN4          ;;If $00, we are done
1BE0 1BE0 : 3C                       inc     a                 ;
1BE1 1BE1 : 28 F7                    jr      z,RDSYN3          ;;If $FF, read another byte
1BE3 1BE3 : 18 EB                    jr      RDSYN1            ;;Otherwise, start all over
1BE5 1BE5 : C1         (~~~) RDSYN4: pop     bc                ;
1BE6 1BE6 : F1                       pop     af                ;;Restore registers
1BE7 1BE7 : C9                       ret                       ;
1BE8 1BE8
1BE8 1BE8 : 50 72 65 73[~~~] PLAYT:  byte    "Press <PLAY>",13,10,0          ;
1BEC 1BEC : 73 20 3C 50
1BF0 1BF0 : 4C 41 59 3E
1BF4 1BF4 : 0D 0A 00   
1BF7 1BF7
1BF7 1BF7 : 50 72 65 73[~~~] RECORT: byte    "Press <RECORD>",13,10,0        ;
1BFB 1BFB : 73 20 3C 52
1BFF 1BFF : 45 43 4F 52
1C03 1C03 : 44 3E 0D 0A
1C07 1C07 : 00         
1C08 1C08
1C08 1C08 : F7         [~~~] CSAVE:  rst     HOOKDO            ;
1C09 1C09 : 15         {~~~} HOOK21: byte    21                ;
1C0A 1C0A : FE AA                    cp      MULTK             ;;If * Token
1C0C 1C0C : CA 62 0C                 jp      z,CSARY           ;;Do CSAVE*
1C0F 1C0F : CD B8 1C                 call    NAMFIL            ;;Scan filename
1C12 1C12 : E5                       push    hl                ;;Save text pointer
1C13 1C13 : CD 25 1D                 call    WRHEAP            ;
1C16 1C16 : 2A 4F 38                 ld      hl,(TXTTAB)       ;
1C19 1C19 : CD 38 1D                 call    CSAVEP            ;
1C1C 1C1C : 06 0F      (~~~) WRTAIL: ld      b,15              ;;Write 15 $00 to tape
1C1E 1C1E : AF                       xor     a                 ;
1C1F 1C1F : CD 8A 1B   (~~~) CSAVE3: call    WRBYTE            ;
1C22 1C22 : 10 FB                    djnz    CSAVE3            ;
1C24 1C24 : 01 40 1F                 ld      bc,8000           ;
1C27 1C27 : CD 4B 1D                 call    SLEEP             ;;Delay 200,000 cycles ~ 50 milliseconds
1C2A 1C2A : E1                       pop     hl                ;;Restore Text Pointer
1C2B 1C2B : C9                       ret                       ;
1C2C 1C2C                                                      
1C2C 1C2C : F7         [~~~] CLOAD:  rst     HOOKDO            
1C2D 1C2D : 14         {~~~} HOOK20: byte    20                
1C2E 1C2E : FE AA                    cp      MULTK             ;;Check for token after CLOAD
1C30 1C30 : CA 63 0C                 jp      z,CLARY           ;;If *, CLOAD variable
1C33 1C33 : D6 95                    sub     PRINTK            ;
1C35 1C35 : 28 02                    jr      z,CLOADQ          ;;If ?, A will be $FF (verify)
1C37 1C37 : AF                       xor     a                 ;;otherwise it will be 0 (load)
1C38 1C38 : 01                       byte    $01               ;;"LD BC," over two instructions
1C39 1C39 : 2F         (~~~) CLOADQ: cpl                       ;;A = $FF
1C3A 1C3A : 23                       inc     hl                ;;Bump text pointer
1C3B 1C3B : FE 01                    cp      1                 ;;If A is 0, set C, else clear C 
1C3D 1C3D : F5                       push    af                ;;Save A and C
1C3E 1C3E : 3E FF                    ld      a,$FF             ;
1C40 1C40 : 32 5E 38                 ld      (CLFLAG),a        ;;Set Cload Flag to $FF
1C43 1C43 : CD B1 1C                 call    NAMFIN            ;;Get FILNAM if present
1C46 1C46                  + ;;Look for Filename
1C46 1C46                  | ;;Reads tape until a file matching FILNAM is found
1C46 1C46                  | ;;If first character of FILNAM is NUL, matches next file on tape
1C46 1C46 : AF         (~~~) CLOADF: xor     a                 ;
1C47 1C47 : 32 5D 38                 ld      (INSYNC),a        ;;Clear SYNC flag
1C4A 1C4A : D5                       push    de                ;
1C4B 1C4B : CD 2E 1B                 call    PPLAY             ;;"Press <PLAY>", wait for RETURN
1C4E 1C4E : CD D9 1C                 call    RDHEAD            ;
1C51 1C51 : 21 57 38                 ld      hl,FILNAF         ;;Filename found on tape
1C54 1C54 : CD ED 1C                 call    CMPNAM            ;;Compare with FILNAM
1C57 1C57 : D1                       pop     de                ;
1C58 1C58 : 28 12                    jr      z,CLOADC          ;;If they match, continue CLOAD
1C5A 1C5A : 21 06 1D                 ld      hl,SKIPT          ;
1C5D 1C5D : CD 0D 1D                 call    OUTNAM            ;;"Skip: " + NAMFIL
1C60 1C60 : 06 0A      (~~~) CLOADE: ld      b,10              ;;???Skip to end of file
1C62 1C62 : CD 4D 1B   (~~~) CLOAD2: call    RDBYTE            ;
1C65 1C65 : B7                       or      a                 ;
1C66 1C66 : 20 F8                    jr      nz,CLOADE         ;;Not $00, start over
1C68 1C68 : 10 F8                    djnz    CLOAD2            ;;Loop until 10 in a row
1C6A 1C6A : 18 DA                    jr      CLOADF            ;;Check next file
1C6C 1C6C : 21 FE 1C   (~~~) CLOADC: ld      hl,FOUNDT         ;
1C6F 1C6F : CD 0D 1D                 call    OUTNAM            ;;"Found:" + NAMFIL
1C72 1C72 : F1                       pop     af                ;;Restore mode
1C73 1C73 : 32 E4 38                 ld      (FACLO),a         ;;and aave it
1C76 1C76 : DC BE 0B                 call    c,SCRTCH          ;;If not CLOAD?, do a NEW
1C79 1C79 : 3A E4 38                 ld      a,(FACLO)         ;;Get mode back
1C7C 1C7C : FE 01                    cp      1                 ;;and check it
1C7E 1C7E : 32 5E 38                 ld      (CLFLAG),a        ;;Store in FlagE
1C81 1C81 : 2A 4F 38                 ld      hl,(TXTTAB)       ;;Set pointer to BASIC program
1C84 1C84 : CD 51 1D                 call    CLOADP            ;;Load/verify program
1C87 1C87 : 20 11                    jr      nz,CLOADV         ;;Check CLOAD? status
1C89 1C89 : 22 D6 38                 ld      (VARTAB),hl       ;;Set end of program
1C8C 1C8C : 21 6E 03   (~~~) CLOADR: ld      hl,REDDY          ;
1C8F 1C8F : CD 9D 0E                 call    STROUT            ;[M80] PRINT "OK" PREMATURELY
1C92 1C92 : 3E FF                    ld      a,$FF             ;
1C94 1C94 : 32 5E 38                 ld      (CLFLAG),a        ;;Set FlagE to $FF
1C97 1C97 : C3 80 04                 jp      FINI              ;
1C9A 1C9A : 23         (~~~) CLOADV: inc     hl                ;
1C9B 1C9B : EB                       ex      de,hl             ;
1C9C 1C9C : 2A D6 38                 ld      hl,(VARTAB)       ;
1C9F 1C9F : E7                       rst     COMPAR            ;;Text pointer past end of program?
1CA0 1CA0 : 38 EA                    jr      c,CLOADR          ;;Yes, CLOAD? successful
1CA2 1CA2 : 21 AB 1C                 ld      hl,BADT           ;
1CA5 1CA5 : CD 9D 0E                 call    STROUT            ;;"Bad"
1CA8 1CA8 : C3 01 04                 jp      STPRDY            ;;Abort to direct mode
1CAB 1CAB
1CAB      : 42 61 E4         BADT:   byte    "Ba",'d'+128
     1CAB : 42 61 64 0D      BADT:   byte    "Bad"
1CAE 1CAE : 0D 0A 00                 byte    13,10,0
1CB1 1CB1                    ;;Scan a Filename for CLOAD command
1CB1 1CB1 : AF               NAMFIN: xor     a                 ;;Store 0
1CB2 1CB2 : 32 51 38                 ld      (FILNAM),a        ;;in first character of FILNAM
1CB5 1CB5 : 2B                       dec     hl                ;;Backup text pointer
1CB6 1CB6 : D7                       rst     CHRGET            ;;Check for terminator
1CB7 1CB7 : C8                       ret     z                 ;;If found, return
1CB8 1CB8
1CB8 1CB8                    ;{GWB} Scan a Filename for CSAVE command                    
1CB8 1CB8 : CD 85 09   [GWB] NAMFIL: call    FRMEVL            ;[GWB] Evaluate string
1CBB 1CBB : E5                       push    hl                ;[GWB] save text pointer
1CBC 1CBC : CD 06 10                 call    ASC2              ;;DE = Pointer to File Name
1CBF 1CBF : 2B                       dec     hl                ;
1CC0 1CC0 : 2B                       dec     hl                ;
1CC1 1CC1 : 2B                       dec     hl                ;
1CC2 1CC2 : 46                       ld      b,(hl)            ;
1CC3 1CC3 : 0E 06                    ld      c,6               ;;Maximum File Name Length
1CC5 1CC5 : 21 51 38                 ld      hl,FILNAM         ;
1CC8 1CC8 : 1A         (~~~) NAMFL1: ld      a,(de)            ;;Copy String to FILNAM
1CC9 1CC9 : 77                       ld      (hl),a            ;
1CCA 1CCA : 23                       inc     hl                ;
1CCB 1CCB : 13                       inc     de                ;
1CCC 1CCC : 0D                       dec     c                 ;
1CCD 1CCD : 28 08                    jr      z,NAMFL3          ;
1CCF 1CCF : 10 F7                    djnz    NAMFL1            ;
1CD1 1CD1 : 41                       ld      b,c               ;
1CD2 1CD2 : 36 00      (~~~) NAMFL2: ld      (hl),0            ;;Pad with NULs to length of 6
1CD4 1CD4 : 23                       inc     hl                ;
1CD5 1CD5 : 10 FB                    djnz    NAMFL2            ;
1CD7 1CD7 : E1         (~~~) NAMFL3: pop     hl                ;
1CD8 1CD8 : C9                       ret                       ;
1CD9 1CD9                                                      
1CD9 1CD9                    ;;Read File Header from Tape      
1CD9 1CD9 : CD CE 1B         RDHEAD: call    RDSYNC            ;;Wait for SYNC
1CDC 1CDC : AF         {~~~} RDNAME: xor     a                 ;
1CDD 1CDD : 32 5D 38                 ld      (INSYNC),a        ;;Clear SYNC flag
1CE0 1CE0 : 21 57 38                 ld      hl,FILNAF         ;;Read 6 bytes into FINLAF
1CE3 1CE3 : 06 06                    ld      b,6               ;
1CE5 1CE5 : CD 4D 1B   (~~~) RDSTRL: call    RDBYTE            ;;Read B characters to [HL] from tapw
1CE8 1CE8 : 77                       ld      (hl),a            ;
1CE9 1CE9 : 23                       inc     hl                ;
1CEA 1CEA : 10 F9                    djnz    RDSTRL            ;
1CEC 1CEC : C9                       ret                       ;
1CED 1CED
1CED 1CED                    ;;Compare Filename
1CED 1CED                    ;;Compares the 6 bytes string to by HL to FILNAM
1CED 1CED                    ;;Returns Z Set if the two are equal or FILNAM is an empty string
1CED 1CED                    ;;Otherwise, return Z Clear
1CED 1CED : 01 51 38         CMPNAM: ld      bc,FILNAM         ;
1CED 1CED                    ;;Entry Point to Compare FILNAM to String pointed to by BC
1CF0 1CF0 : 1E 06      {---} CMPNAF: ld      e,6               ;;Check 6 characters
1CF2 1CF2 : 0A                       ld      a,(bc)            ;;
1CF3 1CF3 : B7                       or      a                 ;;First character of FILNAM
1CF4 1CF4 : C8                       ret     z                 ;;If NUL return Equsl
1CF5 1CF5                    ;;Compare E characters at [BC] against [HL]
1CF5 1CF5 : 0A         (~~~) CPSTRL: ld      a,(bc)            ;;Compare FILNAM character
1CF6 1CF6 : BE                       cp      (hl)              ;;with FILNAF character
1CF7 1CF7 : 23                       inc     hl                ;;Bump pointers
1CF8 1CF8 : 03                       inc     bc                ;
1CF9 1CF9 : C0                       ret     nz                ;;If different, return Not Equal
1CFA 1CFA : 1D                       dec     e                 ;
1CFB 1CFB : 20 F8                    jr      nz,CPSTRL         ;;Decrememt counter and loop
1CFD 1CFD : C9                       ret                       ;
1CFE 1CFE
1CFE 1CFE : 46 6F 75 6E[~~~] FOUNDT: byte    "Found: ",0
1D02 1D02 : 64 3A 20 00 
1D06 1D06 : 53 6B 69 70[~~~] SKIPT:  byte    "Skip: ",0        
1D0A 1D0A : 3A 20 00                 
1D0D 1D0D                    ;;Print string then filename read from tape 
1D0D 1D0D : D5         [~~~] OUTNAM: push    de                ;;Save DE and AF
1D0E 1D0E : F5                       push    af                ;
1D0F 1D0F : CD 9D 0E                 call    STROUT            ;;Print string pointed to by HL
1D12 1D12                    ;;Print filename read from tape   
1D12 1D12 : 21 57 38   {~~~} OUTNMF: ld      hl,FILNAF         ;;Pointer to filename
1D15 1D15 : 06 06                    ld      b,6               ;;Filenames are 6 characters long
1D17 1D17 : 7E         (~~~) OUTNM1: ld      a,(hl)            ;
1D18 1D18 : 23                       inc     hl                ;
1D19 1D19 : B7                       or      a                 
1D1A 1D1A : 28 01                    jr      z,OUTNM2          ;;ASCII NUL?
1D1C 1D1C : DF                       rst     OUTCHR            ;;No, print character
1D1D 1D1D : 10 F8      (~~~) OUTNM2: djnz    OUTNM1            ;;Countdown and loop
1D1F 1D1F : CD EA 19                 call    CRDO              ;;Print CR/LF
1D22 1D22 : F1                       pop     af                ;
1D23 1D23 : D1                       pop     de                ;;Restore AF and DE
1D24 1D24 : C9                       ret                       ;
1D25 1D25    
1D25 1D25                    ;;Prompt User, Wait for RETURN, and Write Header
1D25 1D25 : CD 7F 1B   [~~~] WRHEAP: call    PRECRD            ;;"Press <RECORD>", wait for RETURN
1D28 1D28                    ;;Write File Header to Tape       
1D28 1D28 : CD BC 1B   {~~~} WRHEAD: call    WRSYNC            ;;Write SYNC to tape
1D2B 1D2B : 06 06      {~~~} WRNAME: ld      b,6               
1D2D 1D2D : 21 51 38                 ld      hl,FILNAM         ;;Write Filename to tape 
1D30 1D30 : 7E         (~~~) WRSTRL: ld      a,(hl)            ;;Write B Characters at [HL] to tape
1D31 1D31 : 23                       inc     hl
1D32 1D32 : CD 8A 1B                 call    WRBYTE
1D35 1D35 : 10 F9                    djnz    WRSTRL
1D37 1D37 : C9                       ret
1D38 1D38                        
1D38 1D38                    ;;Save Program Text to tape 
1D38 1D38 : CD BC 1B   [~~~] CSAVEP: call    WRSYNC            ;;Write SYNC to tape
1D3B 1D3B : EB                       ex      de,hl             ;;Save from TXTTAB
1D3C 1D3C : 2A D6 38                 ld      hl,(VARTAB)       ;;to VARTAB
1D3F 1D3F
1D3F 1D3F                    ;;Save RAM from DE to HL on tape
1D3F 1D3F : 1A         (~~~) CSAVEB: ld      a,(de)            ;;Get byte from memory
1D40 1D40 : 13                       inc     de                ;;Bump pointer
1D41 1D41 : CD 8A 1B                 call    WRBYTE            ;;Write byte to text
1D44 1D44 : E7                       rst     COMPAR            ;;Are we there yet?
1D45 1D45 : 20 F8                    jr      nz,CSAVEB         ;;No, write another
1D47 1D47 : C9                       ret                       ;
1D48 1D48
1D48 1D48                    ;;;Orphan code?
1D48 1D48 : 01 00 00         SLEEPS: ld      bc,0              ;Sleep maximum amount
1D4B 1D4B                    
1D4B 1D4B                    ;;Pause program execution
1D4B 1D4B                    ;;Delays BC*25-5 cycles
1D4B 1D4B : 0B               SLEEP:  dec     bc                ;;Decrement Counter
1D4C 1D4C : 78                       ld      a,b               ;                  
1D4D 1D4D : B1                       or      c                 ;;Is it 0?         
1D4E 1D4E : 20 FB                    jr      nz,SLEEP          ;;If not, loop     
1D50 1D50 : C9                       ret                       ;                  
1D51 1D51
1D51 1D51                    ;;Load Program Text from tape 
1D51 1D51 : CD CE 1B   [~~~] CLOADP: call    RDSYNC            ;;Wait for SYNC
1D54 1D54 : 3E FF                    ld      a,$FF
1D56 1D56 : 32 5D 38                 ld      (INSYNC),a        ;;Set SYNC flag
1D59 1D59 : 9F                       sbc     a,a               ;;A = 0
1D5A 1D5A : 2F                       cpl                       ;;A = $FF ???WHY?
1D5B 1D5B : 57                       ld      d,a               ;;D = $FF
1D5C 1D5C : 06 0A      (~~~) CLOADB: ld      b,10              ;
1D5E 1D5E : CD 4D 1B   (~~~) CLOADN: call    RDBYTE            ;;Get Byte
1D61 1D61 : 5F                       ld      e,a               ;;Save it
1D62 1D62 : 96                       sub     (hl)              ;;Compare with byte in memory
1D63 1D63 : A2                       and     d                 ;;If CLOAD?
1D64 1D64 : C0                       ret     nz                ;;and different, return with Zero cleared
1D65 1D65 : 73                       ld      (hl),e            ;;Store byte in memory
1D66 1D66 : CD A9 0B                 call    REASON            ;;If no space left, OM error
1D69 1D69 : 7E                       ld      a,(hl)            ;;Get byte back
1D6A 1D6A : B7                       or      a                 ;;Set flags
1D6B 1D6B : 23                       inc     hl                ;;Bump text pointer
1D6C 1D6C : 20 EE                    jr      nz,CLOADB         ;;Not 0, reset counter
1D6E 1D6E : 10 EE                    djnz    CLOADN            ;;Loop until 256 $00 are read 
1D70 1D70 : AF                       xor     a                 ;;Return with Zero set
1D71 1D71 : C9                       ret
1D72 1D72 
1D72 1D72 =            [M80] TTYCHR: ;Print character to screen
1D72 1D72 : F7                       rst     HOOKDO            ;;Call Extended BASIC Hook Routine
1D73 1D73 : 13         {~~~} HOOK19: byte    19                ;
1D74 1D74 : F5         [~~~] TTYCH:  push    af                ;;Save character
1D75 1D75 : FE 0A                    cp      10                ;[M80] LINE FEED?
1D77 1D77 : 28 1A                    jr      z,ISLF            ;
1D79 1D79 : 3A 00 38                 ld      a,(TTYPOS)        ;
1D7C 1D7C : B7                       or      a                 ;;At beginning of line?
1D7D 1D7D : 20 14                    jr      nz,ISLF           ;;No, skip line counter check
1D7F 1D7F : 3A 08 38                 ld      a,(CNTOFL)        ;
1D82 1D82 : B7                       or      a                 ;;Is line Counter 0?
1D83 1D83 : 28 0E                    jr      z,ISLF            ;;Then no pauses
1D85 1D85 : 3D                       dec     a                 ;
1D86 1D86 : 32 08 38                 ld      (CNTOFL),a        ;;Decrement Line Counter
1D89 1D89 : 20 08                    jr      nz,ISLF           ;;Not 0, don't pause
1D8B 1D8B : 3E 17                    ld      a,23              ;
1D8D 1D8D : 32 08 38                 ld      (CNTOFL),a        ;;Reset line counter
1D90 1D90 : CD 2F 1A                 call    TRYIN             ;;Wait for character from keyboard
1D93 1D93 : F1         (~~~) ISLF:   pop     af                ;;Retrieve Character
1D94 1D94                    ;;Print Character, bypassing Extended Hook and Line Counter checks
1D94 1D94 : F5               TTYOUT: push    af                ;
1D95 1D95 : D9                       exx                       ;;Save HL on Stack
1D96 1D96 : FE 07                    cp      7                 ;;Is it BEL!
1D98 1D98 : CA 14 1E                 jp      z,BEEP            ;;Make Beep Sound
1D9B 1D9B : FE 0B                    cp      11                ;;Is it CLS?
1D9D 1D9D : CA 45 1E                 jp      z,TTYCLR          ;;Clear the Screen
1DA0 1DA0 : 5F                       ld      e,a               ;;Save A
1DA1 1DA1 : 2A 01 38                 ld      hl,(CURRAM)       ;
1DA4 1DA4 : 3A 0D 38                 ld      a,(CURCHR)        ;;Get character under cursor
1DA7 1DA7 : 77                       ld      (hl),a            ;;Place at current screen position
1DA8 1DA8 : 7B                       ld      a,e               ;;Restore A
1DA9 1DA9 : FE 08                    cp      8                 ;;Is it BS?
1DAB 1DAB : 28 30                    jr      z,BS              ;;Do Back Space
1DAD 1DAD : FE 0D                    cp      13                ;;Is it CR?
1DAF 1DAF : 28 0D                    jr      z,CR              ;;Do Carriage Return
1DB1 1DB1 : FE 0A                    cp      10                ;;Is it LF?
1DB3 1DB3 : 28 13                    jr      z,LF              ;;Do Line Feed
1DB5 1DB5 : 2A 01 38                 ld      hl,(CURRAM)       ;;Place character at
1DB8 1DB8 : 77                       ld      (hl),a            ;;current position on screen
1DB9 1DB9 : CD 1F 1E                 call    TTYMOV            ;;Move Cursor Right
1DBC 1DBC : 18 2C                    jr      TTYFIN            ;;Finish Up
1DBE 1DBE                    ;;Carriage Return: Move Cursor to Beginning of Current Line
1DBE 1DBE : ED 5B 00 38(~~~) CR:     ld      de,(TTYPOS)       ;
1DC2 1DC2 : AF                       xor     a                 ;
1DC3 1DC3 : 57                       ld      d,a               ;;Subtract Cursor Column  
1DC4 1DC4 : ED 52                    sbc     hl,de             ;;from Screen Position
1DC6 1DC6 : 18 1F                    jr      TTYFIS            ;
1DC8 1DC8                    ;;Line Feed: Move Cursor Down One Line
1DC8 1DC8 : 11 C0 33   (~~~) LF:     ld      de,SCREEN+960     ;
1DCB 1DCB : E7                       rst     COMPAR            ;;Cursor on Last Row?
1DCC 1DCC : D2 D8 1D                 jp      nc,LFS            ;;Yes, Scroll and Finish Up
1DCF 1DCF : 11 28 00                 ld      de,40             ;       
1DD2 1DD2 : 19                       add     hl,de             ;;Add 40 to Move Down One Line
1DD3 1DD3 : 22 01 38                 ld      (CURRAM),hl       ;;Save New Screen Position
1DD6 1DD6 : 18 12                    jr      TTYFIN            ;
1DD8 1DD8 : CD FE 1D   (~~~) LFS:    call    SCROLL            ;;Scroll Up and Keep Screen Position
1DDB 1DDB : 18 0D                    jr      TTYFIN            ;
1DDD 1DDD                    ;;Back Space: Move Cursor Left and Delete Character 
1DDD 1DDD : 3A 00 38   (~~~) BS:     ld      a,(TTYPOS)        ;
1DE0 1DE0 : B7                       or      a                 ;;At First Column?
1DE1 1DE1 : 28 02                    jr      z,NOBS            ;
1DE3 1DE3 : 2B                       dec     hl                ;;No, Move One to the Left
1DE4 1DE4 : 3D                       dec     a                 ;
1DE5 1DE5 : 36 20      (~~~) NOBS:   ld      (hl),' '          ;;Erase Character at Position
1DE7 1DE7 -                  ;;Save Character and Display Cursor
1DE7 1DE7 = CD 3E 1E   (~~~) TTYFIS: call    TTYSAV            ;;Save Column and Position
1DEA 1DEA : 2A 01 38   (~~~) TTYFIN: ld      hl,(CURRAM)       ;
1DED 1DED : 7E                       ld      a,(hl)            ;;Get character at position
1DEE 1DEE : 32 0D 38                 ld      (CURCHR),a        ;;Save character under cursor 
1DF1 1DF1 : 36 7F                    ld      (hl),$7F          ;Display Cursor
1DF3 1DF3 : D9         (~~~) TTYXPR: exx                       ;Restore [BC], [DE] and [HL]
1DF4 1DF4 : F1                       pop     af                ;Restore [AF]
1DF5 1DF5 : C9                       ret
1DF6 1DF6
1DF6 1DF6                    ;;Restore Character Under Cursor
1DF6 1DF6                    ;;*** Orphan Code?
1DF6 1DF6 : 2A 01 38                 ld      hl,(CURRAM)       ;;Get position
1DF9 1DF9 : 3A 0D 38                 ld      a,(CURCHR)        ;;Get character
1DFC 1DFC : 77                       ld      (hl),a            ;;Put character at position
1DFD 1DFD : C9                       ret                       ;
1DFE 1DFE                                                      
1DFE 1DFE                    ;;Scroll Screen Up one Line       
1DFE 1DFE : 01 98 03         SCROLL: ld      bc,920            ;;Move 23 * 40 bytes
1E01 1E01 : 11 28 30                 ld      de,SCREEN+40      ;;To Row 1 Column 0
1E04 1E04 : 21 50 30                 ld      hl,SCREEN+80      ;;From Row 2 Column 1
1E07 1E07 : ED B0                    ldir                      ;
1E09 1E09 : 06 28                    ld      b,40              ;;Loop 40 Times
1E0B 1E0B : 21 C1 33                 ld      hl,SCREEN+961     ;;Starting at Row 23, Column 0
1E0E 1E0E : 36 20      (~~~) SCROLP: ld      (hl),' '          ;;Put Space
1E10 1E10 : 23                       inc     hl                ;;Next Column
1E11 1E11 : 10 FB                    djnz    SCROLP            ;;Do it again
1E13 1E13 : C9                       ret                       ;
1E14 1E14                                                      
1E14 1E14                    ;;Make a Beep Sound               
1E14 1E14 : 01 C8 00   (~~~) BEEP:   ld      bc,200            ;
1E17 1E17 : 11 32 00                 ld      de,50             ;
1E1A 1E1A : CD 64 1E                 call    SOUNDS            ;;Play freq 50, delay 300
1E1D 1E1D : 18 D4                    jr      TTYXPR            ;;Restore Registers and return
1E1F 1E1F
1E1F 1E1F                    ;;Move Cursor one character to the right
1E1F 1E1F : 2A 01 38         TTYMOV: ld      hl,(CURRAM)       ;
1E22 1E22 : 3A 00 38                 ld      a,(TTYPOS)        ;
1E25 1E25 : 23                       inc     hl                ;;Increment Position in Memory
1E26 1E26 : 3C                       inc     a                 ;;Increment Cursor Column
1E27 1E27 : FE 26                    cp      38                ;;Less than 39?
1E29 1E29 : 38 13                    jr      c,TTYSAV          ;;Save and Return
1E2B 1E2B : 23                       inc     hl                ;
1E2C 1E2C : 23                       inc     hl                ;;Skip border columns
1E2D 1E2D : 11 E8 33                 ld      de,SCREEN+1000    ;
1E30 1E30 : E7                       rst     COMPAR            ;;Past End of Screen?
1E31 1E31 : 3E 00                    ld      a,0               ;;Cursor Column = 0
1E33 1E33 : 38 09                    jr      c,TTYSAV          ;;No, Save Position and Column
1E35 1E35 : 21 C1 33                 ld      hl,033C1H         ;;Yes, Position = Row 24, Column 0  
1E38 1E38 : CD 3E 1E                 call    TTYSAV            ;Save Position and Column
1E3B 1E3B : C3 FE 1D                 jp      SCROLL            ;Scroll Screen
1E3E 1E3E
1E3E 1E3E                    ;;Update Current Screen Position and Cursor Column
1E3E 1E3E : 22 01 38         TTYSAV: ld      (CURRAM),hl       ;;Position in Screen RAM
1E41 1E41 : 32 00 38                 ld      (TTYPOS),a        ;;Cursor Column
1E44 1E44 : C9                       ret                       ;
1E45 1E45
1E45 1E45                    ;;Clear Screen
1E45 1E45 : 06 20            TTYCLR: ld      b,' '             ;
1E47 1E47 : 21 00 30                 ld      hl,SCREEN         ;
1E4A 1E4A : CD 59 1E                 call    FILLIT            ;;Write to Sreen RAM
1E4D 1E4D : 06 06                    ld      b,6               ;;Black on Light Cyan
1E4F 1E4F : CD 59 1E                 call    FILLIT            ;;Write to Color RAM
1E52 1E52 : 21 29 30                 ld      hl,SCREEN+41      ;;Home Cursor
1E55 1E55 : AF                       xor     a                 ;;Column = 0
1E56 1E56 : C3 E7 1D                 jp      TTYFIS            ;;Save and Finish
1E59 1E59
1E59 1E59                    ;;Fill 1024 bytes atarting at HL with A                     
1E59 1E59 : 11 FF 03         FILLIT: ld      de,$3FF           ;;Count down from 1023 
1E5C 1E5C                    ;;Fill BC bytes atartinf at HL with A
1E5C 1E5C : 70               FILLIP: ld      (hl),b            ;;Store byte
1E5D 1E5D : 23                       inc     hl                ;;Increment pointer
1E5E 1E5E : 1B                       dec     de                ;;Decrement Counter
1E5F 1E5F : 7A                       ld      a,d               ;
1E60 1E60 : B3                       or      e                 ;;Is it 0?
1E61 1E61 : 20 F9                    jr      nz,FILLIP         ;;No, Loop
1E63 1E63 : C9                       ret                       ;
1E64 1E64
1E64 1E64 : 78         [GWB] SOUNDS: ld      a,b               ;;Play frequency [DE] for duration [BC]
1E65 1E65 : B1                       or      c                 ;;If BC = 0 return
1E66 1E66 : C8                       ret     z                 ;
1E67 1E67 : AF                       xor     a                 ;
1E68 1E68 : D3 FC                    out     ($FC),a           ;;Write 0 to port $FC
1E6A 1E6A : CD 76 1E                 call    SDELAY            ;
1E6D 1E6D : 3C                       inc     a                 ;
1E6E 1E6E : D3 FC                    out     ($FC),a           ;;Write 1 to port $FC
1E70 1E70 : CD 76 1E                 call    SDELAY            ;;Delay [DE]*31+44 cycles
1E73 1E73 : 0B                       dec     bc                ;;Decrememt duration counter and loop
1E74 1E74 : 18 EE                    jr      SOUNDS            ;
1E76 1E76    
1E76 1E76 : D5               SDELAY: push    de                ;;Delay [DE]*31+27 cycles
1E77 1E77 : E1                       pop     hl                ;;Copy freq delay to HL (+10)
1E78 1E78 : 7C               SDELAL: ld      a,h               ;
1E79 1E79 : B5                       or      l                 ;
1E7A 1E7A : C8                       ret     z                 ;;If 0, return
1E7B 1E7B : 2B                       dec     hl                ;
1E7C 1E7C : 18 FA                    jr      SDELAL            ;;Decrement and loop
1E7E 1E7E                    
1E7E 1E7E                  + ;;INCHRH, INCHRC, and INCHRI - Get Character from Keyboard 
1E7E 1E7E                  | ;;The Keyboard Matrix is 8 columns by 6 rows. The columns are wired to
1E7E 1E7E                  | ;;to address lines A8 through A15 and the rows to I/O Port 255.
1E7E 1E7E                  | ;;When the Z80 executes and IN instruction, it puts the contents of BC 
1E7E 1E7E                  | ;;on the address bus. So to read the keyboard, B is loaded with a column
1E7E 1E7E                  | ;;mask, C is loaded with $FF, and IN (C) reads the rows.
1E7E 1E7E                  | ;;
1E7E 1E7E                  | ;;        A8  A9  A10 A11 A12 A13 A14 A15            
1E7E 1E7E                  | ;;    D0   =   -   9   8   6   5   3   2
1E7E 1E7E                  | ;;    D1  <--  /   O   I   Y   T   E   W
1E7E 1E7E                  | ;;    D2   :   0   K   7   G   4   S   L
1E7E 1E7E                  | ;;    D3  RTN  P   M   U   V   R   Z   Q
1E7E 1E7E                  | ;;    D4   ;   L   N   H   C   D  SPC SHF   
1E7E 1E7E                  | ;;    D5   .   ,   J   B   F   X   A  CTL
1E7E 1E7E                  | ;;
1E7E 1E7E                  | ;; Note: The RESET key is wired directly to the Z80 reset line.
1E7E 1E7E : F7               INCHRH: rst     HOOKDO
1E7F 1E7F : 12         {~~~} HOOK18: byte    18
1E80 1E80 -                  ;;Check for keypress
1E80 1E80 = D9               INCHRC: exx                       ;;Save Registers        
1E81 1E81 : 2A 0B 38         INCHRI: ld      hl,(RESPTR)       
1E84 1E84 : 7C                       ld      a,h               
1E85 1E85 : B7                       or      a                 
1E86 1E86 : 28 1A                    jr      z,KEYSCN          
1E88 1E88 : EB                       ex      de,hl             ;;Save HL
1E89 1E89 : 21 0F 38                 ld      hl,KCOUNT         
1E8C 1E8C : 34                       inc     (hl)              ;;Increment debounce counter
1E8D 1E8D : 7E                       ld      a,(hl)            ;;Get Value
1E8E 1E8E : FE 0F                    cp      15                ;;Less than 15?
1E90 1E90 : 38 3C                    jr      c,KEYFIN          ;;Yes, finish up
1E92 1E92 : 36 05                    ld      (hl),5            ;;Set debounce counter to 5
1E94 1E94 : EB                       ex      de,hl             ;;Restore HL
1E95 1E95 : 23                       inc     hl                
1E96 1E96 : 7E                       ld      a,(hl)            
1E97 1E97 : 22 0B 38                 ld      (RESPTR),hl       
1E9A 1E9A : B7                       or      a                 
1E9B 1E9B : F2 36 1F                 jp      p,KEYRET          
1E9E 1E9E : AF                       xor     a                 
1E9F 1E9F : 32 0C 38                 ld      (RESPTR+1),a      
1EA2 1EA2                    ;;Scan Keyboard                   
1EA2 1EA2 : 01 FF 00         KEYSCN: ld      bc,$FF            ;;B=0 to scan all columns
1EA5 1EA5 : ED 78                    in      a,(c)             ;;Read rows from I/O Port 255
1EA7 1EA7 : 2F                       cpl                       ;;and Invert
1EA8 1EA8 : E6 3F                    and     $3F               ;;Check all rows
1EAA 1EAA : 21 0E 38                 ld      hl,LSTX           ;;Pointer to last scan code
1EAD 1EAD : 28 16                    jr      z,NOKEYS          ;;No key pressed? ???do a thing
1EAF 1EAF                            ;;???Check for Shift and Control Keys
1EAF 1EAF : 06 7F                    ld      b,$7F             ;;Scanning column 7 - %01111111
1EB1 1EB1 : ED 78                    in      a,(c)             ;;Read rows and invert
1EB3 1EB3 : 2F                       cpl                       
1EB4 1EB4 : E6 0F                    and     $0F               ;;Check rows 0 through 3 - %00001111
1EB6 1EB6 : 20 1F                    jr      nz,KEYDN          ;;Key down? Process it
1EB6 1EB6                            ;;Scan the Rest of the Columns
1EB8 1EB8 : 06 BF                    ld      b,$BF              ;;Start with column 6 - %10111111 
1EBA 1EBA : ED 78      (~~~) KEYSCL: in      a,(c)              ;;Read rows and invert
1EBC 1EBC : 2F                       cpl                        ;
1EBD 1EBD : E6 3F                    and     $3F                ;;Check rows 0 through 5 - %00111111
1EBF 1EBF : 20 16                    jr      nz,KEYDN           ;;Key down? Process it
1EC1 1EC1 : CB 08                    rrc     b                  ;;Next column
1EC3 1EC3 : 38 F5                    jr      c,KEYSCL           ;;Loop if not out of columns
1EC5 1EC5 : 23               NOKEYS: inc     hl                 ;;Point to KCOUNT           
1EC6 1EC6 : 3E 46                    ld      a,70               ;
1EC8 1EC8 : BE                       cp      (hl)               ;
1EC9 1EC9 : 38 03                    jr      c,KEYFIN           ;;Less than 70? Clean up and return
1ECB 1ECB : 28 04                    jr      z,SCNINC           ;;0? Increment KCOUNT and return
1ECD 1ECD : 34                       inc     (hl)               ;
1ECE 1ECE : AF               KEYFIN: xor     a                  ;;Clear A
1ECF 1ECF : D9                       exx                        ;;Restore Registers
1ED0 1ED0 : C9                       ret                        ;
1ED1 1ED1 : 34               SCNINC: inc     (hl)               ;;Increment KCOUNT
1ED2 1ED2 : 2B                       dec     hl                 ;
1ED3 1ED3 : 36 00                    ld      (hl),0             ;;Clear LSTX 
1ED5 1ED5 : 18 F7                    jr      KEYFIN             ;;Clean up and Return
1ED7 1ED7                                                       
1ED7 1ED7                    ;;Process Key Currently Pressed    
1ED7 1ED7 : 11 00 00         KEYDN:  ld      de,0               ;
1EDA 1EDA : 1C               KEYROW: inc     e                  ;;Get row number (1-5) 
1EDB 1EDB : 1F                       rra                        ;
1EDC 1EDC : 30 FC                    jr      nc,KEYROW          ;
1EDE 1EDE : 7B                       ld      a,e                ;
1EDF 1EDF : CB 18            KEYCOL: rr      b                  ;;Add column number times 6
1EE1 1EE1 : 30 04                    jr      nc,KEYCHK          ;
1EE3 1EE3 : C6 06                    add     a,6                ;
1EE5 1EE5 : 18 F8                    jr      KEYCOL             ;
1EE7 1EE7 : 5F               KEYCHK: ld      e,a                ;
1EE8 1EE8 : BE                       cp      (hl)               ;;Compare scan code to LSTX
1EE9 1EE9 : 77                       ld      (hl),a             ;;Update LSTX with scan code
1EEA 1EEA : 23                       inc     hl                 ;;Point to KCOUNT
1EEB 1EEB : 20 0F                    jr      nz,KEYCLR          ;;Not the same? Clear KCOUNT and exit
1EED 1EED : 3E 04                    ld      a,4                
1EEF 1EEF : BE                       cp      (hl)               ;;Check KCOUNT
1EF0 1EF0 : 38 05                    jr      c,KEYFN6           ;;Greater than 4? Set to 6 and return
1EF2 1EF2 : 28 0C                    jr      z,KEYASC           ;;Equal to 4? Convert scan code
1EF4 1EF4 : 34                       inc     (hl)               ;;Increment KCOUNT
1EF5 1EF5 : 18 02                    jr      KEYFN2             ;;Clean up and exit
1EF7 1EF7 : 36 06            KEYFN6: ld      (hl),6             ;;Set KCOUNT to 6
1EF9 1EF9 : AF               KEYFN2: xor     a                  ;;Clear A
1EFA 1EFA : D9                       exx                        ;;Restore registers
1EFB 1EFB : C9                       ret                        ;
1EFC 1EFC : 36 00            KEYCLR: ld      (hl),0             ;;Clear KCOUNT
1EFE 1EFE : 18 F9                    jr      KEYFN2             ;;Clean up and return
1F00 1F00
1F00 1F00                    ;;Convert Keyboard Scan Code to ASCII Character
1F00 1F00 : 34               KEYASC: inc     (hl)              ;;Increment KCOUNT
1F01 1F01 : 06 7F                    ld      b,$7F             ;;Read column 7
1F03 1F03 : ED 78                    in      a,(c)             ;;Get row
1F05 1F05 : CB 6F                    bit     5,a               ;;Check Control key
1F07 1F07 : DD 21 93 1F              ld      ix,CTLTAB-1       ;;Point to control table
1F0B 1F0B : 28 0C                    jr      z,KEYLUP          ;;Control? Do lookup
1F0D 1F0D : CB 67                    bit     4,a               ;;Check Shift key
1F0F 1F0F : DD 21 65 1F              ld      ix,SHFTAB-1       ;;Point to shift table
1F13 1F13 : 28 04                    jr      z,KEYLUP          ;;Shift? Do lookup
1F15 1F15 : DD 21 37 1F              ld      ix,KEYTAB-1         
1F19 1F19 : DD 19            KEYLUP: add     ix,de             ;;Get pointer into table
1F1B 1F1B : DD 7E 00                 ld      a,(ix+0)          ;;Load ASCII value
1F1E 1F1E : B7                       or      a                 ;;Reserved Word? 
1F1F 1F1F : F2 36 1F                 jp      p,KEYRET          ;;No, return ASCII code
1F22 1F22 : D6 7F                    sub     $7F               ;;Convert to Reserved Word Count
1F24 1F24 : 4F                       ld      c,a               ;;and copy to C
1F25 1F25 : 21 44 02                 ld      hl,RESLST-1       ;;Point to Reserved Word List
1F28 1F28 -                  ;;Enter Reserved Word From Ctrl-Key Combo
1F28 1F28 = 23               KEYRES: inc     hl                ;;Bump pointer
1F29 1F29 : 7E                       ld      a,(hl)            ;;Get next character
1F2A 1F2A : B7                       or      a                 ;;First letter of reserved word?
1F2B 1F2B : F2 28 1F                 jp      p,KEYRES          ;;No, loop
1F2E 1F2E : 0D                       dec     c                 ;;Decrement Count
1F2F 1F2F : 20 F7                    jr      nz,KEYRES         ;;Not 0? Find next word
1F31 1F31 : 22 0B 38                 ld      (RESPTR),hl       ;;Save Keyword Address
1F34 1F34 : E6 7F                    and     $7F               ;;Strip high bit from first character
1F36 1F36 : D9               KEYRET: exx                       ;;Restore Registers
1F37 1F37 : C9                       ret
1F38 1F38
1F38 1F38                    ;;Unmodified Key Lookup Table
1F38 1F38 : 3D 08 3A 0D      KEYTAB: byte    '=',$08,':',$0D,';','.' ;;Backspace and Return
1F3C 1F3C : 3B 2E                                                    
1F3E 1F3E : 2D 2F 30 70              byte    '-','/','0','p','l',',' 
1F42 1F42 : 6C 2C                                                    
1F44 1F44 : 39 6F 6B 6D              byte    '9','o','k','m','n','j' 
1F48 1F48 : 6E 6A                                                    
1F4A 1F4A : 38 69 37 75              byte    '8','i','7','u','h','b' 
1F4E 1F4E : 68 62                                                    
1F50 1F50 : 36 79 67 76              byte    '6','y','g','v','c','f' 
1F54 1F54 : 63 66                                                    
1F56 1F56 : 35 74 34 72              byte    '5','t','4','r','d','x' 
1F5A 1F5A : 64 78                                                    
1F5C 1F5C : 33 65 73 7A              byte    '3','e','s','z',' ','a' 
1F60 1F60 : 20 61                                                    
1F62 1F62 : 32 77 31 71              byte    '2','w','1','q'         
1F66 1F66
1F66 1F66                    ;;Shifted Key Lookup Table
1F66 1F66 : 2B 5C 2A 0D      SHFTAB: byte    '+',$5C,'*',$0D,'@','>' ;;Backslash, Return
1F6A 1F6A : 40 3E                                                    
1F6C 1F6C : 5F 5E 3F 50              byte    '_','^','?','P','L','<' 
1F70 1F70 : 4C 3C                                                    
1F72 1F72 : 29 4F 4B 4D              byte    ')','O','K','M','N','J' 
1F76 1F76 : 4E 4A                                                    
1F78 1F78 : 28 49 27 55              byte    '(','I',$27,'U','H','B' ;;Apostrophe
1F7C 1F7C : 48 42                                                    
1F7E 1F7E : 26 59 47 56              byte    '&','Y','G','V','C','F' 
1F82 1F82 : 43 46                                                    
1F84 1F84 : 25 54 24 52              byte    '%','T','$','R','D','X' 
1F88 1F88 : 44 58                                                    
1F8A 1F8A : 23 45 53 5A              byte    '#','E','S','Z',' ','A' 
1F8E 1F8E : 20 41                                                    
1F90 1F90 : 22 57 21 51              byte    $22,'W','!','Q'         ;;Quotation Mark
1F94 1F94
1F94 1F94                    ;;Control Key Lookup Table
1F94 1F94 : 82 1C C1 0D      CTLTAB: byte    $82,$1C,$C1,$0D,$94,$C4 ;;NEXT ^\ PEEK Return POKE VAL
1F98 1F98 : 94 C4                                                     
1F9A 1F9A : 81 1E 30 10              byte    $81,$1E,$30,$10,$CA,$C3 ;;FOR ^^ 0 ^P POINT STR$
1F9E 1F9E : CA C3                                                     
1FA0 1FA0 : 92 0F 9D 0D              byte    $92,$0F,$9D,$0D,$C8,$9C ;;COPY ^O PRESET ^M RIGHT$, SET
1FA4 1FA4 : C8 9C                                                     
1FA6 1FA6 : 8D 09 8C 15              byte    $8D,$09,$8C,$15,$08,$C9 ;;RETURN ^I GOSUB ^U ^H MID$
1FAA 1FAA : 08 C9                                                     
1FAC 1FAC : 90 19 07 C7              byte    $90,$19,$07,$C7,$03,$83 ;;ON ^Y ^G LEFT$ ^C DATA
1FB0 1FB0 : 03 83                                                     
1FB2 1FB2 : 88 84 A5 12              byte    $88,$84,$A5,$12,$86,$18 ;;GOTO INPUT THEN ^R READ ^X
1FB6 1FB6 : 86 18                                                     
1FB8 1FB8 : 8A 85 13 9A              byte    $8A,$85,$13,$9A,$C6,$9B ;;IF DIM ^S CLOAD CHR$ CSAVE
1FBC 1FBC : C6 9B                                                     
1FBE 1FBE : 97 8E 89 11              byte    $97,$8E,$89,$11         ;;LIST REM RUN ^Q
1FC2 1FC2 
1FC2      :                          ;;Revision Date?
1FC2      : 31 34 2D 4A              byte    "14-JULY-1982 ",0 
1FC6      : 55 4C 59 2D
1FCA      : 31 39 38 32        
1FCE      : 20 00         
1FD0
1FD0                         ;;Pad rest of ROM space
1FD0      : 00 00 00 00              byte    $00,$00,$00,$00,$00,$00,$00,$00
1FD4      : 00 00 00 00
     1FC2 
     1FC2                    ;;Check for Ctrl-C, called from NEWSTT
     1FC2 : E5               INCNTC: push    hl                ;;Save text pointer
     1FC3 : 21 04 00                 ld      hl,4              ;
     1FC6 : 39                       add     hl,sp             ;
     1FC7 : 22 F9 38                 ld      (SAVSTK),hl       ;;Save stack pointer less 2 entries
     1FCA : E1                       pop     hl                ;;Restore text pointer
     1FCB : C3 25 1A                 jp      ISCNTC            ;;Check for Ctrl-C
     1FCE 
     1FCE                    ;;Finish up Warm Start
     1FCE : 2A F9 38         WRMFIN: ld      hl,(SAVSTK)       ;;Restore stack pointer
     1FD1 : F9                       ld      sp,hl             ;
     1FD2 : 2A CE 38                 ld      hl,(SAVTXT)       ;;Restore text pointer
     1FD5 : CD 20 0C                 call    STOPC             ;;Enter direct mode
     1FD8      
1FD8      : 00 00 00 00              byte    $00,$00,$00,$00,$00,$00,$00,$00
1FDC      : 00 00 00 00
1FE0      : 00 00 00 00              byte    $00,$00,$00,$00,$00,$00,$00,$00
1FE4      : 00 00 00 00              
     1FD8
     1FD8                  + ;;Save Stack Pointer
     1FD8                  | ;;Called from STKINI. Stores stack pointer in TEMPST
     1FD8                  | ;;;This code is inline in all the reference sources
     1FD8 : 2B               STKSAV: dec     hl                ;TAKE INTO ACCOUNT FNDFOR STOPPER
     1FD9 : 2B                       dec     hl                ;
     1FDA : 22 F9 38                 ld      (SAVSTK),hl       ;MAKE SURE SAVSTK OK JUST IN CASE
     1FDD : 21 B1 38                 ld      hl,TEMPST         ;INCREMENT BACK FOR SPHL
     1FE0 : C9                       ret                       ;
     1FE1                    ;;Power Up/Reset Routine: Jumped to from RST 0 
     1FE1 : 3E FF      [M80] JMPINI: ld      a,$FF             ;;Turn off printer and Cold Start
     1FE3 : D3 FE                    out     ($FE),a           ;;Write $FF to Printer Port
     1FE5 : C3 41 00                 jp      INIT              ;[M80] INIT IS THE INTIALIZATION ROUTINE
1FE8
1FE8      : 00 00 00 00              byte    $00,$00,$00,$00,$00,$00,$00,$00
1FEC      : 00 00 00 00
1FF0      : 00 00 00 00              byte    $00,$00,$00,$00,$00,$00,$00,$00
1FE4      : 00 00 00 00
     1FE8                    ;;Start Extended Basic
     1FE8 : 3E AA            XBASIC: ld      a,$AA             ;;
     1FEA : D3 FF                    out     ($FF),a           ;;Write Unlock Code to Port 255
     1FEC : 32 09 38                 ld      (SCRMBL),a        ;;Save It
     1FEF : C3 10 20                 jp      XSTART            ;;Jump to Extended BASIC Startup
     1FF2
     1FF2                    ;;Called from COLDST to print BASIC startup message
     1FF2 : 21 5F 01   [GWB] PRNTIT: ld      hl,HEDING         ;Print copyright message and return
     1FF5 : C3 9D 0E                 jp      STROUT            ;
     1FF8
     1FF8                    ;;Pad rest of ROM space
1FF8      : 00 00 00 00              byte    $00,$00,$00,$00,$00,$00,$00,$00
1FFC      : 00 00 00 00
     1FF8 : F5 F5 F5 F5              byte    $F5,$F5,$F5,$F5,$F5,$F5,$F5,$F5 
     1FFC : F5 F5 F5 F5              
2000 2000 :                          end                       ;;End of Standard BASIC

;;Extended BASIC ROM 
;;
;; Column 1-4 is built in Extended BASIC address
;; Column 6-9 is Extended BASIC Catridge address
;;
---- ---- X
----      X                          org     $2000   ;;Starting Address of Extended BASIC
     ---- X                          org     $E000   ;;Starting Address of Extended BASIC
---- ---- X
2000      X 2C 33 24   [~~~] EXTBAS: byte    ",3$$7+",0  ;;Extended BASIC Cartridge Signature
2003      X 24 37 2B                 
2006      X 00                       
2007      X 00 00 00                 byte    0,0,0,0,0,0,0,0,0     
200A      X 00 00 00          
200D      X 00 00 00         
     E000 X 90 95 FC F6              byte    $90,$95,$FC,$F6,$8B,$40,$91,$6C
     E004 X 8B 40 91 6C
     E008 X D5 B0 8B B8              byte    $D5,$B0,$8B,$B8,$9D,$74,$F7,$AC
     E00C X 9D 74 F7 AC   
     E010 X
     E010 X                  ;;Display Startup Screen
     E010 X 11 A1 31   [~~~] XINIT:  ld      de,SCREEN+417     ;;Display "BASIC"
     E013 X 21 B0 00                 ld      hl,BASICT         ;;at line 10, column 17
     E016 X 01 05 00                 ld      bc,STARTT-BASICT  ;
     E019 X ED B0                    ldir                      ;
     E01B X 11 10 32                 ld      de,SCREEN+528     ;;Display Start Message
     E01E X 21 B5 00                 ld      hl,STARTT         ;at line 13, column 8
     E021 X 01 19 00                 ld      bc,STARTE-STARTT  ;
     E024 X ED B0                    ldir                      ;
     E026 X                                                    
     E026 X                  ;;Cycle Screen Colors             
     E026 X 06 03      (~~~) XCYCLE: ld      b,3               ;;Black on Yellow
     E028 X CD 37 E0                 call    XCOLOR            ;
     E02B X 06 02                    ld      b,2               ;;Black on Green
     E02D X CD 37 E0                 call    XCOLOR            ;
     E030 X 06 06                    ld      b,6               ;;Black on Light Cyan
     E032 X CD 37 E0                 call    XCOLOR            ;
     E035 X 18 EF                    jr      XCYCLE            ;
     E037 X                                                    
     E037 X 21 00 34   [~~~] XCOLOR: ld      hl,COLOR          ;;Store Accumulator in all bytes of Color
     E03A X 70         (~~~) XCOLO1: ld      (hl),b            ;;memory, addresses $3400 through $3FFF
     E03B X 23                       inc     hl                ;;
     E03C X 7C                       ld      a,h               ;;NOTE: This wipes out $3B80 through $3FFF,
     E03D X FE 38                    cp      $38               ;;which are after the end of Color memory.
     E03F X 20 F9                    jr      nz,XCOLO1         ;
     E041 X 21 00 40                 ld      hl,$4000          ;;Loop 12,288 times
     E044 X CD 80 1E   (~~~) XCOLO2: call    INCHRC            ;;Check for keypress
     E047 X FE 0D                    cp      13                ;{M80} IS IT A CARRIAGE RETURN?
     E049 X 28 15                    jr      z,XCOLD           ;;Cold Start
     E04B X FE 03                    cp      3                 ;;Is it CTRL-C?
     E04D X 28 06                    jr      z,XWARM           ;;Warm Start
     E04F X 2B                       dec     hl                ;;Decrement Counter
     E050 X 7C                       ld      a,h               ;
     E051 X B5                       or      l                 ;
     E052 X 20 F0                    jr      nz,XCOLO2         ;;If not 0, loop
     E054 X C9                       ret                       ;;Back to CYCLE
     E055 X                                                    
     E055 X 3E 0B      [~~~] XWARM:  ld      a,11              
     E057 X CD 72 1D                 call    TTYCHR            ;;Clear Screen
     E05A X CD E5 0B                 call    STKINI            ;;Initialize stack
     E05D X CD 40 1A                 call    WRMCON            ;;Finish Up
     E060 X                                                    
     E060 X 21 87 01   [~~~] XCOLD:  ld      hl,DEFALT         ;Set System Variable Default Values
     E063 X 01 51 00                 ld      bc,81             ;
     E066 X 11 03 38                 ld      de,USRPOK         ;;Copy 80 bytes starting at DEFALT
     E069 X ED B0                    ldir                      ;;to the first 80 bytes of System Variables
     E06B X AF                       xor     a                 ;
     E06C X 32 A9 38                 ld      (ENDBUF),a        ;;Clear byte after end of BUF
     E06F X 32 F9 38                 ld      ($38F9),a         ;;Clear byte before start of S1 BASIC program
     E072 X                  ;;Test Memory to Find Top of RAM  
     E072 X 21 5D 39                 ld      hl,$38F9+100     ;;Set RAM Test starting address
     E075 X                                                    
     E075 X 23         (~~~) XTEST:  inc     hl                ;;Bump pointer
     E076 X 4E                       ld      c,(hl)            ;;Save contents of location
     E077 X 7C                       ld      a,h               ;
     E078 X B5                       or      l                 ;;Wrapped around to $0000?
     E079 X 28 0B                    jr      z,XCHECK          ;;Yes, go on to check memory
     E07B X A9                       xor     c                 ;;Scramble bits into A 
     E07C X 77                       ld      (hl),a            ;;and write to location
     E07D X 46                       ld      b,(hl)            ;;Read back into B
     E07E X 2F                       cpl                       ;;Invert scrambled bits
     E07F X 77                       ld      (hl),a            ;;Write to location
     E080 X 7E                       ld      a,(hl)            ;;read it back
     E081 X 2F                       cpl                       ;;and revert back
     E082 X 71                       ld      (hl),c            ;;Write original byte to location
     E083 X B8                       cp      b                 ;;Did reads match writes?
     E084 X 28 EF                    jr      z,XTEST           ;;Yes, check next location
     E086 X                  ;;Check Memory Size               ;;Back up to last good address
     E086 X 2B         (~~~) XCHECK: dec     hl                ;
     E087 X 11 25 3A                 ld      de,$38F9+300     ;;Is there enough RAM?
     E08A X E7                       rst     COMPAR            ;;No, Out of Memory error
     E08B X DA B7 0B                 jp      c,OMERR             
     E08E X                  ;;Set Top of memory                 
     E08E X 11 CE FF                 ld      de,$FFCE            
     E091 X 22 AD 38                 ld      (MEMSIZ),hl       ;;Set MEMSIZ to last RAM location
     E094 X 19                       add     hl,de             
     E095 X 22 4B 38                 ld      (TOPMEM),hl       ;;Set TOPMEM t0 MEMSIZ-50
     E098 X CD BE 0B                 call    SCRTCH            ;;Perform NEW
2010      X                    
2010      X 21 5A 20   [~~~] XSTART: ld      hl,EXBAST         ;;Print "Extended BASIC"
     E09B X 21 E5 E0                 ..                          
2013 E09E X CD 9D 0E                 call    STROUT            
2016 E0A1 X 21 63 01                 ld      hl,HEDING+4       ;;Start of Copyright Message (S1 ROM) 
2019 E0A4 X 7E                       ld      a,(hl)            
201A E0A5 X FE 79                    cp      $79               
201C E0A7 X 20 03                    jr      nz,XSTAR2         ;;If first character is 'y'
201E E0A9 X 2B                       dec     hl                ;;  Back up to 
201F E0AA X 2B                       dec     hl                ;;  Start of Message in S2 ROM
2020 E0AB X 2B                       dec     hl                
2021 E0AC X CD 9D 0E   (~~~) XSTAR2: call    STROUT            ;;Print Copyright Message
2024      X 21 6C 20                 ld      hl,DOHOOK         ;;Store Hook Table Address
     E0AF X 21 F7 E0                 ..                          
2027 E0B2 X 22 06 38                 ld      (HOOK),hl         ;;in Hook Table
202A E0B5 X 21 00 00                 ld      hl,0              ;;
202D E0B8 X 22 31 39                 ld      (BUFPTR),hl       ;;Clear Buffer Pointer
2030 E0BB X 21 04 07                 ld      hl,$0704          ;;Default = White, Current = Blue 
2033 E0BE X 22 00 39                 ld      (FORCLR),hl       ;;Set Foreground Colors
2036 E0C1 X 21 48 39                 ld      hl,BASTXT-1       ;;End of System RAM
2039 E0C4 X 36 00                    ld      (hl),$00          ;;Store a 0 there 
203B E0C6 X 23                       inc     hl                ;;Set Beginning of BASIC Text
203C E0C7 X 22 4F 38                 ld      (TXTTAB),hl       ;;to BASTXT
203F E0CA X CD BE 0B                 call    SCRTCH            ;;Do a NEW
2042 E0CD X 3E C3                    ld      a,$C3             ;;JP Instruction
2044 E0CF X 32 0B 39                 ld      (MAXUPD),a        ;{GWB} Major Axis Move Update
2047 E0D2 X 32 0E 39                 ld      (MINUPD),a        ;{GWB} Minor Axis Move Update
204A E0D5 X 32 3E 39                 ld      (OPCJMP),a        ;;Draw Operator Routine
204D E0D8 X AF                       xor     a                 ;;Store 0 in
204E E0D9 X 32 33 39                 ld      (DRWSCL),a         
2051 E0DC X 32 34 39                 ld      (DRWFLG),a         
2054 E0DF X 32 35 39                 ld      (DRWANG),a         
2057 E0E2 X C3 02 04                 jp      READY             ;;Go to Immediate Mode
205A E0E5 X
205A E0E5 X 0B 45 78   [~~~] EXBAST: byte    11,"Extended BASIC",13,10,0
205D E0E8 X 74 65 6E  
2060 E0EB X 64 65 64  
2063 E0EE X 20 42 41  
2066 E0F1 X 53 49 43  
2069 E0F4 X 0D 0A 00  
206C E0F7 X                  ;;When the Hook Routine is Executed, the stack will contain
206C E0F7 X                  ;;Return Address, Saved Accumulator, and Text Pointer
206C E0F7 X E3         [~~~] DOHOOK: ex      (sp),hl           ;;[HL] = Return Address, Save HL on Stack
206D E0F8 X F5                       push    AF                ;;Stack = Argument, Text Pointer,
206E E0F9 X 7E                       ld      A,(hl)            ;;Get Hook ID
206F E0FA X 23                       inc     hl                ;;Increment Address Past Hook ID
2070 E0FB X E5                       push    hl                ;;Stack = Return Addr, Argument, Text Pointer
2071      X 21 9D 20                 ld      hl,HOOKT          ;;Get Hook Table Start Address
     E0FC X 21 28 E1                 ..
2074 E0FF X C5                       push    bc                ;;Stack = [BC], Return Addr, Arg, Text Ptr
2075 E100 X 01 09 00                 ld      bc,9              ;;
2078 E103 X ED B1                    cpir                      ;;Search Hook List for Hook Number
207A E105 X 79                       ld      a,c               ;;Index into Hook List
207B E106 X C1                       pop     bc                ;;Stack = Return Addr, Arg, Text Ptr
207C E107 X 87                       add     a,a               ;;Multiply by 2
207D      X 21 8B 20                 ld      hl,HOOKD          ;;Add to Address of Hook Table
     E108 X 21 16 E1                 ..
2080 E10B X 85                       add     a,l             
2081 E10C X 6F                       ld      l,a             
2082 E10D X 3E 00                    ld      a,0             
2084 E10F X 8C                       adc     a,h             
2085 E110 X 67                       ld      h,a               ;;Load Hook Routing Address
2086 E111 X 7E                       ld      a,(hl)            ;;into HL
2087 E112 X 23                       inc     hl                
2088 E113 X 66                       ld      h,(hl)            
2089 E114 X 6F                       ld      l,a             
208A E115 X E9                       jp      (hl)              ;;and Execute It
208B      X               
208B      X                  ;;Hook Dispatch Table 
208B      X AD 20      [~~~] HOOKD:  word    UNHOOK            ;;Hook Not Implemented
     E116 X 38 E1                    ..
208D      X EC 20                    word    NOTGOX            ;;(NOTGOS)
     E118 X 77 E1                    ..
208E      X A5 20                    word    OUTDOX            ;;(OUTDO)
     E11A X 30 E1                    ..
2091      X F9 21                    word    ATN1              ;;ATN Routine
     E11C X 84 E2                    ..
2093      X 77 21                    word    DEFX              ;;DEF FN Routine
     E11E X 02 E2                    ..
2095      X A1 21                    word    FNDOEX            ;;FN() Routine
     E120 X 2C E2                    ..
2097      X 37 21                    word    INCHRX            ;;INCHRH Hook
     E122 X C2 E1                    ..
2099      X FF 20                    word    LISTHK            ;;LIST Hook
     E124 X 8A E1                    ..
209B      X 11 21                    word    GONE23            ;;GONE23
     E126 X 9C E1                    ..
209D E128 X
209D E128 X                  ;;Hook Offset Table             
209D E128 X 17         [~~~] HOOKT:  byte    23                ;;Hook 23 (GONE23)
209E E129 X 16                       byte    22                ;;Hook 22 (LIST)
209F E12A X 12                       byte    18                ;;Hook 18 (INCHRH)
20A0 E12B X 10                       byte    16                ;;Hook 16 (FNDOER)
02A1 E12C X 0F                       byte    15                ;;Hook 15 (DEF)
20A2 E12D X 0E                       byte    14                ;;Hook 14 (ATN)
20A3 E12E X 0D                       byte    13                ;;Hook 12 (OUTDO)
20A4 E12F X 0A                       byte    10                ;;Hook 10 (NOTGOS)
20A5      X
20A5      X                + ;;OUTDO Hook Routine
20A5      X                | ;;While Unpacking a Line, Sends Output to BUF
20A5      X                | ;;STACK = Return Address, Saved Accumulator, and Text Pointer
20A5 E130 X 2A 31 39   [~~~] OUTDOX: ld      hl,(BUFPTR)       ;;Get Puffer Pointer
20A8 E133 X 7C                       ld      a,h 
20A9 E134 X B5                       or      l                 ;;If Not Zero, Write to Buffer` 
20AA      X C2 52 23                 jp      nz,OUTBUF         ;;Else Return to OUTDO
     E135 X C2 DD E3                 ..  
20AD E138 X             
20AD E138 X                  ;;Hook Not Implemented - Restore Registers and Return
20AD E138 X E1         [~~~] UNHOOK: pop     hl                ;;Get Return Address
20AE E139 X F1                       pop     af                ;;Restore Accumulator and Flags
20AF E13A X E3                       ex      (sp),hl           ;;Swap Return Address for BASIC Pointer
20B0 E13B X C9         [~~~] XRET:   ret
20B1 E13C X
20B1 E13C X                + ;;Extended BASIC Reserved Word Tokens
20B1 E13C X                | ;;Note: Tokens $CB - $CE are not defined    
20B1 E13C X                  EXTLST: ;;Extended Reserved Words List
20B1 E13C X                  TK      =       $CF               ;;Extended Tokens start at $CF
20B1 E13C X                  XORTK   equ     TK  
20B1 E13C X D8 4F 52                 byte    'X'+$80,"OR"      ;;$CF
20B4 E13F X                  TK      =       TK+1              
20B4 E13F X                  EDITTK  equ     TK  
20B4 E13F X C5 44 49 54              byte    'E'+$80,"DIT"     ;;$D0
20B8 E143 X                  TK      =       TK+1              
20B8 E143 X CC 4F 43                 byte    'L'+$80,"OCATE"   ;;$D1
20BB E146 X 41 54 45                                           
20BE E149 X                  TK      =       TK+1              
20BE E149 X CD 45 4E                 byte    'M'+$80,"ENU"     ;;$D2
20C1 E14C X 55                                                 
20C2 E14D X                  TK      =       TK+1              
20C2 E14D X C3 4C 53                 byte    'C'+$80,"LS"      ;;$D3
20C5 E150 X                  TK      =       TK+1              
20C5 E150 X                  LINETK  equ     TK  
20C5 E150 X CC 49 4E                 byte    'L'+$80,"INE"     ;;$D4
20C8 E153 X 45                                                 
20C9 E154 X                  TK      =       TK+1              
20C9 E154 X                  CIRCTK  equ     TK              ;
20C9 E154 X C3 49 52                 byte    'C'+$80,"IRCLE"   ;;$D5
20CC E157 X 43 4C 45                                         
20CF E15A X                  TK      =       TK+1              
20CF E15A X C7 45 54                 byte    'G'+$80,"ET"      ;;$D6
20D2 E15D X                  TK      =       TK+1              
20D2 E15D X D0 55 54                 byte    'P'+$80,"UT"      ;;$D7
20D5 E160 X                  TK      =       TK+1              
20D5 E160 X                  DRAWTK  equ     TK
20D5 E160 X C4 52 41                 byte    'D'+$80,"RAW"     ;;$D8
20D8 E163 X                  TK      =       TK+1              
20D8 E163 X 57               TKLAST  equ     TK                      
20D9 E164 X 80                       byte    $80               ;End of Table
20DA      X 
20DA      X                  ;;Extended Statement Dispatch Table       
20DA      X 7F 23            EXTDSP: word    EDIT              ;;$237F
     E165 X 0A E4                    ..
20DC      X 4A 22                    word    LOCATE            ;;$224A
     E167 X D5 E2                    ..
20DE      X 67 22                    word    MENU              ;;$2267
     E169 X F2 E2                    .. 
20E0      X 46 22                    word    CLS               ;;$2246
     E16B X D1 E2                    ..
20E2      X E7 25                    word    GLINE             ;;$25E7
     E16D X 72 E6                    ..
20E4      X 00 27                    word    CIRCLE            ;;$2700
     E16F X 8B E7                    ..
20E6      X 6F 23                    word    GGET              ;;$236F
     E171 X FA E3                    ..
20E8      X 6B 23                    word    GPUT              ;;$236B
     E173 X F6 E3                    ..
20EA      X 9D 2A                    word    DRAW              ;;$2A9D  
     E175 X 28 EB                    ..
20EC      X                                                
20EC E177 X 78               NOTGOX: ld      a,b             
20ED E178 X FE CB                    cp      POINTK+1             
20EF      X C2 AD 20                 jp      nz,UNHOOK           
     E17A X C2 38 E1                 jp      nz,UNHOOK
20F2 E17D X C1                       pop     bc              
20F3 E17E X F1                       pop     af                ;;Restore Accumulator and Flags
20F4 E17F X E1                       pop     hl                ;;Restore BASIC Pointer
20F5 E180 X C5                       push    bc                ;;Push Return Address
20F6 E181 X EB                       ex      de,hl             
20F7      X 11 B0 20                 ld      de,XRET          
     E182 X 11 3B E1                 ..
20FA E185 X 06 CE                    ld      b,XORTK-1             
20FC E187 X C3 F9 04                 jp      CRUNCX            ;;Jump into CRUNCH
20FF E18A X
20FF E18A X                  ;;Hook 22 - Check for and Handle Extended BASIC Tokens
20FF E18A X D1               LISTHK: pop     de                ;;Get Return Address
2100 E18B X F1                       pop     af                ;;Restore Accumulator and Flags
2101 E18C X E1                       pop     hl                ;;Restore Basic Pointer
2102 E18D X FE CF                    cp      XORTK                          
2104 E18F X 30 02                    jr      nc,RESSRX         ;;If Token < XORTK
2106 E191 X D5                       push    de                ;;  Push Return Address onto Stack
2107 E192 X C9                       ret                       ;;  and Return
2108 E193 X D6 CE            RESSRX: sub     XORTK-1              
210A E195 X 4F                       ld      c,a               ;;Set Count to Position in EXTLSR
210B      X 11 B1 20                 ld      de,EXTLST         ;;Search in EXTLST
     E196 X 11 3C E1                 ..
210E      X C3 A8 05                 jp      RESSRC            ;;Go Do It
     E199 X C3 A8 05                 jp      RESSRC            ;;Go Do It
2111 E19C X
2111 E19C X                  ;;Hook 23 - Check for and Dispatch Extended BASIC Statement Token
2111 E19C X C1               GONE23: pop     bc                ;;Pop Return Address
2112 E19D X F1                       pop     af                ;;Restore Accumulator and Flags
2113 E19E X E1                       pop     hl                ;;Restore BASIC Pointer
2114 E19F X 30 0C                    jr      nc,GONE24         ;;If Standard BASIC Token
2116 E1A1 X F5                       push    af                ;;  Save Accumulator and Flags
2117 E1A2 X FE 1C                    cp      PSETTK-$80        ;;  If PSET
2119 E1A4 X 28 4E                    jr      z,PSETX           ;;    Do Extended BASIC PSET
211B E1A6 X FE 1D                    cp      PRESTK-$80        ;;  If PRESET
211D E1A8 X 28 46                    jr      z,PRESEX          ;;    Do Extended BASIC PRESET
211F E1AA X F1                       pop     af                ;;  Restore Accumulator and Flags
2120 E1AB X C5                       push    bc                ;;  Push Return Address back on to Stack
2121 E1AC X C9                       ret                       ;;  and Return
2122 E1AD X D6 50            GONE24: sub     EDITTK-$80        ;;Get Position in Extended List
2124 E1AF X DA C4 03                 jp      c,SNERR           ;;  If Negative, Syntax Error
2127 E1B2 X FE 09                    cp      TKLAST-EDITTK     ;;Past End of Extended Tokens?  
2129 E1B4 X D2 C4 03                 jp      nc,SNERR          ;;  Yes, Syntax Error
212C E1B7 X 07                       rlca                      ;;Dispatch Offset = Position *2
212D E1B8 X 4F                       ld      c,a               ;;[B,C] = Dispatch Offset
212E E1B9 X 06 00                    ld      b,0 
2130 E1BB X EB                       ex      de,hl             ;;Text Pointer into [D,E]
2131      X 21 DA 20                 ld      hl,EXTDSP         ;;Use Extended Dispatch Table
     E1BC X 21 65 E1                 ..
2134 E1BF X C3 65 06                 jp      GONE5             ;;Continue Statement Dispatch
2137 E1C2 X
2137 E1C2 X                  ;;Hook 18 - Read Keyboard (INCHRH)
2137 E1C2 X E1               INCHRX: pop     hl                ;;Hook Table Address
2138 E1C3 X F1                       pop     af                ;;Accumulatot and Flags
2139 E1C4 X E1                       pop     hl
213A E1C5 X CD 80 1E                 call    INCHRC            ;;Read The Keyboard
213D E1C8 X D9                       exx
213E      X 21 B1 20                 ld      hl,EXTLST         ;;Use Extended Reserved Words List
     E1C9 X 21 3C E1                 ..
2141 E1CC X FE 0F                    cp      15                ;;Ctrl-O?
2143 E1CE X 28 0F                    jr      z,KCIRCL  
2145 E1D0 X FE 19                    cp      25                ;;Ctrl-Y?
2147 E1D2 X 28 0F                    jr      z,KEDIT 
2149 E1D4 X FE 10                    cp      16                ;;Ctrl-P? 
214B E1D6 X 28 13                    jr      z,KLINE 
214D E1D8 X FE 1E                    cp      30                ;;Ctrl-^?
214F E1DA X 28 0B                    jr      z,KDRAW
2151 E1DC X B7                       or      a
2152 E1DD X D9                       exx
2153 E1DE X C9                       ret
2154 E1DF X
2154 E1DF X 0E 06            KCIRCL: ld      c,CIRCTK-XORTK  ;;CIRCLE
2156 E1E1 X 18 0A                    jr      KEYREX
2158 E1E3 X 0E 01            KEDIT:  ld      c,EDITTK-XORTK
215A E1E5 X 18 06                    jr      KEYREX
215C E1E7 X 0E 09            KDRAW:  ld      c,DRAWTK-XORTK  ;;DRAW
215E E1E9 X 18 02                    jr      KEYREX
2160 E1EB X 0E 05            KLINE:  ld      c,LINETK-XORTK
2162 E1ED X C3 28 1F         KEYREX: jp      KEYRES
2165 E1F0 X
2165 E1F0 X                + ;;Extended PSET or PRESET
2165 E1F0 X                | ;;Reads Coordinates and saves them for subsequent
2165 E1F0 X                | ;;  LINE -(X,Y) or LINE -STEP(X,Y) statement
2165 E1F0 X                | ;;then executes standard basic PSET/PRESET code
2165 E1F0 X F1               PRESEX: pop     af                ;;Discard Saved Flags
2166 E1F1 X AF                       xor     a                 ;;[EBU] PRESET FLAG
2167 E1F2 X 18 03                    jr      PPRSEX             
2169 E1F4 X F1               PSETX:  pop     af                ;;Discard Saved Flags
216A E1F5 X 3E 01                    ld      a,1               ;;[EBU] PSET FLAG
216C E1F7 X 23               PPRSEX: inc     hl                ;;Skip PSET/PRESET Token
216D E1F8 X 08                       ex      af,af'            ;;Save PSET/PRESET flag
216E E1F9 X CF                       rst     SYNCHK            ;;Require '('
216F E1FA X 28                       byte    '('               
2170 E1FB X 2B                       dec     hl                ;;Back up to '(' for SCAN1
2171      X CD 47 25                 call    SCAN1             ;;Scan Coordinates as (X,Y)
     E1FC X CD D2 E5                 ..                        
2174 E1FF X C3 55 1A                 jp      PPRSDO            ;;Go Do PSET/PRESET
2177 E202 X
2177 E202 X                + ;[M80]SIMPLE-USER-DEFINED-FUNCTION CODE
2177 E202 X                | ;[M80]
2177 E202 X                | ;[M80] IN THE 8K VERSION (SEE LATER COMMENT FOR EXTENDED)
2177 E202 X                | ;[M80] NOTE ONLY SINGLE ARGUMENTS ARE ALLOWED TO FUNCTIONS
2177 E202 X                | ;[M80] AND FUNCTIONS MUST BE OF THE SINGLE LINE FORM:
2177 E202 X                | ;[M80] DEF FNA(X)=X^2+X-2
2177 E202 X                | ;[M80] NO STRINGS CAN BE INVOLVED WITH THESE FUNCTIONS
2177 E202 X                | ;[M80]
2177 E202 X                | ;[M80] IDEA: CREATE A FUNNY SIMPLE VARIABLE ENTRY
2177 E202 X                | ;[M80] WHOSE FIRST CHARACTER (SECOND WORD IN MEMORY)
2177 E202 X                | ;[M80] HAS THE 200 BIT SET.
2177 E202 X                | ;[M80] THE VALUE WILL BE:
2177 E202 X                | ;[M80]
2177 E202 X                | ;[M80]   A TXTPTR TO THE FORMULA
2177 E202 X                | ;[M80] THE NAME OF THE PARAMETER VARIABLE
2177 E202 X                | ;[M80]
2177 E202 X                | ;[M80] FUNCTION NAMES CAN BE LIKE "FNA4"
2177 E202 X                | ;[M80]
2177 E202 X E1         [~~~] DEFX:   pop     hl              
2178 E203 X F1                       pop     af              
2179 E204 X E1                       pop     hl              
217A      X CD EA 21                 call    GETFNM            ;[M80] GET A POINTER TO THE FUNCTION NAME
     E205 X CD 75 E2                 ..                        
217D E208 X CD 45 0B                 call    ERRDIR            ;[M80] DEF IS "ILLEGAL DIRECT"
2180 E20B X                                                    ;[M80] MEMORY, RESTORE THE TXTPTRAND GO TO "DATA" 
2180 E20B X                                                    ;[M80] SKIPPING THE REST OF THE FORMULA
2180 E20B X 01 1C 07                 ld      bc,DATA           
2183 E20E X C5                       push    bc                
2184 E20F X D5                       push    de                
2185 E210 X CF                       rst     SYNCHK            
2186 E211 X 28                       byte    '('               ;{GWB} SKIP OVER OPEN PAREN
2187 E212 X CD D1 10                 call    PTRGET            ;[M80] GET POINTER TO DUMMY VAR(CREATE VAR)
2189 E215 X E5                       push    hl                
218B E216 X EB                       ex      de,hl             
218C E217 X 2B                       dec     hl                
218D E218 X 56                       ld      d,(hl)            
218E E219 X 2B                       dec     hl                
218F E21A X 5E                       ld      e,(hl)            
2190 E21B X E1                       pop     hl                
2191 E21C X CD 75 09                 call    CHKNUM            
2194 E21F X CF                       rst     SYNCHK            
2195 E220 X 29                       byte    ')'               ;{M80} MUST BE FOLLOWED BY )
2196 E221 X CF                       rst     SYNCHK            
2197 E222 X B0                       byte    EQUATK            
2198 E223 X 44                       ld      b,h               
2199 E224 X 4D                       ld      c,l               
219A E225 X E3                       ex      (sp),hl           
219B E226 X 71                       ld      (hl),c            
219C E227 X 23                       inc     hl                
219D E228 X 70                       ld      (hl),b            
219E E229 X C3 59 0E                 jp      STRADX             
21A1 E22C X                                                    
21A1 E22C X E1         [M80] FNDOEX: pop     hl                
21A2 E22D X F1                       pop     af                
21A3 E22E X E1                       pop     hl                
21A4      X CD EA 21                 call    GETFNM            ;[M80] GET A POINTER TO THE FUNCTION NAME
     E22F X CD 75 E2                 ..                          
21A7 E232 X D5                       push    de                  
21A8 E233 X CD 37 0A                 call    PARCHK            ;{M80} RECURSIVELY EVALUATE THE FORMULA
21AB E236 X CD 75 09                 call    CHKNUM            ;{M65} MUST BE NUMBER
21AE E239 X E3                       ex      (sp),hl           ;[M80] SAVE THE TEXT POINTER THAT POINTS PAST THE 
21AF E23A X                                                    ;[M80] FUNCTION NAME IN THE CALL
21AF E23A X 5E                       ld      e,(hl)            ;[M80] [H,L]=VALUE OF THE FUNCTION
21B0 E23B X 23                       inc     hl                
21B1 E23C X 56                       ld      d,(hl)            
21B2 E23D X 23                       inc     hl                ;[M80] WHICH IS A TEXT POINTER AT THE FORMAL
21B3 E23E X 7A                       ld      a,d               ;[M80] PARAMETER LIST IN THE DEFINITION
21B4 E23F X B3                       or      e                 ;[M80] A ZERO TEXT POINTER MEANS THE FUNCTION 
21B5 E240 X                                                    ;[M80] WAS NEVER DEFINED
21B5 E240 X CA D0 03                 jp      z,UFERR           ;[M80] IF SO, GIVEN AN "UNDEFINED FUNCTION" ERROR
21B8 E243 X 7E                       ld      a,(hl)            
21B9 E244 X 23                       inc     hl                
21BA E245 X 66                       ld      h,(hl)            
21BB E246 X 6F                       ld      l,a               
21BC E247 X E5                       push    hl                ;[M80] SAVE THE NEW VALUE FOR PRMSTK
21BD E248 X 2A DE 38                 ld      hl,(VARNAM)        
21C0 E24B X E3                       ex      (sp),hl           
21C1 E24C X 22 DE 38                 ld      (VARNAM),hl        
21C4 E24F X 2A E2 38                 ld      hl,(FNPARM)        
21C7 E252 X E5                       push    hl                
21C8 E253 X 2A E0 38                 ld      hl,(VARPNT)        
21CB E256 X E5                       push    hl                
21CC E257 X 21 E0 38                 ld      hl,VARPNT          
21CF E25A X D5                       push    de                
21D0 E25B X CD 3A 15                 call    MOVMF             
21D3 E25E X E1                       pop     hl                
21D4 E25F X CD 72 09                 call    FRMNUM            ;[M80] AND EVALUATE THE DEFINITION FORMULA
21D7 E262 X 2B                       dec     hl                ;[M80] CAN HAVE RECURSION AT THIS POINT
21D8 E263 X D7                       rst     CHRGET            ;[M80] SEE IF THE STATEMENT ENDED RIGHT
21D9 E264 X C2 C4 03                 jp      nz,SNERR          ;[M80] THIS IS A CHEAT, SINCE THE LINE 
21DC E267 X                                                    ;[M80] NUMBER OF THE ERROR WILL BE THE CALLERS
21DC E267 X                                                    ;[M80] LINE # INSTEAD OF THE DEFINITIONS LINE #
21DC E267 X E1                       pop     hl                
21DD E268 X 22 E0 38                 ld      (VARPNT),hl        
21E0 E26B X E1                       pop     hl                
21E1 E26C X 22 E2 38                 ld      (FNPARM),hl        
21E4 E26F X E1                       pop     hl                
21E5 E270 X 22 DE 38                 ld      (VARNAM),hl        
21E8 E273 X E1                       pop     hl                ;[M80] GET BACK THE TEXT POINTER
21E9 E274 X C9                       ret                     
21EA E275 X
21EA E275 X                + ;[M80] SUBROUTINE TO GET A POINTER TO A FUNCTION NAME
21EA E275 X                | ;[M80] 
21EA E275 X CF         [M80] GETFNM: rst     SYNCHK          
21EB E276 X A2                       byte    FNTK              ;[M80] MUST START WITH "FN"
21EC E277 X 3E 80                    ld      a,128             ;[M80] DONT ALLOW AN ARRAY
21EE E279 X 32 CB 38                 ld      (SUBFLG),a        ;[M80] DON'T RECOGNIZE THE "(" AS THE START OF AN ARRAY REFEREENCE
21F1 E27C X B6                       or      (hl)              ;[M80] PUT FUNCTION BIT ON
21F2 E27D X 4F                       ld      c,a               ;[M80] GET FIRST CHARACTER INTO [C]
21F3 E27E X CD D6 10                 call    PTRGT2          
21F6 E281 X C3 75 09                 jp      CHKNUM          
21F9 E284 X
21F9 E284 X                + ;[M80] ARCTANGENT FUNCTION
21F9 E284 X                | ;[M80] IDEA: USE IDENTITIES TO GET ARG BETWEEN 0 AND 1 AND THEN USE AN
21F9 E284 X                | ;[M80] APPROXIMATION POLYNOMIAL TO COMPUTE ARCTAN(X)
21F9 E284 X E1         [~~~] ATN1:   pop     hl
21FA E285 X F1                       pop     af
21FB E286 X E1                       pop     hl
21FC E287 X EF                       rst     FSIGN             ;[M80] SEE IF ARG IS NEGATIVE
21FD E288 X FC 70 17                 call    m,PSHNEG          ;[M80] IF ARG IS NEGATIVE, USE:
2200 E28B X FC 0B 15                 call    m,NEG             ;[M80]    ARCTAN(X)=-ARCTAN(-X
2203 E28E X 3A E7 38                 ld      a,(FAC)           ;[M80] SEE IF FAC .GT. 1
2206 E291 X FE 81                    cp      129               
2208      X DA 17 22                 jp      c,ATN2            
     E293 X DA A2 E2                 ..                        
220B E296 X 01 00 81                 ld      bc,$8100          ;[M80] GET THE CONSTANT 1
220E E299 X 51                       ld      d,c               
220F E29A X 59                       ld      e,c               ;[M80] COMPUTE RECIPROCAL TO USE THE IDENTITY:
2210 E29B X CD 2F 14                 call    FDIV              ;[M80]   ARCTAN(X)=PI/2-ARCTAN(1/X)
2213 E29E X 21 58 12                 ld      hl,FSUBS          ;[M80] PUT FSUBS ON THE STACK SO WE WILL RETURN       
2216 E2A1 X E5                       push    hl                ;[M80]  TO IT AND SUBTRACT THE REULT FROM PI/2
2217      X 21 21 22   [M80] ATN2:   ld      hl,ATNCON         ;[M80] EVALUATE APPROXIMATION POLYNOMIAL
     E2A2 X 21 AC E2                 ..                        
221A E2A5 X CD 37 18                 call    POLYX             
221D E2A8 X 21 53 19                 ld      hl,PI2            ;[M80] GET POINTER TO PI/2 IN CASE WE HAVE TO
2220 E2AB X C9                       ret                       ;[M80]  SUBTRACT THE RESULT FROM PI/2
2221 E2AC X                                                    
2221 E2AC X                  ;CONSTANTS FOR ATN                
2221 E2AC X 09         [M80] ATNCON: byte    9                 ;DEGREE
2222 E2AD X 4A D7 3B 78              byte    $4A,$D7,$3B,$78   ; .002866226
2226 E2B1 X 02 6E 84 7B              byte    $02,$6E,$84,$7B   ; -.01616574
222A E2B5 X FE C1 2F 7C              byte    $FE,$C1,$2F,$7C   ; .04290961
222E E2B9 X 74 31 9A 7D              byte    $74,$31,$9A,$7D   ; -.07528964
2232 E2BD X 84 3D 5A 7D              byte    $84,$3D,$5A,$7D   ; .1065626
2236 E2C1 X C8 7F 91 7E              byte    $C8,$7F,$91,$7E   ; -.142089
223A E2C5 X E4 BB 4C 7E              byte    $E4,$BB,$4C,$7E   ; .1999355
223E E2C9 X 6C AA AA 7F              byte    $6C,$AA,$AA,$7F   ; -.3333315
2242 E2CD X 00 00 00 81              byte    $00,$00,$00,$81   ; 1.0
2246 E2D1 X 
2246 E2D1 X                  ;[M80] CLS: CLear Screen issues an escape sequence to clear the CRT.
2246 E2D1 X 3E 0B      [M80] CLS:    ld      a,11            
2248 E2D3 X DF                       rst     OUTCHR          
2249 E2D4 X C9                       ret
224A E2D5 X
224A E2D5 X                + ;[GWB] LOCATE: Parse the following syntax:
224A E2D5 X                | ;[GWB]        LOCATE X,Y
224A E2D5 X                | ;[GWB]
224A E2D5 X CD 54 0B   [GWB] LOCATE: call    GETBYT            ;[GWB] Get X parameter
224D E2D8 X F5                       push    af                ;;Save it
224E E2D9 X 3D                       dec     a                 ;;Make it 1 less 
224F E2DA X FE 26                    cp      38                ;[GWB] Check for parameter range
2251 E2DC X D2 97 06                 jp      nc,FCERR          
2254 E2DF X CF                       rst     SYNCHK            
2255 E2E0 X 2C                       byte    ','               
2256 E2E1 X CD 54 0B                 call    GETBYT            ;[GWB] Get Y parameter
2259 E2E4 X FE 18                    cp      24                
225B E2E6 X D2 97 06                 jp      nc,FCERR          ;[GWB] Check for parameter range
225E E2E9 X 1C                       inc     e                 ;;[E] = Y + 1          
225F E2EA X F1                       pop     af                ;;Restore X 
2260 E2EB X 57                       ld      d,a               ;;[D] = X
2261 E2EC X EB                       ex      de,hl             ;;{HL] = C,Y
2262      X CD 4D 2D                 call    MOVEIT             
     E2ED X CD D8 ED                 ..                        
2265 E2F0 X EB                       ex      de,hl             ;;Switch Back
2266 E2F1 X C9                       ret                     
2267 E2F2 X
2267 E2F2 X                  ;;;This Statement appears to be unique to the Aquarius
2267 E2F2 X                  ;;The MENU Statement
2267 E2F2 X                  ;;Syntax: MENU (xpos,ypos), spacing; 
2267 E2F2 X                  ;;             "string-1","string-2",...,"string-n" 
2267 E2F2 X                  ;;              GOTO line-1,line-2,...,line-n
2267 E2F2 X                  ;;Spacing is optional, in the form:
2267 E2F2 X                  ;;        MENU (xpos,ypos) "string-1",... GOTO line-1,...
2267 E2F2 X                  ;;An at sign may precede the coordinates:
2267 E2F2 X                  ;;        MENU @(xpos,ypos) ...
2267 E2F2 X FE 40      [~~~] MENU:   cp      '@'               ;{GWB} ALLOW MEANINGLESS "@"
2269 E2F4 X CC 6B 06                 call    z,CHRGTR          ;{GWB} BY SKIPPING OVER IT
226C      X CD E0 22                 call    SCANX             ;;Scan Coordinates into [D,E] 
     E2F7 X CD 6B E3                 ..                        
226F E2FA X D5                       push    de                ;;Push Coordinates onto Stack
2270 E2FB X 1E 01                    ld      e,1               ;;Default Spacing (1) into [E]
2272 E2FD X 7E                       ld      a,(hl)            ;;
2273 E2FE X FE 2C                    cp      ','               ;;If Next Character is a Comma
2275 E300 X 20 08                    jr      nz,MENU2          ;;  Scan Optional Spacing Parameter
2277 E302 X D7                       rst     CHRGET            ;;  Eat Comma
2278 E303 X CD 54 0B                 call    GETBYT            ;;  Scan Spacing in [E]
227B E306 X D5                       push    de                ;;  Push Options onto Stack
227C E307 X CF                       rst     SYNCHK            
227D E308 X 3B                       byte    ';'               ;;  Require a Semicolon          
227E E309 X D1                       pop     de                ;;  Pop Options into [D,E]
227F E30A X 4B         (~~~) MENU2:  ld      c,e               ;;Copy Spacing into [C]
2280 E30B X 06 01                    ld      b,1               ;;Init Counter to 1 ino B
2282 E30D X D1                       pop     de                ;;Pop Coordinates into [D,E]
2283 E30E X D5                       push    de                ;;Push Coordinates back onto Stack
2284 E30F X C5                       push    bc                ;;Push Options onto Stack
2285 E310 X                          ;;Evaluate and Print String
2285 E310 X E5         (~~~) MENUS:  push    hl                ;;Push Text Pointer onto Stack
2286 E311 X EB                       ex      de,hl             ;;Swap Coordinates into [H,L]
2287 E312 X E5                       push    hl                ;;Push Coordinates onto Stack
2288      X CD 4D 2D                 call    MOVEIT            ;;Move Cursor to Coordinates [H,L]
     E313 X CD D8 ED                 ..                          
228B E316 X 3E 2E                    ld      a,'.'                       
228D E318 X DF                       rst     OUTCHR            ;;Print a Period
228E E319 X E1                       pop     hl                ;;HL = Coords, Stack = Text Pointer, Options. Coords
228F E31A X E3                       ex      (sp),hl           ;;HL = Text Pointer, Stack = Coordinates
2290 E31B X CD 85 09                 call    FRMEVL            ;;Evaluate a String
2293 E31E X E5                       push    hl                ;;Stack = Text Pointer, Coords, Options. Coords
2294 E31F X CD C6 0F                 call    FRESTR            ;[M80] FREE UP TEMP POINTED TO BY FACLO
2297 E322 X CD A0 0E                 call    STRPRT            ;;Print the String
229A E325 X E1                       pop     hl                ;;HL = Text Pointer, Stack =  Coords, Options. Coords
229B E326 X D1                       pop     de                ;;DE = Coords, Stack = Options. Coords
229C E327 X C1                       pop     bc                ;;BC = Options, Stack = Coords
229D E328 X 7E                       ld      a,(hl)            
229E E329 X FE 2C                    cp      ','               ;;Is Next Character a Comma?
22A0 E32B X 20 0C                    jr      nz,MENU3          ;;If So
22A2 E32D X EB                       ex      de,hl             ;;  HL = Coords, DE = Text Pointer
22A3 E32E X 04                       inc     b                 ;;  Increment Option Counter
22A4      X CD FB 22                 call    ADDLC             ;;  Add Spacing to Y
     E32F X CD 86 E3                 ..                        
22A7 E332 X C5                       push    bc                ;;  Stack = Options, Coords
22A8 E333 X E5                       push    hl                ;;  Stack = Coords, Options, Coords
22A9 E334 X EB                       ex      de,hl             ;;  HL = Text Pointer, DE = Coords
22AA E335 X D7                       rst     CHRGET            ;;  Eat Comma
22AB E336 X D1                       pop     de                ;;  Get Back Coordinates 
22AC E337 X 18 D7                    jr      MENUS             ;;  Scane Next String
22AE E339 X
22AE E339 X                  ;;BC = Options, DE = Coords, HL = Text Pointer, Stack = Coords
22AE E339 X FE 88      (~~~) MENU3:  cp      GOTOTK            ;;If Not GOTO
22B0 E33B X C2 C4 03                 jp      nz,SNERR          ;;Syntax Error
22B3 E33E X E3                       ex      (sp),hl           ;;HL = Coords, Stack = Text Pointer
22B4 E33F X E5         (~~~) MENUT:  push    hl                ;;Stack = Coords, Text Pointer
22B5 E340 X C5                       push    bc                ;;Stack = Options, Coorda, Text Pointer
22B6 E341 X 1E 00                    ld      e,0               ;;Option Number = 0
22B8      X CD CE 22   (~~~) MENUN:  call    MENUK             ;;Get C/R or Space from Keyboard
     E343 X CD 59 E3                 ..
22BB E346 X 1C                       inc     e                 ;;Increment Option Number
22BC E347 X 38 0A                    jr      c,MENUG           ;;If Space
22BE      X CD FB 22                 call    ADDLC             ;;  Y = Y + Spacing
     E349 X CD 86 E3                 ..                        
22C1 E34C X 05                       dec     b                 ;;  Decrement Option Count
22C2 E34D X 20 F4                    jr      nz,MENUN          ;;  If Not Zero, Move to Next Optionb
22C4 E34F X C1                       pop     bc                ;;    BC = Options, HL = Coords
22C5 E350 X E1                       pop     hl                ;;    Stack = Text Pointer
22C6 E351 X 18 EC                    jr      MENUT             ;;    Start Iver ar Top
22C8 E353 X E1         (~~~) MENUG:  pop     hl                ;;Discard Options
22C9 E354 X E1                       pop     hl                ;;Discard Coords
22CA E355 X E1                       pop     hl                ;;Restore Text Pointer
22CB E356 X C3 85 07                 jp      OMGOTO            ;;Do ON [E] GOTO 
22CE E359 X
22CE E359 X                  ;;Wait for C/R or Space, Return Carry Set if Return
22CE E359 X C5         (~~~) MENUK:  push    bc                ;;Save BC
22CF      X CD 4D 2D                 call    MOVEIT            ;;Move Cursor to H,L
     E35A X CD D8 ED                 ..                          
22D2 E35D X CD 2F 1A   (~~~) MENUL:  call    TRYIN             ;;Get Character from Keyboard
22D5 E360 X FE 0D                    cp      13                ;;If Carriage Return
22D7 E362 X 37                       scf                       ;;  Return Carry Set
22D8 E363 X 28 04                    jr      z,MENUR           
22DA E365 X FE 20                    cp      ' '               ;;If Not Space
22DC E367 X 20 F4                    jr      nz,MENUL          ;;  Loop
22DE E369 X C1         (~~~) MENUR:  pop     bc                ;;Restore BC 
22DF E36A X C9                       ret
22E0 E36B X
22E0 E36B X                  ;;Get Coordinates for MENU Statement   
22E0 E36B X                  ;;Syntax: Coords
22E0 E36B X CF         [~~~] SCANX:  rst     SYNCHK          
22E1 E36C X 28                       byte    '('               ;{GWB} SKIP OVER OPEN PAREN
22E2 E36D X CD 54 0B                 call    GETBYT            ;{GWB} SCAN X INTO [A]
22E5 E370 X FE 26                    cp      38                ;;If X > 38                         
22E7 E372 X 30 09                    jr      nc,SCANX2         ;;  Function Call Error` 
22E9 E374 X 3C                       inc     a                 ;;Bump X Past First Column
22EA E375 X F5                       push    af                ;{GWB} SAVE WHILE SCANNING Y
22EB E376 X CF                       rst     SYNCHK            
22EC E377 X 2C                       byte    ','               ;{GWB} SCAN COMMA
22ED E378 X CD 54 0B                 call    GETBYT            ;{GWB} GET Y INTO [A]
22F0 E37B X FE 25                    cp      37                ;;If Y > 37            
22F2 E37D X D2 97 06   (~~~) SCANX2: jp      nc,FCERR          ;;  Function Call Error`
22F5 E380 X D1                       pop     de                ;;Get X into D
22F6 E381 X 3C                       inc     a                 ;;Bump Y Past First Line
22F7 E382 X 5F                       ld      e,a               ;;Put Y into E
22F8 E383 X CF                       rst     SYNCHK            
22F9 E384 X 29                       byte    ')'               ;{GWB} SKIP OVER CLOSE PAREN
22FA E385 X C9                       ret                       
22FB E386 X                                                    
22FB E386 X 7D         [~~~] ADDLC:  ld      a,l               ;;L = L + C 
22FC E387 X 81                       add     a,c               
22FD E388 X 6F                       ld      l,a               
22FE E389 X FE 18                    cp      24                
2300 E38B X D8                       ret     c                 ;;If L >= 24
2301 E38C X 2E 17                    ld      l,23              ;;L = 23
2303 E38E X C9                       ret
2304 E38F X
2304 E38F X                  ;;Convert FAC to Integer and Return in [H,L]
2304 E38F X EF         [~~~] FRCINX: rst     FSIGN             ;[M80] GET THE SIGN OF THE FAC IN A
2305      X FA 0E 23                 jp      m,FRCINM          ;;If Positive
     E390 X FA 99 E3                 ..                             
2308 E393 X EB                       ex      de,hl             ;;  Save DE in HL
2309 E394 X CD 82 06                 call    FRCINT            ;;  Convert FAC into Integer in DE
230C E397 X EB                       ex      de,hl             ;;  Put Result into HL, Restore DE
230D E398 X C9                       ret                       ;;Else
230E E399 X D5         [~~~] FRCINM: push    de                ;;  Save DE
230F E39A X CD 0B 15                 call    NEG               ;;  Negate FAC
2312 E39D X CD 82 06                 call    FRCINT            ;;  Convert FAC into Integer in DE
2315 E3A0 X CD 0B 15                 call    NEG               ;;  Un-Negate FAC
2318 E3A3 X 21 00 00                 ld      hl,0              
231B E3A6 X B7                       or      a                 
231C E3A7 X ED 52                    sbc     hl,de             ;;  Put 0 - Integer into HL
231E E3A9 X D1                       pop     de                ;;  and Restore DE
231F E3AA X C9                       ret                       
2320 E3AB X                                                    
2320 E3AB X E5         [GWB] MAKINT: push    hl                ;;Save Registers
2321 E3AC X D5                       push    de                
2322 E3AD X C5                       push    bc                
2323 E3AE X 7C                       ld      a,h               
2324 E3AF X 55                       ld      d,l               
2325 E3B0 X CD 23 0B                 call    FLOATD            ;;Put HL into FAC
2328 E3B3 X C1                       pop     bc                ;;Restore Registers
2329 E3B4 X D1                       pop     de
232A E3B5 X E1                       pop     hl
232B E3B6 X C9                       ret
232C E3B7 X
232C E3B7 X                  ;;Print Null Terminated String 
232C E3B7 X                  ;;pointed to by [HL]
232C E3B7 X                  ;;On return [HL] points to 0 terminator
232C E3B7 X 7E         [~~~] LISPRX: ld      a,(hl)            ;;Get Byte
232D E3B8 X B7                       or      a                 ;;If Zero
232E E3B9 X C8                       ret     z                 ;;  Return
232F E3BA X DF                       rst     OUTCHR            ;;Output Byte
2330 E3BB X 23                       inc     hl                ;;Point to Next Byte
2331      X C3 2C 23                 jp      LISPRX            ;;and Do it Again
     E3BC X C3 B7 E3                 ..                        
2334 E3BF X                                                    
2334 E3BF X                  ;;Convert Character to Uppercase     
2334 E3BF X FE 61      [GWB] MAKUPR: cp      'a'               
2336 E3C1 X D8                       ret     c                 ;;If >= 'a' 
2337 E3C2 X FE 7B                    cp      '{'               
2339 E3C4 X D0                       ret     nc                ;;and less than <'{'
233A E3C5 X E6 5F                    and     $5F               ;;Clear Bit 5
233C E3C7 X C9                       ret                     
233D      X
233D E3C8 X                + ;{M80} UNPACK LINE INTO BUF
233D      X                | ;;Sets BUFPTR causing OUTDO to execute OUTBUF
233D      X                | ;;So that when LISTing a line, output goes to BUF
233D      X                | ;;???Might be broken in built in Extended BASIC and
233D      X                | ;;???fixed in Extended BASIC Cartridge, or Vice Versa
233D      X                | ;;On Entry [HL] = Pointer to Beginning of Line
233D      X                | ;;  Stack = Return Address, Line Number
233D E3C8 X E5         [M80] BUFLIN: push    hl                ;;Save Pointer into Line
233E E3C9 X 21 02 00                 ld      hl,2              ;;
2341 E3CC X 39                       add     hl,sp             ;;
2342 E3CD X 22 2F 39                 ld      (BUFRET),hl       ;;Save BUFLIN Return Address
2345      X 21 60 38                 ld      hl,BUF            ;;
2348      X 22 31 39                 ld      (BUFPTR),hl       ;;BUG: Set Buffer Pointer to Return Address
234B      X 2A 4F 38                 ld      hl,(TXTTAB)       ;;BUG: Overwritten in Next Line
     E3D0 X                          ;;??? Bug Fix             
     E3D0 X 21 60 38                 ld      hl,BUF            ;;[HL] = Input Buffer Address
     E3D3 X 22 31 39                 ld      (BUFPTR),hl       ;;
     E3D6 X 2A 4F 38                 ld      hl,(TXTTAB)       ;;[HL] = Start of BASIC Program
234E E3D9 X                                                    
234E E3D9 X E3                       ex      (sp),hl           ;;{HL] = Pointer into Line
234F E3DA X C3 98 05                 jp      LISPRT            ;;Detokenize Line into BUF
2352      X  
2352      X                + ;;Output Character to BUF
2352 E3DD X                | ;;On Entry, [HL] = Puffer Pointer
2352 E3DD X F1               OUTBUF: pop     af                ;;Discard HOOKDO Return Address
2353 E3DE X F1                       pop     af                ;;Get Character to Output
2354 E3DF X FE 0D                    cp      13                ;;
2356 E3E1 X 28 07                    jr      z,CRBUF           ;;If Not Carriage Return
2358 E3E3 X 77                       ld      (hl),a            ;;  Store Character at Puffer Pointer
2359 E3E4 X 23                       inc     hl                ;;  Increment Buffer Pointer
235A E3E5 X 22 31 39                 ld      (BUFPTR),hl       
235D E3E8 X E1                       pop     hl                ;;Restore Text Pointer
235E E3E9 X C9                       ret                       ;;Return Out of OUTDO
235F E3EA X AF               CRBUF:  xor     a                 ;;Else
2360 E3EB X 77                       ld      (hl),a            ;;  Terminate Buffer Text
2361 E3EC X 67                       ld      h,a               
2362 E3ED X 6F                       ld      l,a               
2363 E3EE X 22 31 39                 ld      (BUFPTR),hl       ;;  Clear Line Buffer
2366 E3F1 X 2A 2F 39                 ld      hl,(BUFRET)       ;;  
2369 E3F4 X F9                       ld      sp,hl             ;;  Restore Stack Pointer
236A E3F5 X C9                       ret                       ;;  and Return out of BUFLIN
236B E3F6 X                                                    
236B E3F6 X 3E 01      [~~~] GPUT:   ld      a,1               ;;Mode = GET
236D E3F8 X 18 01                    jr      GGPUTG            
236F E3FA X AF         [~~~] GGET:   xor     a                 ;;Mode = PUT
2370      X C3 84 29   (~~~} GGPUTG: jp      GPUTG
     E3FB X C3 0F EA                 ..
2373 E3FE X
2373 E3FE X                  ;{GWB} CONVERT THE FORMULA TO AN INTEGER IN [D,E]
2373 E3FE X CD 85 09   [GWB] GETIN2: call    FRMEVL          ;[GWB] EVALUATE A FORMULA
2376 E401 X E5         {GWB} INTFR2: push    hl              ;[GWB] SAVE THE TEXT POINTER
2377 E402 X CD 75 09                 call    CHKNUM          ;[M65] MUST BE NUMBER
237A E405 X CD 82 06                 call    FRCINT          ;[GWB] CONVERT THE FORMULA TO AN INTEGER IN [D,E]
237D E408 X E1                       pop     hl              ;[GWB] RESTORE THE TEXT POINTER
237E E409 X C9                       ret
237F E40A X
237F E40A X                + ;[M80] EDIT COMMAND
237f E40A X                | ;;; Need to check if this matches the code
237F E40A X                | ;[M80] [C] CONTAINS COUNT OF CHARACTERS IN LINE
237F E40A X                | ;[M80] [B] CONTAINS CURRENT CHARACTER POSITION 0=FIRST IN LINE.
237F E40A X                | ;[M80] [D] CONTAINS NUMBER OF TIMES TO REPEAT THIS SUBCOMMAND
237F E40A X                | ;[M80] [H,L] POINT TO CURRENT CHARACTER
237F E40A X CD 9C 06   [M80] EDIT:   call    SCNLIN          ;[M80[ GET THE ARGUMENT LINE NUMBER
2382 E40D X C0                       ret     nz              ;[M80] ERROR IF NOT END OF LINE
2383 E40E X E1         {M80} EREDIT  pop     hl              ;[M80] GET RID OF NEWSTT Address
2384 E40F X CD 9F 04   [M80] EEDITS: call    FNDLIN          ;[M80] FIND THE LINE IN QUESTION
2387 E412 X D2 F3 06                 jp      nc,USERR        ;[M80] IF NOT FOUND, UNDEFINED STATEMENT ERROR.
238A E415 X 60                       ld      h,b             ;[M80] PONTER TO LINE IS IN [B,C]
238B E416 X 69                       ld      l,c             ;[M80] TRANSFER IT TO [H,L]
238C E417 X 23                       inc     hl              ;[M80] PASS OVER POINTER TO NEXT LINE
238D E418 X 23                       inc     hl              ;[M80] LIKE SO.
238E E419 X 4E                       ld      c,(hl)          ;[M80] GET FIRST BYTE OF LINE #
238F E41A X 23                       inc     hl              ;[M80] MOVE TO 2ND BYTE
2390 E41B X 46                       ld      b,(hl)          ;[M80] PICK IT UP INTO B
2391 E41C X 23                       inc     hl              ;[M80] ADVANCE TO POINT TO FIRST BYTE OF LINE
2392 E41D X C5                       push    bc              ;[M80] SAVE LINE # ON STACK
2393      X CD 3D 23                 call    BUFLIN          ;[M80] UNPACK LINE INTO BUF
     E41E X CD C8 E3                 ..
2396 E421 X E1         [M80] LLED:   pop     hl              ;[M80] GET BACK LINE #
2397 E422 X E5         {M80} INLED:  push    hl              ;[M80] SAVE IT BACK ON STACK
2398 E423 X 7C                       ld      a,h             ;[M80] TEST FOR DOUBLE BYTE ZERO
2399 E424 X A5                       and     l               
239A E425 X 3C                       inc     a               
239B E426 X 3E 21                    ld      a,'!'           ;[M80] GET PROMPT FOR DIRECT EDIT
239D E428 X CC 8A 19                 call    z,OUTDO         ;[M80] SEND IT
23A0 E42B X C4 75 16                 call    nz,LINPRT       ;[M80] PRINT LINE # IF NOT INLIN EDIT
23A3 E42E X 3E 20                    ld      a,' '           ;[M80] TYPE A SPACE
23A5 E430 X DF                       rst     OUTCHR          ;[M80] ...
23A6 E431 X 21 60 38                 ld      hl,BUF          ;[M80] GET START OF BUF IN [H,L]
23A9 E434 X E5                       push    hl              ;[M80] SAVE [H,L] WHILE WE CALC LINE LENGTH
23AA E435 X 0E FF                    ld      c,255           ;[M80] ASSUME 0 CHAR LINE
23AC E437 X 0C         [M80] LENLP:  inc     c               ;[M80] BUMP COUNT OF CHARS
23AD E438 X 7E                       ld      a,(hl)          ;[M80] GET CHAR FROM LINE
23AE E439 X 23                       inc     hl              ;[M80] BUMP POINTER
23AF E43A X B7                       or      a               
23B0 E43B X 20 FA                    jr      nz,LENLP        ;[M80] IF NOT ZERO (END OF LINE) KEEP COUNTING...
23B2 E43D X E1                       pop     hl              ;[M80] GET BACK POINTER TO LINE
23B3 E43E X 47                       ld      b,a             ;[M80] SET CURRENT LINE POSIT TO ZERO
23B4 E43F X 16 00      [M80] DISPED: ld      d,0             ;[M80] ASSUME REPITION COUNT IS ZERO
23B6 E441 X CD DA 19   [M80] DISPI:  call    INCHR           ;[M80] GET A CHAR FROM USER
23B9 E444 X B7                       or      a               ;[M80] IGNORE NULLS
23BA E445 X 28 FA                    jr      z,DISPI         
23BC      X CD 34 23                 call    MAKUPR          ;[M80] MAKE UPPER CASE COMMAND
     E447 X CD BF E3                 ..
23BF E44A X D6 30                    sub     '0'             ;[M80] GET RID OF OFFSET
23C1 E44C X 38 0E                    jr      c,NOTDGI        ;[M80] ... 
23C3 E44E X FE 0A                    cp      10            
23C5 E450 X 30 0A                    jr      nc,NOTDGI        
23C7 E452 X 5F                       ld      e,a             ;[M80] SAVE CHAR
23C8 E453 X 7A                       ld      a,d             ;[M80] GET ACCUM REPITITION
23C9 E454 X 07                       rlca                    ;[M80] MULTIPLY BY 2
23CA E455 X 07                       rlca                    ;[M80] BY 4
23CB E456 X 82                       add     a,d             ;[M80] AND ADD TO GET 5*D
23CC E457 X 07                       rlca                    ;[M80] *2 TO GET 10*D
23CD E458 X 83                       add     a,e             ;[M80] ADD DIGIT
23CE E459 X 57                       ld      d,a             ;[M80] SAVE BACK NEW ACCUM
23CF E45A X 18 E5                    jr      DISPI           ;[M80]  GET NEXT CHAR
23D1 E45C X
23D1 E45C X E5         [M80] NOTDGI: push    hl              ;[M80] SAVE TEXT POINTER
23D2      X 21 B4 23                 ld      hl,DISPED       ;[M80] PUT RETURN Address TO DISPED
     E45D X 21 3F E4                 ..
23D5 E460 X E3                       ex      (sp),hl         ;[M80] ON THE STACK
23D6 E461 X 15                       dec     d               ;[M80] SEE IF D=0 (REP FACTOR)
23D7 E462 X 14                       inc     d               ;[M80] SET CONDITION CODES
23D8 E463 X 20 01                    jr      nz,NTZERD       ;[M80] BRANCH AROUND
23DA E465 X 14                       inc     d               ;[M80] MAKE IT 1
23DB E466 X
23DB E466 X FE EC      [M80] NTZERD: cp      28-'0'          ;[M80] Backspace?
23DD      X CA 19 25                 jp      z,BAKED         ;[M80] HANDLE IT
     E468 X CA A4 E5                 ..
23E0 E46B X FE DD                    cp      13-'0'          ;[M80] CARRIAGE RETURN
23E2      X CA 26 25                 jp      z,CRED          ;[M80] DONE EDITING
     E46D X CA B1 E5                 ..
23E5 E470 X FE F0                    cp      ' '-'0'         ;[M80] SPACE
23E7 E472 X 28 42                    jr      z,SPED          ;[M80] GO TO ROUTINE
23E9 E474 X FE 31                    cp      'A'+32-'0'      ;[M80] COMMAND IN LOWER CASE?
23EB E476 X 38 02                    jr      c,NOTLW4        ;[M80] NO, SO OK.
23ED E478 X D6 20                    sub     32              ;[M80] CONVERT TO UPPER CASE
23EF E47A X
23EF E47A X FE 21      [M80] NOTLW4: cp      'Q'-'0'         ;[M80] QUIT?
23F1      X CA 3C 25                 jp      z,QED           ;[M80] IF SO, QUIT & PRINT "OK" OR RETURN TO INLIN
     E47C X CA C7 E5                 ..
23F4 E47F X FE 1C                    cp      'L'-'0'         ;[M80] L?
23F6 E481 X 28 68                    jr      z,LED           ;[M80] BRANCH
23F8 E483 X FE 23                    cp      'S'-'0'         ;[M80] S?
23FA E485 X 28 41                    jr      z,SED           ;[M80] SEARCH
23FC E487 X FE 19                    cp      'I'-'0'         ;[M80] I?
23FE      X CA B1 24                 jp      z,IED           ;[M80] INSERT
     E489 X CA 3C E5                 ..
2401 E48C X FE 14                    cp      'D'-'0'         ;[M80] D?
2403 E48E X 28 65                    jr      z,DED           ;[M80] DELETE
2405 E490 X FE 13                    cp      'C'-'0'         ;[M80] C?
2407 E492 X 28 7A                    jr      z,CED           ;[M80] CHANGE
2409 E494 X FE 15                    cp      'E'-'0'         ;[M80] END?
240B      X CA 29 25                 jp      z,EED           ;[M80] (SAME AS <CR> BUT DOESNT PRINT REST)
     E496 X CA B4 E5                 ..
240E E499 X FE 28                    cp      'X'-'0'         ;[M80] EXTEND?
2410      X CA AC 24                 jp      z,XED           ;[M80] GO TO END OF LINE & INSERT
     E49B X CA 37 E5                 ..
2413 E49E X FE 1B                    cp      'K'-'0'         ;[M80] KILL??
2415 E4A0 X 28 20                    jr      z,KED           ;[M80] (SAME AS "S" BUT DELETES CHARS)
2417 E4A2 X FE 18                    cp      'H'-'0'         ;[M80] HACK??
2419      X CA A9 24                 jp      z,HED           ;[M80] HACK OFF THE REST OF THE LINE & INSERT
     E4A4 X CA 34 E5                 ..
241C E4A7 X FE 11                    cp      'A'-'0'         ;[M80] AGAIN??
241E E4A9 X 3E 07                    ld      a,7             ;[M80] GET READY TO TYPE BEL.
2420 E4AB X C2 8A 19                 jp      nz,OUTDO        ;[M80] NO MATCH, SEND BEL AND RETURN TO DISPATCHER
2423 E4AE X C1                       pop     bc              ;[M80] DISPI RETURN Address
2424 E4AF X D1                       pop     de              ;[M80] LINE NUMBER INTO [D,E]
2425 E4B0 X CD EA 19                 call    CRDO            ;[M80] TYPE A CARRIAGE RETURN LINE-FEED
2428      X C3 84 23                 jp      EEDITS          ;[M80] RESTART EDITING
     E4B3 X C3 0F E4                 ..
242B E4B6 X       
242B E4B6 X 7E         [M80] SPED:   ld      a,(hl)          ;[M80] GET CHAR FROM CURENT POSIT
242C E4B7 X B7                       or      a               ;[M80] ARE WE AT END OF LINE?
242D E4B8 X C8                       ret     z               ;[M80] IF SO, RETURN
242E E4B9 X 04                       inc     b               ;[M80] BUMP CURRENT POSITION
242F E4BA X CD 8A 19                 call    OUTDO           ;[M80] TYPE CHARACTER
2432 E4BD X 23                       inc     hl              ;[M80] MOVE POINTER TO NEXT CHAR
2433 E4BE X 15                       dec     d               ;[M80] TEST IF DONE WITH REPITITIONS
2434 E4BF X 20 F5                    jr      nz,SPED         ;[M80] REPEAT
2436 E4C1 X C9                       ret                     ;[M80] RETURN TO DISPATCHER
2437 E4C2 X
2437 E4C2 X E5         [M80] KED:    push    hl              ;[M80] SAVE CURRENT CHAR POSIT
2438      X 21 7F 24                 ld      hl,TYPSLH       ;[M80] TYPE SLASH WHEN DONE
     E4C3 X 21 0A E5                 ..
243B E4C6 X E3                       ex      (sp),hl         ;[M80] PUT IT ON STACK & GET POSIT BACK
243C E4C7 X 37                       scf                     ;[M80] SET THE CARRY FLAG
243D E4C8 X
243D E4C8 X F5         [M80] SED:    push    af              ;[M80] SAVE CONDITION CODES
243E E4C9 X CD DA 19                 call    INCHR           ;[M80] GET SEARCH CHAR
2441 E4CC X 5F                       ld      e,a             ;[M80] SAVE IT
2442 E4CD X F1                       pop     af
2443 E4CE X F5                       push    af
2444      X DC 7F 24                 call    c,TYPSLH        ;[M80] TYPE BEGINNING SLASH FOR "K"
     E4CF X DC 0A E5                 ..
2447 E4D2 X 7E         [M80] SRCALP: ld      a,(hl)
2448 E4D3 X B7                       or      a
2449 E4D4 X 28 13                    jr      z,POPART
244B E4D6 X CD 8A 19                 call    OUTDO           ;[M80] TYPE THE CHAR
244E E4D9 X F1                       pop     af              ;[M80] GET KILL FLAG
244F E4DA X F5                       push    af              ;[M80] SAVE BACK
2450      X DC E6 24                 call    c,DELCHR        ;[M80] DELETE THE CHAR IF K COMMAND.
     E4DB X DC 71 E5                 ..
2453 E4DE X 38 02                    jr      c,NOTSRC        ;[M80] AND DONT MOVE POINTER AS DELCHR ALREADY DID
2455 E4E0 X 23                       inc     hl
2456 E4E1 X 04                       inc     b               ;[M80] INCREMENT LINE POSIT
2457 E4E2 X 7E         [M80] NOTSRC: ld      a,(hl)          ;[M80] ARE WE AT END
2458 E4E3 X BB                       cp      e               ;[M80] ARE CURRENT CHAR & SEARCH
2459 E4E4 X 20 EC                    jr      nz,SRCALP       ;[M80] CHAR THE SAME? IF NOT, LOOK MORE
245B E4E6 X 15                       dec     d               ;[M80] LOOK FOR N MATCHES
245C E4E7 X 20 E9                    jr      nz,SRCALP       ;[M80] IF NOT 0, KEEP LOOKING
245E E4E9 X F1         [M80] POPART: pop     af              ;[M80] GET RID OF KILL FLAG
245F E4EA X C9                       ret                     ;[M80] DONE SEARCHING
2460 E4EB X
2460      X CD 2C 23   [M80] LED:    call    LISPRX          ;[M80] TYPE REST OF LINE
     E4EB X CD B7 E3                 .. 
2463 E4EE X CD EA 19                 call    CRDO            ;[M80] TYPE CARRIAGE RETURN
2466 E4F1 X C1                       pop     bc              ;[M80] GET RID OF RETURN TO DISPED
2467      X C3 96 23                 jp      LLED            ;[M80] GO TO MAIN CODE
     E4F2 X C3 21 E4                 .. 
246A E4F5 X       
246A E4F5 X 7E         [M80] DED:    ld      a,(hl)          ;[M80] GET CHAR WHICH WE ARE TRYING TO DELETE
246B E4F6 X B7                       or      a               ;[M80] IS IT THE END OF LINE
246C E4F7 X C8                       ret     z               ;[M80] DONE IF SO
246D E4F8 X 3E 5C                    ld      a,'\'           ;[M80] TYPE BACKSLASH
246F E4FA X CD 8A 19                 call    OUTDO           ;[M80] LIKE SO
2472 E4FD X 7E         [M80] DELLP:  ld      a,(hl)          ;[M80] GET CHAR FROM LINE
2473 E4FE X B7                       or      a               ;[M80] ARE WE AT END?
2474 E4FF X 28 09                    jr      z,TYPSLH        ;[M80] TYPE SLASH
2476 E501 X CD 8A 19                 call    OUTDO           ;[M80] TYPE CHAR WE'RE GOING TO DELETE
2479      X CD E6 24                 call    DELCHR          ;[M80] DELETE CURRENT CHAR
     E504 X CD 71 E5                 .. 
247C E507 X 15                       dec     d               ;[M80] DECREMENT DELETE COUNT
247D E508 X 20 F3                    jr      nz,DELLP        ;[M80] KEEP DOING IT
247F E50A X 3E 5C      [M80] TYPSLH: ld      a,'\'           ;[M80] TYPE ENDING SLASH
2481 E50C X DF                       rst     OUTCHR          ;[M80] LIKE SO
2482 E50D X C9                       ret
2483 E50E X
2483 E50E X 7E         [M80] CED:    ld      a,(hl)          ;[M80] ARE WE AT END OF LINE?
2484 E50F X B7                       or      a               ;[M80] SEE IF 0
2485 E510 X C8                       ret     z               ;[M80] RETURN
2486 E511 X CD DA 19   [M80] CED2:   call    INCHR           ;[M80] GET CHAR TO REPLACE CHAR
2489 E514 X FE 20                    cp      ' '             ;[M80] IS IT CONTROL CHAR?
248B      X D2 9F 24                 jp      nc,NOTCCC       ;[M80] NO
     E516 X D2 2A E5                 .. 
248E E519 X FE 0A                    cp      10              ;[M80] IS IT LF?
2490 E51B X 28 0D                    jr      z,NOTCCC        ;[M80] YES
2492 E51D X FE 07                    cp      7               ;[M80] OR BELL?
2494 E51F X 28 09                    jr      z,NOTCCC        ;[M80] OK
2496 E521 X FE 09                    cp      9               ;[M80] OR TAB?
2498 E523 X 28 05                    jr      z,NOTCCC        ;[M80] OK
249A E525 X 3E 07                    ld      a,7             ;[M80] GET BELL
249C E527 X DF                       rst     OUTCHR          ;[M80] SEND IT
249D E528 X 18 E7                    jr      CED2            ;[M80] RETRY
249F E52A X 77         [M80] NOTCCC: ld      (hl),a          ;[M80] SAVE IN MEMORY
24A0 E52B X CD 8A 19                 call    OUTDO           ;[M80] ECHO THE CHAR WERE USING TO REPLACE
24A3 E52E X 23                       inc     hl              ;[M80] BUMP POINTER
24A4 E52F X 04                       inc     b               ;[M80] INCREMENT POSITION WITHIN LINE
24A5 E530 X 15                       dec     d               ;[M80] ARE WE DONE CHANGING?
24A6 E531 X 20 DB                    jr      nz,CED          ;[M80] IF NOT, CHANGE SOME MORE.
24A8 E533 X C9                       ret                     ;[M80] DONE
24A9 E534 X
24A9 E534 X 36 00      [M80] HED:    ld      (hl),0          ;[M80] MAKE LINE END AT CURRENT POSITION
24AB E536 X 48                       ld      c,b             ;[M80] SET UP LINE LENGTH CORRECTLY
24AC E537 X
24AC E537 X 16 FF      [M80] XED:    ld      d,255           ;[M80] FIND END OF LINE
24AE      X CD 2B 24                 call    SPED            ;[M80] BY CALLING SPACER
     E539 X CD B6 E4                 ..
24B1 E53C X                  ;NOW FALL INTO INSERT CODE
24B1 E53C X CD DA 19   [M80] IED:    call    INCHR           ;[M80] GET CHAR TO INSERT
24B4 E53F X FE 1C                    cp      28              ;[M80] DELETE??
24B6 E541 X 28 1F                    jr      z,TYPARW        ;[M80] YES, ACT LIKE "_" 
24B8 E543 X FE 0D                    cp      13              ;[M80] IS IT A CARRIAGE RETURN?
24BA E545 X 28 6A                    jr      z,CRED          ;[M80] DONT INSERT, AND SIMULATE <CR>
24BC E547 X FE 11                    cp      17              ;[M80] IS IT ESCAPE?
24BE E549 X C8                       ret     z               ;[M80] IF SO, DONE.
24BF E54A X FE 08                    cp      8               ;[M80] BACKSPACE?              
24C1 E54C X 28 16                    jr      z,TYPAR1        ;[M80] TYPE BACKARROW AND DELETE 
24C3 E54E X FE 0A                    cp      10              ;[M80] LINE FEED?
24C5 E550 X 28 2E                    jr      z,NTARRW        ;[M80] ALLOW IT
24C7 E552 X FE 07                    cp      7               ;[M80] BELL?
24C9 E554 X 28 2A                    jr      z,NTARRW        ;[M80] ALLOW IT
24CB E556 X FE 09                    cp      9               ;[M80] TAB?
24CD E558 X 28 26                    jr      z,NTARRW        ;[M80] ALLOW IT
24CF E55A X FE 20                    cp      ' '             ;[M80] IS IT ILLEGAL CHAR
24D1 E55C X 38 DE                    jr      c,IED           ;[M80] TOO SMALL
24D3 E55E X FE 5F                    cp      '_'             ;[M80] DELETE PREVIOUS CHAR INSERTED?
24D5 E560 X 20 1E                    jr      nz,NTARRW       ;[M80] IF NOT, JUMP AROUND NEXT CODE
24D7 E562 X 3E 5F      [M80] TYPARW: ld      a,'_'           ;[M80] TYPE IT
24D9 E562 X 05         [M80] TYPAR1: dec     b               ;[M80] ARE WE AT START OF LINE?
24DA E565 X 04                       inc     b               ;[M80] LETS SEE
24DB E566 X 28 1F                    jr      z,DINGI         ;[M80] IF SO, TYPE DING.
24DD E568 X CD 8A 19                 call    OUTDO           ;[M80] TYPE THE BACK ARROW
24E0 E56B X 2B                       dec     hl              ;[M80] BACK UP THE POINTER
24E1 E56C X 05                       dec     b               ;[M80] MOVE BACK POSIT IN LINE
24E2      X 11 B1 24                 ld      de,IED          ;[M80] SET UP RETURN Address
     E56D X 11 3C E5                 ..
24E5 E570 X D5                       push    de              ;[M80] SAVE IT  ON STACK & FALL THROUGH
24E6 E571 X                  ;[M80] SUBROUTINE TO DELETE CHAR POINTED TO BY [H,L]. CORRECTS C.
24E6 E571 X E5         [M80] DELCHR: push    hl              ;[M80] SAVE CURRENT POSIT POINTER
24E7 E572 X 0D                       dec     c               ;[M80] MAKE LENGTH OF LINE ONE LESS
24E8 E573 X 7E         [M80] CMPRSS: ld      a,(hl)          ;[M80] GET CHAR TO DELETE
24E9 E574 X B7                       or      a               ;[M80] ARE WE AT END OF LINE
24EA E575 X 37                       scf                     ;[M80] FLAG THAT DELCHR WAS CALLED (FOR K)
24EB E576 X CA 1A 14                 jp      z,POPHRT        ;[M80] IF SO, DONE COMPRESSING
24EE E579 X 23                       inc     hl              ;[M80] POINT TO NEXT BYTE
24EF E57A X 7E                       ld      a,(hl)          ;[M80] PICK IT UP
24F0 E57B X 2B                       dec     hl              ;[M80] NOW BACK AGAIN
24F1 E57C X 77                       ld      (hl),a          ;[M80] DEPOSIT IT
24F2 E57D X 23                       inc     hl              ;[M80] NOW TO NEXT BYTE
24F3 E57E X 18 F3                    jr      CMPRSS          ;[M80] KEEP CRUNCHING
24F5 E580 X
24F5 E580 X F5         [M80] NTARRW: push    af              ;[M80] SAVE THE CHAR TO BE INSERTED
24F6 E581 X 79                       ld      a,c             ;[M80] GET LENGTH OF LINE
24F7 E582 X FE 48                    cp      BUFLEN          ;[M80] SEE IF WE ARENT TRYING TO MAKE LINE TOO LONG
24F9 E584 X 38 06                    jr      c,OKINS         ;[M80] IF LENGTH OK, GO INSERT
24FB E586 X F1                       pop     af              ;[M80] GET THE UNLAWFUL CHAR
24FC E587 X
24FC E587 X 3E 07      [M80] DINGI:  ld      a,7             ;[M80] TYPE A BELL TO LET USER KNOW
24FE E589 X DF                       rst     OUTCHR          ;[M80] IT ALL OVER
24FF E58A X 18 B0      [M80] IEDG:   jr      IED             ;[M80] HE HAS TO TYPE <ESC> TO GET OUT
2501 E58C X 90         [M80] OKINS:  sub     b               ;[M80] CALC POINTER TO 0 AT END OF LINE
2502 E58D X 0C                       inc     c               ;[M80] WE ARE GOING TO HAVE LINE LONGER BY 1
2503 E58E X 04                       inc     b               ;[M80] POSITION MOVES UP ONE ALSO
2504 E58F X C5                       push    bc              ;[M80] SAVE [B,C]
2505 E590 X EB                       ex      de,hl           ;[M80] SAVE [D,E] IN [H,L]
2506 E591 X 6F                       ld      l,a             ;[M80] SAVE # OF BYTES TO MOVE IN [L]
2507 E592 X 26 00                    ld      h,0             ;[M80] GET SET TO ADD [D,E] TO [H,L]
2509 E594 X 19                       add     hl,de           ;[M80] CALC HIGH POINTER
250A E595 X 44                       ld      b,h             ;[M80] GET HIGH BYTE TO MOVE POINTER
250B E596 X 4D                       ld      c,l             ;[M80] IN [B,C]
250C E597 X 23                       inc     hl              ;[M80] ALWAYS MOVE AT LEAST ZERO AT END
250D E598 X CD 95 0B                 call    BLTUC           ;[M80] MOVE LINE OUT 1 CHAR
2510 E59B X C1                       pop     bc              ;[M80] RESTORE [B,C]  
2511 E59C X F1                       pop     af              ;[M80] GET CHAR BACK
2512 E59D X 77                       ld      (hl),a          ;[M80] SAVE IT IN LINE
2513 E59E X CD 8A 19                 call    OUTDO           ;[M80] TYPE THE CHAR
2516 E5A1 X 23                       inc     hl              ;[M80] POINT TO NEXT CHAR
2517 E5A2 X 18 E6                    jr      IEDG            ;[M80] AND GO GET MORE CHARS
2519 E5A4 X
2519 E5A4 X 78         [M80] BAKED:  ld      a,b             ;[M80] ARE WE MOVING BACK PAST THE
251A E5A5 X B7                       or      a               ;[M80] FIRST CHARACTER
251B E5A6 X C8                       ret     z               ;[M80] DON'T ALLOW IT
251C E5A7 X 05                       dec     b               ;[M80] CHANGE CURRENT POSITION
251D E5A8 X 2B                       dec     hl              ;[M80] MOVE CHAR POINTER BACK
251E E5A9 X 7E                       ld      a,(hl)          ;[M80] 
251F E5AA X CD 8A 19                 call    OUTDO           ;[M80] ECHO IT
2522 E5AD X 15                       dec     d               ;[M80] ARE WE DONE MOVING BACK?
2523 E5AE X 20 F4                    jr      nz,BAKED        ;[M80] IF NOT, GO BACK MORE
2525 E5B0 X C9                       ret                     ;[M80] RETURN
2526 E5B1 X
2526      X CD 2C 23   [M80] CRED:   call    LISPRX          ;[M80] TYPE REST OF LINE
     E5B1 X CD B7 E3                 ..
2529 E5B4 X CD EA 19   [M80] EED:    call    CRDO            ;[M80] TYPE CARRIAGE RETURN
252C E5B7 X C1                       pop     bc              ;[M80]  GET RID OF DISPED Address
252D E5B8 X D1                       pop     de              ;[M80] GET LINE # OFF STACK
252E E5B9 X 7A                       ld      a,d             ;[M80] DOUBLE BYTE ZERO.
252F E5BA X A3                       and     e               
2530 E5BB X 3C                       inc     a               ;[M80] SET ZERO IF [D,E] = ALL ONES.
2531 E5BC X 21 5F 38   {M80} EDITRT: ld      hl,BUF-1        ;[M80] START KRUNCHING AT BUF
2534 E5BF X C8                       ret     z               ;[M80] RETURN TO INLIN IF CALLED FROM THERE
2535 E5C0 X 37                       scf                     ;[M80] FLAG LINE # WAS SEEN TO FOOL INSERT CODE
2536 E5C1 X 03                       inc     bc              ;[M80] ;;Not in MBASIC-80
2537 E5C2 X F5                       push    af              ;[M80] PSW IS ON STACK
2538 E5C3 X 23                       inc     hl              ;[M80] NOW POINT AT BUF.
2539 E5C4 X C3 28 04                 jp      EDENT           ;[M80] GO TO ENTRY POINT IN MAIN CODE
253C E5C7 X
253C E5C7 X C1         [M80] QED:    pop     bc              ;[M80] GET RID OF DISPED Address
253D E5C8 X D1                       pop     de              ;[M80] GET LINE # OFF STACK
253E E5C9 X 7A                       ld      a,d             ;[M80] DOUBLE BYTE ZERO.
253F E5CA X A3                       and     e               
2540 E5CB X 3C                       inc     a               ;[M80] SET ZERO IF [D,E] = ALL ONES.
2541 E5CC X CA E5 19                 jp      z,FININL        ;[M80] TYPE CR AND STORE ZERO IN BUF.
2544 E5CF X C3 02 04                 jp      READY           ;[M80] OTHERWISE CALLED FROM MAIN
2547 E5D2 X             
2547 E5D2 X                + ;[GWB] ALLOW A COORDINATE OF THE FORM (X,Y) OR STEP(X,Y)
2547 E5D2 X                | ;[GWB] THE LATTER IS RELATIVE TO THE GRAPHICS AC.
2547 E5D2 X                | ;[GWB] THE GRAPHICS AC IS UPDATED WITH THE NEW VALUE
2547 E5D2 X                | ;[GWB] RESULT IS RETURNED WITH [B,C]=X AND [D,E]=Y
2547 E5D2 X                | ;[GWB] CALL SCAN1 TO GET FIRST IN A SET OF TWO PAIRS SINCE IT ALLOWS
2547 E5D2 X                | ;[GWB] A NULL ARGUMENT TO IMPLY THE CURRENT AC VALUE AND
2547 E5D2 X                | ;[GWB] IT WILL SKIP A "@" IF ONE IS PRESENT
2547 E5D2 X 7E         [GWB] SCAN1:  ld      a,(hl)          ;[GWB] GET THE CURRENT CHARACTER
2548 E5D3 X FE 40                    cp      '@'             ;[GWB] ALLOW MEANINGLESS "@"
254A E5D5 X CC 6B 06                 call    z,CHRGTR        ;[GWB] BY SKIPPING OVER IT
254D E5D8 X 01 00 00                 ld      bc,0            ;[GWB] ASSUME NO COODINATES AT ALL (-SECOND)
2550 E5DB X 50                       ld      d,b             
2551 E5DC X 59                       ld      e,c             
2552 E5DD X FE A9                    cp      MINUTK          ;[GWB] SEE IF ITS SAME AS PREVIOUS            
2554 E5DF X 28 16                    jr      z,SCANN         ;[GWB] USE GRAPHICS ACCUMULATOR
2556 E5E1 X                  ;[GWB] THE STANDARD ENTRY POINT   
2556 E5E1 X 7E         [GWB] SCANDX: ld      a,(hl)          ;[GWB] GET THE CURRENT CHARACTER
2557 E5E2 X FE A7                    cp      STEPTK          ;[GWB] IS IT RELATIVE?
2559 E5E4 X F5                       push    af              ;[GWB] REMEMBER
255A E5E5 X CC 6B 06                 call    z,CHRGTR        ;[GWB] SKIP OVER $STEP TOKEN
255D E5E8 X CF                       rst     SYNCHK          
255E E5E9 X 28                       byte    '('             ;[GWB] SKIP OVER OPEN PAREN
255F      X CD 73 23                 call    GETIN2          ;[GWB] SCAN X INTO [D,E]
     E4EA X CD FE E3                 ..
2562 E5ED X D5                       push    de              ;SAVE WHILE SCANNING Y
2563 E5EE X CF                       rst     SYNCHK          
2564 E5EF X 2C                       byte    ','             ;[GWB] SCAN COMMA               
2565      X CD 73 23                 call    GETIN2          ;[GWB] GET Y INTO [D,E]
     E5F0 X CD FE E3                 ..
2568 E5F3 X CF                       rst     SYNCHK          
2569 E5F4 X 29                       byte    ')'             
256A E5F5 X C1                       pop     bc              ;[GWB] GET BACK X INTO [B,C]             
256B E5F6 X F1                       pop     af              ;[GWB] RECALL IF RELATIVE OR NOT
256C E5F7 X E5         [GWB] SCANN:  push    hl              ;[GWB] SAVE TEXT POINTER
256D E5F8 X 2A 09 39                 ld      hl,(GRPACX)     ;[GWB] GET OLD POSITION
2570 E5FB X 28 03                    jr      z,SCXREL        ;[GWB] IF ZERO,RELATIVE SO USE OLD BASE
2572 E5FD X 21 00 00                 ld      hl,0            ;[GWB] IN ABSOLUTE CASE, JUST Y USE ARGEUMENT
2575 E600 X 09         [GWB] SCXREL: add     hl,bc           ;[GWB] ADD NEW VALUE
2576 E601 X 22 09 39                 ld      (GRPACX),hl     ;[GWB] UPDATE GRAPHICS ACCUMLATOR
2579 E604 X 22 03 39                 ld      (GXPOS),hl      ;[GWB] STORE SECOND COORDINTE FOR CALLER
257C E607 X 44                       ld      b,h             ;[GWB] RETURN X IN BC
257D E608 X 4D                       ld      c,l              
257E E609 X 2A 07 39                 ld      hl,(GRPACY)     ;[GWB] GET OLDY POSITION
2581 E60C X 28 03                    jr      z,SCYREL        ;[GWB] IF ZERO, RELATIVE SO USE OLD BASE
2583 E60E X 21 00 00                 ld      hl,0            ;[GWB] ABSOLUTE SO OFFSET BY 0
2586 E611 X 19         [GWB] SCYREL: add     hl,de           
2587 E612 X 22 07 39                 ld      (GRPACY),hl     ;[GWB] UPDATE Y PART OF ACCUMULATOR
258A E615 X 22 05 39                 ld      (GYPOS),hl      ;[GWB] STORE Y FOR CALLER
258D E618 X EB                       ex      de,hl           ;[GWB] RETURN Y IN [D,E]
258E E619 X E1                       pop     hl              ;[GWB] GET BACK THE TEXT POINTER
258F E61A X C9                       ret
2590 E61B X
2590 E61B X                + ;[GWB] ATTRIBUTE SCAN
2590 E61B X                | ;[GWB] LOOK AT THE CURRENT POSITION AND IF THERE IS AN ARGUMENT READ IT AS
2590 E61B X                | ;[GWB] THE 8-BIT ATTRIBUTE VALUE TO SEND TO SETATR. IF STATEMENT HAS ENDED
2590 E61B X                | ;[GWB] OR THERE IS A NULL ARGUMENT, SEND FORCLR  TO SETATR
2590 E61B X                | ;;
2590 E61B X                | ;;Entry point ATRENT will leave [A] unchanged if there is a null agrument
2590 E61B X                | ;;
2590 E61B X 3A 00 39   [GWB] ATRSCN: ld      a,(FORCLR)      ;;Get Default foreground color
2593 E61E X C5         {GWB} ATRENT: push    bc              ;[GWB] SAVE THE CURRENT POINT
2594 E61F X D5                       push    de              
2595 E620 X 5F                       ld      e,a             ;;Preload Attribute with Default Value
2596 E621 X 2B                       dec     hl              ;[GWB] SEE IF STATEMENT ENDED
2597 E622 X D7                       rst     CHRGET
2598 E623 X 28 09                    jr      z,ATRFIN        ;[GWB] USE DEFAULT
259A E625 X CF                       rst     SYNCHK
259B E626 X 2C                       byte    ','             ;[GWB]  INSIST ON COMMA
259C E627 X FE 2C                    cp      ','             ;[GWB] ANOTHER COMMA FOLLOWS?
259E E629 X 28 03                    jr      z,ATRFIN        ;[GWB] IF SO, NULL ARGUMENT SO USE DEFAULT
25A0 E62B X CD 54 0B                 call    GETBYT          ;[GWB] GET THE BYTE
25A3 E62E X 7B         [GWB] ATRFIN: ld      a,e             ;[GWB] GET ATTRIBUTE INTO [A]
25A4 E62F X E5                       push    hl              ;[GWB] SAVE THE TEXT POINTER
25A5      X CD 84 2D                 call    SETATR          ;[GWB] SET THE ATTRIBUTE AS THE CURRENT ONE
     E630 X CD 0F EE                 ..
25A8 E633 X DA 97 06                 jp      c,FCERR         ;[GWB] ILLEGAL ATTRIBUTES GIVE FUNCTION CALL
25AB E636 X E1                       pop     hl              
25AC E637 X D1                       pop     de              ;[GWB] GET BACK CURRENT POINT
25AD E638 X C1                       pop     bc              
25AE E639 X C3 6C 06                 jp      CHRGT2          
25B1 E63C X
25B1 E63C X                + ;[GWB] XDELT SETS [H,L]=ABS(GXPOS-[B,C]) AND SETS CARRY IF [B,C].GT.GXPOS
25B1 E63C X                | ;[GWB] ALL REGISTERS EXCEPT [H,L] AND [A,PSW] ARE PRESERVED
25B1 E63C X                | ;[GWB] NOTE: [H,L] WILL BE A DELTA BETWEEN GXPOS AND [B,C] - ADD 1 FOR AN X "COUNT"
25B1 E63C X                | ;[GWB]
25B1 E63C X 2A 03 39   [GWB] XDELT:  ld      hl,(GXPOS)      ;[GWB] GET ACCUMULATOR POSITION
25B4 E63F X 7D                       ld      a,l             
25B5 E640 X 91                       sub     c               ;[GWB] DO SUBTRACT INTO [H,L]
25B6 E641 X 6F                       ld      l,a             
25B7 E642 X 7C                       ld      a,h             
25B8 E643 X 98                       sbc     a,b             
25B9 E644 X 67                       ld      h,a             
25BA E645 X D0         [GWB] CNEGHL: ret     nc              
25BB E646 X
25BB E646 X AF         [GWB] NEGHL:  xor       a             ;[GWB] STANDARD [H,L] NEGATE
25BC E647 X 95                       sub       l
25BD E648 X 6F                       ld        l,a
25BE E649 X 9C                       sbc       a,h
25BF E64A X 95                       sub       l
25C0 E64B X 67                       ld        h,a
25C1 E64C X 37                       scf
25C2 E64D X C9                       ret
25C3 E64E X
25C3 E64E X                + ;[GWB] YDELT SETS [H,L]=ABS(GYPOS-[D,E]) AND SETS CARRY IF [D,E].GT.GYPOS
25C3 E64E X                | ;[GWB] ALL REGISTERS EXCEPT [H,L] AND [A,PSW] ARE PRESERVED
25C3 E64E X                | ;[GWB]
25C3 E64E X 2A 05 39   [GWB] YDELT:  ld      hl,(GYPOS)
25C6 E651 X 7D                       ld      a,l
25C7 E652 X 93                       sub     e
25C8 E653 X 6F                       ld      l,a
25C9 E654 X 7C                       ld      a,h
25CA E655 X 9A                       sbc     a,d
25CB E656 X 67                       ld      h,a
25CC E657 X 18 EC                    jr      CNEGHL
25CE E659 X
25CE E659 X                + ;;Register Exchange Routines
25CE E659 X                | ;[GWB] XCHGX EXCHANGES [B,C] WITH GXPOS
25CE E659 X                | ;[GWB] XCHGY EXCHANGES [D,E] WITH GYPOS
25CE E659 X                | ;[GWB] XCHGAC PERFORMS BOTH OF THE ABOVE
25CE E659 X                | ;[GWB] NONE OF THE OTHER REGISTERS IS AFFECTED
25CE E659 X                | ;[GWB]
25CE E659 X E5         [GWB] XCHGY:  push    hl
25CF E65A X 2A 05 39                 ld      hl,(GYPOS)
25D2 E65D X EB                       ex      de,hl
25D3 E65E X 22 05 39                 ld      (GYPOS),hl
25D6 E661 X E1                       pop     hl
25D7 E662 X C9                       ret
25D8 E663 X
25D8      X CD CE 25   [GWB] XCHGAC: call    XCHGY
     E663 X CD 59 E6                 ..
25DB E666 X E5         [GWB] XCHGX:  push    hl
25DC E667 X C5                       push    bc
25DD E668 X 2A 03 39                 ld      hl,(GXPOS)
25E0 E66B X E3                       ex      (sp),hl
25E1 E66C X 22 03 39                 ld      (GXPOS),hl
25E4 E66F X C1                       pop     bc
25E5 E670 X E1                       pop     hl
25E6 E671 X C9                       ret
25E7 E672 X
25E7 E672 X                + ;[GWB] LINE COMMAND
25E7 E672 X                | ;[GWB] 
25E7 E672 X                | ;[GWB] LINE [(X1,Y1)]-(X2,Y2) [,ATTRIBUTE[,B[F]]]
25E7 E672 X                | ;[GWB] DRAW A LINE FROM (X1,Y1) TO (X2,Y2) EITHER
25E7 E672 X                | ;[GWB] 1. STANDARD FORM -- JUST A LINE CONNECTING THE 2 POINTS
25E7 E672 X                | ;[GWB] 2. ,B=BOXLINE -- RECTANGLE TREATING (X1,Y1) AND (X2,Y2) AS OPPOSITE CORNERS
25E7 E672 X                | ;[GWB] 3. ,BF= BOXFILL --  FILLED RECTANGLE WITH (X1,Y1) AND (X2,Y2) AS OPPOSITE CORNERS
25E7 E672 X                | ;[GWB]
25E7 E672 X                | ;;ATTRIBUTE is the Foreground Color
25E7      X CD 47 25   [GWB] GLINE:  call    SCAN1           ;[GWB] SCAN THE FIRST COORDINATE
     E672 X CD D2 E5                 ..
25EA E675 X C5                       push    bc              ;[GWB] SAVE THE POINT
25EB E676 X D5                       push    de              
25EC E677 X CF                       rst     SYNCHK          
25ED E678 X A9                       byte    MINUTK          ;[GWB] MAKE SURE ITS PROPERLY SEPERATED
25EE      X CD 56 25                 call    SCANDX          ;[GWB] SCAN THE SECOND SET
     E679 X CD E1 E5                 ..
25F1      X CD 90 25                 call    ATRSCN          ;[GWB] SCAN THE ATTRIBUTE
     E67C X CD 1B E6                 ..
25F4 E67F X D1                       pop     de              ;[GWB] GET BACK THE FIRST POINT
25F5 E680 X C1                       pop     bc              
25F6 E681 X 28 43                    jr      z,DOLINE        ;[GWB] IF STATEMENT ENDED ITS A NORMAL LINE
25F8 E683 X CF                       rst     SYNCHK          
25F9 E684 X 2C                       byte    ','             ;[GWB] OTHERWISE MUST HAVE A COMMA
25FA E685 X CF                       rst     SYNCHK          
25FB E686 X 42                       byte    'B'             
25FC E687 X 28 53                    jr      z,BOXLIN        ;[GWB] IF JUST "B" THE NON-FILLED BOX
25FE E689 X CF                       rst     SYNCHK          
25FF E68A X 46                       byte    'F'             ;[GWB] MUST BE FILLED BOX
2600 E68B X E5         {GWB} DOBOXF: push    hl              ;[GWB] SAVE THE TEXT POINTER
2601      X CD 2B 2E                 call    SCLXYX          ;[GWB] SCALE FIRST POINT
     E68C X CD B6 EE                 ..
2604      X CD D8 25                 call    XCHGAC          ;[GWB] SWITCH POINTS
     E68F X CD 63 E6                 ..
2607      X CD 2B 2E                 call    SCLXYX          ;[GWB] SCALE SECOND POINT
     E692 X CD B6 EE                 ..
260A      X CD C3 25                 call    YDELT           ;[GWB] SEE HOW MANY LINES AND SET CARRY
     E695 X CD 4E E6                 ..
260D      X DC CE 25                 call    c,XCHGY         ;[GWB] MAKE [D,E] THE SMALLEST Y
     E698 X DC 59 E6                 ..
2610 E69B X 23                       inc     hl              ;[GWB] MAKE [H,L] INTO A COUNT
2611 E69C X E5                       push    hl              ;[GWB] SAVE COUNT OF LINES
2612      X CD B1 25                 call    XDELT           ;[GWB] GET WIDTH AND SMALLEST X
     E69D X CD 3C E6                 ..
2615      X DC DB 25                 call    c,XCHGX         ;[GWB] MAKE [B,C] THE SMALLEST X
     E6A0 X DC 66 E6                 ..
2618 E6A3 X 23                       inc     hl              ;[GWB] MAKE [H,L] INTO A WIDTH COUNT
2619 E6A4 X E5                       push    hl              ;[GWB] SAVE WIDTH COUNT
261A      X CD FD 2D                 call    MAPXYP          ;[GWB] MAP INTO A "C"
     E6A5 X CD 88 EE                 ..
261D E6A8 X D1                       pop     de              ;[GWB] GET WIDTH COUNT
261E E6A9 X C1                       pop     bc              ;[GWB] GET LINE COUNT
261F E6AA X D5         [GWB] BOXLOP: push    de              ;[GWB] SAVE WIDTH
2620 E6AB X C5                       push    bc              ;[GWB] SAVE NUMBER OF LINES
2621      X CD 7D 2D                 call    FETCHC          ;[GWB] LOOK AT CURRENT C
     E6AC X CD 08 EE                 ..
2624 E6AF X F5                       push    af              ;[GWB] SAVE BIT MASK OF CURRENT "C"
2625 E6B0 X E5                       push    hl              ;[GWB] SAVE Address
2626 E6B1 X EB                       ex      de,hl           ;[GWB] SET UP FOR NSETCX WITH COUNT
2627      X CD C0 2D                 call    NSETCX          ;[GWB] IN [H,L] OF POINTS TO SETC
     E6B2 X CD 4B EE                 ..
262A E6B5 X E1                       pop     hl              ;[GWB] GET BACK STARTING C
262B E6B6 X F1                       pop     af              ;[GWB] Address AND BIT MASK
262C      X CD 76 2D                 call    STOREC          ;[GWB] SET UP AS CURRENT "C"
     E6B7 X CD 01 EE                 ..
262F      X CD BD 2E                 call    DOWNC           ;[GWB] MOVE TO NEXT LINE DOWN IN Y
     E6BA X CD 48 EF                 ..
2632 E6BD X C1                       pop     bc              ;[GWB] GET BACK NUMBER OF LINES
2633 E6BE X D1                       pop     de              ;[GWB] GET BACK WIDTH
2634 E6BF X 0B                       dec     bc              ;[GWB] COUNT DOWN LINES
2635 E6C0 X 78                       ld      a,b             
2636 E6C1 X B1                       or      c               ;[GWB] SEE IF ANY LEFT
2637 E6C2 X 20 E6                    jr      nz,BOXLOP       ;[GWB] KEEP DRAWING MORE LINES
2639 E6C4 X E1                       pop     hl              
263A E6C5 X C9                       ret                     
263B E6C6 X
263B E6C6 X C5         [GWB] DOLINE: push    bc              ;[GWB] SAVE COORDINATES
263C E6C7 X D5                       push    de              
263D E6C8 X E5                       push    hl              ;[GWB] SAVE TEXT POINTER
263E      X CD 7B 26                 call    DOGRPH          
     E6C9 X CD 06 E7                 ..
2641 E6CC X 2A 09 39                 ld      hl,(GRPACX)     ;[GWB] RESTORE ORIGINAL SECOND COORDINATE
2644 E6CF X 22 03 39                 ld      (GXPOS),hl      
2647 E6D2 X 2A 07 39                 ld      hl,(GRPACY)     ;[GWB] FOR BOXLIN CODE
264A E6D5 X 22 05 39                 ld      (GYPOS),hl      
264D E6D8 X E1                       pop     hl              ;[GWB] RESTORE TEXT POINTER
264E E6D9 X D1                       pop     de              
264F E6DA X C1                       pop     bc              
2650 E6DB X C9                       ret                     
2651 E6DC X
2651 E6DC X E5         [GWB] BOXLIN: push    hl              ;[GWB] SAVE TEXT POINTER
2652 E6DD X 2A 05 39                 ld      hl,(GYPOS)      
2655 E6E0 X E5                       push    hl              ;[GWB] SAVE Y2
2656 E6E1 X D5                       push    de              ;[GWB] SAVE Y1
2657 E6E2 X EB                       ex      de,hl           ;[GWB] MOVE Y2 TO Y1
2658      X CD 3B 26                 call    DOLINE          ;[GWB] DO TOP LINE
     E6E3 X CD C6 E6                 ..
265B E6E6 X E1                       pop     hl              ;[GWB] MOVE Y1 TO Y2
265C E6E7 X 22 05 39                 ld      (GYPOS),hl      
265F E6EA X EB                       ex      de,hl           ;[GWB] RESTORE Y1 TO [D,E]
2660      X CD 3B 26                 call    DOLINE          
     E6EB X CD C6 E6                 ..
2663 E6EE X E1                       pop     hl              ;[GWB] GET BACK Y2
2664 E6EF X 22 05 39                 ld      (GYPOS),hl      ;[GWB] AND RESTORE
2667 E6F2 X 2A 03 39                 ld      hl,(GXPOS)      ;[GWB] GET X2
266A E6F5 X C5                       push    bc              ;[GWB] SAVE X1
266B E6F6 X 44                       ld      b,h             ;[GWB] SET X1=X2
266C E6F7 X 4D                       ld      c,l             
266D      X CD 3B 26                 call    DOLINE          
     E6F8 X CD C6 E6                 ..
2670 E6FB X E1                       pop     hl              
2671 E6FC X 22 03 39                 ld      (GXPOS),hl      ;[GWB] SET X2=X1
2674 E6FF X 44                       ld      b,h             ;[GWB] RESTORE X1 TO [B,C]
2675 E700 X 4D                       ld      c,l             
2676      X CD 3B 26                 call    DOLINE          
     E701 X CD C6 E6                 ..
2679 E704 X E1                       pop     hl              ;[GWB] RESTORE THE TEXT POINTER
267A E705 X C9                       ret                     
267B E706 X
267B      X CD 2B 2E   [GWB] DOGRPH: call    SCLXYX          ;[GWB] CHEATY SCALING - JUST TRUNCATE FOR NOW
     E706 X CD B6 EE                 ..
267E      X CD D8 25                 call    XCHGAC          
     E709 X CD 63 E6                 ..
2681      X CD 2B 2E                 call    SCLXYX          
     E70C X CD B6 EE                 ..
2684      X CD C3 25   {GWB} DOGRP2: call    YDELT           ;[GWB] GET COUNT DIFFERENCE IN [H,L]
     E70F X CD 4E E6                 ..
2687      X DC D8 25                 call    c,XCHGAC        ;[GWB] IF CURRENT Y IS SMALLER NO EXCHANGE
     E712 X DC 63 E6                 ..
268A E715 X D5                       push    de              ;[GWB] SAVE Y1 COORDINATE
268B E716 X E5                       push    hl              ;[GWB] SAVE DELTA Y
268C      X CD B1 25                 call    XDELT           
     E717 X CD 3C E6                 ..
268F E71A X EB                       ex      de,hl           ;[GWB] PUT DELTA X INTO [D,E]
2690      X 21 DB 2E                 ld      hl,RIGHTC       ;[GWB] ASSUME X WILL GO RIGHT
     E71B X 21 66 EF                 ..
2693 E71E X 30 03                    jr      nc,LINCN2        
2695      X 21 D1 2E                 ld      hl,LEFTC        
     E720 X 21 5C EF                 ..
2698 E723 X E3         [GWB] LINCN2: ex      (sp),hl         ;[GWB] XTHL
2699 E724 X E7                       rst     COMPAR          ;[GWB] SEE WHICH DELTA IS BIGGER
269A E725 X 30 10                    jr      nc,YDLTBG       ;[GWB] YDELTA IS BIGGER OR EQUAL 
269C E727 X 22 13 39                 ld      (MINDEL),hl     ;[GWB] SAVE MINOR AXIS DELTA (Y)
269F E72A X E1                       pop     hl              ;[GWB] GET X ACTION ROUTINE
26A0 E72B X 22 0C 39                 ld      (MAXUPD+1),hl   ;[GWB] SAVE IN MAJOR ACTION Address
26A3      X 21 BD 2E                 ld      hl,DOWNC        ;[GWB] ALWAYS INCREMENT 
     E72E X 21 48 EF                 ..
26A6 E731 X 22 0F 39                 ld      (MINUPD+1),hl   ;[GWB] WHICH IS THE MINOR AXIS
26A9 E734 X EB                       ex      de,hl           ;[GWB] [H,L]=DELTA X=MAJOR DELTA
26AA E735 X 18 0F                    jr      LINCN3          ;[GWB] MERGE WITH YDLTBG CASE AND DO DRAW
26AC E737 X
26AC E737 X E3         [GWB] YDLTBG: ex      (sp),hl         ;[GWB] XTHL
26AD      X 22 0F 39                 ld      (MINUPD+1),hl   ;[GWB] SAVE Address OF MINOR AXIS UPDATE
26B0      X 21 BD 2E                 ld      hl,DOWNC        ;[GWB] Y IS ALWAYS INCREMENT MODE
     E738 X 22 0F 39                 ld      (MINUPD+1),hl   ;;;Swapped
     E73B X 21 48 EF                 ld      hl,DOWNC        ;;;
26B3 E73E X 22 0C 39                 ld      (MAXUPD+1),hl   ;[GWB] SAVE AS MAJOR AXIS UPDATE
26B6 E741 X EB                       ex      de,hl           ;[GWB] [H,L]=DELTA X
26B7 E742 X 22 13 39                 ld      (MINDEL),hl     ;[GWB] SAVE MINOR DELTA
26BA E745 X E1                       pop     hl              ;[GWB] [H,L]=DELTA Y=MAJOR DELTA
26BB E746 X
26BB E746 X                + ;;Draw a Line
26BB E746 X                | ;[GWB] MAJOR AXIS IS ONE WITH THE LARGEST DELTA
26BB E746 X                | ;[GWB] MINOR IS THE OTHER
26BB E746 X                | ;[GWB] READY TO DRAW NOW
26BB E746 X                | ;[GWB] MINUPD+1=Address TO GO TO UPDATE MINOR AXIS COORDINATE
26BB E746 X                | ;[GWB] MAXUPD+1=Address TO GO TO UPDATE MAJOR AXIS COORDINATE
26BB E746 X                | ;[GWB] [H,L]=MAJOR AXIS DELTA=# OF POINTS-1
26BB E746 X                | ;[GWB] MINDEL=DELTA ON MINOR AXIS
26BB E746 X                | ;[GWB]
26BB E746 X                | ;[GWB] IDEA IS
26BB E746 X                | ;[GWB]  SET SUM=MAJOR DELTA/2
26BB E746 X                | ;[GWB]  [B,C]=# OF POINTS
26BB E746 X                | ;[GWB]  MAXDEL=-MAJOR DELTA (CONVENIENT FOR ADDING)
26BB E746 X                | ;[GWB] LINE LOOP (LINLP3):
26BB E746 X                | ;[GWB]       DRAW AT CURRENT POSITION
26BB E746 X                | ;[GWB]       UPDATE MAJOR AXIS
26BB E746 X                | ;[GWB]       SUM=SUM+MINOR DELTA
26BB E746 X                | ;[GWB]       IF SUM.GT.MAJOR DELTA THEN UPDATE MINOR AND SUM=SUM-MAJOR DELTA
26BB E746 X                | ;[GWB]       DECREMENT [B,C] AND TEST FOR 0 -- LOOP IF NOT
26BB E746 X                | ;[GWB] END LOOP
26BB E746 X D1         [GWB] LINCN3: pop     de              ;[GWB] GET BACK Y1 
26BC E747 X E5                       push    hl              ;[GWB] SAVE FOR SETTING UP COUNT
26BD      X CD BB 25                 call    NEGHL           
     E748 X CD 46 E6                 ..                      
26C0 E74B X 22 11 39                 ld      (MAXDEL),hl     ;[GWB] SAVE MAJOR DELTA FOR SUMMING
26C3      X CD FD 2D                 call    MAPXYP          ;[GWB] GET POSITION INTO BITMSK AND [H,L]  
     E74E X CD 88 EE                 ..                      
26C6 E751 X D1                       pop     de              
26C7 E752 X D5                       push    de              ;[GWB] START SUM AT MAXDEL/2 
26C8      X CD F0 26                 call    HLFDE            
     E753 X CD 7B E7                 .. 
26CB E756 X C1                       pop     bc              ;[GWB] GET COUNT IN [B,C]
26CC E757 X 03                       inc     bc              ;[GWB] NUMBER OF POINTS IS DELTA PLUS ONE 
26CD E758 X 18 07                    jr      LINLP3           
26CF E75A X
26CF E75A X E1               LINLPR: pop     hl
26D0 E75B X 78                       ld      a,b
26D1 E75C X B1                       or      c
26D2 E75D X C8                       ret     z
26D3 E75E X CD 0B 39   [GWB] LINLOP: call    MAXUPD          ;[GWB] UPDATE MAJOR AXIS
26D6      X                  ;[GWB] Inner loop of line code. 
26D6      X CD 99 2D   [GWB] LINLP3: call    SETC            ;[GWB] SET CURRENT POINT
     E761 X CD 24 EE                 ..
26D9 E764 X 0B                       dec     bc              
26DA E765 X E5                       push    hl              
26DB E766 X 2A 13 39                 ld      hl,(MINDEL)     
26DE E769 X 19                       add     hl,de           ;[GWB] ADD SMALL DELTA TO SUM
26DF E76A X EB                       ex      de,hl           
26E0 E76B X 2A 11 39                 ld      hl,(MAXDEL)     ;[GWB] UPDATE SUM FOR NEXT POINT
26E3 E76E X 19                       add     hl,de           
26E4 E76F X 30 E9                    jr      nc,LINLPR       
26E6 E771 X EB                       ex      de,hl           
26E7 E772 X E1                       pop     hl              
26E8 E773 X 78                       ld      a,b             
26E9 E774 X B1                       or      c               
26EA E775 X C8                       ret     z               
26EB E776 X CD 0E 39                 call    MINUPD          ;[GWB] ADVANCE MINOR AXIS           
26EE E779 X 18 E3                    jr      LINLOP          ;[GWB] CONTINUE UNTIL COUNT EXHAUSTED
26F0 E77B X    
26F0 E77B X                  ;;;On the Z80 this can be done with RR D : RR E (4 bytes)
26F0 E77B X 7A         [GWB] HLFDE:  ld      a,d             ;;DE = DE/2
26F1 E77C X B7                       or      a
26F2 E77D X 1F                       rra
26F3 E77E X 57                       ld      d,a
26F4 E77F X 7B                       ld      a,e
26F5 E780 X 1F                       rra     
26F6 E781 X 5F                       ld      e,a
26F7 E782 X C9                       ret
26F8 E783 X
26F8 E783 X                  ;Restore Text Pointer and Return
26F8 E783 X E1         [GWB] POPTRT: pop     hl
26F9 E784 X C9                       ret
26FA E785 X  
26FA E785 X EB         [GWB] NEGDE:  ex      de,hl           ;;DE = 0 - DE
26FB      X CD BB 25                 call    NEGHL
     E786 X CD 46 E6                 ..
26FE E789 X EB                       ex      de,hl
26FF E78A X C9                       ret
2700 E78B X
2700      X CD 47 25   [GWB] CIRCLE: call    SCAN1           ;[GWB] GET (X,Y) OF CENTER INTO GRPACX,Y
     E78B X CD D2 E5                 ..
2703 E78E X CF                       rst     SYNCHK
2704 E78F X 2C                       byte    ','             ;[GWB] EAT COMMA
2705      X CD 73 23                 call    GETIN2          ;[GWB] GET THE RADIUS
     E790 X CD FE E3                 ..
2708 E793 X 7A                       ld      a,d
2709 E794 X B7                       or      a
270A E795 X FA 97 06                 jp      m,FCERR
270D E798 X E5                       push    hl              ;[GWB] SAVE TXTPTR
270E E799 X EB                       ex      de,hl
270F E79A X 22 03 39                 ld      (GXPOS),hl      ;[GWB] SAVE HERE TILL START OF MAIN LOOP
2712      X CD 20 23                 call    MAKINT          ;[GWB] PUT INTEGER INTO FAC
     E79D X CD AB E3                 ..
2715 E7A0 X CD 75 09                 call    CHKNUM          ;[M65] MUST BE NUMBER
2718 E7A3 X 01 35 80                 ld      bc,$8035        ;[GWB] LOAD REGS WITH SQR(2)/2
271B E7A6 X 11 F3 04                 ld      de,$04F3        
271E E7A9 X CD CB 13                 call    FMULT           ;[GWB] DO FLOATING PT MULTIPLY
2721      X CD 04 23                 call    FRCINX          ;[GWB] CONVERT TO INTEGER & GET INTO [HL]
     E7AC X CD 8F E3                 ..
2724 E7AF X 22 1A 39                 ld      (CNPNTS),hl     ;[GWB] CNPNTS=RADIUS*SQR(2)/2=# PTS TO PLOT
2727 E7B2 X AF                       xor     a               ;[GWB] ZERO OUT GLINEF - NO LINES TO CENTER
2728 E7B3 X 32 19 39                 ld      (GLINEF),a
272B E7B6 X 32 25 39                 ld      (CSCLXY),a
272E E7B9 X E1                       pop     hl              ;[GWB] REGET TXTPTR
272F      X CD 90 25                 call    ATRSCN          ;[GWB] SCAN POSSIBLE ATTRIBUTE
     E7BA X CD 1B E6                 ..
2732 E7BD X 0E 01                    ld      c,1             ;[GWB] SET LO BIT IN GLINEF FOR LINE TO CNTR
2734 E7BF X 11 00 00                 ld      de,0            ;[GWB] DEFAULT START COUNT = 0
2737      X CD 27 29                 call    CGTCNT           
     E7C2 X CD B2 E9                 ..
273A E7C5 X D5                       push    de              ;[GWB] SAVE COUNT FOR LATER COMPARISON
273B E7C6 X 0E 80                    ld      c,128           ;[GWB] SET HI BIT IN GLINEF FOR LINE TO CNTR
273D E7C8 X 11 FF FF                 ld      de,0-1          ;[GWB] DEFAULT END COUNT = INFINITY
2740      X CD 27 29                 call    CGTCNT           
     E7CB X CD B2 E9                 ..
2743 E7CE X E3                       ex      (sp),hl         ;[GWB] GET START COUNT, PUSH TXTPTR TILL DONE
2744 E7CF X AF                       xor     a               
2745 E7D0 X EB                       ex      de,hl           ;[GWB] REVERSE REGS TO TEST FOR .LT.
2746 E7D1 X E7                       rst     COMPAR          ;[GWB] SEE IF END .GE. START
2747 E7D2 X 3E 00                    ld      a,0          
2749      X D2 5B 27                 jp      nc,CSTPLT       ;[GWB] YES, PLOT POINTS BETWEEN STRT & END
     E7D4 X D2 E6 E7                 ..
274C E7D7 X 3D                       dec     a               ;[GWB] PLOT POINTS ABOVE & BELOW
274D E7D8 X EB                       ex      de,hl           ;[GWB] SWAP START AND END SO START .LT. END
274E E7D9 X F5                       push    af              ;[GWB] Swap sense of center line flags
274F E7DA X 3A 19 39                 ld      a,(GLINEF)      
2752 E7DD X 4F                       ld      c,a             
2753 E7DE X 07                       rlca                    
2754 E7DF X 07                       rlca                    
2755 E7E0 X B1                       or      c               
2756 E7E1 X 0F                       rrca                    
2757 E7E2 X 32 19 39                 ld      (GLINEF),a      ;[GWB] Store swapped flags
275A E7E5 X F1                       pop     af              
275B E7E6 X
275B E7E6 X 32 1C 39   [GWB] CSTPLT: ld      (CPLOTF),a      ;[GWB] SET UP PLOT POLARITY FLAG
275E E7E9 X EB                       ex      de,hl           
275F E7EA X 22 23 39                 ld      (CSTCNT),hl     ;STORE START COUNT
2762 E7ED X EB                       ex      de,hl           
2763 E7EE X 22 17 39                 ld      (CENCNT),hl     ;[GWB] AND END COUNT
2766 E7F1 X E1                       pop     hl              ;[GWB] GET TXTPTR
2767 E7F2 X 2B                       dec     hl              ;[GWB] NOW SEE IF LAST CHAR WAS A COMMA
2768 E7F3 X D7                       rst     CHRGET          
2769      X C2 7E 27                 jp      nz,CIRC1        ;[GWB] SOMETHING THERE
     E7F4 X C2 09 E8                 ..
276C E7F7 X E5                       push    hl              ;[GWB] SAVE TXTPTR
276D      X CD 6F 2D                 call    GTASPC          ;[GWB] GET DEFAULT ASPECT RATIO INTO [HL]
     E7F8 X CD FA ED                 ..
2770 E7FB X 7C                       ld      a,h             
2771 E7FC X B7                       or      a               ;[GWB] IS ASPECT RATIO GREATER THAN ONE?
2772      X CA 9E 27                 jp      z,CIRC2         ;[GWB] BRIF GOOD ASPECT RATIO
     E7FD X CA 29 E8                 ..
2775 E800 X 3E 01                    ld      a,1          
2777 E802 X 32 25 39                 ld      (CSCLXY),a      
277A E805 X EB                       ex      de,hl           ;[GWB] ASPECT RATIO IS GREATER THAN ONE, USE INVERSE
277B      X C3 9E 27                 jp      CIRC2           ;[GWB] NOW GO CONVERT TO FRACTION OF 256
     E806 X C3 29 E8                 ..
277E E809 X                                             
277E E809 X CF         [GWB] CIRC1:  rst     SYNCHK          ;[GWB] EAT COMMA
277F E80A X 2C                       byte    ','             
2780 E80B X CD 85 09                 call    FRMEVL          ;[GWB] EVALUATE A FORMULA
2783 E80E X E5                       push    hl              ;[GWB] SAVE TXTPTR
2784 E80F X CD 75 09                 call    CHKNUM          ;[M65] MUST BE NUMBER
2787      X CD 79 29                 call    CMPONE          ;[GWB] SEE IF GREATER THAN ONE
     E812 X CD 04 EA                 ..
278A      X C2 94 27                 jp      nz,CIRC11       ;[GWB] LESS THAN ONE - SCALING Y
     E815 X C2 1F E8                 ..
278D E818 X 3C                       inc     a               ;[GWB] MAKE [A] NZ
278E E819 X 32 25 39                 ld      (CSCLXY),a      ;[GWB] FLAG SCALING X
2791 E81C X CD 2F 14                 call    FDIV            ;[GWB] RATIO = 1/RATIO, MAKE NUMBER FRACTION OF 256
2794 E81F X              
2794 E81F X 21 E7 38   [GWB] CIRC11: ld      hl,FAC          ;[GWB] BY MULTIPLYING BY 2^8 (256)
2797 E822 X 7E                       ld      a,(hl)               
2798 E823 X C6 08                    add     a,8             ;[GWB] ADD 8 TO EXPONENT
279A E825 X 77                       ld      (hl),a               
279B      X CD 04 23                 call    FRCINX          ;[GWB] MAKE IT AN INTEGER IN [HL]
     E826 X CD 8F E3                 ..
279E E829 X 22 15 39   [GWB] CIRC2:  ld      (ASPECT),hl     ;[GWB] STORE ASPECT RATIO
27A1 E82C X             
27A1 E82C X               +  ;[GWB]       CIRCLE ALGORITHM
27A1 E82C X               |  ;[GWB]
27A1 E82C X               |  ;[GWB]       [HL]=X=RADIUS * 2 (ONE BIT FRACTION FOR ROUNDING)
27A1 E82C X               |  ;[GWB]       [DE]=Y=0
27A1 E82C X               |  ;[GWB]       SUM =0
27A1 E82C X               |  ;[GWB] LOOP: IF Y IS EVEN THEN
27A1 E82C X               |  ;[GWB]             REFLECT((X+1)/2,(Y+1)/2) (I.E., PLOT POINTS)
27A1 E82C X               |  ;[GWB]             IF X.LT.Y THEN EXIT
27A1 E82C X               |  ;[GWB]       SUM=SUM+2*Y+1
27A1 E82C X               |  ;[GWB]       Y=Y+1
27A1 E82C X               |  ;[GWB]       IF SUM.GGWGRP.RNO
27A1 E82C X               |  ;[GWB]             SUM=SUM-2*X+1
27A1 E82C X               |  ;[GWB]             X=X-1
27A1 E82C X               |  ;[GWB]       ENDIF
27A1 E82C X               |  ;[GWB]       GOTO LOOP
27A1 E82C X               |  ;[GWB]
27A1 E82C X 11 00 00                 ld      de,0            ;[GWB] INIT Y = 0
27A4 E82F X EB                       ex      de,hl                
27A5 E830 X 22 21 39                 ld      (CRCSUM),hl     ;[GWB] SUM = 0
27A8 E833 X EB                       ex      de,hl                
27A9 E834 X 2A 03 39                 ld      hl,(GXPOS)      ;[GWB] X = RADIUS*2
27AC E837 X 29                       add     hl,hl               
27AD E838 X
27AD E838 X CD 25 1A   [GWB] CIRCLP: call    ISCNTC          ;[M80] CHECK FOR CONTROL-C
27B0 E83B X 7B                       ld      a,e             ;[GWB] TEST EVENNESS OF Y
27B1 E83C X 1F                       rra                     ;[GWB] TO SEE IF WE NEED TO PLOT
27B2      X DA CB 27                 jp      c,CRCLP2        ;[GWB] Y IS ODD - DON'T TEST OR PLOT
     E83D X DA 56 E8                 ..
27B5 E840 X D5                       push    de              ;[GWB] SAVE Y AND X
27B6 E841 X E5                       push    hl              
27B7 E842 X 23                       inc     hl              ;[GWB] ACTUAL COORDS ARE (X+1)/2,(Y+1)/2
27B8 E843 X EB                       ex      de,hl           
27B9      X CD F0 26                 call    HLFDE           ;[GWB] (PLUS ONE BEFORE DIVIDE TO ROUND UP)
     E844 X CD 7B E7                 ..
27BC E847 X EB                       ex      de,hl           
27BD E848 X 13                       inc     de              
27BE      X CD F0 26                 call    HLFDE           
     E849 X CD 7B E7                 ..
27C1      X CD FC 27                 call    CPLOT8          
     E84C X CD 87 E8                 ..
27C4 E84F X D1                       pop     de              ;[GWB] RESTORE X AND Y
27C5 E850 X E1                       pop     hl              ;[GWB] INTO [DE] AND [HL] (BACKWARDS FOR CMP)
27C6 E851 X E7                       rst     COMPAR          ;[GWB] QUIT IF Y .GE. X
27C7      X D2 F8 26                 jp      nc,POPTRT       ;[GWB] GO POP TXTPTR AND QUIT
     E852 X D2 83 E7                 ..
27CA E855 X EB                       ex      de,hl           ;[GWB] GET OFFSETS INTO PROPER REGISTERS
27CB E856 X 44         [GWB] CRCLP2: ld      b,h             ;[GWB] [BC]=X
27CC E857 X 4D                       ld      c,l             
27CD E858 X 2A 21 39                 ld      hl,(CRCSUM)     
27D0 E85B X 23                       inc     hl              ;[GWB] SUM = SUM+2*Y+1
27D1 E85C X 19                       add     hl,de           
27D2 E85D X 19                       add     hl,de           
27D3 E85E X 7C                       ld      a,h             ;[GWB] NOW CHECK SIGN OF RESULT
27D4 E85F X 87                       add     a,a             
27D5      X DA E7 27                 jp      c,CNODEX        ;[GWB] DON'T ADJUST X IF WAS NEGATIVE
     E860 X DA 72 E8                 ..
27D8 E863 X D5                       push    de              ;[GWB] SAVE Y
27D9 E864 X EB                       ex      de,hl           ;[GWB] [DE]=SUM
27DA E865 X 60                       ld      h,b             ;[GWB] [HL]=X
27DB E866 X 69                       ld      l,c             ;[GWB] [HL]=2*X-1
27DC E867 X 29                       add     hl,hl           
27DD E868 X 2B                       dec     hl              
27DE E869 X EB                       ex      de,hl           ;[GWB] PREPARE TO SUBTRACT
27DF E86A X 7D                       ld      a,l             ;[GWB] CALC SUM-2*X+1
27E0 E86B X 93                       sub     e               
27E1 E86C X 6F                       ld      l,a             
27E2 E86D X 7C                       ld      a,h             
27E3 E86E X 9A                       sbc     a,d             
27E4 E86F X 67                       ld      h,a             
27E5 E870 X 0B                       dec     bc              ;[GWB] X=X-1
27E6 E871 X D1                       pop     de              ;[GWB] GET Y BACK
27E7 E872 X 22 21 39   [GWB] CNODEX: ld      (CRCSUM),hl     ;[GWB] UPDATE CIRCLE SUM
27EA E875 X 60                       ld      h,b             ;[GWB] GET X BACK TO [HL]
27EB E876 X 69                       ld      l,c                  
27EC E877 X 13                       inc     de              ;[GWB] Y=Y+1
27ED      X C3 AD 27                 jp      CIRCLP               
     E878 X C3 38 E8                 ..
27F0 E87B X
27F0 E87B X D5         [GWB] CPLSCX: push    de              
27F1      X CD F7 28                 call    SCALEY           
     E87C X CD 82 E9                 ..
27F4 E87F X E1                       pop     hl              ;[GWB] GET UNSCALED INTO [HL]
27F5 E880 X 3A 25 39                 ld      a,(CSCLXY)      ;[GWB] SEE WHETHER ASPECT WAS .GT. 1
27F8 E883 X B7                       or      a               
27F9 E884 X C8                       ret     z               ;[GWB] DON'T SWAP IF ZERO
27FA E885 X EB                       ex      de,hl           
27FB E886 X C9                       ret                     
27FC E887 X
27FC E887 X                + ;[GWB]
27FC E887 X                | ;[GWB] REFLECT THE POINTS AROUND CENTER
27FC E887 X                | ;[GWB] [HL]=X OFFSET FROM CENTER, [DE]=Y OFFSET FROM CENTER
27FC E887 X                | ;[GWB]
27FC E887 X EB         [GWB] CPLOT8: ex      de,hl           
27FD E887 X 22 1D 39                 ld      (CPCNT),hl      ;[GWB] POINT COUNT IS ALWAYS = Y
2800 E888 X EB                       ex      de,hl           
2801 E88B X E5                       push    hl              ;[GWB] SAVE X
2802 E88C X 21 00 00                 ld      hl,0            ;[GWB] START CPCNT8 OUT AT 0
2805 E890 X 22 1F 39                 ld      (CPCNT8),hl      
2808      X CD F0 27                 call    CPLSCX          ;[GWB] SCALE Y AS APPROPRIATE
     E893 X CD 7B E8                 ..
280B E896 X 22 29 39                 ld      (CXOFF),hl      ;[GWB] SAVE CXOFF
280E E899 X E1                       pop     hl              ;[GWB] GET BACK X
280F E89A X EB                       ex      de,hl           
2810 E89B X E5                       push    hl              ;[GWB] SAVE INITIAL [DE]
2811      X CD F0 27                 call    CPLSCX          ;[GWB] SCALE X AS APPROPRIATE
     E89C X CD 7B E8                 ..
2814 E89F X EB                       ex      de,hl           
2815 E8A0 X 22 2B 39                 ld      (CYOFF),hl      
2818 E8A3 X EB                       ex      de,hl           
2819 E8A4 X D1                       pop     de              ;[GWB] GET BACK INITIAL [DE]
281A      X CD FA 26                 call    NEGDE           ;[GWB] START: [DE]=-Y,[HL]=X,CXOFF=Y,CY=X
     E8A5 X CD 85 E7                 ..
281D      X CD 44 28                 call    CPLOT4          ;[GWB] PLOT +X,-SY -Y,-SX -X,+SY +Y,-SX
     E8A8 X CD CF E8                 ..
2820 E8AB X E5                       push    hl              
2821 E8AC X D5                       push    de              
2822 E8AD X 2A 1A 39                 ld      hl,(CNPNTS)     ;[GWB] GET # PNTS PER OCTANT
2825 E8B0 X 22 1F 39                 ld      (CPCNT8),hl     ;[GWB] AND SET FOR DOING ODD OCTANTS
2828 E8B3 X EB                       ex      de,hl           
2829 E8B4 X 2A 1D 39                 ld      hl,(CPCNT)      ;[GWB] GET POINT COUNT
282C E8B7 X EB                       ex      de,hl           
282D E8B8 X 7D                       ld      a,l             ;[GWB] ODD OCTANTS ARE BACKWARDS SO
282E E8B9 X 93                       sub     e               ;[GWB] PNTCNT = PNTS/OCT - PNTCN
282F E8BA X 6F                       ld      l,a             
2830 E8BB X 7C                       ld      a,h             
2831 E8BC X 9A                       sbc     a,d             
2832 E8BD X 67                       ld      h,a             
2833 E8BE X 22 1D 39                 ld      (CPCNT),hl      ;[GWB] PNTCNT = PNTS/OCT - PNTCNT
2836 E8C1 X 2A 29 39                 ld      hl,(CXOFF)      ;[GWB] NEED TO NEGATE CXOFF TO START OUT RIGHT
2839      X CD BB 25                 call    NEGHL           
     E8C4 X CD 46 E6                 ..
283C E8C7 X 22 29 39                 ld      (CXOFF),hl      
283F E8CA X D1                       pop     de              
2840 E8CB X E1                       pop     hl              
2841      X CD FA 26                 call    NEGDE           ;[GWB] ALSO NEED TO MAKE [DE]=-SX=-[DE], 
     E8CC X CD 85 E7                 ..
2844      X                                                  ;[GBB] PLOT +Y,-SX -X,-SY -Y,+SX +X,+SY
2844 E8CF X                                                  ;[GWB] (FALL THRU TO CPLOT4)
2844 E8CF X 3E 04      [GWB] CPLOT4: ld      a,4             ;[GWB] LOOP FOUR TIMES
2846 E8D1 X F5         [GWB] CPLOT:  push    af              ;[GWB] SAVE LOOP COUNT
2847 E8D2 X E5                       push    hl              ;[GWB] SAVE BOTH X & Y OFFSETS
2848 E8D3 X D5                       push    de              
2849 E8D4 X E5                       push    hl              ;[GWB] SAVE TWICE
284A E8D5 X D5                       push    de              
284B E8D6 X EB                       ex      de,hl           
284C E8D7 X 2A 1F 39                 ld      hl,(CPCNT8)     ;[GWB] GET NP*OCTANT*8
284F E8DA X EB                       ex      de,hl           
2850 E8DB X 2A 1A 39                 ld      hl,(CNPNTS)     ;[GWB] ADD SQR(2)*RADIUS FOR NEXT OCTANT
2853 E8DE X 29                       add     hl,hl           
2854 E8DF X 19                       add     hl,de           
2855 E8E0 X 22 1F 39                 ld      (CPCNT8),hl     ;[GWB] UPDATE FOR NEXT TIME
2858 E8E3 X 2A 1D 39                 ld      hl,(CPCNT)      ;[GWB] CALC THIS POINT'S POINT COUNT
285B E8E6 X 19                       add     hl,de           ;[GWB] ADD IN PNTCNT*OCTANT*NP
285C E8E7 X EB                       ex      de,hl           ;[GWB] SAVE THIS POINT'S COUNT IN [DE]
285D E8E8 X 2A 23 39                 ld      hl,(CSTCNT)     ;[GWB] GET START COUNT
2860 E8EB X E7                       rst     COMPAR          
2861      X CA 85 28                 jp      z,CLINSC        ;[GWB] SEE IF LINE TO CENTER REQUIRED
     E8EC X CA 10 E9                 ..
2864      X D2 71 28                 jp      nc,CNBTWN       ;[GWB] IF SC .GT. PC, THEN NOT BETWEEN
     E8EF X D2 FC E8                 ..
2867 E8F2 X 2A 17 39                 ld      hl,(CENCNT)     ;[GWB] GET END COUNT
286A E8F5 X E7                       rst     COMPAR          
286B      X CA 7B 28                 jp      z,GLINEC        ;[GWB] GO SEE IF LINE FROM CENTER NEEDED
     E8F6 X CA 06 E9                 ..
286E      X D2 97 28                 jp      nc,CBTWEN       ;[GWB] IF EC .GT. PC, THEN BETWEEN
     E8F9 X D2 22 E9                 ..
2871 E8FC X
2871 E8FC X 3A 1C 39   [GWB] CNBTWN: ld      a,(CPLOTF)      ;[GWB] SEE WHETHER TO PLOT OR NOT
2874 E8FF X B7                       or      a               ;[GWB] IF NZ, PLOT POINTS NOT IN BETWEEN
2875      X C2 A3 28                 jp      nz,CPLTIT       ;[GWB] NEED TO PLOT NOT-BETWEEN POINTS
     E900 X C2 2E E9                 ..
2878      X C3 9E 28                 jp      GCPLFN          ;[GWB] DON'T PLOT - FIX UP STACK & RETURN
     E903 X C3 29 E9                 ..
287B E906 X
287B E906 X 3A 19 39   [GWB] GLINEC: ld      a,(GLINEF)      ;[GWB] GET CENTER LINE FLAG BYTE
287E E909 X 87                       add     a,a             ;[GWB] BIT 7=1 MEANS DRAW LINE FROM CENTER
287F      X D2 A3 28                 jp      nc,CPLTIT       ;[GWB] NO LINE REQUIRED - JUST PLOT POINT
     E90A X D2 2E E9                 ..
2882      X C3 8C 28                 jp      CLINE           ;[GWB] LINE REQUIRED.
     E90D X C3 17 E9                 ..
2885 E910 X
2885 E910 X 3A 19 39   [GWB] CLINSC: ld      a,(GLINEF)      ;[GWB] GET CENTER LINE FLAG BYTE
2888 E913 X 1F                       rra                     ;[GWB] BIT 0=1 MEANS LINE FROM CENTER NEEDED.
2889      X D2 A3 28                 jp      nc,CPLTIT       ;[GWB] NO LINE REQUIRED - JUST PLOT POINT
     E914 X D2 2E E9                 ..
288C      X
288C E917 X D1         [GWB] CLINE:  pop     de              ;[GWB] GET X & Y OFFSETS
288D E918 X E1                       pop     hl              
288E      X CD E7 28                 call    GTABSC          ;[GWB] GO CALC TRUE COORDINATE OF POINT
     E919 X CD 72 E9                 ..
2891      X CD D8 28                 call    GLINE2          ;[GWB] DRAW LINE FROM [BC],[DE] TO CENTER
     E91C X CD 63 E9                 ..
2894      X C3 B4 28                 jp      CPLFIN          
     E91F X C3 3F E9                 ..
2897 E922 X                                              
2897 E922 X 3A 1C 39   [GWB] CBTWEN: ld      a,(CPLOTF)      ;[GWB] SEE WHETHER PLOTTING BETWEENS OR NOT
289A E925 X B7                       or      a               
289B      X CA A3 28                 jp      z,CPLTIT        ;[GWB] IF Z, THEN DOING BETWEENS
     E926 X CA 2E E9                 ..
289E E929 X D1         [GWB] GCPLFN: pop     de              ;[GWB] CLEAN UP STACK
289F E92A X E1                       pop     hl              
28A0      X C3 B4 28                 jp      CPLFIN          
     E92B X C3 3F E9                 ..
28A3 E92E X
28A3 E92E X D1         [GWB] CPLTIT: pop     de              ;[GWB] GET X & Y OFFSETS
28A4 E92F X E1                       pop     hl              
28A5      X CD E7 28                 call    GTABSC          ;[GWB] CALC TRUE COORDINATE OF POINT
     E930 X CD 72 E9                 ..
28A8      X CD 2B 2E                 call    SCLXYX          ;[GWB] SEE IF POINT OFF SCREEN
     E933 X CD B6 EE                 ..
28AB      X D2 B4 28                 jp      nc,CPLFIN       ;[GWB] NC IF POINT OFF SCREEN - NO PLOT
     E936 X D2 3F E9                 ..
28AE      X CD FD 2D                 call    MAPXYP          
     E939 X CD 88 EE                 ..
28B1      X CD 99 2D                 call    SETC            ;[GWB] PLOT THE POINT
     E93C X CD 24 EE                 ..
28B4 E93F X
28B4 E93F X D1         [GWB] CPLFIN: pop     de              ;[GWB] GET BACK OFFSETS
28B5 E940 X E1                       pop     hl              
28B6 E941 X F1                       pop     af              ;[GWB] GET BACK LOOP COUNT
28B7 E942 X 3D                       dec     a               
28B8 E943 X C8                       ret     z               ;[GWB] QUIT IF DONE.
28B9 E944 X F5                       push    af              ;[GWB]  PUSH PSW
28BA E945 X D5                       push    de              ;[GWB] SAVE X OFFSET
28BB E946 X EB                       ex      de,hl           
28BC E947 X 2A 29 39                 ld      hl,(CXOFF)      ;[GWB] SWAP [HL] AND CXOFF
28BF E94A X EB                       ex      de,hl           
28C0      X CD FA 26                 call    NEGDE           ;[GWB] NEGATE NEW [HL]
     E94B X CD 85 E7                 ..
28C3 E94E X 22 29 39                 ld      (CXOFF),hl      
28C6 E951 X EB                       ex      de,hl           
28C7 E952 X D1                       pop     de              
28C8 E953 X E5                       push    hl              
28C9 E954 X 2A 2B 39                 ld      hl,(CYOFF)      ;[GWB] SWAP [DE] AND CYOFF
28CC E957 X EB                       ex      de,hl           ;[GWB] NEGATE NEW [DE]
28CD E958 X 22 2B 39                 ld      (CYOFF),hl      
28D0      X CD FA 26                 call    NEGDE           
     E95B X CD 85 E7                 ..
28D3 E95E X E1                       pop     hl              
28D4 E95F X F1                       pop     af              ;[GWB]  POP PSW
28D5      X C3 46 28                 jp      CPLOT           ;[GWB] PLOT NEXT POINT
     E960 X C3 D1 E8                 ..
28D8 E963 X
28D8 E963 X 2A 09 39   [GWB] GLINE2: ld      hl,(GRPACX)     ;[GWB] DRAW LINE FROM [BC],[DE]
28DB E966 X 22 03 39                 ld      (GXPOS),hl      ;[GWB] TO GRPACX,Y
28DE E969 X 2A 07 39                 ld      hl,(GRPACY)     
28E1 E96C X 22 05 39                 ld      (GYPOS),hl      
28E4      X C3 7B 26                 jp      DOGRPH          ;[GWB] GO DRAW THE LINE
     E96F X C3 06 E7                 ..
28E7 E972 X            
28E7 E972 X                + ;[GWB] GTABSC - GET ABSOLUTE COORDS
28E7 E972 X                | ;[GWB] ([BC],[DE])=(GRPACX+[HL],GRPACY+[DE])
28E7 E972 X                | ;[GWB]
28E7 E972 X D5         [GWB] GTABSC: push    de              ;[GWB] SAVE Y OFFSET FROM CENTER
28E8 E973 X EB                       ex      de,hl           
28E9 E974 X 2A 09 39                 ld      hl,(GRPACX)     ;[GWB] GET CENTER POS
28EC E977 X EB                       ex      de,hl           
28ED E978 X 19                       add     hl,de           ;[GWB] ADD TO DX
28EE E979 X 44                       ld      b,h             ;[GWB] [BC]=X CENTER + [HL]
28EF E97A X 4D                       ld      c,l             
28F0 E97B X D1                       pop     de              
28F1 E97C X 2A 07 39                 ld      hl,(GRPACY)     ;[GWB] GET CENTER Y
28F4 E97F X 19                       add     hl,de           
28F5 E980 X EB                       ex      de,hl           ;[GWB] [DE]=Y CENTER + [DE]
28F6 E981 X C9                       ret                     
28F7 E982 X
28F7 E982 X 2A 15 39   [GWB] SCALEY: ld      hl,(ASPECT)     ;[GWB] CHECK FOR *0 AND *1 CASES
28FA E985 X 7D                       ld      a,l             
28FB E986 X B7         [GWB] SCALE2: or      a               ;[GWB] ENTRY TO DO [A]*[DE] ([A] NON-Z)
28FC      X C2 03 29                 jp      nz,SCAL2        ;[GWB] NON-ZERO
     E987 X C2 8E E9                 ..
28FF E98A X B4                       or      h               ;[GWB] TEST HI BYTE
2900 E98B X C0                       ret     nz              ;[GWB] IF NZ, THEN WAS *1 CASE
2901 E98C X EB                       ex      de,hl           ;[GWB] WAS *0 CASE - PUT 0 IN [DE]
2902 E98D X C9                       ret                     
2903 E98E X
2903 E98E X 4A         (GWB) SCAL2:  ld      c,d             
2904 E98F X 16 00                    ld      d,0             
2906 E991 X F5                       push    af              
2907      X CD 17 29                 call    SCAL2M           
     E992 X CD A2 E9                 ..
290A E995 X 1E 80                    ld      e,128            
290C E997 X 19                       add     hl,de           ;??? [GWB] ADDI AX,128  - ROUND UP
290D E998 X 59                       ld      e,c             
290E E999 X 4C                       ld      c,h             
290F E99A X F1                       pop     af              
2910      X CD 17 29                 call    SCAL2M           
     E99B X CD A2 E9                 ..
2913 E99E X 59                       ld      e,c             
2914 E99F X 19                       add     hl,de           
2915 E9A0 X EB                       ex      de,hl           
2916 E9A1 X C9                       ret                     
2917 E9A2 X                  
2917 E9A2 X 06 08      (~~~) SCAL2M: ld      b,8             ;;Going to Loop 8 Times
2919 E9A4 X 21 00 00                 ld      hl,0            ;;Clear [HL] First
291C E9A7 X 29         (~~~) SCAL2L: add     hl,hl           ;;[HL] = [HL] * 2
291D E9A8 X 87                       add     a,a             ;;[A] = [A] * 2
291E      X D2 22 29                 jp      nc,NOCARY       ;;If Carry
     E9A9 X D2 AD E9                 ..                      
2921 E9AC X 19                       add     hl,de           ;;  [HL] = [HL] + [DE]
2922 E9AD X 05         (GWB) NOCARY: dec     b               ;;Countdown  
2923      X C2 1C 29                 jp      nz,SCAL2L        ;;  and Loop
     E9AE X C2 A7 E9                 ..
2926 E9B1 X C9                       ret     
2927      X
2928      X                + ;[GWB] PARSE THE BEGIN AND END ANGLES
2928      X                | ;[GWB]  SETTING APPROPRIATE BITS IN GLINEF IF NEG.
2928 E9B2 X                | ;[GWB]
2927 E9B2 X 2B         [GWB] CGTCNT: dec     hl              
2928 E9B3 X D7                       rst     CHRGET          ;[GWB] GET CURRENT CHAR
2929 E9B4 X C8                       ret     z               ;[GWB] IF NOTHING, RETURN DFLT IN [DE]
292A E9B5 X CF                       rst     SYNCHK          
292B E9B6 X 2C                       byte    ','             ;[GWB] EAT THE COMMA
292C E9B7 X FE 2C                    cp      ','             ;[GWB] USE DEFAULT IF NO ARGUMENT.
292E E9B9 X C8                       ret     z               
292F E9BA X C5                       push    bc              ;[GWB] SAVE FLAG BYTE IN [C]
2930 E9BB X CD 85 09                 call    FRMEVL          ;[GWB] EVALUATE THE THING
2933 E9BE X E3                       ex      (sp),hl         ;[GWB] XTHL
2934 E9BF X E5                       push    hl              ;[GWB] POP FLAG BYTE, PUSH TXTPTR
2935 E9C0 X CD 75 09                 call    CHKNUM          ;[M65] MUST BE NUMBER
2938 E9C3 X C1                       pop     bc              ;[GWB] GET BACK FLAG BYTE
2939 E9C4 X 21 E7 38                 ld      hl,FAC          ;[GWB] NOW SEE WHETHER POSITIVE OR NOT
293C E9C7 X 7E                       ld      a,(hl)          ;[GWB] GET EXPONENT BYTE
293D E9C8 X B7                       or      a               
293E      X CA 50 29                 jp      z,CGTC2         ;[GWB] SET TO HIGH MANTISSA BYTE
     E9C9 X CA DB E9                 ..
2941 E9CC X 2B                       dec     hl              
2942 E9CD X 7E                       ld      a,(hl)          
2943 E9CE X B7                       or      a               
2944      X F2 50 29                 jp      p,CGTC2         
     E9CF X F2 DB E9                 ..
2947 E9D2 X E6 7F                    and     127             ;[GWB] MAKE IT POSITIVE
2949 E9D4 X 77                       ld      (hl),a          
294A E9D5 X 21 19 39                 ld      hl,GLINEF       ;[GWB] SET BIT IN [C] IN GLINEF
294D E9D8 X 7E                       ld      a,(hl)          
294E      X B1                       or      c               
     E9D9 X B1                       or      c               
294F E9DA X 77                       ld      (hl),a          
2950 E9DB X 01 22 7E   [GWB] CGTC2:  ld      bc,$7E22        ;[GWB] LOAD REGS WITH 1/2*PI
2953 E9DE X 11 83 F9                 ld      de,$F983        
2956 E9E1 X CD CB 13                 call    FMULT           ;[GWB] MULTIPLY BY 1/(2*PI) TO GET FRACTION
2959      X CD 79 29                 call    CMPONE          ;[GWB] SEE IF RESULT IS GREATER THAN ONE
     E9E4 X CD 04 EA                 ..
295C E9E7 X CA 97 06                 jp      z,FCERR         ;[GWB] FC ERROR IF SO
295F E9EA X CD 13 15                 call    PUSHF           ;[GWB] SAVE FAC ON STAC
2962 E9ED X 2A 1A 39                 ld      hl,(CNPNTS)     ;[GWB] GET NO. OF POINTS PER OCTANT
2965 E9F0 X 29                       add     hl,hl           ;[GWB] TIMES 8 FOR TRUE CIRCUMFERENCE
2966 E9F1 X 29                       add     hl,hl           
2967 E9F2 X 29                       add     hl,hl           
2968      X CD 20 23                 call    MAKINT          ;[GWB] STICK IT IN FAC
     E9F3 X CD AB E3                 ..
296B E9F6 X CD 75 09                 call    CHKNUM          ;[M65] MUST BE NUMBER
296E E9F9 X C1                       pop     bc              ;[GWB] GET BACK ANG/2*PI IN REGS
296F E9FA X D1                       pop     de              
2970 E9FB X CD CB 13                 call    FMULT           ;[GWB] DO THE MULTIPLY
2973      X CD 04 23                 call    FRCINX          ;[GWB] CONVERT TO INTEGER IN [HL]
     E9FE X CD 8F E3                 ..
2976 EA01 X D1                       pop     de              ;[GWB] GET BACK TXTPTR
2977 EA02 X EB                       ex      de,hl           
2978 EA03 X C9                       ret                     
2979 EA04 X
2979 EA04 X 01 00 81         CMPONE: ld      bc,$8100        ;;Compare FAC with 1.0
297C EA07 X 11 00 00                 ld      de,$0000
297F EA0A X CD 5B 15                 call    FCOMP
2982 EA0D X 3D                       dec     a
2983 EA0E X C9                       ret
2984      X
2984      X                + ;[GWB] GET & PUT - READ & WRITE GRAPHICS BIT ARRAY
2984      X                | ;[GWB] 
2984      X                | ;[GWB]  SYNTAX:
2984      X                | ;[GWB]        GET @(X,Y),ARRAYVAR
2984      X                | ;[GWB]        PUT @(X,Y),ARRAYVAR[,FUNCTION]
2984      X                | ;[GWB] 
2984      X                | ;[GWB]        FUNCTION = OR/AND/PRESET/PSET/XOR
2984 EA0F X                | ;[GWB] 
2984 EA0F X 32 3B 39   [GWB] GPUTG:  ld      (PUTFLG),a      ;[GWB] IFE PC8A&RSTLES-1STORE WHETHER PUTTING OR NOT
2987 EA12 X F5                       push    af              ;[GWB] SAVE THIS FLAG A SEC
2988 EA13 X CF                       rst     SYNCHK          
2989 EA14 X 28                       byte    '('             ;[GWB] SKIP OVER OPEN PAREN
298A EA15 X 2B                       dec     hl              
298B      X CD 47 25                 call    SCAN1           ;[GWB] GET FIRST COORD
     EA16 X CD D2 E5                 ..
298E      X CD 12 2C                 call    CHKRNG          
     EA19 X CD 9D EC                 ..
2991 EA1C X F1                       pop     af              ;[GWB] REGET PUT FLAG
2992 EA1D X B7                       or      a               
2993 EA1E X 20 6C                    jr      nz,PUT1        
2995 EA20 X CF                       rst     SYNCHK          
2996 EA21 X A9                       byte    MINUTK          ;[GWB] EAT "-"
2997 EA22 X C5                       push    bc              ;[GWB] SAVE X1
2998 EA23 X D5                       push    de              ;[GWB] SAVE Y1
2999      X CD 56 25                 call    SCANDX          ;[GWB] GET SECOND COORD FOR 'GET' ONLY
     EA24 X CD E1 E5                 ..
299C      X CD 12 2C                 call    CHKRNG          
     EA27 X CD 9D EC                 ..
299F EA2A X D1                       pop     de              ;[GWB] GET Y1 BACK
29A0 EA2B X C1                       pop     bc              ;[GWB] AND X1
29A1 EA2C X E5                       push    hl              ;[GWB] SAVE TXTPTR
29A2      X CD C3 25                 call    YDELT           ;[GWB] CALC DELTA Y
     EA2D X CD 4E E6                 ..
29A5      X DC CE 25                 call    c,XCHGY         ;[GWB] MAKE DE=MIN(GXPOS,DE)
     EA30 X DC 59 E6                 ..
29A8 EA33 X 23                       inc     hl              ;[GWB] MAKE DELTA A COUNT
29A9 EA34 X 22 13 39                 ld      (MINDEL),hl     ;[GWB] SAVE DELTA Y IN MIDEL
29AC      X CD B1 25                 call    XDELT           
     EA37 X CD 3C E6                 ..
29AF      X DC DB 25                 call    c,XCHGX         ;[GWB] BC = MIN(GXPOS,DE)
     EA3A X DC 66 E6                 ..
29B2 EA3D X 23                       inc     hl              ;[GWB] MAKE DELTA A COUNT
29B3 EA3E X 22 11 39                 ld      (MAXDEL),hl     ;[GWB] SAVE DX IN MAXDEL
29B6      X CD ED 2D                 call    MAPXYC           
     EA41 X CD 78 EE                 ..
29B9 EA44 X E1                       pop     hl              
29BA      X CD 77 2A                 call    GTARRY           
     EA45 X CD 02 EB                 ..
29BD EA48 X E5                       push    hl              
29BE EA49 X D5                       push    de              ;;Save Pointer to Array Data
29BF EA4A X C5                       push    bc              ;;Save End of Array Data
29C0 EA4B X D5                       push    de              ;;Save Number of Bytes to be Used
29C1 EA4C X EB                       ex      de,hl           
29C2 EA4D X 2A 11 39                 ld      hl,(MAXDEL)     
29C5 EA50 X 4D                       ld      c,l             
29C6 EA51 X 44                       ld      b,h             
29C7 EA52 X EB                       ex      de,hl           
29C8 EA53 X CB 23                    sla     e               
29CA EA55 X CB 12                    rl      d               
29CC EA57 X 2A 13 39                 ld      hl,(MINDEL)     ;[GWB] GET DELTA Y
29CF EA5A X C5                       push    bc              ;[GWB] SAVE DX*BITS/PIX
29D0 EA5B X 44                       ld      b,h             ;[GWB] INTO [BC] FOR UMULT
29D1 EA5C X 4D                       ld      c,l             
29D2 EA5D X CD CA 15                 call    UMULT           ;[GWB] [DE]=DX*DY*BITS/PIX
29D5 EA60 X C1                       pop     bc              ;[GWB] GET BACK DX*BITS/PIX
29D6 EA61 X 11 04 00                 ld      de,4            ;[GWB] ADD 4 BYTES FOR DX,DY STORAGE
29D9 EA64 X 19                       add     hl,de           ;[HL] HAS NO. OF BYTES TO BE USED
29DA EA65 X D1                       pop     de              ;ADD NO. OF BYTES TO BE USED
29DB EA66 X 19                       add     hl,de           
29DC EA67 X EB                       ex      de,hl           ;[GWB] [DE] = CALCULATED END OF DATA
29DD EA68 X E1                       pop     hl              ;[GWB] END OF ARRAY DATA TO [HL]
29DE EA69 X E7                       rst     COMPAR          
29DF EA6A X DA 97 06                 jp      c,FCERR         ;[GWB] ARRAY START+LENGTH .GT. 64K
29E2 EA6D X                                                  ;[GWB] BEG OF DATA PTR IS ON STK HERE
29E2 EA6D X E1                       pop     hl              ;[GWB] GET POINTER TO ARRAY DATA
29E3 EA6E X E7                       rst     COMPAR          
29E4 EA6F X D2 97 06                 jp      nc,FCERR        ;[GWB] ARRAY START+LENGTH .GT. 64K
29E7 EA72 X 71                       ld      (hl),c          ;[GWB] SAVE DX*BITS/PIX IN 1ST 2 BYTES OF ARY
29E8 EA73 X 23                       inc     hl              
29E9 EA74 X 70                       ld      (hl),b          ;[GWB] PASS NO. OF BITS DESIRED IN [BC]
29EA EA75 X 23                       inc     hl              
29EB EA76 X EB                       ex      de,hl           
29EC EA77 X 2A 13 39                 ld      hl,(MINDEL)     ;[GWB] GET LINE (Y) COUNT
29EF EA7A X EB                       ex      de,hl           
29F0 EA7B X 73                       ld      (hl),e          
29F1 EA7C X 23                       inc     hl              
29F2 EA7D X 72                       ld      (hl),d          
29F3 EA7E X 23                       inc     hl              ;[GWB] SAVE DY IN 2ND 2 BYTES
29F4 EA7F X B7                       or      a               ;[GWB] CLEAR CARRY FOR GET INIT.
29F5 EA80 X 18 57                    jr      GOPGIN          ;[GWB] GIVE LOW LEVEL ADDR OF ARRAY & GO
29F7      X
29F7 EA82 X F5                       push    af              ;;Orphan Code?
29F8 EA83 X 21 00 00                 ld      hl,0            
29FB EA86 X 19         [GWB] MULBLP: add     hl,de           ;[GWB] CALC DX * BITS/PIX
29FC EA87 X 3D                       dec     a               
29FD EA88 X 20 FC                    jr      nz,MULBLP        
29FF EA8A X F1                       pop     af              
2A00 EA8B X C9                       ret                     
2A01 EA8C X
2A01 EA8C X E5         [GWB] PUT1:   push    hl              ;[GWB] SAVE TXTPTR
2A02      X CD ED 2D                 call    MAPXYC          ;[GWB] MAP THE POINT
     EA8D X CD 78 EE                 ..
2A05 EA90 X E1                       pop     hl              
2A06      X CD 77 2A                 call    GTARRY          ;[GWB] SCAN ARRAY NAME & GET PTR TO IT
     EA91 X CD 02 EB                 ..
2A09 EA94 X D5                       push    de              ;[GWB] SAVE PTR TO DELTAS IN ARRAY
2A0A EA95 X 2B                       dec     hl              ;[GWB] NOW SCAN POSSIBLE PUT OPTION
2A0B EA96 X D7                       rst     CHRGET          
2A0C EA97 X 06 05                    ld      b,5             ;[GWB] DEFAULT OPTION IS XOR
2A0E EA99 X 28 12                    jr      z,PUT2          ;[GWB] IF NO CHAR, USE DEFAULT
2A10 EA9B X CF                       rst     SYNCHK          
2A11 EA9C X 2C                       byte    ','             ;[GWB] MUST BE A COMMA
2A12 EA9D X EB                       ex      de,hl           ;[GWB] PUT TXTPTR IN [DE]
2A13      X 21 9C 2A                 ld      hl,GFUNTB+4     ;;From End of Table to Start if Table
     EA9E X 21 27 EB                 ..
2A16 EAA1 X BE         [GWB] PFUNLP: cp      (hl)            ;[GWB] IS THIS AN OPTION?
2A17 EAA2 X 28 07                    jr      z,PUT20         ;[GWB] YES, HAND IT TO PGINIT.
2A19 EAA4 X 2B                       dec     hl              ;[GWB] POINT TO NEXT
2A1A EAA5 X 05                       dec     b               
2A1B EAA6 X 20 F9                    jr      nz,PFUNLP       
2A1D EAA8 X EB                       ex      de,hl           ;[GWB] GET TXTPTR BACK TO [HL]
2A1E EAA9 X D1                       pop     de              ;[GWB] CLEAN UP STACK
2A1F EAAA X C9                       ret                     ;[GWB] LET NEWSTT GIVE SYNTAX ERROR
2A20 EAAB X
2A20 EAAB X EB         [GWB] PUT20:  ex      de,hl           ;[GWB] GET TXTPTR BACK TO [HL]
2A21 EAAC X D7                       rst     CHRGET          ;[GWB] EAT THE TOKEN
2A22 EAAD X 05         [GWB] PUT2:   dec     b               ;[GWB] 1..5 TO 0..4
2A23 EAAE X 78                       ld      a,b             ;[GWB] INTO [A] FOR PGINIT
2A24 EAAF X E3                       ex      (sp),hl         ;[GWB] XTHL
2A25 EAB0 X F5                       push    af              ;[GWB] SAVE PUT ACTION MODE
2A26 EAB1 X 5E                       ld      e,(hl)          ;[GWB] [DE]=NO. OF BITS IN X
2A27 EAB2 X 23                       inc     hl              
2A28 EAB3 X 56                       ld      d,(hl)          
2A29 EAB4 X 23                       inc     hl              
2A2A EAB5 X D5                       push    de              ;[GWB] SAVE BIT COUNT
2A2B EAB6 X E5                       push    hl              ;[GWB] SAVE ARRAY POINTER
2A2C EAB7 X 1B                       dec     de              ;[GWB] DECREMENT DX SINCE IT'S A COUNTER
2A2D EAB8 X 2A 03 39                 ld      hl,(GXPOS)      ;[GWB] NOW CALC TRUE X
2A30 EABB X EB                       ex      de,hl           
2A31 EABC X 19                       add     hl,de           
2A32 EABD X 38 0E                    jr      c,PRNGER        ;[GWB] ERROR IF CARRY
2A34 EABF X 44                       ld      b,h             ;[GWB] TO [BC] FOR SCLXYX
2A35 EAC0 X 4D                       ld      c,l             
2A36 EAC1 X E1                       pop     hl              ;[GWB] GET BACK ARRAY POINTER
2A37 EAC2 X 5E                       ld      e,(hl)          ;[GWB] [DE] = DELTA Y ([HL] POINTS TO DATA)
2A38 EAC3 X 23                       inc     hl              
2A39 EAC4 X 56                       ld      d,(hl)          
2A3A EAC5 X 23                       inc     hl              
2A3B EAC6 X D5                       push    de              ;[GWB] SAVE DELTA Y ON STACK
2A3C EAC7 X E5                       push    hl              ;[GWB] SAVE PTR ON STACK AGAIN
2A3D EAC8 X 2A 05 39                 ld      hl,(GYPOS)      
2A40 EACB X 1B                       dec     de              ;[GWB] DECREMENT DY SINCE IT'S A COUNTER
2A41 EACC X 19                       add     hl,de           
2A42 EACD X DA 97 06   [GWB] PRNGER: jp      c,FCERR         ;[GWB] ERROR IF CARRY
2A45 EAD0 X EB                       ex      de,hl           ;[GWB] [DE]=Y + DELTA Y
2A46 EAD1 X E1                       pop     hl              ;[GWB] GET BACK ARRAY POINTER
2A47      X CD 12 2C                 call    CHKRNG          ;[GWB] MAKE SURE [BC],[HL] ARE ON THE SCREEN
     EAD2 X CD 9D EC                 ..
2A4A EAD5 X D1                       pop     de              ;[GWB] POP DY
2A4B EAD6 X C1                       pop     bc              ;[GWB] POP DX*BITS/PIX
2A4C EAD7 X F1                       pop     af              ;[GWB] GET BACK ACTION MODE
2A4D EAD8 X 37                       scf                     ;[GWB] SET CARRY TO FLAG PUT INIT
2A4E EAD9 X
2A4E EAD9 X D5         [GWB] GOPGIN: push    de              ;[GWB] RESAVE DY
2A4F      X CD 00 2F                 call    PGINIT          ;;Set Operation Routine Address
     EADA X CD 8B EF                 ..
2A52 EADD X D1                       pop     de              ;[GWB] GET Y COUNT
2A53 EADE X D5         [GWB] PGLOOP: push    de              ;[GWB] SAVE LINE COUNT
2A54      X CD 7D 2D                 call    FETCHC          
     EADF X CD 08 EE                 ..
2A57 EAE2 X E5                       push    hl              
2A58 EAE3 X F5                       push    af              
2A59 EAE4 X 3A 3B 39                 ld      a,(PUTFLG)      ;[GWB] SEE IF PUTTING OR GETTING
2A5C EAE7 X B7                       or      a               
2A5D EAE8 X 20 05                    jr      nz,PGLOO2       
2A5F      X CD 22 2F                 call    NREAD           
     EAEA X CD AD EF                 ..
2A62 EAED X 18 03                    jr      PGLOO3          
2A64      X CD 39 2F   [GWB] PGLOO2: call    NWRITE          
     EAEF X CD C4 EF                 ..
2A67 EAF2 X F1         [GWB] PGLOO3: pop     af              ;{GWB} GET BACK STARTING C          
2A68 EAF3 X E1                       pop     hl              ;{GWB} Address AND BIT MASK
2A69      X CD 76 2D                 call    STOREC          ;{GWB} SET UP AS CURRENT "C"          
     EAF4 X CD 01 EE                 ..
2A6C      X CD B1 2E                 call    DOWNL           ;[GWB] NOW MOVE DOWN A LINE
     EAF7 X CD 3C EF                 ..
2A6F EAFA X D1                       pop     de              
2A70 EAFB X 1B                       dec     de              
2A71 EAFC X 7A                       ld      a,d             
2A72 EAFD X B3                       or      e               
2A73 EAFE X 20 DE                    jr      nz,PGLOOP       ;[GWB] CONTINUE IF NOT ZERO
2A75 EB00 X E1                       pop     hl              ;[GWB] GET BACK TXTPTR
2A76 EB01 X C9                       ret                     ;[GWB] AND RETURN
2A77 EB02 X
2A77 EB02 X CF         [GWB] GTARRY: rst     SYNCHK          
2A78 EB03 X 2C                       byte    ','             ;[GWB] EAT COMMA
2A79 EB04 X 3E 01                    ld      a,1             ;[GWB] SEARCH ARRAYS ONLY
2A7B EB06 X 32 CB 38                 ld      (SUBFLG),a       
2A7E EB09 X CD D1 10                 call    PTRGET          ;[GWB] GET PTR TO ARRAY
2A81 EB0C X C2 97 06                 jp      nz,FCERR        ;[GWB] NOT THERE - ERROR
2A84 EB0F X 32 CB 38                 ld      (SUBFLG),a      ;[GWB] CLEAR THIS
2A87 EB12 X E5                       push    hl              ;[GWB] SAVE TXTPTR
2A88 EB13 X 60                       ld      h,b             ;[GWB] HL = PTR TO ARRAY
2A89 EB14 X 69                       ld      l,c             
2A8A EB15 X EB                       ex      de,hl           ;[GWB] HL = LENGTH
2A8B EB16 X 19                       add     hl,de           ;[GWB] HL = LAST BYTE OF ARRAY
2A8C EB17 X E5                       push    hl              ;[GWB] SAVE
2A8D EB18 X 0A                       ld      a,(bc)          ;[GWB] GET NO. OF DIMS 
2A8E EB19 X 87                       add     a,a             ;[GWB] DOUBLE SINCE 2 BYTE ENTRIES
2A8F EB1A X 6F                       ld      l,a             
2A90 EB1B X 26 00                    ld      h,0             
2A92 EB1D X 03                       inc     bc              ;[GWB] SKIP NO. OF DIMS
2A93 EB1E X 09                       add     hl,bc           
2A94 EB1F X EB                       ex      de,hl           ;[GWB] DE = PTR TO FIRST BYTE OF DATA
2A95 EB20 X C1                       pop     bc              ;[GWB] BC = PTR TO LAST BYTE OF DATA
2A96 EB21 X E1                       pop     hl              ;[GWB] GET TXTPTR
2A97 EB22 X C9                       ret                     
2A98 EB23 X
2A98 EB23 X AE AD      [GWB] GFUNTB: byte    ORTK, ANDTK      ;;PUT Action Tokens Table
2A9A EB25 X 9D 9C                    byte    PRESTK, PSETTK
2A9C EB27 X CF                       byte    XORTK
2A9D      X
2A9D      X                  ;[GWB] GRAPHICS MACRO LANGUAGE SUPPORT
2A9D      X 11 A7 2A   [GWB] DRAW:   ld      de,DRWTAB       ;[GWB] DISPATCH TABLE FOR GML
     EB28 X 11 32 EB                 ..
2AA0 EB2B X AF                       xor     a               ;[GWB] CLEAR OUT DRAW FLAGS
2AA1 EB2C X 32 34 39                 ld      (DRWFLG),a
2AA4      X C3 24 2C                 jp      MACLNG
     EB2F X C3 AF EC                 ..
2AA7 EB32 X
2AA7 EB32 X D5         [GWB] DRWTAB: byte    'U'+128         ;[GWB] UP
2AA8      X D5 2A                    word    DRUP           
     EB33 X 60 EB                    ..
2AAA EB35 X C4                       byte    'D'+128         ;[GWB] DOWN
2AAB      X D8 2A                    word    DRDOWN    
     EB36 X 63 EB                    ..
2AAC EB38 X CC                       byte    'L'+128         ;[GWB] LEFT
2AAE      X DE 2A                    word    DRLEFT    
     EB39 X 69 EB                    ..   
2AB0 EB3B X D2                       byte    'R'+128         ;[GWB] RIGHT
2AB1      X E1 2A                    word    DRIGHT
     EB3C X 6C EB                    ..
2AB3 EB3E X 4D                       byte    'M'             ;[GWB] MOVE
2AB4      X 01 2B                    word    DMOVE   
     EB3F X 8C EB                    ..
2AB6 EB41 X C5                       byte    'E'+128         ;[GWB] -,-
2AB7      X F1 2A                    word    DRWEEE     
     EB42 X 7C EB                    ..
2AB9 EB44 X C6                       byte    'F'+128         ;[GWB] +,-
2ABA      X EC 2A                    word    DRWFFF     
     EB45 X 77 EB                    ..
2ABC EB47 X C7                       byte    'G'+128         ;[GWB] +,+
2ABD      X F9 2A                    word    DRWGGG     
     EB48 X 84 EB                    ..
2ABF EB4A X C8                       byte    'H'+128         ;[GWB] -,+
2AC0      X E9 2A                    word    DRWHHH     
     EB4B X 74 EB                    ..
2AC2 EB4D X C1                       byte    'A'+128         ;[GWB] ANGLE COMMAND
2AC3      X BA 2B                    word    DANGLE
     EB4E X 45 EC                    ..
2AC5 EB50 X 42                       byte    'B'             ;[GWB] MOVE WITHOUT PLOTTING
2AC6      X B2 2B                    word    DNOPLT          
     EB51 X 3D EC                    ..
2AC8 EB53 X 4E                       byte    'N'             ;[GWB] DON'T CHANGE CURRENT COORDS
2AC9      X AD 2B                    word    DNOMOV          
     EB54 X 38 EC                    ..
2ACB EB56 X 58                       byte    'X'             ;[GWB] EXECUTE STRING
2ACC      X 33 2D                    word    MCLXEQ   
     EB57 X BE ED                    ..
2ACE EB59 X C3                       byte    'C'+128         ;[GWB] COLOR
2ACF      X 07 2C                    word    DCOLR
     EB5A X 92 EC                    ..
2AD1 EB5C X D3                       byte    'S'+128         ;[GWB] SCALE
2AD2      X C7 2B                    word    DSCALE
     EB5D X 52 EC                    ..
2AD4 EB5F X 00                       byte    0               ;[GWB] END OF TABLE
2AD5 EB60 X                             
2AD5      X CD FA 26   [GWB] DRUP:   call    NEGDE           ;[GWB] MOVE +0,-Y
     EB60 X CD 85 E7                 ..               
2AD8 EB63 X 01 00 00   [GWB] DRDOWN: ld      bc,0            ;[GWB] MOVE +0,+Y, DX=0
2ADB      X C3 2B 2B                 jp      DOMOVR          ;[GWB] TREAT AS RELATIVE MOVE
     EB66 X C3 B6 EB                 ..               
2ADE EB69 X                                              
2ADE      X CD FA 26   [GWB] DRLEFT: call    NEGDE           ;[GWB] MOVE -X,+0
     EB69 X CD 85 E7                 ..               
2AE1 EB6C X 42         [GWB] DRIGHT: ld      b,d             ;[GWB] MOVE +X,+0
2AE2 EB6D X 4B                       ld      c,e             ;[GWB] [BC]=VALUE
2AE3 EB6E X 11 00 00                 ld      de,0            ;[GWB] DY=0
2AE6      X C3 2B 2B                 jp      DOMOVR          ;[GWB] TREAT AS RELATIVE MOVE
     EB71 X C3 B6 EB                 ..               
2AE9 EB74 X                                             
2AE9      X CD FA 26   [GWB] DRWHHH: call    NEGDE           ;[GWB] MOVE -X,-Y
     EB74 X CD 85 E7                 ..               
2AEC EB77 X 42         [GWB] DRWFFF: ld      b,d             ;[GWB] MOVE +X,+Y
2AED EB78 X 4B                       ld      c,e             
2AEE      X C3 2B 2B                 jp      DOMOVR          
     EB79 X C3 B6 EB                 ..               
2AF1 EB7C X                                             
2AF1 EB7C X 42         [GWB] DRWEEE: ld      b,d             ;[GWB] MOVE +X,-Y
2AF2 EB7D X 4B                       ld      c,e             
2AF3      X CD FA 26   [GWB] DRWHHC: call    NEGDE           
     EB7E X CD 85 E7                 ..               
2AF6      X C3 2B 2B                 jp      DOMOVR          
     EB81 X C3 B6 EB                 ..               
2AF9 EB84 X                                             
2AF9      X CD FA 26   [GWB] DRWGGG: call    NEGDE           ;[GWB] MOVE -X,+Y
     EB84 X CD 85 E7                 ..               
2AFC EB87 X 42                       ld      b,d             
2AFD EB88 X 4B                       ld      c,e             
2AFE      X C3 F3 2A                 jp      DRWHHC          ;[GWB] MAKE DY POSITIVE & GO
     EB89 X C3 7E EB                 ..
2B01 EB8C X                                             
2B01      X CD 92 2C   [GWB] DMOVE:  call    FETCHZ          ;[GWB] GET NEXT CHAR AFTER COMMA
     EB8C X CD 1D ED                 ..
2B04 EB8F X 06 00                    ld      b,0             ;[GWB] ASSUME RELATIVE
2B06 EB91 X FE 2B                    cp      '+'             ;[GWB] IF "+" OR "-" THEN RELATIVE
2B08      X CA 11 2B                 jp      z,MOVREL        
     EB93 X CA 9C EB                 ..
2B0B EB96 X FE 2D                    cp      '-'           
2B0D      X CA 11 2B                 jp      z,MOVREL        
     EB98 X CA 9C EB                 ..
2B10 EB9B X 04                       inc     b               ;[GWB] NON-Z TO FLAG ABSOLUTE
2B11 EB9C X 78         [GWB] MOVREL: ld      a,b
2B12 EB9D X F5                       push    af              ;[GWB] SAVE ABS/REL FLAG ON STACK
2B13      X CD B5 2C                 call    DECFET          ;[GWB] BACK UP SO VALSCN WILL SEE "-"
     EB9E X CD 40 ED                 ..
2B16      X CD C3 2C                 call    VALSCN          ;[GWB] GET X VALUE
     EBA1 X CD 4E ED                 ..
2B19 EBA4 X D5                       push    de              ;[GWB] SAVE IT
2B1A      X CD 92 2C                 call    FETCHZ          ;[GWB] NOW CHECK FOR COMMA
     EBA5 X CD 1D ED                 ..
2B1D EBA8 X FE 2C                    cp      ','             ;[GWB] COMMA?
2B1F      X C2 97 06                 jp      nz,FCERR        
     EBAA X C2 97 06                 ..               
2B22      X CD C3 2C                 call    VALSCN          ;[GWB] GET Y VALUE IN D
     EBAD X CD 4E ED                 ..
2B25 EBB0 X C1                       pop     bc              ;[GWB] GET BACK X VALUE
2B26 EBB1 X F1                       pop     af              ;[GWB] GET ABS/REL FLAG
2B27 EBB2 X B7                       or      a               
2B28      X C2 87 2B                 jp      nz,DRWABS       ;[GWB] NZ - ABSOLUTE
     EBB3 X C2 12 EC                 ..
2B2B EBB6 X
2B2B      X CD D4 2B   [GWB] DOMOVR: call    DSCLDE          ;[GWB] ADJUST Y OFFSET BY SCALE
     EBB6 X CD 5F EC                 ..
2B2E EBB9 X D5                       push    de              ;[GWB] SAVE Y OFFSET
2B2F EBBA X 50                       ld      d,b             ;[GWB] GET X INTO [DE]
2B30 EBBB X 59                       ld      e,c             
2B31      X CD D4 2B                 call    DSCLDE          ;[GWB] GO SCALE IT.
     EBBC X CD 5F EC                 ..
2B34 EBBF X EB                       ex      de,hl           ;[GWB] GET ADJUSTED X INTO [HL]
2B35 EBC0 X D1                       pop     de              ;[GWB] GET ADJUSTED Y INTO [DE]
2B36 EBC1 X AF                       xor     a               
2B37 EBC2 X 32 25 39                 ld      (CSCLXY),a      
2B3A EBC5 X 3A 35 39                 ld      a,(DRWANG)      ;[GWB] GET ANGLE BYTE
2B3D EBC8 X 1F                       rra                     ;[GWB] LOW BIT TO CARRY
2B3E EBC9 X 30 3A                    jr      nc,ANGEVN       ;[GWB] ANGLE IS EVEN - DON'T SWAP X AND Y
2B40 EBCB X F5                       push    af              ;[GWB] SAVE THIS BYTE
2B41 EBCC X D5                       push    de              ;[GWB] SAVE DY
2B42 EBCD X E5                       push    hl              ;[GWB] SAVE DX
2B43      X CD 6F 2D                 call    GTASPC          ;[GWB] GO GET SCREEN ASPECT RATIO
     EBCE X CD FA ED                 ..
2B46 EBD1 X 7C                       ld      a,h             
2B47 EBD2 X B7                       or      a               ;[GWB] IS ASPECT RATIO GREATER THAN ONE?
2B48 EBD3 X 28 05                    jr      z,ASPLS0        ;[GWB] BRIF GOOD ASPECT RATIO
2B4A EBD5 X 3E 01                    ld      a,1             
2B4C EBD7 X 32 25 39                 ld      (CSCLXY),a      
2B4F EBDA X EB         [GWB] ASPLS0: ex      de,hl           ;[GWB] GET ASPECT RATIO INTO [C] FOR GOSCAL
2B50 EBDB X 4D                       ld      c,l             
2B51 EBDC X E1                       pop     hl              ;[GWB] GET BACK DX
2B52 EBDD X 3A 25 39                 ld      a,(CSCLXY)      
2B55 EBE0 X B7                       or      a               
2B56 EBE1 X 28 01                    jr      z,ASPLS1        ;branch if aspect ratio less 1.0
2B58 EBE3 X E3                       ex      (sp),hl         ;[GWB] XTHL
2B59 EBE4 X EB         [GWB] ASPLS1: ex      de,hl           ;[GWB] [HL]=DY, save DX
2B5A EBE5 X E5                       push    hl              ;[GWB] SAVE 1/ASPECT
2B5B      X CD F7 2B                 call    GOSCAL          ;[GWB] SCALE DELTA X BY ASPECT RATIO
     EBE6 X CD 82 EC                 ..
2B5E EBE9 X C1                       pop     bc              ;[GWB] GET BACK 1/ASPECT RATIO
2B5F EBEA X E1                       pop     hl              ;[GWB] GET DY
2B60 EBEB X D5                       push    de              ;[GWB] SAVE SCALED DX
2B61 EBEC X EB                       ex      de,hl           ;[GWB] DY TO [DE] FOR GOSCAL
2B62 EBED X 21 00 00                 ld      hl,0            
2B65 EBF0 X 19         [GWB] DMULP:  add     hl,de           ;[GWB] MULTIPLY [DE] BY HI BYTE OF 1/ASPECT
2B66 EBF1 X 10 FD                    djnz    DMULP           
2B68 EBF3 X E5                       push    hl              ;[GWB] SAVE PARTIAL RESULT
2B69      X CD F7 2B                 call    GOSCAL          ;[GWB] MULTIPLY [DE] BY LOW BYTE
     EBF4 X CD 82 EC                 ..
2B6C EBF7 X E1                       pop     hl              ;[GWB] GET BACK PARTIAL RESULT
2B6D EBF8 X 19                       add     hl,de           ;[GWB] [HL]=Y * 1/ASPECT
2B6E EBF9 X D1                       pop     de              ;[GWB] GET BACK SCALED Y
2B6F EBFA X 3A 25 39                 ld      a,(CSCLXY)      
2B72 EBFD X B7                       or      a               
2B73 EBFE X 28 01                    jr      z,ASLSS1        ;[GWB] branch if aspect ratio less than 1
2B75 EC00 X EB                       ex      de,hl           
2B76      X CD FA 26   [GWB] ASLSS1: call    NEGDE           ;[GWB] ALWAYS NEGATE NEW DY
     EC01 X CD 85 E7                 ..
2B79 EC04 X F1                       pop     af              ;[GWB] GET BACK SHIFTED ANGLE
2B7A EC05 X 1F         [GWB] ANGEVN: rra                     ;[GWB] TEST SECOND BIT
2B7B      X D2 84 2B                 jp      nc,ANGPOS       ;[GWB] DON'T NEGATE COORDS IF NOT SET
     EC06 X D2 0F EC                 ..
2B7E      X CD BB 25                 call    NEGHL           
     EC09 X CD 46 E6                 ..
2B81      X CD FA 26                 call    NEGDE           ;[GWB] NEGATE BOTH DELTAS
     EC0C X CD 85 E7                 ..
2B84      X CD E7 28   [GWB] ANGPOS: call    GTABSC          ;[GWB] GO CALC TRUE COORDINATES
     EC0F X CD 72 E9                 ..
2B87 EC12 X                                             
2B87 EC12 X 3A 34 39   [GWB] DRWABS: ld      a,(DRWFLG)      ;[GWB] SEE WHETHER WE PLOT OR NOT
2B8A EC15 X 87                       add     a,a             ;[GWB] CHECK HI BIT
2B8B      X DA 9A 2B                 jp      c,DSTPOS        ;[GWB] JUST SET POSITION.
     EC16 X DA 25 EC                 ..
2B8E EC19 X F5                       push    af              ;[GWB] SAVE THIS FLAG
2B8F EC1A X C5                       push    bc              ;[GWB] SAVE X,Y COORDS
2B90 EC1B X D5                       push    de              ;[GWB] BEFORE SCALE SO REFLECT DISTANCE OFF
2B91      X CD 2B 2E                 call    SCLXYX          ;[GWB] SCALE IN CASE COORDS OFF SCREEN
     EC1C X CD B6 EE                 ..
2B94      X CD D8 28                 call    GLINE2          
     EC1F X CD 63 E9                 ..
2B97 EC22 X D1                       pop     de              
2B98 EC23 X C1                       pop     bc              ;[GWB] GET THEM BACK
2B99 EC24 X F1                       pop     af              ;[GWB] GET BACK FLAG
2B9A EC25 X 87         [GWB] DSTPOS: add     a,a             ;[GWB] SEE WHETHER TO STORE COORDS
2B9B      X DA A8 2B                 jp      c,DNSTOR        ;[GWB] DON'T UPDATE IF B6=1
     EC26 X DA 33 EC                 ..
2B9E EC29 X EB                       ex      de,hl           
2B9F EC2A X 22 07 39                 ld      (GRPACY),hl     ;[GWB] UPDATE GRAPHICS AC
2BA2 EC2D X EB                       ex      de,hl           
2BA3 EC2E X 60                       ld      h,b             
2BA4 EC2F X 69                       ld      l,c             
2BA5 EC30 X 22 09 39                 ld      (GRPACX),hl     
2BA8 EC33 X AF         [GWB] DNSTOR: xor     a               ;[GWB] CLEAR SPECIAL FUNCTION FLAGS
2BA9 EC34 X 32 34 39                 ld      (DRWFLG),a      
2BAC EC37 X C9                       ret                     
2BAD EC38 X                                             
2BAD EC38 X 3E 40      [GWB] DNOMOV: ld      a,64            ;[GWB] SET BIT SIX IN FLAG BYTE
2BAF      X C3 B4 2B                 jp      DSTFLG          
     EC3A X C3 3F EC                 ..
2BB2 EC3D X                                             
2BB2 EC3D X 3E 80      [GWB] DNOPLT: ld      a,128           ;[GWB] SET BIT 7
2BB4 EC3F X 21 34 39   [GWB] DSTFLG: ld      hl,DRWFLG       
2BB7 EC42 X B6                       or      (hl)            
2BB8 EC43 X 77                       ld      (hl),a          ;[GWB] STORE UPDATED BYTE
2BB9 EC44 X C9                       ret
2BBA EC45 X
2BBA      X D2 C7 2B   [GWB] DANGLE: jp      nc,NCFCER       ;[GWB] ERROR IF NO ARG
     EC45 X D2 52 EC                 ..
2BBD EC48 X 7B                       ld      a,e             ;[GWB] MAKE SURE LESS THAN 4
2BBE EC49 X FE 04                    cp      4               
2BC0      X D2 C7 2B                 jp      nc,NCFCER       ;[GWB] ERROR IF NOT
     EC4B X D2 52 EC                 ..
2BC3 EC4E X 32 35 39                 ld      (DRWANG),a      
2BC6 EC51 X C9                       ret                     
2BC7 EC52 X            [GWB] NCFCER:                                         
2BC7 EC52 X D2 97 06   [GWB] DSCALE: jp      nc,FCERR        ;[GWB] FC ERROR IF NO ARG
2BCA EC55 X 7A                       ld      a,d             ;[GWB] MAKE SURE LESS THAN 256
2BCB EC56 X B7                       or      a               
2BCC EC57 X C2 97 06                 jp      nz,FCERR        
2BCF EC5A X 7B                       ld      a,e             
2BD0 EC5B X 32 33 39                 ld      (DRWSCL),a      ;[GWB] STORE SCALE FACTOR
2BD3 EC5E X C9                       ret                     
2BD4 EC5F X                                              
2BD4 EC5F X 3A 33 39   [GWB] DSCLDE: ld      a,(DRWSCL)      ;[GWB] GET SCALE FACTOR
2BD7 EC62 X B7                       or      a               ;[GWB] ZERO MEANS NO SCALING
2BD8 EC63 X C8                       ret     z               
2BD9 EC64 X 21 00 00                 ld      hl,0            
2BDC EC67 X                                             
2BDC EC67 X 19         [GWB] DSCLP:  add     hl,de           ;[GWB] ADD IN [DE] SCALE TIMES
2BDD EC68 X 3D                       dec     a               
2BDE      X C2 DC 2B                 jp      nz,DSCLP        
     EC69 X C2 67 EC                 ..
2BE1 EC6C X EB                       ex      de,hl           ;[GWB] PUT IT BACK IN [DE]
2BE2 EC6D X 7A                       ld      a,d             ;[GWB] SEE IF VALUE IS NEGATIVE
2BE3 EC6E X 87                       add     a,a             
2BE4 EC6F X F5                       push    af              ;[GWB] SAVE RESULTS OF TEST
2BE5      X D2 E9 2B                 jp      nc,DSCPOS       
     EC70 X D2 74 EC                 ..
2BE8 EC73 X 1B                       dec     de              ;[GWB] MAKE IT TRUNCATE DOWN
2BE9      X CD F0 26   [GWB] DSCPOS: call    HLFDE           ;[GWB] DIVIDE BY FOUR
     EC74 X CD 7B E7                 ..
2BEC      X CD F0 26                 call    HLFDE           
     EC77 X CD 7B E7                 ..
2BEF EC7A X F1                       pop     af              ;[GWB] SEE IF WAS NEGATIVE
2BF0 EC7B X D0                       ret     nc              
2BF1 EC7C X 7A                       ld      a,d             
2BF2 EC7D X F6 C0                    or      0C0H            
2BF4 EC7F X 57                       ld      d,a             
2BF5 EC80 X 13                       inc     de              
2BF6 EC81 X C9                       ret                     ;[GWB] ALL DONE IF WAS POSITIVE
2BF7 EC82 X
2BF7 EC82 X 7A         [GWB] GOSCAL: ld      a,d             ;[GWB] SEE IF NEGATIVE
2BF8 EC83 X 87                       add     a,a             
2BF9      X D2 03 2C                 jp      nc,GOSC2        ;[GWB] NO, MULTIPLY AS-IS
     EC84 X D2 8E EC                 ..
2BFC      X 21 46 2D                 ld      hl,NEGD         ;[GWB] NEGATE BEFORE RETURNING
     EC87 X 21 D1 ED                 ..
2BFF EC8A X E5                       push    hl              
2C00      X CD FA 26                 call    NEGDE           ;[GWB] MAKE POSITIVE FOR MULTIPLY
     EC8B X CD 85 E7                 ..
2C03 EC8E X 79         [GWB] GOSC2:  ld      a,c             ;[GWB] GET SCALE FACTOR
2C04      X C3 FB 28                 jp      SCALE2          ;[GWB] GET SCALE FACTOR
     EC8F X C3 86 E9                 ..
2C07 EC92 X   
2C07      X D2 C7 2B   [GWB] DCOLR:  jp      nc,NCFCER       ;[GWB] FC ERROR IF NO ARG
     EC92 X D2 52 EC                 ..
2C0A EC95 X 7B                       ld      a,e             ;[GWB] GO SET ATTRIBUTE
2C0B      X CD 84 2D                 call    SETATR          
     EC96 X CD 0F EE                 ..
2C0E EC99 X DA 97 06                 jp      c,FCERR         ;[GWB] ERROR IF ILLEGAL ATTRIBUTE
2C11 EC9C X C9                       ret                      
2C12 EC9D X
2C12 EC9D X                  ;;Issue FC Error if Point is Not on Screen
2C12 EC9D X E5         [GWB] CHKRNG: push    hl              ;[GWB] SAVE TXTPTR
2C13      X CD 1F 2E                 call    CHKRXY           
     EC9E X CD AA EE                 ..
2C16 ECA1 X D2 97 06                 jp      nc,FCERR        ;[GWB] OUT OF BOUNDS - ERROR
2C19 ECA4 X E1         {GWB} CHKPHR: pop     hl              
2C1A ECA5 X C9                       ret                     
2C1B ECA6 X
2C1B ECA6 X                  ;;Deprecated: Issue FC Error if Point is Not on Screen
2C1B ECA6 X                  ;;This is the same code as CHKRNG in GW-BASIC
2C1B ECA6 X                  ;;The above code is uses instead, and this is never called
2C1B ECA6 X                  ;;
2C1B ECA6 X E5                       push    hl              ;;Save [HL]
2C1C      X CD 2B 2E                 call    SCLXYX          ;;Check if Point is Off Screen
     ECA7 X CD B6 EE                 ..
2C1F ECAA X D2 97 06                 jp      nc,FCERR        ;;If it is, generate FC Error
2C22 ECAD X E1                       pop     hl              ;;Otherwise, Restorw [HL]
2C23 ECAE X C9                       ret                     ;;and Return
2C24 ECAF X
2C24 ECAF X EB         [GWB] MACLNG: ex      de,hl           
2C25 ECB0 X 22 39 39                 ld      (MCLTAB),hl     ;[GWB] SAVE POINTER TO COMMAND TABLE
2C28 ECB3 X EB                       ex      de,hl           
2C29 ECB4 X CD 85 09                 call    FRMEVL          ;[GWB] EVALUATE STRING ARGUMENT
2C2C ECB7 X E5                       push    hl              ;[GWB] SAVE TXTPTR TILL DONE
2C2D ECB8 X 11 00 00                 ld      de,0            ;[GWB] PUSH DUMMY ENTRY TO MARK END OF STK
2C30 ECBB X D5                       push    de              ;[GWB] DUMMY ADDR
2C31 ECBC X F5                       push    af              ;[GWB] DUMMY LENGTH
2C32 ECBD X
2C32 ECBD X CD C6 0F   [GWB] MCLNEW: call    FRESTR          
2C35 ECC0 X CD 31 15                 call    MOVRM           ;[GWB] GET LENGTH & POINTER
2C38 ECC3 X 78                       ld      a,b             
2C39 ECC4 X B1                       or      c               
2C3A ECC5 X 28 06                    jr      z,MCLOOP        ;[GWB] Don't Push if addr is 0
2C3C ECC7 X 7B                       ld      a,e             
2C3D ECC8 X B7                       or      a               
2C3E ECC9 X 28 02                    jr      z,MCLOOP        ;[GWB]  or if Len is 0...
2C40 ECCB X C5                       push    bc              ;[GWB] PUSH ADDR OF STRING
2C41 ECCC X F5                       push    af              
2C42 ECCD X
2C42 ECCD X F1         [GWB] MCLOOP: pop     af              ;GWB] GET LENGTH OFF STACK
2C43 ECCE X 32 38 39                 ld      (MCLLEN),a       
2C46 ECD1 X E1                       pop     hl              ;GWB] GET ADDR
2C47 ECD2 X 7C                       ld      a,h             
2C48 ECD3 X B5                       or      l               ;[GWB] SEE IF LAST ENTRY
2C49 ECD4 X 28 68                    jr      z,POPHRX        ;[GWB] ALL FINISHED IF ZERO
2C4B ECD6 X 22 36 39                 ld      (MCLPTR),hl     ;[GWB] SET UP POINTER
2C4E      X CD 98 2C   [GWB] MCLSCN: call    FETCHR          ;[GWB] GET A CHAR FROM STRING
     ECD9 X CD 23 ED                 ..
2C51 ECDC X 28 EF                    jr      z,MCLOOP        ;[GWB] END OF STRING - SEE IF MORE ON STK
2C53 ECDE X 87                       add     a,a             ;[GWB] PUT CHAR * 2 INTO [C]
2C54 ECDF X 4F                       ld      c,a             
2C55 ECE0 X 2A 39 39                 ld      hl,(MCLTAB)     ;GWB] POINT TO COMMAND TABLE
2C58 ECE3 X
2C58 ECE3 X 7E         [GWB] MSCNLP: ld      a,(hl)          ;[GWB] GET CHAR FROM COMMAND TABLE
2C59 ECE4 X 87                       add     a,a             ;[GWB] CHAR = CHAR * 2 (CLR HI BIT FOR CMP)
2C5A ECE5 X
2C5A ECE5 X CC 97 06   [GWB] GOFCER: call    z,FCERR         ;[GWB] END OF TABLE.
2C5D ECE8 X B9                       cp      c               ;[GWB] HAVE WE GOT IT?
2C5E ECE9 X 28 05                    jr      z,MISCMD        ;[GWB] YES.
2C60 ECEB X 23                       inc     hl              ;[GWB] MOVE TO NEXT ENTRY
2C61 ECEC X 23                       inc     hl              
2C62 ECED X 23                       inc     hl              
2C63 ECEE X 18 F3                    jr      MSCNLP          
2C65 ECF0 X
2C65      X 01 4E 2C   [GWB] MISCMD: ld      bc,MCLSCN       ;[GWB] RETURN TO TOP OF LOOP WHEN DONE
     ECF0 X 01 D9 EC                 ..
2C68 ECF3 X C5                       push    bc              
2C69 ECF4 X 7E                       ld      a,(hl)          ;[GWB] SEE IF A VALUE NEEDED
2C6A ECF5 X 4F                       ld      c,a             ;[GWB] PASS GOTTEN CHAR IN [C]
2C6B ECF6 X 87                       add     a,a             
2C6C ECF7 X 30 1E                    jr      nc,MNOARG       ;[GWB] COMMAND DOESN'T REQUIRE ARGUMENT
2C6E ECF9 X B7                       or      a               ;[GWB] CLEAR CARRY
2C6F ECFA X 1F                       rra                     ;[GWB] MAKE IT A CHAR AGAIN
2C70 ECFB X 4F                       ld      c,a             ;[GWB] PUT IN [C]
2C71 ECFC X C5                       push    bc              
2C72 ECFD X E5                       push    hl              ;[GWB] SAVE PTR INTO CMD TABLE
2C73      X CD 98 2C                 call    FETCHR          ;[GWB] GET A CHAR
     ECFE X CD 23 ED                 ..
2C76 ED01 X 11 01 00                 ld      de,1            ;[GWB] DEFAULT ARG=1
2C79 ED04 X 28 0E                    jr      z,VSNAR0        
2C7B ED06 X CD C6 0C                 call    ISLETC          
2C7E ED09 X 30 06                    jr      nc,VSNARG       ;[GWB] NO ARG IF END OF STRING
2C80      X CD C6 2C                 call    ISLET2          ;[GWB] SEE IF POSSIBLE LETTER
     ED0B X CD 51 ED                 ..
2C83 ED0E X 37                       scf                     
2C84 ED0F X 18 04                    jr      ISCMD3          
2C86 ED11 X
2C86      X CD B5 2C   [GWB] VSNARG: call    DECFET          ;[GWB] PUT CHAR BACK INTO STRING
     ED11 X CD 40 ED                 ..
2C89 ED14 X B7         [GWB] VSNAR0: or      a               ;[GWB] CLEAR CARRY
2C8A ED15 X E1         (GWB) ISCMD3: pop     hl                  
2C8B ED16 X C1                       pop     bc              ;[GWB] GET BACK COMMAND CHAR
2C8C ED17 X 23         [GWB] MNOARG: inc     hl              ;[GWB] POINT TO DISPATCH ADDR
2C8D ED18 X 7E                       ld      a,(hl)          ;[GWB] GET Address INTO HL
2C8E ED19 X 23                       inc     hl                  
2C8F ED1A X 66                       ld      h,(hl)               
2C90 ED1B X 6F                       ld      l,a                  
2C91 ED1C X E9                       jp      (hl)            ;[GWB] DISPATCH
2C92 ED1D X
2C92      X CD 98 2C   [GWB] FETCHZ: call    FETCHR          ;[GWB] GET A CHAR FROM STRING
     ED1D X CD 23 ED                 ..
2C95 ED20 X 28 C3                    jr      z,GOFCER        ;[GWB] GIVE ERROR IF END OF LINE
2C97 ED22 X C9                       ret
2C98 ED23 X
2C98 ED23 X E5         [GWB] FETCHR: push    hl              
2C99 ED24 X 21 38 39   [GWB] FETCH2: ld      hl,MCLLEN       ;[GWB] POINT TO STRING LENGTH
2C9C ED24 X 7E                       ld      a,(hl)          
2C9D ED27 X B7                       or      a               
2C9E ED28 X 28 13                    jr      z,POPHRX        ;[GWB] RETURN Z=0 IF END OF STRING
2CA0 ED29 X 35                       dec     (hl)            ;[GWB] UPDATE COUNT FOR NEXT TIME
2CA1 ED2B X 2A 36 39                 ld      hl,(MCLPTR)     ;[GWB] GET PTR TO STRING
2CA4 ED2C X 7E                       ld      a,(hl)          ;[GWB] GET CHARACTER FROM STRING
2CA5 ED2F X 23                       inc     hl              ;UPDATE PTR FOR NEXT TIME
2CA6 ED30 X 22 36 39                 ld      (MCLPTR),hl     
2CA9 ED31 X FE 20                    cp      ' '             ;[GWB] [GWB] SKIP SPACES
2CAB ED34 X 28 EC                    jr      z,FETCH2        
2CAD ED36 X FE 60                    cp      96              ;[GWB] CONVERT LOWER CASE TO UPPER
2CAF ED38 X 38 02                    jr      c,POPHRX        
2CB1 ED3A X D6 20                    sub     32              ;[GWB] DO CONVERSION
2CB3 ED3C X E1         (~~~) POPHRX: pop     hl              
2CB4 ED3E X C9                       ret
2CB5 ED3F X
2CB5 ED40 X E5         [GWB] DECFET: push    hl              
2CB6 ED40 X 21 38 39                 ld      hl,MCLLEN       ;[GWB] INCREMENT LENGTH
2CB9 ED41 X 34                       inc     (hl)            
2CBA ED44 X 2A 36 39                 ld      hl,(MCLPTR)     ;[GWB] BACK UP POINTER
2CBD ED45 X 2B                       dec     hl              
2CBE ED48 X 22 36 39                 ld      (MCLPTR),hl     
2CC1 ED49 X E1                       pop     hl              
2CC2 ED4C X C9                       ret                     
2CC3 ED4E X
2CC3      X CD 92 2C   [GWB] VALSCN: call    FETCHZ          ;[GWB] GET FIRST CHAR OF ARGUMENT
     ED4E X CD 1D ED                 ..
2CC6 ED51 X FE 3D      [GWB] ISLET2: cp      '='             ;[GWB] NUMERIC?
2CC8 ED53 X 28 61                    jr      z,VARGET        ;;No, Evaluate Variable
2CCA ED55 X FE 2B                    cp      '+'             ;[GWB] PLUS SIGN?
2CCC ED57 X 28 F5                    jr      z,VALSCN        ;[GWB] THEN SKIP IT
2CCE ED59 X FE 2D                    cp      '-'             ;[GWB] NEGATIVE VALUE?
2CD0 ED5B X 20 06                    jr      nz,VALSC2       
2CD2      X 11 46 2D                 ld      de,NEGD         ;[GWB] IF SO, NEGATE BEFORE RETURNING
     ED5D X 11 D1 ED                 ..
2CD5 ED60 X D5                       push    de              
2CD6 ED61 X 18 EB                    jr      VALSCN          ;[GWB] EAT THE "-"
2CD8 ED63 X 11 00 00   [GWB] VALSC2: ld      de,0
2CDB ED66 X 06 04                    ld      b,4
2CDD ED68 X
2CDD ED68 X FE 2C      [GWB] NUMLOP: cp      ','             ;[GWB] COMMA
2CDF ED6A X 28 D4                    jr      z,DECFET        ;[GWB] YES, BACK UP AND RETURN
2CE1 ED6C X FE 3B                    cp      ';'             ;[GWB] SEMICOLON?
2CE3 ED6E X C8                       ret     z               ;[GWB] YES, JUST RETURN
2CE4 ED6F X FE 3A                    cp      '9'+1           ;[GWB] NOW SEE IF ITS A DIGIT 
2CE6 ED71 X 30 CD                    jr      nc,DECFET       ;[GWB] IF NOT, BACK UP AND RETURN
2CE8 ED73 X FE 30                    cp      '0'                  
2CEA ED75 X 38 C9                    jr      c,DECFET             
2CEC ED77 X 6B                       ld      l,e                  
2CED ED78 X 62                       ld      h,d                  
2CEE ED79 X 29                       add     hl,hl               
2CEF ED7A X 29                       add     hl,hl               
2CF0 ED7B X 19                       add     hl,de               
2CF1 ED7C X 29                       add     hl,hl               
2CF2 ED7D X D6 30                    sub     '0'             ;[GWB] ADD IN THE DIGIT
2CF4 ED7F X 5F                       ld      e,a                  
2CF5 ED80 X 16 00                    ld      d,0               
2CF7 ED82 X 19                       add     hl,de           ;[GWB] VALUE SHOULD BE IN [DE]
2CF8 ED83 X EB                       ex      de,hl           ;[GWB] GET NEXT CHAR     
2CF9      X CD 98 2C                 call    FETCHR             
     ED84 X CD 23 ED                 ..
2CFC ED87 X C8                       ret     z                   
2CFD ED88 X 05                       dec     b                   
2CFE ED89 X 20 DD                    jr      nz,NUMLOP            
2D00 ED8B X FE 30                    cp      '0'                 
2D02 ED8D X 38 D9                    jr      c,NUMLOP             
2D04 ED8F X FE 3A                    cp      '9'+1                 
2D06 ED91 X 30 D5                    jr      nc,NUMLOP            
2D08 ED93 X 18 1A                    jr      SCNFC                
2D0A ED95 X
2D0A      X CD 92 2C   [GWB] SCNVAR: call    FETCHZ          ;[GWB] MAKE SURE FIRST CHAR IS LETTER
     ED95 X CD 1D ED                 ..
2D0D ED98 X 11 60 38                 ld      de,BUF          ;[GWB] PLACE TO COPY NAME FOR PTRGET
2D10 ED9B X D5                       push    de              ;[GWB] SAVE ADDR OF BUF FOR "ISVAR"
2D11 ED9C X 06 20                    ld      b,32            ;[GWB] COPY MAX OF 32 CHARACTERS           
2D13 ED9E X CD C6 0C                 call    ISLETC          ;[GWB] MAKE SURE IT'S A LETTER
2D16 EDA1 X 38 0C                    jr      c,SCNFC         ;[GWB] FC ERROR IF NOT LETTER
2D18 EDA3 X 12         [GWB] SCNVLP: ld      (de),a          ;[GWB] STORE CHAR IN BUF
2D19 EDA4 X 13                       inc     de              
2D1A EDA5 X FE 3B                    cp      ';'             ;[GWB] A SEMICOLON?
2D1C EDA7 X 28 09                    jr      z,SCNV2         ;[GWB] YES - END OF VARIABLE NAME
2D1E      X CD 92 2C                 call    FETCHZ          ;[GWB] GET NEXT CHAR
     EDA9 X CD 1D ED                 ..
2D21 EDAC X 05                       dec     b               
2D22 EDAD X 20 F4                    jr      nz,SCNVLP       
2D24 EDAF X CD 97 06   [GWB] SCNFC:  call    FCERR           ;[GWB]ERROR - VARIABLE TOO LONG
2D27 EDB2 X E1         [GWB] SCNV2:  pop     hl              ;[GWB]GET PTR TO BUF
2D28 EDB3 X C3 4E 0A                 jp      ISVAR           ;[GWB]GO GET ITS VALUE
2D2B EDB6 X
2D2B      X CD 0A 2D   [GWB] VARGET: call    SCNVAR          ;[GWB]SCAN & EVALUATE VARIABLE
     EDB6 X CD 95 ED                 ..
2D2E      X CD 04 23                 call    FRCINX          ;[GWB]MAKE IT AN INTEGER
     EDB9 X CD 8F E3                 ..
2D31 EDBC X EB                       ex      de,hl           ;[GWB]IN [DE]
2D32 EDBD X C9                       ret                     
2D33 EDBE X                                             
2D33      X CD 0A 2D   [GWB] MCLXEQ: call    SCNVAR          ;[GWB] SCAN VARIABLE NAME 
     EDBE X CD 95 ED                 ..
2D36 EDC1 X 3A 38 39                 ld      a,(MCLLEN)      ;[GWB] SAVE CURRENT STRING POS & LENGTH
2D39 EDC4 X 2A 36 39                 ld      hl,(MCLPTR)     
2D3C EDC7 X E3                       ex      (sp),hl         ;[GWB]PUSH MCLPTR
2D3D EDC8 X F5                       push    af              
2D3E EDC9 X 0E 02                    ld      c,2             ;[GWB]MAKE SURE OF ROOM ON STACK
2D40 EDCB X CD A0 0B                 call    GETSTK          
2D43      X C3 32 2C                 jp      MCLNEW          
     EDCE X C3 BD EC                 ..
2D46 EDD1 X
2D46 EDD1 X AF         [GWB] NEGD:   xor     a               ;;[DE] = -[DE]
2D47 EDD2 X 93                       sub     e               
2D48 EDD3 X 5F                       ld      e,a             
2D49 EDD4 X 9A                       sbc     a,d             
2D4A EDD5 X 93                       sub     e               
2D4B EDD6 X 57                       ld      d,a             
2D4C EDD7 X C9                       ret                     
2D4D EDD8 X
2D4D EDD8 X                  ;;Move Cursor to Column [H], Row [L]    
2D4D EDD8 X F5         [~~~] MOVEIT: push    af              
2D4E EDD9 X E5                       push    hl              ;;Save Location
2D4F EDDA X D9                       exx                     
2D50 EDDB X 2A 01 38                 ld      hl,(CURRAM)     ;;Get Current Cursor Address
2D53 EDDE X 3A 0D 38                 ld      a,(CURCHR)      ;;Get Character Under Cursor
2D56 EDE1 X 77                       ld      (hl),a          ;;and Put Back into Screen Location
2D57 EDE2 X E1                       pop     hl              ;;Restore Location
2D58 EDE3 X 7D                       ld      a,l             ;;Address Offset = Row * 5 
2D59 EDE4 X 87                       add     a,a             
2D5A EDE5 X 87                       add     a,a             
2D5B EDE6 X 85                       add     a,l             
2D5C EDE7 X EB                       ex      de,hl           
2D5D EDE8 X 5A                       ld      e,d             ;;[DE] = Column
2D5E EDE9 X 16 00                    ld      d,0             
2D60 EDEB X 62                       ld      h,d             ;;[HL] = Offset
2D61 EDEC X 6F                       ld      l,a             
2D62 EDED X 7B                       ld      a,e             ;;[A] = Column - 1
2D63 EDEE X 3D                       dec     a               
2D64 EDEF X 29                       add     hl,hl           ;;Offset = Offset * 8 (Row * 40)
2D65 EDF0 X 29                       add     hl,hl           
2D66 EDF1 X 29                       add     hl,hl           
2D67 EDF2 X 19                       add     hl,de           ;;Offset = Offset + Column
2D68 EDF3 X 11 00 30                 ld      de,SCREEN       ;;Get Screen Address
2D6B EDF6 X 19                       add     hl,de           ;;and Add Offset
2D6C EDF7 X C3 E7 1D                 jp      TTYFIS          ;;Save Position and Finish
2D6F EDFA X
2D6F EDFA X 11 CC 00   [GWB] GTASPC: ld      de,204          ;;Aspect Ration = 318:204 (6.25:4)
2D72 EDFD X 21 3E 01                 ld      hl,318        
2D75 EE00 X C9                       ret                     
2D76 EE01 X                                             
2D76 EE01 X 32 28 39   [GWB] STOREC: ld      (PINDEX),a      ;;Store Point Position
2D79 EE04 X 22 26 39                 ld      (CURLOC),hl     ;;and Semigraphics Character Address
2D7C EE07 X C9                       ret                     
2D7D EE08 X                                             
2D7D EE08 X 3A 28 39   [GWB] FETCHC: ld      a,(PINDEX)      ;;Load Bit Index 
2D80 EE0B X 2A 26 39                 ld      hl,(CURLOC)     ;;Load Current Point Address
2D83 EE0E X C9                       ret                     
2D84 EE0F X                                             
2D84 EE0F X                  ;;Set Graphics Attribute (Foreground Color)                                                   
2D84 EE0F X FE 10      [GWB] SETATR: cp      16              ;;Is Color > 16
2D86 EE11 X 3F                       ccf                     ;;If Yes
2D87 EE12 X D8                       ret     c               ;;  Return Error
2D88 EE13 X 32 02 39                 ld      (ATRBYT),a      ;;Store Color
2D8B EE16 X C9                       ret                     
2D8C EE17 X
2D8C EE17 X                  ;;Get Bit Mask for Bit Position PINDEX
2D8C EE17 X 11 CA 1A   [~~~] GETMSK: ld      de,BITTAB       
2D8F EE1A X 3A 28 39                 ld      a,(PINDEX)
2D92 EE1D X 83                       add     a,e
2D93 EE1E X 5F                       ld      e,a
2D94 EE1F X 30 01                    jr      nc,GETMSS
2D96 EE21 X 14                       inc     d
2D97 EE22 X 1A               GETMSS: ld      a,(de)
2D98 EE23 X C9                       ret
2D99 EE24 X
2D99 EE24 X                + ;{GWB} SET CURRENT POINT
2D99 EE24 X                | ;;Sets Current Point to Foreground Color ATRBYT
2D99 EE24 X                | ;;Background Color is not changed
2D99 EE24 X                | ;;Current point is at Current Point Index PINDEX in 
2D99 EE24 X                | ;;Semigraphics Character at Current Address CURLOC
2D99 EE24 X                
2D99 EE24 X E5         [GWB] SETC:   push    hl              ;;Save [HL]
2D9A EE25 X D5                       push    de              ;;and [DE]
2D9B EE26 X 2A 26 39                 ld      hl,(CURLOC)     ;;Get Current Screen Address
2D9E EE29 X 7E                       ld      a,(hl)          ;;Get Character at Address
2D9F EE2A X F6 A0                    or      SGBASE          ;;Verify it's in the range of              
2DA1 EE2C X AE                       xor     (hl)            ;;Semigraphics Characters
2DA2 EE2D X 28 02                    jr      z,SETC2         ;;If Not
2DA4 EE2F X 36 A0                    ld      (hl),SGBASE     ;;  Store Base Semigraphic Character
2DA6      X CD 8C 2D   (~~~) SETC2:  call    GETMSK          ;;Get Bit Mask for Pixel to set
     EE31 X CD 17 EE                 ..
2DA9 EE34 X B6                       or      (hl)            ;;Set it
2DAA EE35 X 77                       ld      (hl),a          ;;Write Character back to Screen Matrix
2DAB EE36 X 11 00 04                 ld      de,COLOR-SCREEN ;;Add Offset into Color Matrix to
2DAE EE39 X 19                       add     hl,de           ;;Screen Address to Get Color Address
2DAF EE3A X 3A 02 39                 ld      a,(ATRBYT)      ;;Get Color Byte
2DB2 EE3D X 87                       add     a,a             ;;Now multiply by 16,
2DB3 EE3E X 87                       add     a,a             ;;moving it to the high nybble (Foreground Color)
2DB4 EE3F X 87                       add     a,a             ;;leaving 0 (Black) in thr low nybblr (Background Color)
2DB5 EE40 X 87                       add     a,a             
2DB6 EE41 X 57                       ld      d,a             ;;Save New Color Byte
2DB7 EE42 X 5E                       ld      e,(hl)          ;;Get Old Color Byte
2DB8 EE43 X 3E 0F                    ld      a,15            ;;Override Old Background Color ($0F would keep it)
2DBA EE45 X A3                       and     e               ;;Clear Old Foreground Color
2DBB EE46 X B2                       or      d               ;;Put in the New Foreground Color
2DBC EE47 X 77                       ld      (hl),a          ;;Writeback Attribute back to Color Matrix
2DBD EE48 X D1                       pop     de              
2DBE EE49 X E1                       pop     hl              
2DBF EE4A X C9                       ret                     
2DC0 EE4B X
2DC0 EE4B X                  ;;Draw Horizontal Line [HL] Pixels Long 
2DC0 EE4B X 7D         [~~~] NSETCX: ld      a,l             ;;Looping HL Times
2DC1 EE4C X B4                       or      h               ;;If HL is 0
2DC2 EE4D X C8                       ret     z               ;;  Return
2DC3      X CD 99 2D                 call    SETC            ;;Set Pixel at Current Location
     EE4E X CD 24 EE                 ..
2DC6      X CD DB 2E                 call    RIGHTC          ;;Move 1 Pixel Right
     EE51 X CD 66 EF                 ..
2DC9 EE54 X 2B                       dec     hl              ;;Count Down
2DCA EE55 X 18 F4                    jr      NSETCX          ;;and Loop
2DCC EE57 X
2DCC EE57 X                + ;;Deprecated: Get Foreground Color at Current Location
2DCC EE57 X                | ;;This routine was intended to return both the Pixel State and Color
2DCC EE57 X                | ;;It first sets [A] to the pixel value, which is always 0 due to a bug,
2DCC EE57 X                | ;;  then sets [A] to the Foreground Color, so it
2DCC EE57 X                | ;;Returns Only the Foreground Color.
2DCC EE57 X E5         {~~~} GETC:   push    hl              ;;Save [HL]
2DCD EE58 X D5                       push    de              ;;and [DE]
2DCE EE59 X 2A 26 39                 ld      hl,(CURLOC)     ;;Get Current Screen Address
2DD1 EE5C X 7E                       ld      a,(hl)          ;;Get Character at Address
2DD2 EE5D X F6 A0                    or      SGBASE          ;;Verify it's in the range of  
2DD4 EE5F X AE                       xor     (hl)            ;;Semigraphics Characters
2DD5 EE60 X 28 10                    jr      z,GETC2         ;;If it is, Check Pixel BUG: Should be JR NZ
2DD7 EE62 X 11 00 04   (~~~) GETC3:  ld      de,COLOR-SCREEN ;;Add Offset into Color Matrix to
2DDA EE65 X 19                       add     hl,de           ;;Screen Address to Get Color Address
2DDB EE66 X 7E                       ld      a,(hl)          ;;Get Color Byte
2DDC EE67 X 28 04                    jr      z,GETC4         ;;If Not Zero
2DDE EE69 X 0F                       rrca                    ;;  Rotate 4 Bits Right
2DDF EE6A X 0F                       rrca                    ;;  Moving High Nybble (Foreground Color)
2DE0 EE6B X 0F                       rrca                    ;;  to Low Nybbme
2DE1 EE6C X 0F                       rrca
2DE2 EE6D X E6 0F      (~~~) GETC4:  and     $0F             ;;Set High Nybble to 0, leaving only Foreground color
2DE4 EE6F X D1                       pop     de              ;;Restore [DE]
2DE5 EE70 X E1                       pop     hl              ;;and [HL]
2DE6 EE71 X C9                       ret
2DE7      X CD 8C 2D   (~~~) GETC2:  call    GETMSK          ;;Get Bit Mask for Pixel to set
     EE72 X CD 17 EE                 ..
2DEA EE75 X A6                       and     (hl)            ;;and Remove all other Bits of Character
2DEB EE76 X 18 EA                    jr      GETC3           ;;Then continue on to Get the Foreground Color
2DED EE78 X
2DED EE78 X                  ;{GWB} MACHINE DEPENDENT GRAPHICS ROUTINES: 
2DED EE78 X                  ;
2DED EE78 X                + ;;Get Screen Address and and Pixel Index from Character X, Character Y
2DED EE78 X                | ;{GWB} GET POSITION INTO BITMSK AND [H,L]
2DED EE78 X                | ;;Uses: [B,C] = Character X Position 
2DED EE78 X                | ;;      [D,E] = Character Y Position 
2DED EE78 X                | ;;Sets: PINDEX = [A] = 0
2DED EE78 X                | ;;      CURLOC = [H,L] = Screen Address
2DED EE78 X                | ;;
2DED EE78 X E5         [GWB] MAPXYC: push    hl              ;;Save [H,L] 
2DEE EE79 X D5                       push    de              ;;Save [D,E] (YPOS)
2DEF EE7A X 21 28 30                 ld      hl,SCREEN+40    ;;Address = Column 0, Line 1
2DF2 EE7D X 7B                       ld      a,e             ;;
2DF3 EE7E X 11 28 00                 ld      de,40           ;;Screen Width
2DF6 EE81 X 3C                       inc     a               ;;Mask = YPOS +1 
2DF7 EE82 X 3D         (~~~) MAPCLP: dec     a               ;;Mask = Mask - 1
2DF8 EE83 X 28 1B                    jr      z,MAPXYA        ;;iF Zero, Add XPOS and FInish Up 
2DFA EE85 X 19                       add     hl,de           ;;Else Add Screen Width to Address
2DFB EE86 X 18 FA                    jr      MAPCLP          ;;and Loop
2DFD EE88 X 
2DED EE88 X                + ;;Get Screen Address and and Pixel Index from Character X, Character Y
2DED EE88 X                | ;;Uses: [B,C] = Character X Position 
2DED EE88 X                | ;;      [D,E] = Pixel Y Position 
2DFD EE88 X                | ;;Sets: PINDEX = [A] = 0, 1, or 2
2DFD EE88 X                | ;;      CURLOC = [H,L] = Screen Address
2DFD EE88 X E5         [GWB] MAPXYP: push    hl              ;;Save [H,L] 
2DFE EE89 X D5                       push    de              ;;Save [D,E] (YPOS)
2DFF EE8A X 21 28 30                 ld      hl,SCREEN+40    ;;Address = Column 0, Line 1
2E02 EE8D X 7B                       ld      a,e             ;;Mask = YPOS
2E03 EE8E X 11 28 00                 ld      de,40           ;;Screen Width
2E06 EE91 X D6 03      (~~~) MAPPLP: sub     3               ;;Mask = Mask - 3
2E08 EE93 X 38 03                    jr      c,MAPPAD        ;;If Positive
2E0A EE95 X 19                       add     hl,de           ;;  Add Screen Width to Screen Address
2E0B EE96 X 18 F9                    jr      MAPPLP          ;;  and Loop
2E0D EE98 X C6 03      (~~~) MAPPAD: add     a,3             ;;Mask = Mask + 3
2E0F EE9A X 87                       add     a,a             ;;
2E10 EE9B X CB 29                    sra     c               ;;
2E12 EE9D X 30 01                    jr      nc,MAPXYA       ;;If Mask is Even
2E14 EE9F X 3C                       inc     a               ;;  Mask = Mask + 1
2E15 EEA0 X 09         (~~~) MAPXYA: add     hl,bc           ;;Add XPOS to Screen Address
2E16 EEA1 X 32 28 39                 ld      (PINDEX),a      ;;Store Mask
2E19 EEA4 X 22 26 39                 ld      (CURLOC),hl     ;;Store Address
2E1C EEA7 X D1                       pop     de              ;;Get YPOS back into DE
2E1D EEA8 X E1                       pop     hl              ;;Restore HL
2E1E EEA9 X C9                       ret                     
2E1F EEAA X
2E1F EEAA X                  ;{GWB} SEE IF LOCATION OFF SCREEN
2E1F EEAA X 3E 17      [~~~] CHKRXY: ld       a,23            
2E21 EEAC X 32 41 39                 ld       (GYMAX),a       ;;Mex Y = 23 Rows
2E24 EEAF X 3E 27                    ld       a,39            
2E26 EEB1 X 32 42 39                ld       (GXMAX),a       ;;Mac X = 39 Coumns
2E29 EEB4 X 18 0A                    jr       CMPGMY           
2E2B EEB6 X
2E2B EEB6 X                  ;{GWB} SEE IF POINT OFF SCREEN
2E2B EEB6 X                  ;;; Labeled SCALXY in GW-BASIC, but Standard BASIC also has a SCALXY Routine
2E2B EEB6 X 3E 47      [GWB] SCLXYX: ld      a,71            
2E2D EEB8 X 32 41 39                 ld      (GYMAX),a       ;;Max Y = 71 Pixels
2E30 EEBB X 3E 4F                    ld      a,79            
2E32 EEBD X 32 42 39                 ld      (GXMAX),a       ;;Max X = 79 Pixels
2E35 EEC0 X E5         (~~~) CMPGMY: push    hl              ;Save Registers
2E36 EEC1 X C5                       push    bc              
2E37 EEC2 X D5                       push    de              
2E38 EEC3 X 3A 41 39                 ld      a,(GYMAX)       
2E3B EEC6 X 26 00                    ld      h,0             ;;[H,L] = GYMAX
2E3D EEC8 X 6F                       ld      l,a             
2E3E EEC9 X CB 7A                    bit     7,d             ;;If [D,E] is Negative
2E40 EECB X 20 1F                    jr      nz,SETGYZ       ;;  [H,L] = 0 and Set Carry
2E42 EECD X E7                       rst     COMPAR          ;;Else Compare [D,E] and [H,L]
2E43 EECE X 50         (~~~) SCLXY2: ld      d,b             ;;[D,E] = [B,C]
2E44 EECF X 59                       ld      e,c             
2E45 EED0 X 06 00                    ld      b,0             
2E47 EED2 X 30 02                    jr      nc,CMPGMX       
2E49 EED4 X E3                       ex      (sp),hl         
2E4A EED5 X 04                       inc     b               
2E4B EED6 X 3A 42 39   (~~~) CMPGMX: ld      a,(GXMAX)       
2E4E EED9 X 26 00                    ld      h,0             ;;[H,L] = GXMAX
2E50 EEDB X 6F                       ld      l,a             
2E51 EEDC X CB 7A                    bit     7,d             ;;If [D,E] is Negative
2E53 EEDE X 20 11                    jr      nz,SETGXZ       ;;  [H,L] = 0 and Set Carry
2E55 EEE0 X E7                       rst     COMPAR          ;;Else Compare [D,E] and [H,L]
2E56 EEE1 X D1         (~~~) SCLXY3: pop     de              
2E57 EEE2 X 38 03                    jr      c,SCLXY4         
2E59 EEE4 X CB 18                    rr      b               
2E5B EEE6 X 06                       byte    $06             ;;LD B, over EX
2E5C EEE7 X E3         (~~~) SCLXY4: ex      (sp),hl            
2E5D EEE8 X C1                       pop     bc              
2E5E EEE9 X 3F                       ccf                     
2E5F EEEA X E1                       pop     hl              
2E60 EEEB X C9                       ret                     
2E61 EEEC X
2E61 EEEC X 2E 00      (~~~) SETGYZ: ld      l,0             ;;[L] = 0
2E63 EEEE X 37                       scf                     ;;Set Carry Flag
2E64 EEEF X 18 DD                    jr      SCLXY2          ;;and Continue
2E66 EEF1 X
2E66 EEF1 X 2E 00      (~~~) SETGXZ: ld      l,0             ;;[L] = 0
2E68 EEF3 X 37                       scf                     ;;Set Carry Flag
2E69 EEF4 X 18 EB                    jr      SCLXY3          ;;and Continue
2E6B EEF6 X
2E6B EEF6 X                  ;;; Orphan Code???
2E6B EEF6 X FE 02      {~~~} CHKMSK: cp      2               
2E6D EEF8 X 30 07                    jr      nc,CHKMS2        
2E6F EEFA X D5                       push    de              
2E70 EEFB X 11 29 30                 ld      de,SCREEN+41    
2E73 EEFE X E7                       rst     COMPAR          
2E74 EEFF X D1                       pop     de              
2E75 EF00 X D8                       ret     c               
2E76 EF01 X 3D         (~~~) CHKMS2: dec     a               
2E77 EF02 X 3D                       dec     a               
2E78 EF03 X D0                       ret     nc              
2E79 EF04 X C6 06                    add     a,6             
2E7B EF06 X D5                       push    de              
2E7C EF07 X 11 D8 FF                 ld      de,$FFD8        ;;-40
2E7F EF0A X 19                       add     hl,de           
2E80 EF0B X D1                       pop     de              
2E81 EF0C X B7                       or      a               
2E82 EF0D X C9                       ret                     
2E83 EF0E X 
2E83 EF0E X                  ;;; Orphan Code???
2E83 EF0E X                  ;;Call with [A] = Pixel Index, [HL] = Screen Address
2E83 EF0E X FE 04      (~~~) DOWN4:  cp      4                
2E85 EF10 X 38 08                    jr      c,DOWNP         ;;If Pixel Index > 3, Move Down 1 Pixel
2E87 EF12 X D5                       push    de              
2E88 EF13 X 11 C0 33                 ld      de,SCREEN+960   
2E8B EF16 X E7                       rst     COMPAR          
2E8C EF17 X D1                       pop     de              
2E8D EF18 X 3F                       ccf                     
2E8E EF19 X D8                       ret     c               
2E8F EF1A X
2E8F EF1A X                  ;Down 1 Pixel: Calculate New Screen Address and Bit Index
2E8F EF1A X 3C               DOWNP:  inc     a               
2E90 EF1B X 3C                       inc     a               ;;[A] = Bit Index * 2
2E91 EF1C X FE 06                    cp      6               
2E93 EF1E X 3F                       ccf                     
2E94 EF1F X D0                       ret     nc              
2E95 EF20 X D6 06                    sub     6               ;;[A] = [A] - 6 
2E97 EF22 X D5                       push    de              
2E98 EF23 X 11 28 00                 ld      de,40        
2E9B EF26 X 19                       add     hl,de           ;;[HL] = curloc + 40
2E9C EF27 X D1                       pop     de              
2E9D EF28 X B7                       or      a               ;;Set Flags
2E9E EF29 X C9                       ret                     
2E9F EF2A X   
2E9F EF2A X                  ;;Left 1 Pixel: Calculate New Screen Address and Bit Index
2E9F EF2A X 3D               LEFTP:  dec     a               ;;Decrement Bit Index
2EA0 EF2B X CB 47                    bit     0,a             
2EA2 EF2D X C8                       ret     z               ;;If Bit Index is Even
2EA3 EF2E X 3C                       inc     a               ;;  Add 2
2EA4 EF2F X 3C                       inc     a               
2EA5 EF30 X 2B                       dec     hl              ;;  Decremement Address
2EA6 EF31 X B7                       or      a               ;;  Set Flags from Bit Index
2EA7 EF32 X C9                       ret                     
2EA8 EF33 X
2EA8 EF33 X                  ;;Right 1 Pixel: Calculate New Screen Address and Bit Index
2EA8 EF33 X 3C         [GWB] RIGHTP: inc     a               ;;Increment Bit Index
2EA9 EF34 X CB 47                    bit     0,a             
2EAB EF36 X C0                       ret     nz              ;;If Bit Index is Odd
2EAC EF37 X 3D                       dec     a               ;;  Add 2
2EAD EF38 X 3D                       dec     a               
2EAE EF39 X 23                       inc     hl              ;;  Incremement Address
2EAF EF3A X B7                       or      a               ;;  Set Flags from Bit Index
2EB0 EF3B X C9                       ret                     
2EB1 EF3C X
2EB1 EF3C X                  ;;Move Text Cursor Down One Line   
2EB1 EF3C X F5         [~~~] DOWNL:  push    af              ;[GWB] SAVE BIT MASK OF CURRENT "C" Address
2EB2 EF3D X E5                       push    hl              ;[GWB] SAVE Address    
2EB3      X CD 7D 2D                 call    FETCHC          ;[GWB] GET CURRENT LOCATION
     EF3E X CD 08 EE                 ..
2EB6 EF41 X 11 28 00                 ld      de,40           ;;Line Width = 40 characters
2EB9 EF44 X 19                       add     hl,de           ;;Move Down One Line
2EBA      X C3 F7 2E                 jp      POPSTC          ;;Store Current, Restore Saved and Return
     EF45 X C3 82 EF                 ..
2EBD EF48 X                                               
2EB1 EF48 X                  ;;Move Pixel Cursor Down One Line   
2EBD EF48 X F5         [GWB] DOWNC:  push    af              ;[GWB] SAVE BIT MASK OF CURRENT "C" Address
2EBE EF49 X E5                       push    hl              ;[GWB] SAVE Address    
2EBF      X CD 7D 2D                 call    FETCHC          ;[GWB] ;GET CURRENT LOCATION
     EF4A X CD 08 EE                 ..
2EC2      X CD 8F 2E                 call    DOWNP           ;;Calculate New Screen Address, Bit Index
     EF4D X CD 1A EF                 ..
2EC5 EF50 X 18 30                    jr      POPSTC          ;;Store Current, Restore Saved and Return
2EC7 EF52 X
2EC7 EF52 X                  ;;Orphan Code???
2EC7 EF52 X F5                       push    af              ;[GWB] SAVE BIT MASK OF CURRENT "C" Address
2EC8 EF53 X E5                       push    hl              ;[GWB] SAVE Address    
2EC9      X CD 7D 2D                 call    FETCHC          ;[GWB] ;GET CURRENT LOCATION
     EF54 X CD 08 EE                 ..
2ECC      X CD 76 2E                 call    CHKMS2           
     EF57 X CD 01 EF                 ..
2ECF EF5A X 18 26                    jr      POPSTC          ;;Store Current, Restore Saved and Return
2ED1 EF5C X                                             
2ED1 EF5C X F5         [GWB] LEFTC:  push    af              ;[GWB] SAVE BIT MASK OF CURRENT "C" Address
2ED2 EF5D X E5                       push    hl              ;[GWB] SAVE Address    
2ED3      X CD 7D 2D                 call    FETCHC          ;[GWB] GET CURRENT LOCATION
     EF5E X CD 08 EE                 ..
2ED6      X CD 9F 2E                 call    LEFTP           ;;Calculate New Screen Address, Bit Index
     EF61 X CD 2A EF                 ..
2ED9 EF64 X 18 1C                    jr      POPSTC          ;;Store Current, Restore Saved and Return
2EDB EF66 X                                             
2EDB EF66 X F5         [GWB] RIGHTC: push    af              ;[GWB] SAVE BIT MASK OF CURRENT "C" Address
2EDC EF67 X E5                       push    hl              ;[GWB] SAVE Address    
2EDD      X CD 7D 2D                 call    FETCHC          ;[GWB] GET CURRENT LOCATION
     EF68 X CD 08 EE                 ..
2EE0      X CD A8 2E                 call    RIGHTP           
     EF6B X CD 33 EF                 ..
2EE3 EF70 X 18 12                    jr      POPSTC          ;;Store Current, Restore Saved and Return
2EE5 EF70 X
2EE5 EF70 X                  ;;Orphan Code???
2EE5 EF70 X F5                       push    af
2EE6 EF71 X E5                       push    hl
2EE7      X CD 7D 2D                 call    FETCHC
     EF72 X CD 08 EE                 ..
2EEA      X CD 83 2E                 call    DOWN4
     EF75 X CD 0E EF                 ..   
2EED EF78 X 18 08                    jr      POPSTC
2EEF EF7A X
2EEF EF7A X                  ;;Orphan Code???
2EEF EF7A X F5                       push    af
2EF0 EF7B X E5                       push    hl
2EF1      X CD 7D 2D                 call    FETCHC
     EF7C X CD 08 EE                 ..    
2EF4      X CD 83 2E                 call    DOWN4
     EF7F X CD 0E EF                 ..
2EF7 EF82 X
2EF7 EF82 X 32 28 39         POPSTC: ld      (PINDEX),a      ;;Store Bit Position 
2EFA EF85 X 22 26 39                 ld      (CURLOC),hl     ;;Store Current Point Address
2EFD EF88 X E1                       pop     hl              ;;Restore Saved Address
2EFE EF89 X F1                       pop     af              ;;Restore Saved Bit Index
2EFF EF8A X C9                       ret                     ;;Return from Subroutine
2F00 EF8B X
2F00 EF8B X 22 3C 39   [GWB] PGINIT: ld      (ARYPNT),hl     ;;Save Pointer into Array
2F03 EF8E X 60                       ld      h,b             
2F04 EF8F X 69                       ld      l,c             
2F05 EF90 X 22 11 39                 ld      (MAXDEL),hl     ;;Save Bit Counr?
2F08 EF93 X 87                       add     a,a             ;;Index = Operation ID * 2
2F09 EF94 X 4F                       ld      c,a             ;;Copy to BC
2F0A EF95 X 06 00                    ld      b,0          
2F0C      X 21 18 2F                 ld      hl,OPCTAB       ;;Get Operation Table Address
     EF97 X 21 A3 EF                 ..
2F0F EF9A X 09                       add     hl,bc           ;;Add Index
2F10 EF9B X 7E                       ld      a,(hl)          ;;Get Address from Table
2F11 EF9C X 23                       inc     hl              
2F12 EF9D X 66                       ld      h,(hl)          
2F13 EF9E X 6F                       ld      l,a             
2F14 EF9F X 22 3F 39                 ld      (OPCADR),hl      ;;Store It
2F17 EFA2 X C9                       ret                     
2F18      X
2F18      X 6C 2F            OPCTAB: word    ORC             ;;A = A | C     OR
     EFA3 X F7 EF                    ..
2F1A      X 6E 2F                    word    ANDC            ;;A = A & C     AND
     EFA5 X F9 EF                    ..
2F1C      X 72 2F                    word    CPLA            ;;A = !A        PRESET
     EFA7 X FD EF                    ..
2F1E      X 73 2F                    word    NOOP            ;;No Operation  PSET
     EFA9 X FE EF                    ..
2F20      X 70 2F                    word    XORC            ;;A = A ^ C     XOR (Default)
     EFAB X FB EF                    ..
2F22 EFAD X
2F22 EFAD X                  ;;Read One Line of Characters from Colors to Screen
2F22      X CD 5F 2F   [GWB] NREAD:  call    NSETUP          ;;[H,L] = Screen Address, [A] = Counter
     EFAD X CD EA EF                 ..   
2F25 EFB0 X 46               NREADL: ld      b,(hl)          ;;[B] = Character at Address
2F26 EFB1 X 11 00 04                 ld      de,COLOR-SCREEN ;;[D,E] = Offset into Color Matrix
2F29 EFB4 X EB                       ex      de,hl           ;;[D,E] = Screen Address, [H,L] = Offset
2F2A EFB5 X 19                       add     hl,de           ;;[H,L] = Color Address
2F2B EFB6 X 4E                       ld      c,(hl)          ;;[C] = Color Attribute
2F2C EFB7 X E1                       pop     hl              ;;Pop Array Pointer into [H,L]
2F2D EFB8 X 70                       ld      (hl),b          ;;Copy Character into Array
2F2E EFB9 X 23                       inc     hl              ;;Bump Array Pointer
2F2F EFBA X 71                       ld      (hl),c          ;;Copy Colors into Array
2F30 EFBB X 23                       inc     hl              ;;Bump Array Pointer
2F31 EFBC X E5                       push    hl              ;;Push Array Pointer back onto Stack
2F32 EFBD X EB                       ex      de,hl           ;;[H,L} = Screen Address, Discard Offset
2F33 EFBE X 23                       inc     hl              ;;Bump Screen Address 
2F34 EFBF X 3D                       dec     a               ;;Decrement Counter
2F35 EFC0 X 20 EE                    jr      nz,NREADL       ;;If Not Done, Do Next Position
2F37 EFC2 X 18 21                    jr      NDONE           ;;Else Save Array Pointer and Return
2F39 EFC4 X
2F39 EFC4 X                  ;;Write One Line of Characters and Colors to Screen
2F39      X CD 5F 2F   [GWB] NWRITE: call    NSETUP          ;;[H,L] = Screen Address, [A] = Counter
     EFC4 X CD EA EF                 ..
2F3C EFC7 X EB               NWRITL: ex      de,hl           ;;[D,E] = Screen Address
2F3D EFC8 X 21 00 04                 ld      hl,COLOR-SCREEN ;;[H,L] = Offset into Color Matrix
2F40 EFCB X 19                       add     hl,de           ;;[H,L] = Color Address
2F41 EFCC X 4E                       ld      c,(hl)          ;;[C] = Color Attribute
2F42 EFCD X E1                       pop     hl              ;;Pop Array Pointer into [H,L]
2F43 EFCE X 46                       ld      b,(hl)          ;;Read Character from Array into [B]
2F44 EFCF X 23                       inc     hl              ;;Bump Array Pointer
2F45 EFD0 X 08                       ex      af,af'          ;;Save Counter
2F46 EFD1 X 7E                       ld      a,(hl)          ;;Read Color Attribute from into [A]
2F47 EFD2 X 23                       inc     hl              ;;Bump Array Pointer
2F48 EFD3 X CD 3E 39                 call    OPCJMP          ;;Do Operation on Color Attribute
2F4B EFD6 X E5                       push    hl              ;;Push Array Pointer onto Stack
2F4C EFD7 X EB                       ex      de,hl           ;;[H,L} = Screen Address, Discard Offset
2F4D EFD8 X 70                       ld      (hl),b          ;;Write Character to Character
2F4E EFD9 X 11 00 04                 ld      de,COLOR-SCREEN ;;[H,L] = Offset into Color Matrix
2F51 EFDC X EB                       ex      de,hl           ;;[D,E] = Screen Address, [H,L] = Offse
2F52 EFDD X 19                       add     hl,de           ;;[H,L] = Color Address
2F53 EFDE X 77                       ld      (hl),a          ;;Write Attribute to Color Matrix
2F54 EFDF X EB                       ex      de,hl           ;;[H,L] = Screen Address
2F55 EFE0 X 23                       inc     hl              ;;Next Screen Address
2F56 EFE1 X 08                       ex      af,af'          ;;Restore Counter
2F57 EFE2 X 3D                       dec     a               ;;Decremement it
2F58 EFE3 X 20 E2                    jr      nz,NWRITL       ;;If Not Done, Do Next Position
2F5A EFE5 X E1               NDONE:  pop     hl              ;;Pop Array Pointer off Stack
2F5B EFE6 X 22 3C 39                 ld      (ARYPNT),hl     ;;and Store in ARYPNT
2F5E EFE9 X C9                       ret                     
2F5F      X   
2F5F EFEA X                  ;;Get CURLOC and MAXDEL for NREAD and NWRITE
2F5F EFEA X 2A 11 39         NSETUP: ld      hl,(MAXDEL)     
2F62 EFED X 7D                       ld      a,l             ;;[A] = Byte Count 
2F63 EFEE X 2A 3C 39                 ld      hl,(ARYPNT)     
2F66 EFF1 X E3                       ex      (sp),hl         ;;Push Array Pointer under Return Address
2F67 EFF2 X E5                       push    hl              
2F68 EFF3 X 2A 26 39                 ld      hl,(CURLOC)     ;;[H,L] = Screen Address
2F6B EFF6 X C9                       ret                     
2F6C EFF7 X
2F6C EFF7 X                  ;;PUT Action Subroutines
2F6C EFF7 X B1               ORC:    or      c               ;;OR
2F6D EFF8 X C9                       ret                     ;;
2F6E EFF9 X A1               ANDC:   and     c               ;;AND
2F6F EFFA X C9                       ret                     ;;
2F70 EFFB X A9               XORC:   xor     c               ;;XOR (Default)
2F71 EFFC X C9                       ret                     ;;
2F72 EFFD X 2F               CPLA:   cpl                     ;;PRSET
2F73 EFFE X C9               NOOP:   ret                     ;;PSET (Use Color from Array)
     EFFF X 23                       byte    $23
2F74      X
2F74      X FF FF 00 00              word    $FFFF,$0000     ;;Filler to End of 4K ROM
2F78      X FF FF 00 00              word    $FFFF,$0000  
2F7C      X FF FF 00 00              word    $FFFF,$0000  
2F80      X FF FF 00 00              word    $FFFF,$0000  
2F84      X FF FF 00 00              word    $FFFF,$0000  
2F88      X FF FF 00 00              word    $FFFF,$0000  
2F8C      X FF FF 00 00              word    $FFFF,$0000   
2F90      X FF FF 00 00              word    $FFFF,$0000   
2F94      X FF FF 00 00              word    $FFFF,$0000   
2F98      X FF FF 00 00              word    $FFFF,$0000   
2F9C      X FF FF 00 00              word    $FFFF,$0000  
2FA0      X FF FF 00 00              word    $FFFF,$0000   
2FA4      X FF FF 00 00              word    $FFFF,$0000   
2FA8      X FF FF 00 00              word    $FFFF,$0000   
2FAC      X FF FF 00 00              word    $FFFF,$0000  
2FB0      X FF FF 00 00              word    $FFFF,$0000  
2FB4      X FF FF 00 00              word    $FFFF,$0000   
2FB8      X FF FF 00 00              word    $FFFF,$0000   
2FBC      X FF FF 00 00              word    $FFFF,$0000   
2FC0      X FF FF 00 00              word    $FFFF,$0000   
2FC4      X FF FF 00 00              word    $FFFF,$0000  
2FC8      X FF FF 00 00              word    $FFFF,$0000   
2FCC      X FF FF 00 00              word    $FFFF,$0000   
2FD0      X FF FF 00 00              word    $FFFF,$0000  
2FD4      X FF FF 00 00              word    $FFFF,$0000 
2FD8      X FF FF 00 00              word    $FFFF,$0000  
2FDC      X FF FF 00 00              word    $FFFF,$0000  
2FE0      X FF FF 00 00              word    $FFFF,$0000  
2FE4      X FF FF 00 00              word    $FFFF,$0000  
2FE8      X FF FF 00 00              word    $FFFF,$0000 
2FEC      X FF FF 00 00              word    $FFFF,$0000  
2FF0      X FF FF 00 00              word    $FFFF,$0000  
2FF4      X FF FF 00 00              word    $FFFF,$0000  
2FF8      X FF FF 00 00              word    $FFFF,$0000  
2FFC      X FF FF 00 00              word    $FFFF,$0000 
3000 F000 X
3000 F000 X                          end
