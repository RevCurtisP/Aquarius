


SB                      ;;8K BASIC Subroutines
SB                [M80] SYNCHK  equ     $0008   ;;RST 1 - Syntax Check
SB                [M80] CHRGET  equ     $0010   ;;RST 2 - Get Next Character
SB                [GWB] OUTCHR  equ     $0018   ;;RST 3 - Output Character
SB                [M80] COMPAR  equ     $0020   ;;RST 4 - Integer Compare
SB                [M80] FSIGN   equ     $0028   ;;RST 4 - Integer Compare
SB                [M80] SNERR   equ     $03C4   ;[M80] "SYNTAX ERROR"
SB                [M80] UFERR   equ     $03D0   ;[M80] "UNDEFINED FUNCTION" ERROR
SB                [M80] READY   equ     $0402   ;;Enter Immediate Mode
SB                [M80] EDENT   equ     $0428   ;;Tokenize and Store Line of Code
SB                [M80] FNDLIN  equ     $049F   ;;Find Basic Line
SB                      CRUNCX  equ     $04F9   ;;Convert Keyword to Token
SB                [M80] LISPRT  equ     $0598   ;;Detokenize and Print BASIC Line
SB                [M80] RESSRC  equ     $05A8   ;;Search for Reserved Word
SB                      GONE5   equ     $0665   ;;Add Offset to Table and Dispatch
SB                [M80] CHRGTR  equ     $066B   ;;Skip Statement Token and Execute
SB                [M80] CHRGT2  equ     $066C   ;;Execute Statement
SB                [M80] FRCINT  equ     $0682   ;{M80} GET AN INTEGER IN [D,E]
SB                [M80] FCERR   equ     $0697   ;{M65} "FUNCTION CALL" ERROR
SB                [M80] SCNLIN  equ     $069C   ;;Back Up and Read Line Number
SB                [M80] USERR   equ     $06F3   ;{M80} GIVE A "US" ERROR
SB                      OMGOTO  equ     $0785   ;;Execute ON..GOTO
SB                [M80] FRMNUM  equ     $0972   ;;Evaluate Numeric Formula
SB                [M80] CHKNUM  equ     $0975   ;;Issue "TM" Error if Not a Number
SB                [M80] FRMEVL  equ     $0985   ;{M80) EVALUATE A FORMULA
SB                [M80] PARCHK  equ     $0A37   ;;Evaluate Formula in Parentheses
SB                [M80] ISVAR   equ     $0A4E   ;;Get Variable Value or String Pointer
SB                      FLOATD  equ     $0B23   ;;Convert [D] to a Float
SB                      ERRDIR  equ     $0B45   ;;Error if in Direct Mode
SB                [M80] GETBYT  equ     $0B54   ;;Evaluate 8 bit Numeric Value
SB                [M80] BLTUC   equ     $0B95   ;{M80} BLOCK TRANSFER ROUTINE
SB                [M80] GETSTK  equ     $0BA0   ;;Check Stack Size
SB                [M80] SCRTCH  equ     $0BBE   ;;Execute NEW Command
SB                [M80] ISLETC  equ     $0CC6   ;{M80} TEST FOR A LETTER
SB                      STRADX  equ     $0E59   ;{M80} STORE [D,E]=POINTER TO FREE SPACE
SB                [M80] STROUT  equ     $0E9D   ;{M80} PRINT STRING POINTED TO BY [H,L]
SB                [M80] STRPRT  equ     $0EA0   ;PRINT THE STRING POINTED TO BY FACLO.
SB                [M80] FRESTR  equ     $0FC6   ;{M80} FREE UP STRING TEMPORARY
SB                [M80] PTRGET  equ     $10D1   ;;Get Pointer to Variable
SB                [M80] PTRGT2  equ     $10D6   ;;Get Pointer Alternate Entry Point
SB                [M80] FSUBS   equ     $1258   ;{M80} SUBTRACTION      FAC:=ARG-FAC
SB                [M80] FMULT   equ     $13CB   ;{M80} MULTIPLICATION   FAC:=ARG*FAC
SB                [M80] POPHRT  equ     $141A   ;;Pop [HL] and Return
SB                [M80] FDIV    equ     $142F   ;{M80} DIVISION         FAC:=ARG/FAC
SB                [M80] NEG     equ     $150B   ;[M80] NEGATE ANY TYPE VALUE IN THE FAC
SB                [M80] PUSHF   equ     $1513   ;[M80] PUT FAC ON STACK, ALTERS D,E
SB                [M80] MOVRM   equ     $1531   ;{M80} GET ARGUMENT INTO THE REGISTERS
SB                [M80] MOVMF   equ     $153A   ;[M80] MOVE NUMBER FROM FAC TO MEMORY [(HL)]
SB                [M80] FCOMP   equ     $155B   ;[M80] COMPARE TWO NUMBERS
SB                [M80] UMULT   equ     $15CA   ;[M80] INTEGER MULTIPLY FOR ARRAYS
SB                [M80] LINPRT  equ     $1675   ;[M80] PRINT THE 2 BYTE NUMBER IN H,L
SB                [M80] PSHNEG  equ     $1770   ;[M80] SUBROUTINE FOR FPWR, ATN
SB                [M80] POLYX   equ     $1837   ;[M80] EVALUATE P(X^2)*X
SB                [M80] PI2     equ     $1953   ;[M80] PI/2
SB                [M80] OUTDO   equ     $198A   ;;Execute OUTCHR
SB                [M80] INCHR   equ     $19DA   ;;Get Character from Keyboard
SB                [M80] FININL  equ     $19E5   ;;Terminate BUF and Print CR
SB                [M80] CRDO    equ     $19EA   ;;Print CR
SB                [M80] ISCNTC  equ     $1A25   ;;Check for ^C and ^S
SB                [M65] CQINCH  equ     $1A2F   ;;Wait for character from keyboard
SB                      PPRSDO  equ     $1A55   ;;Do PSET or PRESET
SB                      TTYFIS  equ     $1DE7   ;;Save Character and Display Cursor
SB                      INCHRC  equ     $1E80   ;;Check for keypress
SB                      KEYRES  equ     $1F28   ;;Enter Reserved Word From Ctrl-Key Combo


SB                      ;;8K BASIC System Variables
SB                      SCREEN  equ     $3000   ;;Screen Character Matrix
SB                      COLOR   equ     $3400   ;;Screen Color Matrix

SB                [M65] VARNAM  equ     $38DE   ;;Variable Name
SB                [M65] VARPNT  equ     $38E0   ;;Pointer to Variable
SB                      FAC     equ     $38E7   ;;Floating Point Accumulator

                        ;;Extended BASIC Constants
                        SGBASE  equ     $A0     ;;ASCII Code of First Semigraphics Character

                        ;;Extended BASIC System Variables
                        FORCLR  equ     $3900   ;;Default Attribute (Default Foreground Color?)
                        ATRBYT  equ     $3902   ;[GWB] Attribute Byte to Store
                  [GWB] GXPOS   equ     $3903   ;[GWB] X Position of Second Coordinate
                  [GWB] GYPOS   equ     $3905   ;[GWB] Y Position of Second Coordinate
                  [GWB] GRPACY  equ     $3907   ;[GWB] Previous Y Coordinate
                  [GWB] GRPACX  equ     $3909   ;[GWB] Previous X Coordinate
                  [GWB] MAXUPD  equ     $390B   ;;Jump Instruction
                        ;;              $390C   ;[GWB] Address of Major Axis Move Update
                  [GWB] MINUPD  equ     $390E   ;;Jump Instruction
                       ;;               $390F   ;[GWB] Address of Minor Axis Move Update
                  [GWB] MAXDEL  equ     $3911   ;[GWB] Largest Delta for Line
                  [GWB] MINDEL  equ     $3913   ;[GWB] Smaller of 2 Deltas for Line
                  [GWB] ASPECT  equ     $3915   ;[GWB] ASPECT RATIO
                  [GWB] CENCNT  equ     $3917   ;[GWB] END CIRCLE POINT COUNT
                  [GWB] GLINEF  equ     $3919   ;[GWB] LINE-TO-CENTER FLAG
                  [GWB] CNPNTS  equ     $391A   ;[GWB] 1/8 NO. OF PTS IN CIRCLE
                  [GWB] CPLOTF  equ     $391C   ;[GWB] PLOT FLAG
                  [GWB] CPCNT   equ     $391D   ;[GWB] ;1/8 NO. OF PTS IN CIRCLE
                  [GWB] CPCNT8  equ     $391F   ;[GWB] NO. OF PTS IN CIRCLE
                  [GWB] CRCSUM  equ     $3921   ;[GWB] CIRCLE SUM
                  [GWB] CSTCNT  equ     $3923   ;[GWB] START COUNT
                  [GWB] CSCLXY  equ     $3925   ;[GWB] FLAG WHETHER ASPECT WAS .GT. 1
                        CURLOC  equ     $3926   ;;Address of Semigraphics Character containing Point
                        PINDEX  equ     $3928   ;;Index of Point in 2x3 Semigraphics Character
                  [GWB] CXOFF   equ     $3929   ;[GWB] X OFFSET FROM CENTER SAVE LOC
                  [GWB] CYOFF   equ     $392B   ;[GWB] Y OFFSET SAVE LOCATION
                        X392F   equ     $392F   ;;
                        X3931   equ     $3931   ;;
                        DRWSCL  equ     $3933   ;[GWB] DRAW: SCALE - DRAW POS,Scaling factor
                        DRWFLG  equ     $3934   ;[GWB] OPTION FLAGS - DRAW flag
                        DRWANG  equ     $3935   ;[GWB] DRAW "ANGLE" (0..3) - DRAW translation angle
                        MCLPTR  equ     $3936   ;[GWB] MAC LANG PTR
                        MCLLEN  equ     $3938   ;[GWB] STRING LENGTH
                        MCLTAB  equ     $3939   ;[GWB] ;PTR TO COMMAND TABLE
                        PUTFLG  equ     $393B   ;[GWB] WHETHER DOING PUT() OR GET()
                        ARYPNT  equ     $393C   ;;Pointer into GET/PUT Array
                        OPCJMP  equ     $393E   ;;Jump Instruction
                        OPCADR  equ     $393F   ;;Draw Operator Routine Address
                        GYMAX   equ     $3941   ;;Msximum X Position: 39
                        GXMAX   equ     $3942   ;;Maximum Y Position: 23
                        ;;        $3943-$3948   ;Probably Unused
                        BASTXT  =       $3949   ;;Start of Extended Basic Program 



2000 : 2C 33 24         EXTBAS:  byte    ",3$$7+",0  ;;Extended BASIC Cartridge Signature
2003 : 24 37 2B          
2006 : 00                   
2007 : 00 00 00                  byte    0,0,0,0,0,0,0,0,0     
200A : 00 00 00          
200D : 00 00 00         
2010 : 21 5A 20         XSTART:  ld      hl,EXBAST        ;;Print "Extended BASIC"
2013 : CD 9D 0E                  call    STROUT          
2016 : 21 63 01                  ld      hl,HEDING+3      ;;Start of Copyright Message (S1 ROM?) 
2019 : 7E                        ld      a,(hl)           
201A : FE 79                     cp      $79         
201C : 20 03                     jr      nz,XSTAR2        ;;If first character is 'y'
201E : 2B                        dec     hl               ;;  Back up to 
201F : 2B                        dec     hl               ;;  Start of Message in S2 ROM
2020 : 2B                        dec     hl          
2021 : CD 9D 0E          XSTAR2: call    STROUT           ;;Print Copyright Message
2024 : 21 6C 20                  ld      hl,DOHOOK        ;;Store Hook Table Address
2027 : 22 06 38                  ld      (HOOK),hl        ;;in Hook Table
202A : 21 00 00                  ld      hl,0             ;;
202D : 22 31 39                  ld      (X3931),hl       ;;
2030 : 21 04 07                  ld      hl,$0704         ;;Default = White, Current = Blue 
2033 : 22 00 39                  ld      (FORCLR),hl      ;;Set Foreground Colors
2036 : 21 48 39                  ld      hl,BASTXT-1      ;;End of System RAM
2039 : 36 00                     ld      (hl),$00         ;;Store a 0 there 
203B : 23                        inc     hl               ;;Set Beginning of BASIC Text
203C : 22 4F 38                  ld      (TXTTAB),hl      ;;to BASTXT
203F : CD BE 0B                  call    SCRTCH           ;;Do a NEW
2042 : 3E C3                     ld      a,$C3            ;;JP Instruction
2044 : 32 0B 39                  ld      (MAXUPD),a       ;{GWB} Major Axis Move Update
2047 : 32 0E 39                  ld      (MINUPD),a       ;{GWB} Minor Axis Move Update
204A : 32 3E 39                  ld      (OPCJMP),a       ;;Draw Operator Routine
204D : AF                        xor     a                ;;Store 0 in
204E : 32 33 39                  ld      (DRWSCL),a       
2051 : 32 34 39                  ld      (DRWFLG),a       
2054 : 32 35 39                  ld      (DRWANG),a       
2057 : C3 02 04                  jp      READY            ;;Go to Immediate Mode
205A
205A : 0B 45 78         EXBAST: byte " Extended BASIC",13,10,0
205D : 74 65 6E  
2060 : 64 65 64  
2063 : 20 42 41  
2066 : 53 49 43  
2069 : 0D 0A 00  
206C                    ;;When the Hook Routine is Executed, the stack will contain
206C                    ;;Return Address, Saved Accumulator, and Text Pointer
206C : E3               DOHOOK: ex      (SP),hl           ;;[HL] = Return Address, Save HL on Stack
206D : F5                       push    AF                ;;Stack = Argument, Text Pointer,
206E : 7E                       ld      A,(hl)            ;;Get Hook ID
206F : 23                       inc     hl                ;;Increment Address Past Hook ID
2070 : E5                       push    hl                ;;Stack = Return Addr, Argument, Text Pointer
2071 : 21 9D 20                 ld      hl,HOOKT             
2074 : C5                       push    bc                ;;Stack = [BC], Return Addr, Arg, Text Ptr
2075 : 01 09 00                 ld      bc,9              ;;
2078 : ED B1                    cpir                      ;;Search Hook List for Hook Number
207A : 79                       ld      a,c               ;;Index into Hook List
207B : C1                       pop     bc                ;;Stack = Return Addr, Arg, Text Ptr
207C : 87                       add     a,a               ;;Multiply by 2
207D : 21 8B 20                 ld      hl,HOOKD          ;;Add to Address of Hook Table
2080 : 85                       add     a,l             
2081 : 6F                       ld      l,a             
2082 : 3E 00                    ld      a,0             
2084 : 8C                       adc     a,h             
2085 : 67                       ld      h,a               ;;Load Hook Routing Address
2086 : 7E                       ld      a,(hl)            ;;into HL
2087 : 23                       inc     hl                
2088 : 66                       ld      h,(hl)            
2089 : 6F                       ld      l,a             
208A : E9                       jp      (hl)              ;;and Execute It
208B                      
208B                    ;;Hook Dispatch Table 
208B : AD 20            HOOKD:  word    UNHOOK            ;;Hook Not Implemented
208D : EC 20                    word    NOTGOX            ;;(NOTGOS)
208E : A5 20                    word    OUTDOX            ;;(OUTDO)
2091 : F9 21                    word    ATN1              ;;ATN Routine
2093 : 77 21                    word    DEFX              ;;DEF FN Routine
2095 : A1 21                    word    FNDOER            ;;FN() Routine
2097 : 37 21                    word    INCHRX            ;;INCHRH Hook
2099 : FF 20                    word    LISTHK            ;;LIST Hook
209B : 11 21                    word    GONE23            ;;GONE23
209D                                                    
209D :                  ;;Hook Offset Table             
209D : 17               HOOKT:  byte    23                ;;Hook 23 (GONE23)
209E : 16                       byte    22                ;;Hook 22 (LIST)
209F : 12                       byte    18                ;;Hook 18 (INCHRH)
20A0 : 10                       byte    16                ;;Hook 16 (FNDOER)
02A1 : 0F                       byte    15                ;;Hook 15 (DEF)
20A2 : 0E                       byte    14                ;;Hook 14 (ATN)
20A3 : 0D                       byte    13                ;;Hook 12 (OUTDO)
20A4 : 0A                       byte    10                ;;Hook 10 (NOTGOS)
20A5    
20A5 : 2A 31 39         OUTDOX: ld      hl,(X3931)        ;;Get Line Number
20A8 : 7C                       ld      a,h 
20A9 : B5                       or      l                 ;;If Not Zero 
20AA : C2 52 23                 jp      nz,L2352          ;;
20AD                    
20AD                    ;;Hook Not Implemented - Restore Registers and Return
20AD : E1               UNHOOK: pop     hl                ;;Get Return Address
20AE : F1                       pop     af                ;;Restore Accumulator and Flags
20AF : E3                       ex      (sp),hl           ;;Swap Return Address for BASIC Pointer
20B0 : C9                       ret
20B1
20B1 :                + ;;Extended BASIC Reserved Word Tokens
20B1 :                | ;;Note: Tokens $CB - $CE are not defined    
20B1 :                  EXTLST: ;;Extended Reserved Words List
20B1 :                  TK      =       $CF               ;;Extended Tokens start at $CF
20B1 :                  XORTK   equ     TK  
20B1 : D8 4F 52                 byte    'X'+$80,"OR"      ;;$CF
20B1                    TK      =       TK+1              ;
20B1 :                  EDITTK  equ     TK  
20B4 : C5 44 49 54              byte    'E'+$80,"DIT"     ;;$D0
20B8                    TK      =       TK+1              ;
20B8 : CC 4F 43                 byte    'L'+%80,"OCATE"   ;;$D1
20BB : 41 54 45                                           
20BE                    TK      =       TK+1              ;
20BE : CD 45 4E                 byte    'M'+$80,"ENU"     ;;$D2
20C1 : 55                                                 
20C2                    TK      =       TK+1              ;
20C2 : C3 4C 53                 byte    'C'+$80,"LS"      ;;$D3
20C5                    TK      =       TK+1              ;
20C5 : CC 49 4E                 byte    'L'+$80,"INE"     ;;$D4
20C8 : 45                                                 
20C9                    TK      =       TK+1              ;
20C9 : C3 49 52                 byte    'C'+$80,"IRCLE"   ;;$D5
20CC : 43 4C 45                                         
20CF                    TK      =       TK+1              ;
20CF : C7 45 54                 byte    'G'+$80,"ET"      ;;$D6
20D2                    TK      =       TK+1              ;
20D2 : D0 55                    byte    'P'+$80,"UT"      ;;$D7
20D5                    TK      =       TK+1              ;
20D5 : C4 52 41                 byte    'D'+$80,"RAW"     ;;$D8
20D8                    TK      =       TK+1              ;
20D8 : 57               TKLAST  equ     TK                      
20D9 : 80                       byte    $80               ;End of Table
20DA
20DA                    ;;Extended Statement Dispatch Table       
20DA : 7F 23            EXTDSP: word    EDIT              ;;$237F
20DC : 4A 22                    word    LOCATE            ;;$224A
20DE : 67 22                    word    MENU              ;;$2267
20E0 : 46 22                    word    CLS               ;;$2246
20E2 : E7 25                    word    GLINE             ;;$25E7
20E4 : 00 27                    word    CIRCLE            ;;$2700
20E6 : 6F 23                    word    GGET              ;;$236F
20E8 : 6B 23                    word    GPUT              ;;$236B
20EA : 9D 2A                    word    DRAW              ;;$2A9D  
20EC                                                        
20EC : 78               NOTGOX: ld      a,b             
20ED : FE CB                    cp      POINTK             
20EF : C2 AD 20                 jp      nz,UNHOOK           
20F2 : C1                       pop     bc              
20F3 : F1                       pop     af                ;;Restore Accumulator and Flags
20F4 : E1                       pop     hl                ;;Restore BASIC Pointer
20F5 : C5                       push    bc                ;;Push Return Address
20F6 : EB                       ex      de,hl             
20F7 : 11 B0 20                 ld      de,$20B0          
20FA : 06 CE                    ld      b,XORTK-1             
20FC : C3 F9 04                 jp      CRUNCX            ;;Jump into CRUNCH
20FF 
20FF :                  ;;Hook 22 - Check for and Handle Extended BASIC Tokens
20FF : D1               LISTHK: pop     de                ;;Get Return Address
2100 : F1                       pop     af                ;;Restore Accumulator and Flags
2101 : E1                       pop     hl                ;;Restore Basic Pointer
2102 : FE CF                    cp      XORTK                          
2104 : 30 02                    jr      nc,RESSRX         ;;If Token < XORTK
2106 : D5                       push    de                ;;  Push Return Address onto Stack
2107 : C9                       ret                       ;;  and Return
2108 : D6 CE            RESSRX: sub     XORTK-1           
210A : 4F                       ld      c,a               ;;Set Count to Position in EXTLSR
210B : 11 B1 20                 ld      de,EXTLST         ;;Search in EXTLST
210E : C3 A8 05                 jp      RESSRC            ;;Go Do It
2111 
2111 :                  ;;Hook 23 - Check for and Dispatch Extended BASIC Statement Token
2111 : C1               GONE23: pop     bc                ;;Pop Return Address
2112 : F1                       pop     af                ;;Restore Accumulator and Flags
2113 : E1                       pop     hl                ;;Restore BASIC Pointer
2114 : 30 0C                    jr      nc,GONE24         ;;If Standard BASIC Token
2116 : F5                       push    af                ;;  Save Accumulator and Flags
2117 : FE 1C                    cp      PSETTK-$80        ;;  If PSET
2119 : 28 4E                    jr      z,PSETX           ;;    Do Extended BASIC PSET
211B : FE 1D                    cp      PRESTK-$80        ;;  If PRESET
211D : 28 46                    jr      z,PRESEX          ;;    Do Extended BASIC PRESET
211F : F1                       pop     af                ;;  Restore Accumulator and Flags
2120 : C5                       push    bc                ;;  Push Return Address back on to Stack
2121 : C9                       ret                       ;;  and Return
2122 : D6 50            GONE24: sub     EDITTK-$80        ;;Get Position in Extended List
2124 : DA C4 03                 jp      c,SNERR           ;;  If Negative, Syntax Error
2127 : FE 09                    cp      TKLAST-EDITTK     ;;Past End of Extended Tokens?  
2129 : D2 C4 03                 jp      nc,SNERR          ;;  Yes, Syntax Error
212C : 07                       rlca                      ;;Dispatch Offset = Position *2
212D : 4F                       ld      c,a               ;;[B,C] = Dispatch Offset
212E : 06 00                    ld      b,0 
2130 : EB                       ex      de,hl             ;;Text Pointer into [D,E]
2131 : 21 DA 20                 ld      hl,EXTDSP         ;;Use Extended Dispatch Table
2134 : C3 65 06                 jp      GONE5             ;;Continue Statement Dispatch
2137
2137 :                  ;;Hook 18 - Read Keyboard (INCHRH)
2137 : E1               INCHRX: pop     hl                ;;Hook Table Address
2138 : F1                       pop     af                ;;Accumulatot and Flags
2139 : E1                       pop     hl
213A : CD 80 1E                 call    INCHRC            ;;Read The Keyboard
213D : D9                       exx
213E : 21 B1 20                 ld      hl,EXTLST         ;;Use Extended Reserved Words List
2141 : FE 0F                    cp      15                ;;Ctrl-O?
2143 : 28 0F                    jr      z,KCIRCL  
2145 : FE 19                    cp      25                ;;Ctrl-Y?
2147 : 28 0F                    jr      z,KEDIT 
2149 : FE 10                    cp      16                ;;Ctrl-P? 
214B : 28 13                    jr      z,KLINE 
214D : FE 1E                    cp      30                ;;Ctrl-^?
214F : 28 0B                    jr      z,KDRAW
2151 : B7                       or      a
2152 : D9                       exx
2153 : C9                       ret
2154    
2154 : 0E 06            KCIRCL: ld      c,CIRCTK-XORTK  ;;CIRCLE
2156 : 18 0A                    jr      KEYREX
2158 : 0E 01            KEDIT:  ld      c,EDITTK-XORTK
215A : 18 06                    jr      KEYREX
215C : 0E 09            KDRAW:  ld      c,DRAWTK-XORTK  ;;DRAW
215E : 18 02                    jr      KEYREX
2160 : 0E 05            KLINE:  ld      c,LINETK-`  //LINE
2162 : C3 28 1F         KEYREX: jp      KEYRES
2165    
2165 :              + ;;Semigraphics Drawing Routines
2165 :              } ;;explanation of semigraphics and bit index
2165 :              } ;;
2165 :              } ;;
2165 :              } ;;
2165    
2165 :                + ;;Extended PSET or PRESET
2165 :                | ;;Reads Coordinates and saves them for subsequent
2165 :                | ;;  LINE -(X,Y) or LINE -STEP(X,Y) statement
2165 :                | ;;then executes standard basic PSET/PRESET code
2165 : F1               PRESEX: pop     af              ;;Discard Hook Table Address
2166 : AF                       xor     a               ;;[EUB] PRESET FLAG
2167 : 18 03                    jr      PPRSEX           
2169 : F1               PSETX:  pop     af              ;;Discard Hook Table Address
216A : 3E 01                    ld      a,1             ;;[EUB] PSET FLAG
216C : 23               PPRSEX: inc     hl              
216D : 08                       ex      af,af'          
216E : CF                       rst     SYNCHK          ;;Require '('
216F : 28                       byte    '('             
2170 : 2B                       dec     hl              ;;Back up to '(' for SCAN1
2171 : CD 47 25                 call SCAN1              ;;Scan Coordinates as (X,Y)
2174 : C3 55 1A                 jp PPRSDO               ;;Go Do PSET/PRESET
2177
2177 :                + ;[M80]SIMPLE-USER-DEFINED-FUNCTION CODE
2177 :                | ;[M80]
2177 :                | ;[M80] IN THE 8K VERSION (SEE LATER COMMENT FOR EXTENDED)
2177 :                | ;[M80] NOTE ONLY SINGLE ARGUMENTS ARE ALLOWED TO FUNCTIONS
2177 :                | ;[M80] AND FUNCTIONS MUST BE OF THE SINGLE LINE FORM:
2177 :                | ;[M80] DEF FNA(X)=X^2+X-2
2177 :                | ;[M80] NO STRINGS CAN BE INVOLVED WITH THESE FUNCTIONS
2177 :                | ;[M80]
2177 :                | ;[M80] IDEA: CREATE A FUNNY SIMPLE VARIABLE ENTRY
2177 :                | ;[M80] WHOSE FIRST CHARACTER (SECOND WORD IN MEMORY)
2177 :                | ;[M80] HAS THE 200 BIT SET.
2177 :                | ;[M80] THE VALUE WILL BE:
2177 :                | ;[M80]
2177 :                | ;[M80] 	A TXTPTR TO THE FORMULA
2177 :                | ;[M80]	THE NAME OF THE PARAMETER VARIABLE
2177 :                | ;[M80]
2177 :                | ;[M80] FUNCTION NAMES CAN BE LIKE "FNA4"
2177 :                | ;[M80]
2177 : E1               DEFX:   pop     hl              
2178 : F1                       pop     af              
2179 : E1                       pop     hl              
217A : CD EA 21                 call    GETFNM          ;[M80] GET A POINTER TO THE FUNCTION NAME
217D : CD 45 0B                 call    ERRDIR          ;[M80] DEF IS "ILLEGAL DIRECT"
2180 :                                                  ;[M80] MEMORY, RESTORE THE TXTPTRAND GO TO "DATA" 
2180 :                                                  ;[M80] SKIPPING THE REST OF THE FORMULA
2180 : 01 1C 07                 ld      bc,$071C      
2183 : C5                       push    bc              
2184 : D5                       push    de              
2185 : CF                       rst     SYNCHK          
2186 : 28                       byte    '('             ;{GWB} SKIP OVER OPEN PAREN
2187 : CD D1 10                 call    PTRGET          ;[M80] GET POINTER TO DUMMY VAR(CREATE VAR)
2189 : E5                       push    hl              
218B : EB                       ex      de,hl           
218C : 2B                       dec     hl              
218D : 56                       ld      d,(hl)          
218E : 2B                       dec     hl              
218F : 5E                       ld      e,(hl)          
2190 : E1                       pop     hl              
2191 : CD 75 09                 call    CHKNUM          
2194 : CF                       rst     SYNCHK          
2195 : 29                       byte    ')'             ;{M80} MUST BE FOLLOWED BY )
2196 : CF                       rst     SYNCHK          
2197 : B0                       byte    $B0
2198 : 44                       ld      b,h             
2199 : 4D                       ld      c,l             
219A : E3                       ex      (sp),hl         
219B : 71                       ld      (hl),c          
219C : 23                       inc     hl              
219D : 70                       ld      (hl),b          
219E : C3 59 0E                 jp      STRADX           
21A1
21A1 : E1         [M80] FNDOER: pop     hl              
21A2 : F1                       pop     af              
21A3 : E1                       pop     hl              
21A4 : CD EA 21                 call    GETFNM          ;[M80] GET A POINTER TO THE FUNCTION NAME
21A7 : D5                       push    de                
21A8 : CD 37 0A                 call    PARCHK          ;{M80} RECURSIVELY EVALUATE THE FORMULA
21AB : CD 75 09                 call    CHKNUM          ;{M65} MUST BE NUMBER
21AE : E3                       ex      (sp),hl         ;[M80] SAVE THE TEXT POINTER THAT POINTS PAST THE 
21AF :                                                  ;[M80] FUNCTION NAME IN THE CALL
21AF : 5E                       ld      e,(hl)          ;[H,L]=VALUE OF THE FUNCTION
21B0 : 23                       inc     hl              
21B1 : 56                       ld      d,(hl)          
21B2 : 23                       inc     hl              ;[M80] WHICH IS A TEXT POINTER AT THE FORMAL
21B3 : 7A                       ld      a,d             ;[M80] PARAMETER LIST IN THE DEFINITION
21B4 : B3                       or      e               ;[M80] A ZERO TEXT POINTER MEANS THE FUNCTION 
21B5 :                                                  ;[M80] WAS NEVER DEFINED
21B5 : CA D0 03                 jp      z,UFERR         ;[M80] IF SO, GIVEN AN "UNDEFINED FUNCTION" ERROR
21B8 : 7E                       ld      a,(hl)          
21B9 : 23                       inc     hl              
21BA : 66                       ld      h,(hl)          
21BB : 6F                       ld      l,a             
21BC : E5                       push    hl              ;SAVE THE NEW VALUE FOR PRMSTK
21BD : 2A DE 38                 ld      hl,(VARNAM)      
21C0 : E3                       ex      (sp),hl         
21C1 : 22 DE 38                 ld      (VARNAM),hl      
21C4 : 2A E2 38                 ld      hl,(X38E2)      
21C7 : E5                       push    hl              
21C8 : 2A E0 38                 ld      hl,(VARPNT)      
21CB : E5                       push    hl              
21CC : 21 E0 38                 ld      hl,VARPNT        
21CF : D5                       push    de              
21D0 : CD 3A 15                 call    MOVMF           
21D3 : E1                       pop     hl              
21D4 : CD 72 09                 call    FRMNUM          ;AND EVALUATE THE DEFINITION FORMULA
21D7 : 2B                       dec     hl              ;CAN HAVE RECURSION AT THIS POINT
21D8 : D7                       rst     CHRGET          ;SEE IF THE STATEMENT ENDED RIGHT
21D9 : C2 C4 03                 jp      nz,SNERR        ;THIS IS A CHEAT, SINCE THE LINE 
21DC :                                                  ;NUMBER OF THE ERROR WILL BE THE CALLERS
21DC :                                                  ;LINE # INSTEAD OF THE DEFINITIONS LINE #
21DC : E1                       pop     hl              
21DD : 22 E0 38                 ld      (VARPNT),hl      
21E0 : E1                       pop     hl              
21E1 : 22 E2 38                 ld      (X38E2),hl      
21E4 : E1                       pop     hl              
21E5 : 22 DE 38                 ld      (VARNAM),hl      
21E8 : E1                       pop     hl              ;GET BACK THE TEXT POINTER
21E9 : C9                       ret                     
21EA    
21EA                  + ;[M80] SUBROUTINE TO GET A POINTER TO A FUNCTION NAME
21EA                  | ;[M80] 
21EA : CF         [M80] GETFNM: rst     SYNCHK          
21EB : A2                       byte    FNTK            ; [M80] MUST START WITH "FN"
21EC : 3E 80                    ld      a,128           ; [M80] DONT ALLOW AN ARRAY
21EE : 32 CB 38                 ld      (SUBFLG),a      ; [M80] DON'T RECOGNIZE THE "(" AS THE START OF AN ARRAY REFEREENCE
21F1 : B6                       or      (hl)            ; [M80] PUT FUNCTION BIT ON
21F2 : 4F                       ld      c,a             ; [M80] GET FIRST CHARACTER INTO [C]
21F3 : CD D6 10                 call    PTRGT2          
21F6 : C3 75 09                 jp      CHKNUM          
21F9 
21F9                  + ;[M80] ARCTANGENT FUNCTION
21F9					        | ;[M80] IDEA: USE IDENTITIES TO GET ARG BETWEEN 0 AND 1 AND THEN USE AN
21F9					        | ;[M80] APPROXIMATION POLYNOMIAL TO COMPUTE ARCTAN(X)
21F9 : E1              ATN1:   pop     hl
21FA : F1                       pop     af
21FB : E1                       pop     hl
21FC : EF                       rst     FSIGN           ;[M80] SEE IF ARG IS NEGATIVE
21FD : FC 70 17                 call    m,PSHNEG        ;[M80] IF ARG IS NEGATIVE, USE:
2200 : FC 0B 15                 call    m,NEG           ;[M80]    ARCTAN(X)=-ARCTAN(-X
2203 : 3A E7 38                 ld      a,(FAC)         ;[M80] SEE IF FAC .GT. 1
2206 : FE 81                    cp      129            
2208 : DA 17 22                 jp      c,ATN2          ;[M80] GET THE CONSTANT 1
220B : 01 00 81                 ld      bc,129*128      ;[M80] GET THE CONSTANT 1
220E : 51                       ld      d,c             
220F : 59                       ld      e,c             ;[M80] COMPUTE RECIPROCAL TO USE THE IDENTITY:
2210 : CD 2F 14                 call    FDIV            ;[M80]   ARCTAN(X)=PI/2-ARCTAN(1/X)
2213 : 21 58 12                 ld      hl,FSUBS        ;[M80] PUT FSUBS ON THE STACK SO WE WILL RETURN       
2216 : E5                       push    hl              ;[M80]  TO IT AND SUBTRACT THE REULT FROM PI/2
2217 : 21 21 22   [M80] ATN2:   ld      hl,ATNCON       ;[M80] EVALUATE APPROXIMATION POLYNOMIAL
221A : CD 37 18                 call    POLYX           
221D : 21 53 19                 ld      hl,PI2          ;[M80] GET POINTER TO PI/2 IN CASE WE HAVE TO
2220 : C9                       ret                     ;[M80]  SUBTRACT THE RESULT FROM PI/2
2221
2221                    ;CONSTANTS FOR ATN
2221 : 09         [M80] ATNCON: byte    9               ;DEGREE
2222 : 4A D7 3B                 byte    $4A,$D7,$3B,$78 ; .002866226
2225 : 78  
2226 : 02 6E 84                 byte    $02,$6E,$84,$7B ; -.01616574
2229 : 7B         
222A : FE C1 2F                 byte    $FE,$C1,$2F,$2F ; .04290961
222D : 7C  
222E : 74 31 9A                 byte    $74,$31,$9A,$7D ; -.07528964
2231 : 7D                       
2232 : 84 3D 5A                 byte    $84,$3D,$5A,$7D ; .1065626
2235 : 7D                       
2236 : C8 7F 91                 byte    $C8,$7F,$91,$7E ; -.142089
2239 : 7E                       
223A : E4 BB 4C                 byte    $E4,$BB,$4C,$7E ; .1999355
223D : 7E                       
223E : 6C AA AA                 byte    $6C,$AA,$AA,$7F ; -.3333315
2241 : 7F                       
2242 : 00 00 00                 byte    $00,$00,$00,$81 ; 1.0
2245 : 81  
2246
2246 :`                 ;[M80] CLS: CLear Screen issues an escape sequence to clear the CRT.
2246 : 3E 0B      [M80] CLS:    ld      a,11            
2248 : DF                       rst     OUTCHR          
2249 : C9                       ret
224A
224A                  + ;[GWB] LOCATE: Parse the following syntax:
224A                  | ;[GWB]        LOCATE X,Y
224A                  | ;[GWB]
224A : CD 54 0B  `[GWB] LOCATE: call    GETBYT          ;[GWB] Get X parameter
224D : F5                       push    af              ;;Save it
224E : 3D                       dec     a               ;;Make it 1 less 
224F : FE 26                    cp      38              ;[GWB] Check for parameter range
2251 : D2 97 06                 jp      nc,FCERR        
2254 : CF                       rst     SYNCHK          
2255 : 2C                       byte    ','             
2256 : CD 54 0B                 call    GETBYT          ;[GWB] Get Y parameter
2259 : FE 18                    cp      24              
225B : D2 97 06                 jp      nc,FCERR        ;[GWB] Check for parameter range
225E : 1C                       inc     e               ;;[E] = Y + 1          
225F : F1                       pop     af              ;;Restore X 
2260 : 57                       ld      d,a             ;;[D] = X
2261 : EB                       ex      de,hl           ;;{HL] = C,Y
2262 : CD 4D 2D                 call    MOVEIT           
2265 : EB                       ex      de,hl           ;;Switch Back
2266 : C9                       ret                     
2267    
2267                    ;;;This Statement appears to be unique to the Aquarius
2267 :                  ;;The MENU Statement
2267 :                  ;;Syntax: MENU (xpos,ypos), spacing; 
2267 :                  ;;             "string-1","string-2",...,"string-n" 
2267 :                  ;;              GOTO line-1,line-2,...,line-n
2267 :                  ;;Spacing is optional, in the form:
2267 :                  ;;        MENU (xpos,ypos) "string-1",... GOTO line-1,...
2267 :                  ;;An at sign may precede the coordinates:
2267 :                  ;;        MENU @(xpos,ypos) ...
2267 : FE 40            MENU:   cp      '@'             ;{GWB} ALLOW MEANINGLESS "@"
2269 : CC 6B 06                 call    z,CHRGTR        ;{GWB} BY SKIPPING OVER IT
226C : CD E0 22                 call    SCANX           ;;Scan Coordinates into [D,E] 
226F : D5                       push    de              ;;Push Coordinates onto Stacj
2270 : 1E 01                    ld      e,1             ;;Default Spacing (1) into [E]
2272 : 7E                       ld      a,(hl)          ;;
2273 : FE 2C                    cp      ','             ;;If Next Character is a Comma
2275 : 20 08                    jr      nz,MENU2        ;;  Scan Optional Spacing Parameter
2277 : D7                       rst     CHRGET          ;;  Eat Comma
2278 : CD 54 0B                 call    GETBYT          ;;  Scan Spacing in [E]
227B : D5                       push    de              ;;  Push Options onto Stack
227C : CF                       rst     SYNCHK          
227D : 3B                       byte    ';'             ;;  Require a Semicolon          
227E : D1                       pop     de              ;;  Pop Options into [D,E]
227F : 4B               MENU2:  ld      c,e             ;;Copy Spacing into [C]
2280 : 06 01                    ld      b,1             ;;Init Counter to 1 ino B
2282 : D1                       pop     de              ;;Pop Coordinates into [D,E]
2283 : D5                       push    de              ;;Push Coordinates back onto Stack
2284 : C5                       push    bc              ;;Push Options onto Stack
2285 :                          ;;Evaluate and Print String
2285 : E5               MENUS:  push    hl              ;;Push Text Pointer onto Stack
2286 : EB                       ex      de,hl           ;;Swap Coordinates into [H,L]
2287 : E5                       push    hl              ;;Push Coordinates onto Stack
2288 : CD 4D 2D                 call    MOVEIT          ;;Move Cursor to Coordinates [H,L]
228B : 3E 2E                    ld      a,'.'                     
228D : DF                       rst     OUTCHR          ;;Print a Period
228E : E1                       pop     hl              ;;HL = Coords, Stack = Text Pointer, Options. Coords
228F : E3                       ex      (sp),hl         ;;HL = Text Pointer, Stack = Coordinates
2290 : CD 85 09                 call    FRMEVL          ;;Evaluate a String
2293 : E5                       push    hl              ;;Stack = Text Pointer, Coords, Options. Coords
2294 : CD C6 0F                 call    FRESTR          ;[M80] FREE UP TEMP POINTED TO BY FACLO
2297 : CD A0 0E                 call    STRPRT          ;;Print the String
229A : E1                       pop     hl              ;;HL = Text Pointer, Stack =  Coords, Options. Coords
229B : D1                       pop     de              ;;DE = Coords, Stack = Options. Coords
229C : C1                       pop     bc              ;;BC = Options, Stack = Coords
229D : 7E                       ld      a,(hl)          
229E : FE 2C                    cp      ','             ;;Is Next Character a Comma?
22A0 : 20 0C                    jr      nz,MENU3        ;;If So
22A2 : EB                       ex      de,hl           ;;  HL = Coords, DE = Text Pointer
22A3 : 04                       inc     b               ;;  Increment Option Counter
22A4 : CD FB 22                 call    ADDLC           ;;  Add Spacing to Y
22A7 : C5                       push    bc              ;;  Stack = Options, Coords
22A8 : E5                       push    hl              ;;  Stack = Coords, Options, Coords
22A9 : EB                       ex      de,hl           ;;  HL = Text Pointer, DE = Coords
22AA : D7                       rst     CHRGET          ;;  Eat Comma
22AB : D1                       pop     de              ;;  Get Back Coordinates 
22AC : 18 D7                    jr      MENUS           ;;  Scane Next String
22AE    
22AE :                  ;;BC = Options, DE = Coords, HL = Text Pointer, Stack = Coords
22AE : FE 88            MENU3:  cp      GOTOTK          ;;If Not GOTO
22B0 : C2 C4 03                 jp      nz,SNERR        ;;Syntax Error
22B3 : E3                       ex      (sp),hl         ;;HL = Coords, Stack = Text Pointer
22B4 : E5               MENUT:  push    hl              ;;Stack = Coords, Text Pointer
22B5 : C5                       push    bc              ;;Stack = Options, Coorda, Text Pointer
22B6 : 1E 00                    ld      e,0             ;;Option Number = 0
22B8 : CD CE 22         MENUN:  call    MENUK           ;;Get C/R or Space from Keyboard
22BB : 1C                       inc     e               ;;Increment Option Number
22BC : 38 0A                    jr      c,MENUG         ;;If Space
22BE : CD FB 22                 call    ADDLC           ;;  Y = Y + Spacing
22C1 : 05                       dec     b               ;;  Decrement Option Count
22C2 : 20 F4                    jr      nz,MENUN        ;;  If Not Zero, Move to Next Optionb
22C4 : C1                       pop     bc              ;;    BC = Options, HL = Coords
22C5 : E1                       pop     hl              ;;    Stack = Text Pointer
22C6 : 18 EC                    jr      MENUT           ;;    Start Iver ar Top
22C8 : E1               MENUG:  pop     hl              ;;Discard Options
22C9 : E1                       pop     hl              ;;Discard Coords
22CA : E1                       pop     hl              ;;Restore Text Pointer
22CB : C3 85 07                 jp      OMGOTO          ;;Do ON [E] GOTO 
22CE
22CE                    ;;Wait for C/R or Space, Return Carry Set if Return
22CE : C5               MENUK:  push    bc              ;;Save BC
22CF : CD 4D 2D                 call    MOVEIT          ;;Move Cursor to H,L
22D2 : CD 2F 1A         MENUL:  call    CQINCH          ;;Get Character from Keyboard
22D5 : FE 0D                    cp      13              ;;If Carriage Return
22D7 : 37                       scf                     ;;  Return Carry Set
22D8 : 28 04                    jr      z,MENUR         
22DA : FE 20                    cp      ' '             ;;If Not Space
22DC : 20 F4                    jr      nz,MENUL        ;;  Loop
22DE : C1               MENUR:  pop     bc              ;;Restore BC 
22DF : C9                       ret
22E0
22E0 :                  ;;Get Coordinates for MENU Statement   
22E0 :                  ;;Syntax: Coords
22E0 : CF               SCANX:  rst     SYNCHK          
22E1 : 28                       byte    '('             ;{GWB} SKIP OVER OPEN PAREN
22E2 : CD 54 0B                 call    GETBYT          ;{GWB} SCAN X INTO [A]
22E5 : FE 26                    cp      38              ;;If X > 38                         
22E7 : 30 09                    jr      nc,SCANX2       ;;  Function Call Error` 
22E9 : 3C                       inc     a               ;;Bump X Past First Column
22EA : F5                       push    af              ;{GWB} SAVE WHILE SCANNING Y
22EB : CF                       rst     SYNCHK          
22EC : 2C                       byte    ','             ;{GWB} SCAN COMMA
22ED : CD 54 0B                 call    GETBYT          ;{GWB} GET Y INTO [A]
22F0 : FE 25                    cp      37              ;;If Y > 37            
22F2 : D2 97 06         SCANX2: jp      nc,FCERR        ;;  Function Call Error`
22F5 : D1                       pop     de              ;;Get X into D
22F6 : 3C                       inc     a               ;;Bump Y Past First Line
22F7 : 5F                       ld      e,a             ;;Put Y into E
22F8 : CF                       rst     SYNCHK          
22F9 : 29                       byte    ')'             ;{GWB} SKIP OVER CLOSE PAREN
22FA : C9                       ret                     
22FB    
22FB : 7D               ADDLC:  ld      a,l             ;;L = L + C 
22FC : 81                       add     a,c             
22FD : 6F                       ld      l,a             
22FE : FE 18                    cp      24              
2300 : D8                       ret     c               ;;If L >= 24
2301 : 2E 17                    ld      l,23            ;;L = 23
2303 : C9                       ret
2304    
2304 : EF               FRCINX: rst     FSIGN           ;[M80] GET THE SIGN OF THE FAC IN A
2305 : FA 0E 23                 jp      m,FRCINM        ;;If Positive
2308 : EB                       ex      de,hl           ;;  Save DE in HL
2309 : CD 82 06                 call    FRCINT          ;;  Convert FAC into Integer in DE
230C : EB                       ex      de,hl           ;;  Put Result into HL, Restore DE
230D : C9                       ret                     ;;Else
230E : D5               FRCINM: push    de              ;;  Save DE
230F : CD 0B 15                 call    NEG             ;;  Negate FAC
2312 : CD 82 06                 call    FRCINT          ;;  Convert FAC into Integer in DE
2315 : CD 0B 15                 call    NEG             ;;  Un-Negate FAC
2318 : 21 00 00                 ld      hl,0            
231B : B7                       or      a               
231C : ED 52                    sbc     hl,de           ;;  Put 0 - Integer into HL
231E : D1                       pop     de              ;;  and Restore DE
231F : C9                       ret
2320    
2320 : E5         [GWB] MAKINT: push    hl              ;;Save Registers
2321 : D5                       push    de
2322 : C5                       push    bc
2323 : 7C                       ld      a,h
2324 : 55                       ld      d,l
2325 : CD 23 0B                 call    FLOATD          ;;Put HL into FAC
2328 : C1                       pop     bc              ;;Restore Registers
2329 : D1                       pop     de
232A : E1                       pop     hl
232B : C9                       ret
232C    
232C :                          ;;Print Null Terminated String 
232C :                          ;;pointed to by [HL]
232C :                          ;;On return [HL] points to 0 terminator
232C : 7E                       LISPRX: ld a,(hl)         ;;Get Nyte
232D : B7                               or a              ;;If it's Zero
232E : C8                               ret z             ;;  Return
232F : DF                               rst OUTCHR        ;;Output Byte
2330 : 23                               inc hl            ;;Point to Next Byte
2331 : C3 2C 23                         jp LISPRX         ;;and Do it Again
2334 :
2334 :                  ;;Convert Character to Uppercase   
2334 : FE 61      [GWB] MAKUPS: cp      'a'             
2336 : D8                       ret     c               ;;If >= 'a' 
2337 : FE 7B                    cp      '{'             
2339 : D0                       ret     nc              ;;and less than <'['
233A : E6 5F                    and     $5F             ;;Clear Bit 5
233C : C9                       ret                     
233D :
233D :                  ;{M80} UNPACK LINE INTO BUF
233D : E5         [M80] BUFLIN: push    hl              ;{GWB} SAVE THE TEXT POINTER
233E : 21 02 00                 ld      hl,2            
2341 : 39                       add     hl,sp             ;;Point [HL] Line Number on Stack
2342 : 22 2F 39                 ld      (X392F),hl        ;;Save Line Number
2348 : 22 31 39                 ld      (X3931),hl        ;;
234B : 2A 4F 38                 ld      hl,(TXTTAB)       ;;[HL] = Start of BASIC Program
2345 : 21 60 38                 ld      hl,BUF            ;;[HL] = Input Buffer Address
234E : E3                       ex      (sp),hl           ;;{HL] = Text Pointer, Stack = BUF Address
234F : C3 98 05                 jp      LISPRT            ;;Detokenize Line into BUF
2352 :  
2352 :  
2352 : F1               L2352:  pop     af                ;;Discard Return Address
2353 : F1                       pop     af                ;;Restore Argument 
2354 : FE 0D                    cp      13                ;;Is it a Carriage Return
2356 : 28 07                    jr      z,L235F           ;;No
2358 : 77                       ld      (hl),a             
2359 : 23                       inc     hl              
235A : 22 31 39                 ld      (X3931),hl      
235D : E1                       pop     hl                ;;Restore Text Pointer
235E : C9                       ret                     
    ;
235F                                                      ;;Yes
235F : AF               L235F:  xor     a                 ;;[A] = 0
2360 : 77                       ld      (hl),a          
2361 : 67                       ld      h,a             
2362 : 6F                       ld      l,a             
2363 : 22 31 39                 ld      (X3931),hl      
2366 : 2A 2F 39                 ld      hl,(X392F)      
2369 : F9                       ld      sp,hl           
236A : C9                       ret                     
236B
236B : 3E 01            GPUT:   ld      a,1             ;;Mode = GET
236D : 18 01                    jr      GGPUTG
236F : AF               GGET:   xor a                   ;;Mode = PUT
2370 : C3 84 29         GGPUTG: jp      GPUTG
2373    
2373 : CD 85 09   [GWB] GETIN2: call    FRMEVL          ;[GWB] EVALUATE A FORMULA
2376 : E5         {GWB} INTFR2: push    hl              ;[GWB] SAVE THE TEXT POINTER
2377 : CD 75 09                 call    CHKNUM          ;[M65] MUST BE NUMBER
237A : CD 82 06                 call    FRCINT          ;[GWB] CONVERT THE FORMULA TO AN INTEGER IN [H,L]
237D : E1                       pop     hl              ;[GWB] RESTORE THE TEXT POINTER
237E : C9                       ret
237F
237F                  + ;[M80] EDIT COMMAND
237f                  | ;;; Need to check if this matches the code
237F                  | ;[M80] [C] CONTAINS COUNT OF CHARACTERS IN LINE
237F                  | ;[M80] [B] CONTAINS CURRENT CHARACTER POSITION 0=FIRST IN LINE.
237F                  | ;[M80] [D] CONTAINS NUMBER OF TIMES TO REPEAT THIS SUBCOMMAND
237F                  | ;[M80] [H,L] POINT TO CURRENT CHARACTER
237F : CD 9C 06   [M80] EDIT:   call    SCNLIN          ;[M80[ GET THE ARGUMENT LINE NUMBER
2382 : C0                       ret     nz              ;[M80] ERROR IF NOT END OF LINE
2383 : E1         {M80} EREDIT  pop     hl              ;[M80] GET RID OF NEWSTT Address
2384 : CD 9F 04   [M80] EEDITS: call    FNDLIN          ;[M80] FIND THE LINE IN QUESTION
2387 : D2 F3 06                 jp      nc,USERR        ;[M80] IF NOT FOUND, UNDEFINED STATEMENT ERROR.
238A : 60                       ld      h,b             ;[M80] PONTER TO LINE IS IN [B,C]
238B : 69                       ld      l,c             ;[M80] TRANSFER IT TO [H,L]
238C : 23                       inc     hl              ;[M80] PASS OVER POINTER TO NEXT LINE
238D : 23                       inc     hl              ;[M80] LIKE SO.
238E : 4E                       ld      c,(hl)          ;[M80] GET FIRST BYTE OF LINE #
238F : 23                       inc     hl              ;[M80] MOVE TO 2ND BYTE
2390 : 46                       ld      b,(hl)          ;[M80] PICK IT UP INTO B
2391 : 23                       inc     hl              ;[M80] ADVANCE TO POINT TO FIRST BYTE OF LINE
2392 : C5                       push    bc              ;[M80] SAVE LINE # ON STACK
2393 : CD 3D 23                 call    BUFLIN          ;[M80] UNPACK LINE INTO BUF
2396 : E1         [M80] LLED:   pop     hl              ;[M80] GET BACK LINE #
2397 : E5         {M80} INLED:  push    hl              ;[M80] SAVE IT BACK ON STACK
2398 : 7C                       ld      a,h             ;[M80] TEST FOR DOUBLE BYTE ZERO
2399 : A5                       and     l               
239A : 3C                       inc     a               
239B : 3E 21                    ld      a,'!'           ;[M80] GET PROMPT FOR DIRECT EDIT
239D : CC 8A 19                 call    z,OUTDO         ;[M80] SEND IT
23A0 : C4 75 16                 call    nz,LINPRT       ;[M80] PRINT LINE # IF NOT INLIN EDIT
23A3 : 3E 20                    ld      a,' '           ;[M80] TYPE A SPACE
23A5 : DF                       rst     OUTCHR          ;[M80] ...
23A6 : 21 60 38                 ld      hl,BUF          ;[M80] GET START OF BUF IN [H,L]
23A9 : E5                       push    hl              ;[M80] SAVE [H,L] WHILE WE CALC LINE LENGTH
23AA : 0E FF                    ld      c,255           ;[M80] ASSUME 0 CHAR LINE
23AC : 0C         [M80] LENLP:  inc     c               ;[M80] BUMP COUNT OF CHARS
23AD : 7E                       ld      a,(hl)          ;[M80] GET CHAR FROM LINE
23AE : 23                       inc     hl              ;[M80] BUMP POINTER
23AF : B7                       or      a               
23B0 : 20 FA                    jr      nz,LENLP        ;[M80] IF NOT ZERO (END OF LINE) KEEP COUNTING...
23B2 : E1                       pop     hl              ;[M80] GET BACK POINTER TO LINE
23B3 : 47                       ld      b,a             ;[M80] SET CURRENT LINE POSIT TO ZERO
23B4 : 16 00      {M80} DISPED: ld      d,0             ;[M80] ASSUME REPITION COUNT IS ZERO
23B6 : CD DA 19   [M80] DISPI:  call    INCHR           ;[M80] GET A CHAR FROM USER
23B9 : B7                       or      a               ;[M80] IGNORE NULLS
23BA : 28 FA                    jr      z,DISPI         
23BC : CD 34 23                 call    MAKUPS          ;[M80] MAKE UPPER CASE COMMAND
23BF : D6 30                    sub     '0'             ;[M80] GET RID OF OFFSET
23C1 : 38 0E                    jr      c,NOTDGI        ;[M80] ... 
23C3 : FE 0A                    cp      10            
23C5 : 30 0A                    jr      nc,NOTDGI        
23C7 : 5F                       ld      e,a             ;[M80] SAVE CHAR
23C8 : 7A                       ld      a,d             ;[M80] GET ACCUM REPITITION
23C9 : 07                       rlca                    ;[M80] MULTIPLY BY 2
23CA : 07                       rlca                    ;[M80] BY 4
23CB : 82                       add     a,d             ;[M80] AND ADD TO GET 5*D
23CC : 07                       rlca                    ;[M80] *2 TO GET 10*D
23CD : 83                       add     a,e             ;[M80] ADD DIGIT
23CE : 57                       ld      d,a             ;[M80] SAVE BACK NEW ACCUM
23CF : 18 E5                    jr      DISPI           ;[M80]  GET NEXT CHAR
23D1    
23D1 : E5         [M80] NOTDGI: push    hl              ;[M80] SAVE TEXT POINTER
23D2 : 21 B4 23                 ld      hl,023B4H       ;[M80] PUT RETURN Address TO DISPED
23D5 : E3                       ex      (sp),hl         ;[M80] ON THE STACK
23D6 : 15                       dec     d               ;[M80] SEE IF D=0 (REP FACTOR)
23D7 : 14                       inc     d               ;[M80] SET CONDITION CODES
23D8 : 20 01                    jr      nz,NTZERD       ;[M80] BRANCH AROUND
23DA : 14                       inc     d               ;[M80] MAKE IT 1
23DB    
23DB : FE EC      [M80] NTZERD: cp      8-'0'           ;[M80] Backspace?
23DD : CA 19 25                 jp      z,BAKED         ;[M80] HANDLE IT
23E0 : FE DD                    cp      13-'0'          ;[M80] CARRIAGE RETURN
23E2 : CA 26 25                 jp      z,CRED          ;[M80] DONE EDITING
23E5 : FE F0                    cp      ' '-'0'         ;[M80] SPACE
23E7 : 28 42                    jr      z,SPED          ;[M80] GO TO ROUTINE
23E9 : FE 31                    cp      'A'+32-'0'      ;[M80] COMMAND IN LOWER CASE?
23EB : 38 02                    jr      c,NOTLW4        ;[M80] NO, SO OK.
23ED : D6 20                    sub     32              ;[M80] CONVERT TO UPPER CASE
23EF    
23EF : FE 21      [M80] NOTLW4: cp      'Q'-'0'         ;[M80] QUIT?
23F1 : CA 3C 25                 jp      z,QED           ;[M80] IF SO, QUIT & PRINT "OK" OR RETURN TO INLIN
23F4 : FE 1C                    cp      'L'-'0'         ;[M80] L?
23F6 : 28 68                    jr      z,LED           ;[M80] BRANCH
23F8 : FE 23                    cp      'S'-'0'         ;[M80] S?
23FA : 28 41                    jr      z,SED           ;[M80] SEARCH
23FC : FE 19                    cp      'I'-'0'         ;[M80] I?
23FE : CA B1 24                 jp      z,IED           ;[M80] INSERT
2401 : FE 14                    cp      CPI 'D'-'0'     ;[M80] D?
2403 : 28 65                    jr      z,DED           ;[M80] DELETE
2405 : FE 13                    cp      'C'-'0'         ;[M80] C?
2407 : 28 7A                    jr      z,CED           ;[M80] CHANGE
2409 : FE 15                    cp      'E'-'0'         ;[M80] END?
240B : CA 29 25                 jp      z,EED           ;[M80] (SAME AS <CR> BUT DOESNT PRINT REST)
240E : FE 28                    cp      'X'-'0'         ;[M80] EXTEND?
2410 : CA AC 24                 jp      z,XED           ;[M80] GO TO END OF LINE & INSERT
2413 : FE 1B                    cp      'K'-'0'         ;[M80] KILL??
2415 : 28 20                    jr      z,KED           ;[M80] (SAME AS "S" BUT DELETES CHARS)
2417 : FE 18                    cp      'H'-'0'         ;[M80] HACK??
2419 : CA A9 24                 jp      z,HED           ;[M80] HACK OFF THE REST OF THE LINE & INSERT
241C : FE 11                    cp      'A'-'0'         ;[M80] AGAIN??
241E : 3E 07                    ld      a,7             ;[M80] GET READY TO TYPE BEL.
2420 : C2 8A 19                 jp      nz,OUTDO        ;[M80] NO MATCH, SEND BEL AND RETURN TO DISPATCHER
2423 : C1                       pop     bc              ;[M80] DISPI RETURN Address
2424 : D1                       pop     de              ;[M80] LINE NUMBER INTO [D,E]
2425 : CD EA 19                 call    CRDO            ;[M80] TYPE A CARRIAGE RETURN LINE-FEED
2428 : C3 84 23                 jp      EEDITS          ;[M80] RESTART EDITING
242B              
242B : 7E         [M80] SPED:   ld      a,(hl)          ;[M80] GET CHAR FROM CURENT POSIT
242C : B7                       or      a               ;[M80] ARE WE AT END OF LINE?
242D : C8                       ret     z               ;[M80] IF SO, RETURN
242E : 04                       inc     b               ;[M80] BUMP CURRENT POSITION
242F : CD 8A 19                 call    OUTDO           ;[M80] TYPE CHARACTER
2432 : 23                       inc     hl              ;[M80] MOVE POINTER TO NEXT CHAR
2433 : 15                       dec     d               ;[M80] TEST IF DONE WITH REPITITIONS
2434 : 20 F5                    jr      nz,SPED         ;[M80] REPEAT
2436 : C9                       ret                     ;[M80] RETURN TO DISPATCHER
    ;
2437    
2437 : E5         [M80] KED:    push    hl              ;[M80] SAVE CURRENT CHAR POSIT
2438 : 21 7F 24                 ld      hl,TYPSLH       ;[M80] TYPE SLASH WHEN DONE
243B : E3                       ex      (sp),hl         ;[M80] PUT IT ON STACK & GET POSIT BACK
243C : 37                       scf                     ;[M80] SET THE CARRY FLAG
243D    
243D : F5         [M80] SED:    push    af              ;[M80] SAVE CONDITION CODES
243E : CD DA 19  "              call    INCHR           ;[M80] GET SEARCH CHAR
2441 : 5F                       ld      e,a             ;[M80] SAVE IT
2442 : F1                       pop     af
2443 : F5                       push    af
2444 : DC 7F 24                 call    c,TYPSLH        ;[M80] TYPE BEGINNING SLASH FOR "K"
2447 : 7E         [M80] SRCALP: ld      a,(hl)
2448 : B7                       or      a
2449 : 28 13                    jr      z,POPART
244B : CD 8A 19                 call    OUTDO           ;[M80] TYPE THE CHAR
244E : F1                       pop     af              ;[M80] GET KILL FLAG
244F : F5                       push    af              ;[M80] SAVE BACK
2450 : DC E6 24                 call    c,DELCHR        ;[M80] DELETE THE CHAR IF K COMMAND.
2453 : 38 02                    jr      c,NOTSRC        ;[M80] AND DONT MOVE POINTER AS DELCHR ALREADY DID
2455 : 23                       inc     hl
2456 : 04                       inc     b               ;[M80] INCREMENT LINE POSIT
2457 : 7E         [M80] NOTSRC: ld      a,(hl)          ;[M80] ARE WE AT END
2458 : BB                       cp      e               ;[M80] ARE CURRENT CHAR & SEARCH
2459 : 20 EC                    jr      nz,SRCALP       ;[M80] CHAR THE SAME? IF NOT, LOOK MORE
245B : 15                       dec     d               ;[M80] LOOK FOR N MATCHES
245C : 20 E9                    jr      nz,SRCALP       ;[M80] IF NOT 0, KEEP LOOKING
245E : F1         [M80] POPART: pop     af              ;[M80] GET RID OF KILL FLAG
245F : C9                       ret                     ;[M80] DONE SEARCHING
2460    
2460 : CD 2C 23   [M80] LED:    call    LISPRX          ;[M80] TYPE REST OF LINE
2463 : CD EA 19                 call    CRDO            ;[M80] TYPE CARRIAGE RETURN
2466 : C1                       pop     bc              ;[M80] GET RID OF RETURN TO DISPED
2467 : C3 96 23                 jp      LLED            ;[M80] GO TO MAIN CODE
246A              
246A : 7E         [M80] DED:    ld      a,(hl)          ;[M80] GET CHAR WHICH WE ARE TRYING TO DELETE
246B : B7                       or      a               ;[M80] IS IT THE END OF LINE
246C : C8                       ret     z               ;[M80] DONE IF SO
246D : 3E 5C                    ld      a,'\'           ;[M80] TYPE BACKSLASH
246F : CD 8A 19                 call    OUTDO           ;[M80] LIKE SO
2472 : 7E         [M80] DELLP:  ld      a,(hl)          ;[M80] GET CHAR FROM LINE
2473 : B7                       or      a               ;[M80] ARE WE AT END?
2474 : 28 09                    jr      z,TYPSLH        ;[M80] TYPE SLASH
2476 : CD 8A 19                 call    OUTDO           ;[M80] TYPE CHAR WE'RE GOING TO DELETE
2479 : CD E6 24                 call    DELCHR          ;[M80] DELETE CURRENT CHAR
247C : 15                       dec     d               ;[M80] DECREMENT DELETE COUNT
247D : 20 F3                    jr      nz,DELLP        ;[M80] KEEP DOING IT
247F : 3E 5C      [M80] TYPSLH: ld      a,'\'           ;[M80] TYPE ENDING SLASH
2481 : DF                       rst     OUTCHR          ;[M80] LIKE SO
2482 : C9                       ret
2483    
2483 : 7E         [M80] CED:    ld      a,(hl)          ;[M80] ARE WE AT END OF LINE?
2484 : B7                       or      a               ;[M80] SEE IF 0
2485 : C8                       ret     z               ;[M80] RETURN
2486 : CD DA 19   [M80] CED2:   call    INCHR           ;[M80] GET CHAR TO REPLACE CHAR
2489 : FE 20                    cp      ' '             ;[M80] IS IT CONTROL CHAR?
248B : D2 9F 24                 jp      nc,NOTCCC       ;[M80] NO
248E : FE 0A                    cp      10              ;[M80] IS IT LF?
2490 : 28 0D                    jr      z,NOTCCC        ;[M80] YES
2492 : FE 07                    cp      7               ;[M80] OR BELL?
2494 : 28 09                    jr      z,NOTCCC        ;[M80] OK
2496 : FE 09                    cp      9               ;[M80] OR TAB?
2498 : 28 05                    jr      z,NOTCCC        ;[M80] OK
249A : 3E 07                    ld      a,7             ;[M80] GET BELL
249C : DF                       rst     OUTCHR          ;[M80] SEND IT
249D : 18 E7                    jr      CED2            ;[M80] RETRY
249F : 77         [M80] NOTCCC: ld      (hl),a          ;[M80] SAVE IN MEMORY
24A0 : CD 8A 19                 call    OUTDO           ;[M80] ECHO THE CHAR WERE USING TO REPLACE
24A3 : 23                       inc     hl              ;[M80] BUMP POINTER
24A4 : 04                       inc     b               ;[M80] INCREMENT POSITION WITHIN LINE
24A5 : 15                       dec     d               ;[M80] ARE WE DONE CHANGING?
24A6 : 20 DB                    jr      nz,CED          ;[M80] IF NOT, CHANGE SOME MORE.
24A8 : C9                       ret                     ;[M80] DONE
24A9    
24A9 : 36 00      [M80] HED:    ld      (hl),0          ;[M80] MAKE LINE END AT CURRENT POSITION
24AB : 48                       ld c,b                  ;[M80] SET UP LINE LENGTH CORRECTLY
24AC    
24AC : 16 FF      [M80] XED:    ld      d,255           ;[M80] FIND END OF LINE
24AE : CD 2B 24                 call    SPED            ;[M80] BY CALLING SPACER
24B1 :                  ;NOW FALL INTO INSERT CODE
24B1 : CD DA 19   [M80] IED:    call    INCHR           ;[M80] GET CHAR TO INSERT
24B4 : FE 1C                    cp      28              ;[M80] DELETE??
24B6 : 28 1F                    jr      z,TYPARW        ;[M80] YES, ACT LIKE "_" 
24B8 : FE 0D                    cp      13              ;[M80] IS IT A CARRIAGE RETURN?
24BA : 28 6A                    jr      z,CRED          ;[M80] DONT INSERT, AND SIMULATE <CR>
24BC : FE 11                    cp      17              ;[M80] IS IT ESCAPE?
24BE : C8                       ret     z               ;[M80] IF SO, DONE.
24BF : FE 08                    cp      8               ;[M80] BACKSPACE?              
24C1 : 28 16                    jr      z,TYPAR1        ;[M80] TYPE BACKARROW AND DELETE 
24C3 : FE 0A                    cp      10              ;[M80] LINE FEED?
24C5 : 28 2E                    jr      z,NTARRW        ;[M80] ALLOW IT
24C7 : FE 07                    cp      7               ;[M80] BELL?
24C9 : 28 2A                    jr      z,NTARRW        ;[M80] ALLOW IT
24CB : FE 09                    cp      9               ;[M80] TAB?
24CD : 28 26                    jr      z,NTARRW        ;[M80] ALLOW IT
24CF : FE 20                    cp      ' '             ;[M80] IS IT ILLEGAL CHAR
24D1 : 38 DE                    jr      c,IED           ;[M80] TOO SMALL
24D3 : FE 5F                    cp      '_'             ;[M80] DELETE PREVIOUS CHAR INSERTED?
24D5 : 20 1E                    jr      nz,NTARRW       ;[M80] IF NOT, JUMP AROUND NEXT CODE
24D7 : 3E 5F      [M80] TYPARW: ld      a,'_'           ;[M80] TYPE IT
24D9 : 05         [M80] TYPAR1: dec     b               ;[M80] ARE WE AT START OF LINE?
24DA : 04                       inc     b               ;[M80] LETS SEE
24DB : 28 1F                    jr      z,DINGI         ;[M80] IF SO, TYPE DING.
24DD : CD 8A 19                 call    OUTDO           ;[M80] TYPE THE BACK ARROW
24E0 : 2B                       dec     hl              ;[M80] BACK UP THE POINTER
24E1 : 05                       dec     b               ;[M80] MOVE BACK POSIT IN LINE
24E2 : 11 B1 24                 ld      de,IED          ;[M80] SET UP RETURN Address
24E5 : D5                       push    de              ;[M80] SAVE IT  ON STACK & FALL THROUGH
24E6                    ;[M80] SUBROUTINE TO DELETE CHAR POINTED TO BY [H,L]. CORRECTS C.
24E6 : E5         [M80] DELCHR: push    hl              ;[M80] SAVE CURRENT POSIT POINTER
24E7 : 0D                       dec     c               ;[M80] MAKE LENGTH OF LINE ONE LESS
24E8 : 7E         [M80] CMPRSS: ld      a,(hl)          ;[M80] GET CHAR TO DELETE
24E9 : B7                       or      a               ;[M80] ARE WE AT END OF LINE
24EA : 37                       scf                     ;[M80] FLAG THAT DELCHR WAS CALLED (FOR K)
24EB : CA 1A 14                 jp      z,POPHRT        ;[M80] IF SO, DONE COMPRESSING
24EE : 23                       inc     hl              ;[M80] POINT TO NEXT BYTE
24EF : 7E                       ld      a,(hl)          ;[M80] PICK IT UP
24F0 : 2B                       dec     hl              ;[M80] NOW BACK AGAIN
24F1 : 77                       ld      (hl),a          ;[M80] DEPOSIT IT
24F2 : 23                       inc     hl              ;[M80] NOW TO NEXT BYTE
24F3 : 18 F3                    jr      CMPRSS          ;[M80] KEEP CRUNCHING
24F5    
24F5 : F5         [M80] NTARRW: push    af              ;[M80] SAVE THE CHAR TO BE INSERTED
24F6 : 79                       ld      a,c             ;[M80] GET LENGTH OF LINE
24F7 : FE 48                    cp      BUFLEN          ;[M80] SEE IF WE ARENT TRYING TO MAKE LINE TOO LONG
24F9 : 38 06                    jr      c,OKINS         ;[M80] IF LENGTH OK, GO INSERT
24FB : F1                       pop     af              ;[M80] GET THE UNLAWFUL CHAR
24FC    
24FC : 3E 07      [M80] DINGI:  ld      a,7             ;[M80] TYPE A BELL TO LET USER KNOW
24FE : DF                       rst     OUTCHR          ;[M80] IT ALL OVER
24FF : 18 B0      [M80] IEDG:   jr      IED             ;[M80] HE HAS TO TYPE <ESC> TO GET OUT
2501 : 90         [M80] OKINS:  sub     b               ;[M80] CALC POINTER TO 0 AT END OF LINE
2502 : 0C                       inc     c               ;[M80] WE ARE GOING TO HAVE LINE LONGER BY 1
2503 : 04                       inc     b               ;[M80] POSITION MOVES UP ONE ALSO
2504 : C5                       push    bc              ;[M80] SAVE [B,C]
2505 : EB                       ex      de,hl           ;[M80] SAVE [D,E] IN [H,L]
2506 : 6F                       ld      l,a             ;[M80] SAVE # OF BYTES TO MOVE IN [L]
2507 : 26 00                    ld      h,0             ;[M80] GET SET TO ADD [D,E] TO [H,L]
2509 : 19                       add     hl,de           ;[M80] CALC HIGH POINTER
250A : 44                       ld      b,h             ;[M80] GET HIGH BYTE TO MOVE POINTER
250B : 4D                       ld      c,l             ;[M80] IN [B,C]
250C : 23                       inc     hl              ;[M80] ALWAYS MOVE AT LEAST ZERO AT END
250D : CD 95 0B                 call    BLTUC           ;[M80] MOVE LINE OUT 1 CHAR
2510 : C1                       pop     bc              ;[M80] RESTORE [B,C]  
2511 : F1                       pop     af              ;[M80] GET CHAR BACK
2512 : 77                       ld      (hl),a          ;[M80] SAVE IT IN LINE
2513 : CD 8A 19                 call    OUTDO           ;[M80] TYPE THE CHAR
2516 : 23                       inc     hl              ;[M80] POINT TO NEXT CHAR
2517 : 18 E6                    jr      IEDG            ;[M80] AND GO GET MORE CHARS
2519    
2519 : 78         [M80] BAKED:  ld      a,b             ;[M80] ARE WE MOVING BACK PAST THE
251A : B7                       or      a               ;[M80] FIRST CHARACTER
251B : C8                       ret     z               ;[M80] DON'T ALLOW IT
251C : 05                       dec     b               ;[M80] CHANGE CURRENT POSITION
251D : 2B                       dec     hl              ;[M80] MOVE CHAR POINTER BACK
251E : 7E                       ld      a,(hl)          ;[M80] 
251F : CD 8A 19                 call    OUTDO           ;[M80] ECHO IT
2522 : 15                       dec     d               ;[M80] ARE WE DONE MOVING BACK?
2523 : 20 F4                    jr      nz,BAKED        ;[M80] IF NOT, GO BACK MORE
2525 : C9                       ret                     ;[M80] RETURN
2526    
2526 : CD 2C 23   [M80] CRED:   call    LISPRX          ;[M80] TYPE REST OF LINE
2529 : CD EA 19   [M80] EED:    call    CRDO            ;[M80] TYPE CARRIAGE RETURN
252C : C1                       pop     bc              ;[M80]  GET RID OF DISPED Address
252D : D1                       pop     de              ;[M80] GET LINE # OFF STACK
252E : 7A                       ld      a,d             ;[M80] DOUBLE BYTE ZERO.
252F : A3                       and     e               
2530 : 3C                       inc     a               ;[M80] SET ZERO IF [D,E] = ALL ONES.
2531 : 21 5F 38  {M80} EDITRT:  ld      hl,BUF-1        ;[M80] START KRUNCHING AT BUF
2534 : C8                       ret     z               ;[M80] RETURN TO INLIN IF CALLED FROM THERE
2535 : 37                       scf                     ;[M80] FLAG LINE # WAS SEEN TO FOOL INSERT CODE
2536 : 03                       inc     bc              ;[M80] ;;Not in MBASIC-80
2537 : F5                       push    af              ;[M80] PSW IS ON STACK
2538 : 23                       inc     hl              ;[M80] NOW POINT AT BUF.
2539 : C3 28 04                 jp      EDENT           ;[M80] GO TO ENTRY POINT IN MAIN CODE
253C    
253C : C1         [M80] QED:    pop bc                  ;[M80] GET RID OF DISPED Address
253D : D1                       pop de                  ;[M80] GET LINE # OFF STACK
253E : 7A                       ld a,d                  ;[M80] DOUBLE BYTE ZERO.
253F : A3                       and e                   
2540 : 3C                       inc a                   ;[M80] SET ZERO IF [D,E] = ALL ONES.
2541 : CA E5 19                 jp z,FININL             ;[M80] TYPE CR AND STORE ZERO IN BUF.
2544 : C3 02 04                 jp READY                ;[M80] OTHERWISE CALLED FROM MAIN
2547                    
2547                  + ;[GWB] ALLOW A COORDINATE OF THE FORM (X,Y) OR STEP(X,Y)
2547                  | ;[GWB] THE LATTER IS RELATIVE TO THE GRAPHICS AC.
2547                  | ;[GWB] THE GRAPHICS AC IS UPDATED WITH THE NEW VALUE
2547                  | ;[GWB] RESULT IS RETURNED WITH [B,C]=X AND [D,E]=Y
2547                  | ;[GWB] CALL SCAN1 TO GET FIRST IN A SET OF TWO PAIRS SINCE IT ALLOWS
2547                  | ;[GWB] A NULL ARGUMENT TO IMPLY THE CURRENT AC VALUE AND
2547                  | ;[GWB] IT WILL SKIP A "@" IF ONE IS PRESENT
2547 : 7E         [GWB] SCAN1:  ld      a,(hl)          ;[GWB] GET THE CURRENT CHARACTER
2548 : FE 40                    cp      '@'             ;[GWB] ALLOW MEANINGLESS "@"
254A : CC 6B 06                 call    z,CHRGTR        ;[GWB] BY SKIPPING OVER IT
254D : 01 00 00                 ld      bc,0            ;[GWB] ASSUME NO COODINATES AT ALL (-SECOND)
2550 : 50                       ld      d,b             
2551 : 59                       ld      e,c             
2552 : FE A9                    cp      MINUTK          ;[GWB] SEE IF ITS SAME AS PREVIOUS            
2554 : 28 16                    jr      z,SCANN         ;[GWB] USE GRAPHICS ACCUMULATOR
2556 :                  ;[GWB] THE STANDARD ENTRY POINT   
2556 : 7E         [GWB] SCAND:  ld      a,(hl)          ;[GWB] GET THE CURRENT CHARACTER
2557 : FE A7                    cp      STEPTK          ;[GWB] IS IT RELATIVE?
2559 : F5                       push    af              ;[GWB] REMEMBER
255A : CC 6B 06                 call    z,CHRGTR        ;[GWB] SKIP OVER $STEP TOKEN
255D : CF                       rst     SYNCHK          
255E : 28                       byte    '('             ;[GWB] SKIP OVER OPEN PAREN
255F : CD 73 23                 call    GETIN2          ;[GWB] SCAN X INTO [D,E]
2562 : D5                       push    de              ;SAVE WHILE SCANNING Y
2563 : CF                       rst     SYNCHK          
2564 : 2C                       byte    ','             ;[GWB] SCAN COMMA               
2565 : CD 73 23                 call    GETIN2          ;[GWB] GET Y INTO [D,E]
2568 : CF                       rst     SYNCHK          
2569 : 29                       byte    ')'             
256A : C1                       pop     bc              ;[GWB] GET BACK X INTO [B,C]             
256B : F1                       pop     af              ;[GWB] RECALL IF RELATIVE OR NOT
256C : E5         [GWB] SCANN:  push    hl              ;[GWB] SAVE TEXT POINTER
256D : 2A 09 39                 ld      hl,(GRPACX)     ;[GWB] GET OLD POSITION
2570 : 28 03                    jr      z,SCXREL        ;[GWB] IF ZERO,RELATIVE SO USE OLD BASE
2572 : 21 00 00                 ld      hl,0            ;[GWB] IN ABSOLUTE CASE, JUST Y USE ARGEUMENT
2575 : 09         [GWB] SCXREL: add     hl,bc           ;[GWB] ADD NEW VALUE
2576 : 22 09 39                 ld      (GRPACX),hl     ;[GWB] UPDATE GRAPHICS ACCUMLATOR
2579 : 22 03 39                 ld      (GXPOS),hl      ;[GWB] STORE SECOND COORDINTE FOR CALLER
257C : 44                       ld      b,h             ;[GWB] RETURN X IN BC
257D : 4D                       ld      c,l              
257E : 2A 07 39                 ld      hl,(GRPACY)     ;[GWB] GET OLDY POSITION
2581 : 28 03                    jr      z,SCYREL        ;[GWB] IF ZERO, RELATIVE SO USE OLD BASE
2583 : 21 00 00  "              ld      hl,0            ;[GWB] ABSOLUTE SO OFFSET BY 0
2586 : 19         [GWB] SCYREL: add     hl,de           
2587 : 22 07 39                 ld      (GRPACY),hl     ;[GWB] UPDATE Y PART OF ACCUMULATOR
258A : 22 05 39                 ld      (GYPOS),hl      ;[GWB] STORE Y FOR CALLER
258D : EB                       ex      de,hl           ;[GWB] RETURN Y IN [D,E]
258E : E1                       pop     hl              ;[GWB] GET BACK THE TEXT POINTER
258F : C9                       ret
2590    
2590                  + ;[GWB] ATTRIBUTE SCAN
2590                  | ;[GWB] LOOK AT THE CURRENT POSITION AND IF THERE IS AN ARGUMENT READ IT AS
2590                  | ;[GWB] THE 8-BIT ATTRIBUTE VALUE TO SEND TO SETATR. IF STATEMENT HAS ENDED
2590                  | ;[GWB] OR THERE IS A NULL ARGUMENT, SEND FORCLR  TO SETATR
2590                  | ;;
2590                  | ;;Entry point ATRENT will leave [A] unchanged if there is a null agrument
2590                  | ;;
2590 : 3A 00 39   [GWB] ATRSCN: ld      a,(FORCLR)      ;;Get Default foreground color
2593 : C5         {GWB} ATRENT: push    bc              ;[GWB] SAVE THE CURRENT POINT
2594 : D5                       push    de              
2595 : 5F                       ld      e,a             ;;Preload Attribute with Default Value
2596 : 2B                       dec     hl              ;[GWB] SEE IF STATEMENT ENDED
2597 : D7                       rst     CHRGET
2598 : 28 09                    jr      z,ATRFIN        ;[GWB] USE DEFAULT
259A : CF                       rst     SYNCHK
259B : 2C                       byte    ','             ;[GWB]  INSIST ON COMMA
259C : FE 2C                    cp      ','             ;[GWB] ANOTHER COMMA FOLLOWS?
259E : 28 03                    jr      z,ATRFIN        ;[GWB] IF SO, NULL ARGUMENT SO USE DEFAULT
25A0 : CD 54 0B                 call    GETBYT          ;[GWB] GET THE BYTE
25A3 : 7B         [GWB] ATRFIN: ld      a,e             ;[GWB] GET ATTRIBUTE INTO [A]
25A4 : E5                       push    hl              ;[GWB] SAVE THE TEXT POINTER
25A5 : CD 84 2D                 call    SETATR          ;[GWB] SET THE ATTRIBUTE AS THE CURRENT ONE
25A8 : DA 97 06                 jp      c,FCERR         ;[GWB] ILLEGAL ATTRIBUTES GIVE FUNCTION CALL
25AB : E1                       pop     hl              
25AC : D1                       pop     de              ;[GWB] GET BACK CURRENT POINT
25AD : C1                       pop     bc              
25AE : C3 6C 06                 jp      CHRGT2          
25B1    
25B1                 + ;[GWB] XDELT SETS [H,L]=ABS(GXPOS-[B,C]) AND SETS CARRY IF [B,C].GT.GXPOS
25B1                 | ;[GWB] ALL REGISTERS EXCEPT [H,L] AND [A,PSW] ARE PRESERVED
25B1                 | ;[GWB] NOTE: [H,L] WILL BE A DELTA BETWEEN GXPOS AND [B,C] - ADD 1 FOR AN X "COUNT"
25B1                 | ;[GWB]
25B1 : 2A 03 39   [GWB] XDELT:  ld      hl,(GXPOS)      ;[GWB] GET ACCUMULATOR POSITION
25B4 : 7D                       ld      a,l             
25B5 : 91                       sub     c               ;[GWB] DO SUBTRACT INTO [H,L]
25B6 : 6F                       ld      l,a             
25B7 : 7C                       ld      a,h             
25B8 : 98                       sbc     a,b             
25B9 : 67                       ld      h,a             
25BA : D0         [GWB] CNEGHL: ret     nc              
25BB    
25BB : AF         [GWB] NEGHL:  xor       a             ;[GWB] STANDARD [H,L] NEGATE
25BC : 95                       sub       l
25BD : 6F                       ld        l,a
25BE : 9C                       sbc       a,h
25BF : 95                       sub       l
25C0 : 67                       ld        h,a
25C1 : 37                       scf
25C2 : C9                       ret
25C3
25C3                  + ;[GWB] YDELT SETS [H,L]=ABS(GYPOS-[D,E]) AND SETS CARRY IF [D,E].GT.GYPOS
25C3                  | ;[GWB] ALL REGISTERS EXCEPT [H,L] AND [A,PSW] ARE PRESERVED
25C3                  | ;[GWB]
25C3 : 2A 05 39   [GWB] YDELT:  ld      hl,(GYPOS)
25C6 : 7D                       ld      a,l
25C7 : 93                       sub     e
25C8 : 6F                       ld      l,a
25C9 : 7C                       ld      a,h
25CA : 9A                       sbc     a,d
25CB : 67                       ld      h,a
25CC : 18 EC                    jr      CNEGHL
25CE
25CE :               + ;;Register Exchange Routines
25CE :               | ;[GWB] XCHGX EXCHANGES [B,C] WITH GXPOS
25CE :               | ;[GWB] XCHGY EXCHANGES [D,E] WITH GYPOS
25CE :               | ;[GWB] XCHGAC PERFORMS BOTH OF THE ABOVE
25CE :               | ;[GWB] NONE OF THE OTHER REGISTERS IS AFFECTED
25CE :               | ;[GWB]
25CE : E5         [GWB] XCHGY:  push    hl
25CF : 2A 05 39                 ld      hl,(GYPOS)
25D2 : EB                       ex      de,hl
25D3 : 22 05 39                 ld      (GYPOS),hl
25D6 : E1                       pop     hl
25D7 : C9                       ret
25D8    
25D8 : CD CE 25   [GWB] XCHGAC: call    XCHGY
25DB : E5         [GWB] XCHGX:  push    hl
25DC : C5                       push    bc
25DD : 2A 03 39                 ld      hl,(GXPOS)
25E0 : E3                       ex      (sp),hl
25E1 : 22 03 39                 ld      (GXPOS),hl
25E4 : C1                       pop     bc
25E5 : E1                       pop     hl
25E6 : C9                       ret
25E7    
25E7                  + ;[GWB] LINE COMMAND
25E7                  | ;[GWB] 
25E7                  | ;[GWB] LINE [(X1,Y1)]-(X2,Y2) [,ATTRIBUTE[,B[F]]]
25E7                  | ;[GWB] DRAW A LINE FROM (X1,Y1) TO (X2,Y2) EITHER
25E7                  | ;[GWB] 1. STANDARD FORM -- JUST A LINE CONNECTING THE 2 POINTS
25E7                  | ;[GWB] 2. ,B=BOXLINE -- RECTANGLE TREATING (X1,Y1) AND (X2,Y2) AS OPPOSITE CORNERS
25E7                  | ;[GWB] 3. ,BF= BOXFILL --  FILLED RECTANGLE WITH (X1,Y1) AND (X2,Y2) AS OPPOSITE CORNERS
25E7                  | ;[GWB]
25E7                  | ;;ATTRIBUTE is the Foreground Color
25E7 : CD 47 25   [GWB] GLINE:  call    SCAN1           ;[GWB] SCAN THE FIRST COORDINATE
25EA : C5                       push    bc              ;[GWB] SAVE THE POINT
25EB : D5                       push    de              
25EC : CF                       rst     SYNCHK          
25ED : A9                       byte    MINUTK          ;[GWB] MAKE SURE ITS PROPERLY SEPERATED
25EE : CD 56 25                 call    SCAND           ;[GWB] SCAN THE SECOND SET
25F1 : CD 90 25                 call    ATRSCN          ;[GWB] SCAN THE ATTRIBUTE
25F4 : D1                       pop     de              ;[GWB] GET BACK THE FIRST POINT
25F5 : C1                       pop     bc              
25F6 : 28 43                    jr      z,DOLINE        ;[GWB] IF STATEMENT ENDED ITS A NORMAL LINE
25F8 : CF                       rst     SYNCHK          
25F9 : 2C                       byte    ','             ;[GWB] OTHERWISE MUST HAVE A COMMA
25FA : CF                       rst     SYNCHK          
25FB : 42                       ld      b,d             
25FC : 28 53                    jr      z,BOXLIN        ;[GWB] IF JUST "B" THE NON-FILLED BOX
25FE : CF                       rst     SYNCHK          
25FF : 46                       byte    'F'             ;[GWB] MUST BE FILLED BOX
2600 : E5         {GWB} DOBOXF: push    hl              ;[GWB] SAVE THE TEXT POINTER
2601 : CD 2B 2E                 call    SCLXYX          ;[GWB] SCALE FIRST POINT
2604 : CD D8 25                 call    XCHGAC          ;[GWB] SWITCH POINTS
2607 : CD 2B 2E                 call    SCLXYX          ;[GWB] SCALE SECOND POINT
260A : CD C3 25                 call    YDELT           ;[GWB] SEE HOW MANY LINES AND SET CARRY
260D : DC CE 25                 call    c,XCHGY         ;[GWB] MAKE [D,E] THE SMALLEST Y
2610 : 23                       inc     hl              ;[GWB] MAKE [H,L] INTO A COUNT
2611 : E5                       push    hl              ;[GWB] SAVE COUNT OF LINES
2612 : CD B1 25                 call    XDELT           ;[GWB] GET WIDTH AND SMALLEST X
2615 : DC DB 25                 call    c,XCHGX         ;[GWB] MAKE [B,C] THE SMALLEST X
2618 : 23                       inc     hl              ;[GWB] MAKE [H,L] INTO A WIDTH COUNT
2619 : E5                       push    hl              ;[GWB] SAVE WIDTH COUNT
261A : CD FD 2D                 call    MAPXYP          ;[GWB] MAP INTO A "C"
261D : D1                       pop     de              ;[GWB] GET WIDTH COUNT
261E : C1                       pop     bc              ;[GWB] GET LINE COUNT
261F : D5         [GWB] BOXLOP: push    de              ;[GWB] SAVE WIDTH
2620 : C5                       push    bc              ;[GWB] SAVE NUMBER OF LINES
2621 : CD 7D 2D                 call    FETCHC          ;[GWB] LOOK AT CURRENT C
2624 : F5                       push    af              ;[GWB] SAVE BIT MASK OF CURRENT "C"
2625 : E5                       push    hl              ;[GWB] SAVE Address
2626 : EB                       ex      de,hl           ;[GWB] SET UP FOR NSETCX WITH COUNT
2627 : CD C0 2D                 call    NSETCX          ;[GWB] IN [H,L] OF POINTS TO SETC
262A : E1                       pop     hl              ;[GWB] GET BACK STARTING C
262B : F1                       pop     af              ;[GWB] Address AND BIT MASK
262C : CD 76 2D                 call    STOREC          ;[GWB] SET UP AS CURRENT "C"
262F : CD BD 2E                 call    DOWNC           ;[GWB] MOVE TO NEXT LINE DOWN IN Y
2632 : C1                       pop     bc              ;[GWB] GET BACK NUMBER OF LINES
2633 : D1                       pop     de              ;[GWB] GET BACK WIDTH
2634 : 0B                       dec     bc              ;[GWB] COUNT DOWN LINES
2635 : 78                       ld      a,b             
2636 : B1                       or      c               ;[GWB] SEE IF ANY LEFT
2637 : 20 E6                    jr      nz,BOXLOP       ;[GWB] KEEP DRAWING MORE LINES
2639 : E1                       pop     hl              
263A : C9                       ret                     
263B    
263B : C5         [GWB] DOLINE: push    bc              ;[GWB] SAVE COORDINATES
263C : D5                       push    de              
263D : E5                       push    hl              ;[GWB] SAVE TEXT POINTER
263E : CD 7B 26                 call    DOGRPH          
2641 : 2A 09 39                 ld      hl,(GRPACX)     ;[GWB] RESTORE ORIGINAL SECOND COORDINATE
2644 : 22 03 39                 ld      (GXPOS),hl      
2647 : 2A 07 39                 ld      hl,(GRPACY)     ;[GWB] FOR BOXLIN CODE
264A : 22 05 39                 ld      (GYPOS),hl      
264D : E1                       pop     hl              ;[GWB] RESTORE TEXT POINTER
264E : D1                       pop     de              
264F : C1                       pop     bc              
2650 : C9                       ret                     
2651    
2651 : E5         [GWB] BOXLIN: push    hl              ;[GWB] SAVE TEXT POINTER
2652 : 2A 05 39                 ld      hl,(GYPOS)      
2655 : E5                       push    hl              ;[GWB] SAVE Y2
2656 : D5                       push    de              ;[GWB] SAVE Y1
2657 : EB                       ex      de,hl           ;[GWB] MOVE Y2 TO Y1
2658 : CD 3B 26                 call    DOLINE          ;[GWB] DO TOP LINE
265B : E1                       pop     hl              ;[GWB] MOVE Y1 TO Y2
265C : 22 05 39                 ld      (GYPOS),hl      
265F : EB                       ex      de,hl           ;[GWB] RESTORE Y1 TO [D,E]
2660 : CD 3B 26                 call    DOLINE          
2663 : E1                       pop     hl              ;[GWB] GET BACK Y2
2664 : 22 05 39                 ld      (GYPOS),hl      ;[GWB] AND RESTORE
2667 : 2A 03 39                 ld      hl,(GXPOS)      ;[GWB] GET X2
266A : C5                       push    bc              ;[GWB] SAVE X1
266B : 44                       ld      b,h             ;[GWB] SET X1=X2
266C : 4D                       ld      c,l             
266D : CD 3B 26                 call    DOLINE          
2670 : E1                       pop     hl              
2671 : 22 03 39                 ld      (GXPOS),hl      ;[GWB] SET X2=X1
2674 : 44                       ld      b,h             ;[GWB] RESTORE X1 TO [B,C]
2675 : 4D                       ld      c,l             
2676 : CD 3B 26                 call    DOLINE          
2679 : E1                       pop     hl              ;[GWB] RESTORE THE TEXT POINTER
267A : C9                       ret                     
267B    
267B : CD 2B 2E   [GWB] DOGRPH: call    SCLXYX          ;[GWB] CHEATY SCALING - JUST TRUNCATE FOR NOW
267E : CD D8 25                 call    XCHGAC          
2681 : CD 2B 2E                 call    SCLXYX          
2684 : CD C3 25   {GWB} DOGRP2  call    YDELT           ;[GWB] GET COUNT DIFFERENCE IN [H,L]
2687 : DC D8 25                 call    c,XCHGAC        ;[GWB] IF CURRENT Y IS SMALLER NO EXCHANGE
268A : D5                       push    de              ;[GWB] SAVE Y1 COORDINATE
268B : E5                       push    hl              ;[GWB] SAVE DELTA Y
268C : CD B1 25                 call    XDELT           
268F : EB                       ex      de,hl           ;[GWB] PUT DELTA X INTO [D,E]
2690 : 21 DB 2E                 ld      hl,RIGHTC       ;[GWB] ASSUME X WILL GO RIGHT
2693 : 30 03                    jr      nc,LINCN2        
2695 : 21 D1 2E                 ld      hl,LEFTC        
2698 : E3         [gwb] LINCN2: ex      (sp),hl         ;[GWB] XTHL
2699 : E7                       rst     COMPAR          ;[GWB] SEE WHICH DELTA IS BIGGER
269A : 30 10                    jr      nc,YDLTBG       ;[GWB] YDELTA IS BIGGER OR EQUAL 
269C : 22 13 39                 ld      (MINDEL),hl     ;[GWB] SAVE MINOR AXIS DELTA (Y)
269F : E1                       pop     hl              ;[GWB] GET X ACTION ROUTINE
26A0 : 22 0C 39                 ld      (MAXUPD+1),hl   ;[GWB] SAVE IN MAJOR ACTION Address
26A3 : 21 BD 2E                 ld      hl,DOWNC       	;[GWB] ALWAYS INCREMENT 
26A6 : 22 0F 39                 ld      (MINUPD+1),hl   ;[GWB] WHICH IS THE MINOR AXIS
26A9 : EB                       ex      de,hl           ;[GWB] [H,L]=DELTA X=MAJOR DELTA
26AA : 18 0F                    jr      LINCN3          ;[GWB] MERGE WITH YDLTBG CASE AND DO DRAW
26AC    
26AC : E3         [GWB] YDLTBG: ex      (sp),hl         ;[GWB] XTHL
26B0 : 21 BD 2E                 ld      hl,DOWNC        ;[GWB] Y IS ALWAYS INCREMENT MODE
26AD : 22 0F 39                 ld      (MINUPD+1),hl   ;[GWB] SAVE Address OF MINOR AXIS UPDATE
26B3 : 22 0C 39                 ld      (MAXUPD+1),hl   ;[GWB] SAVE AS MAJOR AXIS UPDATE
26B6 : EB                       ex      de,hl           ;[GWB] [H,L]=DELTA X
26B7 : 22 13 39                 ld      (MINDEL),hl     ;[GWB] SAVE MINOR DELTA
26BA : E1                       pop     hl              ;[GWB] [H,L]=DELTA Y=MAJOR DELTA
26BB    
26BB : D1         [GWB] LINCN3: pop     de              ;[GWB] GET BACK Y1 
26BC                  + ;
26BC                  | ;[GWB] MAJOR AXIS IS ONE WITH THE LARGEST DELTA
26BC                  | ;[GWB] MINOR IS THE OTHER
26BC                  | ;[GWB] READY TO DRAW NOW
26BC                  | ;[GWB] MINUPD+1=Address TO GO TO UPDATE MINOR AXIS COORDINATE
26BC                  | ;[GWB] MAXUPD+1=Address TO GO TO UPDATE MAJOR AXIS COORDINATE
26BC                  | ;[GWB] [H,L]=MAJOR AXIS DELTA=# OF POINTS-1
26BC                  | ;[GWB] MINDEL=DELTA ON MINOR AXIS
26BC                  | ;[GWB]
26BC                  | ;[GWB] IDEA IS
26BC                  | ;[GWB]  SET SUM=MAJOR DELTA/2
26BC                  | ;[GWB]  [B,C]=# OF POINTS
26BC                  | ;[GWB]  MAXDEL=-MAJOR DELTA (CONVENIENT FOR ADDING)
26BC                  | ;[GWB] LINE LOOP (LINLP3):
26BC                  | ;[GWB]       DRAW AT CURRENT POSITION
26BC                  | ;[GWB]       UPDATE MAJOR AXIS
26BC                  | ;[GWB]       SUM=SUM+MINOR DELTA
26BC                  | ;[GWB]       IF SUM.GT.MAJOR DELTA THEN UPDATE MINOR AND SUM=SUM-MAJOR DELTA
26BC                  | ;[GWB]       DECREMENT [B,C] AND TEST FOR 0 -- LOOP IF NOT
26BC                  | ;[GWB] END LOOP
26BC : E5                       push    hl             ;[GWB] SAVE FOR SETTING UP COUNT
26BD : CD BB 25                 call    NEGHL          
26C0 : 22 11 39                 ld      (MAXDEL),hl    ;[GWB] SAVE MAJOR DELTA FOR SUMMING
26C3 : CD FD 2D                 call    MAPXYP         ;[GWB] GET POSITION INTO BITMSK AND [H,L]  
26C6 : D1                       pop     de             
26C7 : D5                       push    de             ;[GWB] START SUM AT MAXDEL/2 
26C8 : CD F0 26                 call    HLFDE          
26CB : C1                       pop     bc             ;[GWB] GET COUNT IN [B,C]
26CC : 03                       inc     bc             ;[GWB] NUMBER OF POINTS IS DELTA PLUS ONE 
26CD : 18 07                    jr      LINLP3           
26CF    
26CF : E1               LINLPR: pop     hl
26D0 : 78                       ld      a,b
26D1 : B1                       or      c
26D2 : C8                       ret     z
26D3 : CD 0B 39   [GWB] LINLOP: call    MAXUPD          ;[GWB] UPDATE MAJOR AXIS
26D6                    ;[GWB] Inner loop of line code.
26D6 : CD 99 2D   [GWB] LINLP3: call    SETC            ;[GWB] SET CURRENT POINT
26D9 : 0B                       dec     bc              
26DA : E5                       push    hl              
26DB : 2A 13 39                 ld      hl,(MINDEL)     
26DE : 19                       add     hl,de           ;[GWB] ADD SMALL DELTA TO SUM
26DF : EB                       ex      de,hl           
26E0 : 2A 11 39                 ld      hl,(MAXDEL)     ;[GWB] UPDATE SUM FOR NEXT POINT
26E3 : 19                       add     hl,de           
26E4 : 30 E9                    jr      nc,LINLPR       
26E6 : EB                       ex      de,hl           
26E7 : E1                       pop     hl              
26E8 : 78                       ld      a,b             
26E9 : B1                       or      c               
26EA : C8                       ret     z               
26EB : CD 0                     call    MINUPD          ;[GWB] ADVANCE MINOR AXIS           
26EE : 18 E3                    jr      LINLOP          ;[GWB] CONTINUE UNTIL COUNT EXHAUSTED
26F0 :    
26F0 : 7A         [GWB] HLFDE:  ld a,d                  ;;Shift DE 3 Bits Right
26F1 : B7                       or a
26F2 : 1F                       rra
26F3 : 57                       ld d,a
26F4 : 7B                       ld a,e
26F5 : 1F                       rra
26F6 : 5F                       ld e,a
26F7 : C9                       ret
26F8 :
26F8 :                  ;Restore Text Pointer and Return
26F8 : E1         [GWB] POPTRT: pop hl
26F9 : C9                       ret
26FA :  
26FA : EB         [GWB] NEGDE:  ex      de,hl           ;;DE = 0 - DE
26FB : CD BB 25                 call    NEGHL
26FE : EB                       ex      de,hl
26FF : C9                       ret
2700
2700 : CD 47 25   [GWB] CIRCLE: call    SCAN1           ;[GWB] GET (X,Y) OF CENTER INTO GRPACX,Y
2703 : CF                       rst     SYNCHK
2704 : 2C                       byte    ','             ;[GWB] EAT COMMA
2705 : CD 73 23                 call    GETIN2          ;[GWB] GET THE RADIUS
2708 : 7A                       ld      a,d
2709 : B7                       or      a
270A : FA 97 06                 jp      m,FCERR
270D : E5                       push    hl              ;[GWB] SAVE TXTPTR
270E : EB                       ex      de,hl
270F : 22 03 39                 ld      (GXPOS),hl      ;[GWB] SAVE HERE TILL START OF MAIN LOOP
2712 : CD 20 23                 call    MAKINT          ;[GWB] PUT INTEGER INTO FAC
2715 : CD 75 09                 call    CHKNUM          ;[M65] MUST BE NUMBER
2718 : 01 35 80                 ld      bc,$8035        ;[GWB] LOAD REGS WITH SQR(2)/2
271B : 11 F3 04                 ld      de,$04F3        
271E : CD CB 13                 call    FMULT           ;[GWB] DO FLOATING PT MULTIPLY
2721 : CD 04 23                 call    FRCINX          ;[GWB] CONVERT TO INTEGER & GET INTO [HL]
2724 : 22 1A 39                 ld      (CNPNTS),hl     ;[GWB] CNPNTS=RADIUS*SQR(2)/2=# PTS TO PLOT
2727 : AF                       xor     a               ;[GWB] ZERO OUT GLINEF - NO LINES TO CENTER
2728 : 32 19 39                 ld      (GLINEF),a
272B : 32 25 39                 ld      (CSCLXY),a
272E : E1                       pop     hl              ;[GWB] REGET TXTPTR
272F : CD 90 25                 call    ATRSCN          ;[GWB] SCAN POSSIBLE ATTRIBUTE
2732 : 0E 01                    ld      c,1             ;[GWB] SET LO BIT IN GLINEF FOR LINE TO CNTR
2734 : 11 00 00                 ld      de,0            ;[GWB] DEFAULT START COUNT = 0
2737 : CD 27 29                 call    CGTCNT           
273A : D5                       push    de              ;[GWB] SAVE COUNT FOR LATER COMPARISON
273B : 0E 80                    ld      c,128           ;[GWB] SET HI BIT IN GLINEF FOR LINE TO CNTR
273D : 11 FF FF                 ld      de,0-1          ;[GWB] DEFAULT END COUNT = INFINITY
2740 : CD 27 29                 call    CGTCNT           
2743 : E3                       ex      (sp),hl         ;[GWB] GET START COUNT, PUSH TXTPTR TILL DONE
2744 : AF                       xor     a               
2745 : EB                       ex      de,hl           ;[GWB] REVERSE REGS TO TEST FOR .LT.
2746 : E7                       rst     COMPAR          ;[GWB] SEE IF END .GE. START
2747 : 3E 00                    ld      a,0          
2749 : D2 5B 27                 jp      nc,CSTPLT       ;[GWB] YES, PLOT POINTS BETWEEN STRT & END
274C : 3D                       dec     a               ;[GWB] PLOT POINTS ABOVE & BELOW
274D : EB                       ex      de,hl           ;[GWB] SWAP START AND END SO START .LT. END
274E : F5                       push    af              ;[GWB] Swap sense of center line flags
274F : 3A 19 39                 ld      a,(GLINEF)      
2752 : 4F                       ld      c,a             
2753 : 07                       rlca                    
2754 : 07                       rlca                    
2755 : B1                       or      c               
2756 : 0F                       rrca                    
2757 : 32 19 39                 ld      (GLINEF),a      ;[GWB] Store swapped flags
275A : F1                       pop     af              
275B    
275B : 32 1C 39   [GWB] CSTPLT: ld      (CPLOTF),a      ;[GWB] SET UP PLOT POLARITY FLAG
275E : EB                       ex      de,hl           
275F : 22 23 39                 ld      (CSTCNT),hl     ;STORE START COUNT
2762 : EB                       ex      de,hl           
2763 : 22 17 39                 ld      (CENCNT),hl     ;[GWB] AND END COUNT
2766 : E1                       pop     hl              ;[GWB] GET TXTPTR
2767 : 2B                       dec     hl              ;[GWB] NOW SEE IF LAST CHAR WAS A COMMA
2768 : D7                       rst     CHRGET          
2769 : C2 7E 27                 jp      nz,CIRC1        ;[GWB] SOMETHING THERE
276C : E5                       push    hl              ;[GWB] SAVE TXTPTR
276D : CD 6F 2D                 call    GTASPC          ;[GWB] GET DEFAULT ASPECT RATIO INTO [HL]
2770 : 7C                       ld      a,h             
2771 : B7                       or      a               ;[GWB] IS ASPECT RATIO GREATER THAN ONE?
2772 : CA 9E 27                 jp      z,CIRC2         ;[GWB] BRIF GOOD ASPECT RATIO
2775 : 3E 01                    ld      a,1          
2777 : 32 25 39                 ld      (CSCLXY),a      
277A : EB                       ex      de,hl           ;[GWB] ASPECT RATIO IS GREATER THAN ONE, USE INVERSE
277B : C3 9E 27                 jp      CIRC2           ;[GWB] NOW GO CONVERT TO FRACTION OF 256
277E                                                    
277E : CF         [GWB] CIRC1:  rst     SYNCHK          ;[GWB] EAT COMMA
277F : 2C                       byte    ','             
2780 : CD 85 09                 call    FRMEVL          ;[GWB] EVALUATE A FORMULA
2783 : E5                       push    hl              ;[GWB] SAVE TXTPTR
2784 : CD 75 09                 call    CHKNUM          ;[M65] MUST BE NUMBER
2787 : CD 79 29                 call    CMPONE          ;[GWB] SEE IF GREATER THAN ONE
278A : C2 94 27                 jp      nz,CIRC11       ;[GWB] LESS THAN ONE - SCALING Y
278D : 3C                       inc     a               ;[GWB] MAKE [A] NZ
278E : 32 25 39                 ld      (CSCLXY),a      ;[GWB] FLAG SCALING X
2791 : CD 2F 14                 call    FDIV            ;[GWB] RATIO = 1/RATIO, MAKE NUMBER FRACTION OF 256
2794                     
2794 : 21 E7 38   [GWB] CIRC11: ld      hl,FAC          ;[GWB] BY MULTIPLYING BY 2^8 (256)
2797 : 7E                       ld      a,(hl)               
2798 : C6 08                    add     a,8             ;[GWB] ADD 8 TO EXPONENT
279A : 77                       ld      (hl),a               
279B : CD 04 23                 call    FRCINX          ;[GWB] MAKE IT AN INTEGER IN [HL]
279E : 22 15 39   [GWB] CIRC2:  ld    (ASPECT),hl       ;[GWB] STORE ASPECT RATIO
271A1                   
271A1                +  ;[GWB]       CIRCLE ALGORITHM
271A1                |  ;[GWB]
271A1                |  ;[GWB]       [HL]=X=RADIUS * 2 (ONE BIT FRACTION FOR ROUNDING)
271A1                |  ;[GWB]       [DE]=Y=0
271A1                |  ;[GWB]       SUM =0
271A1                |  ;[GWB] LOOP: IF Y IS EVEN THEN
271A1                |  ;[GWB]             REFLECT((X+1)/2,(Y+1)/2) (I.E., PLOT POINTS)
271A1                |  ;[GWB]             IF X.LT.Y THEN EXIT
271A1                |  ;[GWB]       SUM=SUM+2*Y+1
271A1                |  ;[GWB]       Y=Y+1
271A1                |  ;[GWB]       IF SUM.GGWGRP.RNO
271A1                |  ;[GWB]             SUM=SUM-2*X+1
271A1                |  ;[GWB]             X=X-1
271A1                |  ;[GWB]       ENDIF
271A1                |  ;[GWB]       GOTO LOOP
271A1                |  ;[GWB]
27A1 : 11 00 00                 ld      de,0            ;[GWB] INIT Y = 0
27A4 : EB                       ex      de,hl                
27A5 : 22 21 39                 ld      (CRCSUM),hl     ;[GWB] SUM = 0
27A8 : EB                       ex      de,hl                
27A9 : 2A 03 39                 ld      hl,(GXPOS)      ;[GWB] X = RADIUS*2
27AC : 29                       add     hl,hl               
27AD    
27AD : CD 25 1A   [GWB] CIRCLP: call    ISCNTC          ;[M80] CHECK FOR CONTROL-C
27B0 : 7B                       ld      a,e             ;[GWB] TEST EVENNESS OF Y
27B1 : 1F                       rra                     ;[GWB] TO SEE IF WE NEED TO PLOT
27B2 : DA CB 27                 jp      c,CRCLP2        ;[GWB] Y IS ODD - DON'T TEST OR PLOT
27B5 : D5                       push    de              ;[GWB] SAVE Y AND X
27B6 : E5                       push    hl              
27B7 : 23                       inc     hl              ;[GWB] ACTUAL COORDS ARE (X+1)/2,(Y+1)/2
27B8 : EB                       ex      de,hl           
27B9 : CD F0 26                 call    HLFDE           ;[GWB] (PLUS ONE BEFORE DIVIDE TO ROUND UP)
27BC : EB                       ex      de,hl           
27BD : 13                       inc     de              
27BE : CD F0 26                 call    HLFDE           
27C1 : CD FC 27                 call    CPLOT8          
27C4 : D1                       pop     de              ;[GWB] RESTORE X AND Y
27C5 : E1                       pop     hl              ;[GWB] INTO [DE] AND [HL] (BACKWARDS FOR CMP)
27C6 : E7                       rst     COMPAR          ;[GWB] QUIT IF Y .GE. X
27C7 : D2 F8 26                 jp      nc,POPTRT       ;[GWB] GO POP TXTPTR AND QUIT
27CA : EB                       ex      de,hl           ;[GWB] GET OFFSETS INTO PROPER REGISTERS
27CB : 44         [GWB] CRCLP2: ld      b,h             ;[GWB] [BC]=X
27CC : 4D                       ld      c,l             
27CD : 2A 21 39                 ld      hl,(CRCSUM)     
27D0 : 23                       inc     hl              ;[GWB] SUM = SUM+2*Y+1
27D1 : 19                       add     hl,de           
27D2 : 19                       add     hl,de           
27D3 : 7C                       ld      a,h             ;[GWB] NOW CHECK SIGN OF RESULT
27D4 : 87                       add     a,a             
27D5 : DA E7 27                 jp      c,CNODEX        ;[GWB] DON'T ADJUST X IF WAS NEGATIVE
27D8 : D5                       push    de              ;[GWB] SAVE Y
27D9 : EB                       ex      de,hl           ;[GWB] [DE]=SUM
27DA : 60                       ld      h,b             ;[GWB] [HL]=X
27DB : 69                       ld      l,c             ;[GWB] [HL]=2*X-1
27DC : 29                       add     hl,hl           
27DD : 2B                       dec     hl              
27DE : EB                       ex      de,hl           ;[GWB] PREPARE TO SUBTRACT
27DF : 7D                       ld      a,l             ;[GWB] CALC SUM-2*X+1
27E0 : 93                       sub     e               
27E1 : 6F                       ld      l,a             
27E2 : 7C                       ld      a,h             
27E3 : 9A                       sbc     a,d             
27E4 : 67                       ld      h,a             
27E5 : 0B                       dec     bc              ;[GWB] X=X-1
27E6 : D1                       pop     de              ;[GWB] GET Y BACK
27E7 : 22 21 39   [GWB] CNODEX: ld (CRCSUM),hl          ;[GWB] UPDATE CIRCLE SUM
27EA : 60                       ld h,b                  ;[GWB] GET X BACK TO [HL]
27EB : 69                       ld l,c                  
27EC : 13                       inc de                  ;[GWB] Y=Y+1
27ED : C3 AD 27  "              jp CIRCLP               
27F0    
27F0 : D5         [GWB] CPLSCX: push    de              
27F1 : CD F7 28                 call    SCALEY           
27F4 : E1                       pop     hl              ;[GWB] GET UNSCALED INTO [HL]
27F5 : 3A 25 39                 ld      a,(CSCLXY)      ;[GWB] SEE WHETHER ASPECT WAS .GT. 1
27F8 : B7                       or      a               
27F9 : C8                       ret     z               ;[GWB] DON'T SWAP IF ZERO
27FA : EB                       ex      de,hl           
27FB : C9                       ret                     
27FC    
27FC                  + ;[GWB]
27FC                  | ;[GWB] REFLECT THE POINTS AROUND CENTER
27FC                  | ;[GWB] [HL]=X OFFSET FROM CENTER, [DE]=Y OFFSET FROM CENTER
27FC                  | ;[GWB]
27FC : EB         [GWB] CPLOT8: ex      de,hl           
27FD : 22 1D 39                 ld      (CPCNT),hl      ;[GWB] POINT COUNT IS ALWAYS = Y
2800 : EB                       ex      de,hl           
2801 : E5                       push    hl              ;[GWB] SAVE X
2802 : 21 00 00                 ld      hl,0            ;[GWB] START CPCNT8 OUT AT 0
2805 : 22 1F 39                 ld      (CPCNT8),hl      
2808 : CD F0 27                 call    CPLSCX          ;[GWB] SCALE Y AS APPROPRIATE
280B : 22 29 39                 ld      (CXOFF),hl      ;[GWB] SAVE CXOFF
280E : E1                       pop     hl              ;[GWB] GET BACK X
280F : EB                       ex      de,hl           
2810 : E5                       push    hl              ;[GWB] SAVE INITIAL [DE]
2811 : CD F0 27                 call    CPLSCX          ;[GWB] SCALE X AS APPROPRIATE
2814 : EB                       ex      de,hl           
2815 : 22 2B 39                 ld      (CYOFF),hl      
2818 : EB                       ex      de,hl           
2819 : D1                       pop     de              ;[GWB] GET BACK INITIAL [DE]
281A : CD FA 26                 call    NEGDE           ;[GWB] START: [DE]=-Y,[HL]=X,CXOFF=Y,CY=X
281D : CD 44 28                 call    CPLOT4          ;[GWB] PLOT +X,-SY -Y,-SX -X,+SY +Y,-SX
2820 : E5                       push    hl              
2821 : D5                       push    de              
2822 : 2A 1A 39                 ld      hl,(CNPNTS)     ;[GWB] GET # PNTS PER OCTANT
2825 : 22 1F 39                 ld      (CPCNT8),hl     ;[GWB] AND SET FOR DOING ODD OCTANTS
2828 : EB                       ex      de,hl           
2829 : 2A 1D 39                 ld      hl,(CPCNT)      ;[GWB] GET POINT COUNT
282C : EB                       ex      de,hl           
282D : 7D                       ld      a,l             ;[GWB] ODD OCTANTS ARE BACKWARDS SO
282E : 93                       sub     e               ;[GWB] PNTCNT = PNTS/OCT - PNTCN
282F : 6F                       ld      l,a             
2830 : 7C                       ld      a,h             
2831 : 9A                       sbc     a,d             
2832 : 67                       ld      h,a             
2833 : 22 1D 39                 ld      (CPCNT),hl      ;[GWB] PNTCNT = PNTS/OCT - PNTCNT
2836 : 2A 29 39                 ld      hl,(CXOFF)      ;[GWB] NEED TO NEGATE CXOFF TO START OUT RIGHT
2839 : CD BB 25                 call    NEGHL           
283C : 22 29 39                 ld      (CXOFF),hl      
283F : D1                       pop     de              
2840 : E1                       pop     hl              
2841 : CD FA 26                 call    NEGDE           ;[GWB] ALSO NEED TO MAKE [DE]=-SX=-[DE], 
2844 :                                                  ;[GBB] PLOT +Y,-SX -X,-SY -Y,+SX +X,+SY
2844 :                                                  ;[GWB] (FALL THRU TO CPLOT4)
2844 : 3E 04      [GWB] CPLOT4: ld      a,4             ;[GWB] LOOP FOUR TIMES
2846    
2846 : F5         [GWB] CPLOT:  push    af              ;[GWB] SAVE LOOP COUNT
2847 : E5                       push    hl              ;[GWB] SAVE BOTH X & Y OFFSETS
2848 : D5                       push    de              
2849 : E5                       push    hl              ;[GWB] SAVE TWICE
284A : D5                       push    de              
284B : EB                       ex      de,hl           
284C : 2A 1F 39                 ld      hl,(CPCNT8)     ;[GWB] GET NP*OCTANT*8
284F : EB                       ex      de,hl           
2850 : 2A 1A 39                 ld      hl,(CNPNTS)     ;[GWB] ADD SQR(2)*RADIUS FOR NEXT OCTANT
2853 : 29                       add     hl,hl           
2854 : 19                       add     hl,de           
2855 : 22 1F 39                 ld      (CPCNT8),hl     ;[GWB] UPDATE FOR NEXT TIME
2858 : 2A 1D 39                 ld      hl,(CPCNT)      ;[GWB] CALC THIS POINT'S POINT COUNT
285B : 19                       add     hl,de           ;[GWB] ADD IN PNTCNT*OCTANT*NP
285C : EB                       ex      de,hl           ;[GWB] SAVE THIS POINT'S COUNT IN [DE]
285D : 2A 23 39                 ld      hl,(CSTCNT)     ;[GWB] GET START COUNT
2860 : E7                       rst     COMPAR          
2861 : CA 85 28                 jp      z,CLINSC        ;[GWB] SEE IF LINE TO CENTER REQUIRED
2864 : D2 71 28                 jp      nc,CNBTWN       ;[GWB] IF SC .GT. PC, THEN NOT BETWEEN
2867 : 2A 17 39                 ld      hl,(CENCNT)     ;[GWB] GET END COUNT
286A : E7                       rst     COMPAR          
286B : CA 7B 28                 jp      z,GLINEC        ;[GWB] GO SEE IF LINE FROM CENTER NEEDED
286E : D2 97 28                 jp      nc,CBTWEN       ;[GWB] IF EC .GT. PC, THEN BETWEEN
2871    
2871 : 3A 1C 39   [GWB] CNBTWN: ld      a,(CPLOTF)      ;[GWB] SEE WHETHER TO PLOT OR NOT
2874 : B7                       or      a               ;[GWB] IF NZ, PLOT POINTS NOT IN BETWEEN
2875 : C2 A3 28                 jp      nz,CPLTIT       ;[GWB] NEED TO PLOT NOT-BETWEEN POINTS
2878 : C3 9E 28                 jp      GCPLFN          ;[GWB] DON'T PLOT - FIX UP STACK & RETURN
287B    
287B : 3A 19 39   [GWB] GLINEC: ld      a,(GLINEF)      ;[GWB] GET CENTER LINE FLAG BYTE
287E : 87                       add     a,a             ;[GWB] BIT 7=1 MEANS DRAW LINE FROM CENTER
287F : D2 A3 28                 jp      nc,CPLTIT       ;[GWB] NO LINE REQUIRED - JUST PLOT POINT
2882 : C3 8C 28                 jp      CLINE           ;[GWB] LINE REQUIRED.
2885    
2885 : 3A 19 39   [GWB] CLINSC: ld      a,(GLINEF)      ;[GWB] GET CENTER LINE FLAG BYTE
2888 : 1F                       rra                     ;[GWB] BIT 0=1 MEANS LINE FROM CENTER NEEDED.
2889 : D2 A3 28                 jp      nc,CPLTIT       ;[GWB] NO LINE REQUIRED - JUST PLOT POINT
288C    
288C : D1         [GWB] CLINE:  pop     de              ;[GWB] GET X & Y OFFSETS
288D : E1                       pop     hl              
288E : CD E7 28                 call    GTABSC          ;[GWB] GO CALC TRUE COORDINATE OF POINT
2891 : CD D8 28                 call    GLINE2          ;[GWB] DRAW LINE FROM [BC],[DE] TO CENTER
2894 : C3 B4 28                 jp      CPLFIN          
2897                                                     
2897 : 3A 1C 39   [GWB] CBTWEN: ld      a,(CPLOTF)      ;[GWB] SEE WHETHER PLOTTING BETWEENS OR NOT
289A : B7                       or      a               
289B : CA A3 28                 jp      z,CPLTIT        ;[GWB] IF Z, THEN DOING BETWEENS
289E : D1         [GWB] GCPLFN: pop     de              ;[GWB] CLEAN UP STACK
289F : E1                       pop     hl              
28A0 : C3 B4 28                 jp      CPLFIN          
28A3    
28A3 : D1         [GWB] CPLTIT: pop     de              ;[GWB] GET X & Y OFFSETS
28A4 : E1                       pop     hl              
28A5 : CD E7 28                 call    GTABSC          ;[GWB] CALC TRUE COORDINATE OF POINT
28A8 : CD 2B 2E                 call    SCLXYX          ;[GWB] SEE IF POINT OFF SCREEN
28AB : D2 B4 28                 jp      nc,CPLFIN       ;[GWB] NC IF POINT OFF SCREEN - NO PLOT
28AE : CD FD 2D                 call    MAPXYP          
28B1 : CD 99 2D                 call    SETC            ;[GWB] PLOT THE POINT
28B4    
28B4 : D1         [GWB] CPLFIN: pop     de              ;[GWB] GET BACK OFFSETS
28B5 : E1                       pop     hl              
28B6 : F1                       pop     af              ;[GWB] GET BACK LOOP COUNT
28B7 : 3D                       dec     a               
28B8 : C8                       ret     z               ;[GWB] QUIT IF DONE.
28B9 : F5                       push    af              ;[GWB]  PUSH PSW
28BA : D5                       push    de              ;[GWB] SAVE X OFFSET
28BB : EB                       ex      de,hl           
28BC : 2A 29 39                 ld      hl,(CXOFF)      ;[GWB] SWAP [HL] AND CXOFF
28BF : EB                       ex      de,hl           
28C0 : CD FA 26                 call    NEGDE           ;[GWB] NEGATE NEW [HL]
28C3 : 22 29 39                 ld      (CXOFF),hl      
28C6 : EB                       ex      de,hl           
28C7 : D1                       pop     de              
28C8 : E5                       push    hl              
28C9 : 2A 2B 39                 ld      hl,(CYOFF)      ;[GWB] SWAP [DE] AND CYOFF
28CC : EB                       ex      de,hl           ;[GWB] NEGATE NEW [DE]
28CD : 22 2B 39                 ld      (CYOFF),hl      
28D0 : CD FA 26                 call    NEGDE           
28D3 : E1                       pop     hl              
28D4 : F1                       pop     af              ;[GWB]  POP PSW
28D5 : C3 46 28                 jp      CPLOT           ;[GWB] PLOT NEXT POINT
28D8    
28D8 : 2A 09 39   [GWB] GLINE2: ld      hl,(GRPACX)     ;[GWB] DRAW LINE FROM [BC],[DE]
28DB : 22 03 39                 ld      (GXPOS),hl      ;[GWB] TO GRPACX,Y
28DE : 2A 07 39                 ld      hl,(GRPACY)     
28E1 : 22 05 39                 ld      (GYPOS),hl      
28E4 : C3 7B 26                 jp      DOGRPH          ;[GWB] GO DRAW THE LINE
28E7                   
28E7                  + ;[GWB] GTABSC - GET ABSOLUTE COORDS
28E7                  | ;[GWB] ([BC],[DE])=(GRPACX+[HL],GRPACY+[DE])
28E7                  | ;[GWB]
28E7 : D5         [GWB] GTABSC: push    de              ;[GWB] SAVE Y OFFSET FROM CENTER
28E8 : EB                       ex      de,hl           
28E9 : 2A 09 39                 ld      hl,(GRPACX)     ;[GWB] GET CENTER POS
28EC : EB                       ex      de,hl           
28ED : 19                       add     hl,de           ;[GWB] ADD TO DX
28EE : 44                       ld      b,h             ;[GWB] [BC]=X CENTER + [HL]
28EF : 4D                       ld      c,l             
28F0 : D1                       pop     de              
28F1 : 2A 07 39                 ld      hl,(GRPACY)     ;[GWB] GET CENTER Y
28F4 : 19                       add     hl,de           
28F5 : EB                       ex      de,hl           ;[GWB] [DE]=Y CENTER + [DE]
28F6 : C9                       ret                     
28F7    
28F7 : 2A 15 39   [GWB] SCALEY: ld      hl,(ASPECT)     ;[GWB] CHECK FOR *0 AND *1 CASES
28FA : 7D                       ld      a,l             
28FB : B7         [GWB] SCALE2: or      a               ;[GWB] ENTRY TO DO [A]*[DE] ([A] NON-Z)
28FC : C2 03 29                 jp      nz,SCAL2        ;[GWB] NON-ZERO
28FF : B4                       or      h               ;[GWB] TEST HI BYTE
2900 : C0                       ret     nz              ;[GWB] IF NZ, THEN WAS *1 CASE
2901 : EB                       ex      de,hl           ;[GWB] WAS *0 CASE - PUT 0 IN [DE]
2902 : C9                       ret                     
2903    
2903 : 4A         [GWB] SCAL2:  ld      c,d             
2904 : 16 00                    ld      d,0             
2906 : F5                       push    af              
2907 : CD 17 29                 call    L2917           
290A : 1E 80                    ld      e,128            
290C : 19                       add     hl,de           ;??? [GWB] ADDI AX,128  - ROUND UP
290D : 59                       ld      e,c             
290E : 4C                       ld      c,h             
290F : F1                       pop     af              
2910 : CD 17 29                 call    L2917           
2913 : 59                       ld      e,c             
2914 : 19                       add     hl,de           
2915 : EB                       ex      de,hl           
2916 : C9                       ret                     
2917    
2917 : 06 08            L2917:  ld      b,8
2919 : 21 00 00                 ld      hl,0
291C : 29               L291C:  add     hl,hl
291D : 87                       add     a,a
291E : D2 22 29                 jp      nc,L2922
2921 : 19                       add     hl,de
2922 : 05               L2922:  dec     b
2923 : C2 1C 29                 jp      nz,L291C
2926 : C9                       ret     
2927    
2928                  + ;[GWB] PARSE THE BEGIN AND END ANGLES
2928                  | ;[GWB]  SETTING APPROPRIATE BITS IN GLINEF IF NEG.
2928                  | ;[GWB]
2927 : 2B         [GWB] CGTCNT: dec     hl              
2928 : D7                       rst     CHRGET          ;[GWB] GET CURRENT CHAR
2929 : C8                       ret     z               ;[GWB] IF NOTHING, RETURN DFLT IN [DE]
292A : CF                       rst     SYNCHK          
292B : 2C                       byte    ','             ;[GWB] EAT THE COMMA
292C : FE 2C                    cp      ','             ;[GWB] USE DEFAULT IF NO ARGUMENT.
292E : C8                       ret     z               
292F : C5                       push    bc              ;[GWB] SAVE FLAG BYTE IN [C]
2930 : CD 85 09                 call    FRMEVL          ;[GWB] EVALUATE THE THING
2933 : E3                       ex      (sp),hl         ;[GWB] XTHL
2934 : E5                       push    hl              ;[GWB] POP FLAG BYTE, PUSH TXTPTR
2935 : CD 75 09                 call    CHKNUM          ;[M65] MUST BE NUMBER
2938 : C1                       pop     bc              ;[GWB] GET BACK FLAG BYTE
2939 : 21 E7 38                 ld      hl,FAC          ;[GWB] NOW SEE WHETHER POSITIVE OR NOT
293C : 7E                       ld      a,(hl)          ;[GWB] GET EXPONENT BYTE
293D : B7                       or      a               
293E : CA 50 29                 jp      z,CGTC2         ;[GWB] SET TO HIGH MANTISSA BYTE
2941 : 2B                       dec     hl              
2942 : 7E                       ld      a,(hl)          
2943 : B7                       or      a               
2944 : F2 50 29                 jp      p,CGTC2         
2947 : E6 7F                    and     127             ;[GWB] MAKE IT POSITIVE
2949 : 77                       ld      (hl),a          
294A : 21 19 39                 ld      hl,GLINEF       ;[GWB] SET BIT IN [C] IN GLINEF
294E : B1                       or      c               
294D : 7E                       ld      a,(hl)          
294F : 77                       ld      (hl),a          
2950    CGTC2:
2950 : 01 22 7E   [GWB] CGTC2:  ld      bc,7E22$        ;[GWB] LOAD REGS WITH 1/2*PI
2953 : 11 83 F9                 ld      de,F983$        
2956 : CD CB 13                 call    FMULT           ;[GWB] MULTIPLY BY 1/(2*PI) TO GET FRACTION
2959 : CD 79 29                 call    CMPONE          ;[GWB] SEE IF RESULT IS GREATER THAN ONE
295C : CA 97 06                 jp      z,FCERR         ;[GWB] FC ERROR IF SO
295F : CD 13 15                 call    PUSHF           ;[GWB] SAVE FAC ON STAC
2962 : 2A 1A 39                 ld      hl,(CNPNTS)     ;[GWB] GET NO. OF POINTS PER OCTANT
2965 : 29                       add     hl,hl           ;[GWB] TIMES 8 FOR TRUE CIRCUMFERENCE
2966 : 29                       add     hl,hl           
2967 : 29                       add     hl,hl           
2968 : CD 20 23                 call    MAKINT          ;[GWB] STICK IT IN FAC
296B : CD 75 09                 call    CHKNUM          ;[M65] MUST BE NUMBER
296E : C1                       pop     bc              ;[GWB] GET BACK ANG/2*PI IN REGS
296F : D1                       pop     de              
2970 : CD CB 13                 call    FMULT           ;[GWB] DO THE MULTIPLY
2973 : CD 04 23                 call    FRCINX          ;[GWB] CONVERT TO INTEGER IN [HL]
2976 : D1                       pop     de              ;[GWB] GET BACK TXTPTR
2977 : EB                       ex      de,hl           
2978 : C9                       ret                     
2979    
2979 : 01 00 81         CMPONE: ld bc,$8100             ;;Compare FAC with 1.0
297C : 11 00 00                 ld de,$0000
297F : CD 5B 15                 call FCOMP
2982 : 3D                       dec a
2983 : C9                       ret
2984    
2984                  + ;[GWB] GET & PUT - READ & WRITE GRAPHICS BIT ARRAY
2984                  | ;[GWB] 
2984                  | ;[GWB]  SYNTAX:
2984                  | ;[GWB]        GET @(X,Y),ARRAYVAR
2984                  | ;[GWB]        PUT @(X,Y),ARRAYVAR[,FUNCTION]
2984                  | ;[GWB] 
2984                  | ;[GWB]        FUNCTION = OR/AND/PRESET/PSET/XOR
2984                  | ;[GWB] 
2984 : 32 3B 39   [GWB] GPUTG:  ld      (PUTFLG),a      ;[GWB] IFE PC8A&RSTLES-1STORE WHETHER PUTTING OR NOT
2987 : F5                       push    af              ;[GWB] SAVE THIS FLAG A SEC
2988 : CF                       rst     SYNCHK          
2989 : 28                       byte    '('             ;[GWB] SKIP OVER OPEN PAREN
298A : 2B                       dec     hl              
298B : CD 47 25                 call    SCAN1           ;[GWB] GET FIRST COORD
298E : CD 12 2C                 call    CHKRNG          
2991 : F1                       pop     af              ;[GWB] REGET PUT FLAG
2992 : B7                       or      a               
2993 : 20 6C                    jr      nz,PUT1        
2995 : CF                       rst     SYNCHK          
2996 : A9                       byte    MINUTK          ;[GWB] EAT "-"
2997 : C5                       push    bc              ;[GWB] SAVE X1
2998 : D5                       push    de              ;[GWB] SAVE Y1
2999 : CD 56 25                 call    SCAND           ;[GWB] GET SECOND COORD FOR 'GET' ONLY
299C : CD 12 2C                 call    CHKRNG          
299F : D1                       pop     de              ;[GWB] GET Y1 BACK
29A0 : C1                       pop     bc              ;[GWB] AND X1
29A1 : E5                       push    hl              ;[GWB] SAVE TXTPTR
29A2 : CD C3 25                 call    YDELT           ;[GWB] CALC DELTA Y
29A5 : DC CE 25                 call    c,XCHGY         ;[GWB] MAKE DE=MIN(GXPOS,DE)
29A8 : 23                       inc     hl              ;[GWB] MAKE DELTA A COUNT
29A9 : 22 13 39                 ld      (MINDEL),hl     ;[GWB] SAVE DELTA Y IN MIDEL
29AC : CD B1 25                 call    XDELT           
29AF : DC DB 25                 call    c,XCHGX         ;[GWB] BC = MIN(GXPOS,DE)
29B2 : 23                       inc     hl              ;[GWB] MAKE DELTA A COUNT
29B3 : 22 11 39                 ld      (MAXDEL),hl     ;[GWB] SAVE DX IN MAXDEL
29B6 : CD ED 2D                 call    MAPXYC           
29B9 : E1                       pop     hl              
29BA : CD 77 2A                 call    GTARRY           
29BD : E5                       push    hl              
29BE : D5                       push    de              ;;Save Pointer to Array Data
29BF : C5                       push    bc              ;;Save End of Array Data
29C0 : D5                       push    de              ;;Save Number of Bytes to be Used
29C1 : EB                       ex      de,hl           
29C2 : 2A 11 39                 ld      hl,(MAXDEL)     
29C5 : 4D                       ld      c,l             
29C6 : 44                       ld      b,h             
29C7 : EB                       ex      de,hl           
29C8 : CB 23                    sla     e               
29CA : CB 12                    rl      d               
29CC : 2A 13 39                 ld      hl,(MINDEL)     ;[GWB] GET DELTA Y
29CF : C5                       push    bc              ;[GWB] SAVE DX*BITS/PIX
29D0 : 44                       ld      b,h             ;[GWB] INTO [BC] FOR UMULT
29D1 : 4D                       ld      c,l             
29D2 : CD CA 15                 call    UMULT           ;[GWB] [DE]=DX*DY*BITS/PIX
29D5 : C1                       pop     bc              ;[GWB] GET BACK DX*BITS/PIX
29D6 : 11 04 00                 ld      de,4            ;[GWB] ADD 4 BYTES FOR DX,DY STORAGE
29D9 : 19                       add     hl,de           ;[HL] HAS NO. OF BYTES TO BE USED
29DA : D1                       pop     de              ;ADD NO. OF BYTES TO BE USED
29DB : 19                       add     hl,de           
29DC : EB                       ex      de,hl           ;[GWB] [DE] = CALCULATED END OF DATA
29DD : E1                       pop     hl              ;[GWB] END OF ARRAY DATA TO [HL]
29DE : E7                       rst     COMPAR          
29DF : DA 97 06                 jp      c,FCERR         ;[GWB] ARRAY START+LENGTH .GT. 64K
29E2 :                                                  ;[GWB] BEG OF DATA PTR IS ON STK HERE
29E2 : E1                       pop     hl              ;[GWB] GET POINTER TO ARRAY DATA
29E3 : E7                       rst     COMPAR          
29E4 : D2 97 06                 jp      nc,FCERR        ;[GWB] ARRAY START+LENGTH .GT. 64K
29E7 : 71                       ld      (hl),c          ;[GWB] SAVE DX*BITS/PIX IN 1ST 2 BYTES OF ARY
29E8 : 23                       inc     hl              
29E9 : 70                       ld      (hl),b          ;[GWB] PASS NO. OF BITS DESIRED IN [BC]
29EA : 23                       inc     hl              
29EB : EB                       ex      de,hl           
29EC : 2A 13 39                 ld      hl,(MINDEL)     ;[GWB] GET LINE (Y) COUNT
29EF : EB                       ex      de,hl           
29F0 : 73                       ld      (hl),e          
29F1 : 23                       inc     hl              
29F2 : 72                       ld      (hl),d          
29F3 : 23                       inc     hl              ;[GWB] SAVE DY IN 2ND 2 BYTES
29F4 : B7                       or      a               ;[GWB] CLEAR CARRY FOR GET INIT.
29F5 : 18 57                    jr      GOPGIN          ;[GWB] GIVE LOW LEVEL ADDR OF ARRAY & GO
    ;
29F7 : F5                       push    af              ;;Orphan Code?
29F8 : 21 00 00                 ld      hl,0            
29FB : 19         [GWB] L29FB:  add     hl,de           
29FC : 3D                       dec     a               
29FD : 20 FC                    jr      nz,L29FB        
29FF : F1                       pop     af              
2A00 : C9                       ret                     
2A01    
2A01 : E5         [GWB] PUT1:   push    hl              ;[GWB] SAVE TXTPTR
2A02 : CD ED 2D                 call    MAPXYC          ;[GWB] MAP THE POINT
2A05 : E1                       pop     hl              
2A06 : CD 77 2A                 call    GTARRY          ;[GWB] SCAN ARRAY NAME & GET PTR TO IT
2A09 : D5                       push    de              ;[GWB] SAVE PTR TO DELTAS IN ARRAY
2A0A : 2B                       dec     hl              ;[GWB] NOW SCAN POSSIBLE PUT OPTION
2A0B : D7                       rst     CHRGET          
2A0C : 06 05                    ld      b,5             ;[GWB] DEFAULT OPTION IS XOR
2A0E : 28 12                    jr      z,PUT2          ;[GWB] IF NO CHAR, USE DEFAULT
2A10 : CF                       rst     SYNCHK          
2A11 : 2C                       byte    ','             ;[GWB] MUST BE A COMMA
2A12 : EB                       ex      de,hl           ;[GWB] PUT TXTPTR IN [DE]
2A13 : 21 9C 2A                 ld      hl,GFUNTB+4     ;;From End of Table to Start if Table
2A16 : BE         [GWB] PFUNLP: cp      (hl)            ;[GWB] IS THIS AN OPTION?
2A17 : 28 07                    jr      z,PUT20         ;[GWB] YES, HAND IT TO PGINIT.
2A19 : 2B                       dec     hl              ;[GWB] POINT TO NEXT
2A1A : 05                       dec     b               
2A1B : 20 F9                    jr      nz,PFUNLP       
2A1D : EB                       ex      de,hl           ;[GWB] GET TXTPTR BACK TO [HL]
2A1E : D1                       pop     de              ;[GWB] CLEAN UP STACK
2A1F : C9                       ret                     ;[GWB] LET NEWSTT GIVE SYNTAX ERROR
2A20    
2A20 : EB         [GWB] PUT20:  ex      de,hl           ;[GWB] GET TXTPTR BACK TO [HL]
2A21 : D7                       rst     CHRGET          ;[GWB] EAT THE TOKEN
2A22 : 05         [GWB] PUT2:   dec     b               ;[GWB] 1..5 TO 0..4
2A23 : 78                       ld      a,b             ;[GWB] INTO [A] FOR PGINIT
2A24 : E3                       ex      (sp),hl         ;[GWB] XTHL
2A25 : F5                       push    af              ;[GWB] SAVE PUT ACTION MODE
2A26 : 5E                       ld      e,(hl)          ;[GWB] [DE]=NO. OF BITS IN X
2A27 : 23                       inc     hl              
2A28 : 56                       ld      d,(hl)          
2A29 : 23                       inc     hl              
2A2A : D5                       push    de              ;[GWB] SAVE BIT COUNT
2A2B : E5                       push    hl              ;[GWB] SAVE ARRAY POINTER
2A2C : 1B                       dec     de              ;[GWB] DECREMENT DX SINCE IT'S A COUNTER
2A2D : 2A 03 39                 ld      hl,(GXPOS)      ;[GWB] NOW CALC TRUE X
2A30 : EB                       ex      de,hl           
2A31 : 19                       add     hl,de           
2A32 : 38 0E                    jr      c,PRNGER        ;[GWB] ERROR IF CARRY
2A34 : 44                       ld      b,h             ;[GWB] TO [BC] FOR SCLXYX
2A35 : 4D                       ld      c,l             
2A36 : E1                       pop     hl              ;[GWB] GET BACK ARRAY POINTER
2A37 : 5E                       ld      e,(hl)          ;[GWB] [DE] = DELTA Y ([HL] POINTS TO DATA)
2A38 : 23                       inc     hl              
2A39 : 56                       ld      d,(hl)          
2A3A : 23                       inc     hl              
2A3B : D5                       push    de              ;[GWB] SAVE DELTA Y ON STACK
2A3C : E5                       push    hl              ;[GWB] SAVE PTR ON STACK AGAIN
2A3D : 2A 05 39                 ld      hl,(GYPOS)      
2A40 : 1B                       dec     de              ;[GWB] DECREMENT DY SINCE IT'S A COUNTER
2A41 : 19                       add     hl,de           
2A42 : DA 97 06   [GWB] PRNGER:`jp c,FCERR              ;[GWB] ERROR IF CARRY
2A45 : EB                       ex de,hl                ;[GWB] [DE]=Y + DELTA Y
2A46 : E1                       pop hl                  ;[GWB] GET BACK ARRAY POINTER
2A47 : CD 12 2C                 call CHKRNG             ;[GWB] MAKE SURE [BC],[HL] ARE ON THE SCREEN
2A4A : D1                       pop de                  ;[GWB] POP DY
2A4B : C1                       pop bc                  ;[GWB] POP DX*BITS/PIX
2A4C : F1                       pop af                  ;[GWB] GET BACK ACTION MODE
2A4D : 37                       scf                     ;[GWB] SET CARRY TO FLAG PUT INIT
2A4E    
2A4E : D5         [GWB] GOPGIN: push    de              ;[GWB] RESAVE DY
2A4F : CD 00 2F                 call    PGINIT          ;;Set Operation Routine Address
2A52 : D1                       pop     de              ;[GWB] GET Y COUNT
2A53 : D5         [GWB] PGLOOP: push    de              ;[GWB] SAVE LINE COUNT
2A54 : CD 7D 2D                 call    FETCHC          
2A57 : E5                       push    hl              
2A58 : F5                       push    af              
2A59 : 3A 3B 39                 ld      a,(PUTFLG)      ;[GWB] SEE IF PUTTING OR GETTING
2A5C : B7                       or      a               
2A5D : 20 05                    jr      nz,PGLOO2       
2A5F : CD 22 2F                 call    NREAD           
2A62 : 18 03                    jr      PGLOO3          
2A64 : CD 39 2F   [GWB] PGLOO2: call    NWRITE          
2A67 : F1         [GWB] PGLOO3: pop     af              ;{GWB} GET BACK STARTING C          
2A68 : E1                       pop     hl              ;{GWB} Address AND BIT MASK
2A69 : CD 76 2D                 call    STOREC          ;{GWB} SET UP AS CURRENT "C"          
2A6C : CD B1 2E                 call    DOWNL           ;[GWB] NOW MOVE DOWN A LINE
2A6F : D1                       pop     de              
2A70 : 1B                       dec     de              
2A71 : 7A                       ld      a,d             
2A72 : B3                       or      e               
2A73 : 20 DE                    jr      nz,PGLOOP       ;[GWB] CONTINUE IF NOT ZERO
2A75 : E1                       pop     hl              ;[GWB] GET BACK TXTPTR
2A76 : C9                       ret                     ;[GWB] AND RETURN
2A77    
2A77 : CF               GTARRY: rst     SYNCHK          
2A78 : 2C                       byte    ','             ;[GWB] EAT COMMA
2A79 : 3E 01                    ld      a,1             ;[GWB] SEARCH ARRAYS ONLY
2A7B : 32 CB 38                 ld      (SUBFLG),a       
2A7E : CD D1 10                 call    PTRGET          ;[GWB] GET PTR TO ARRAY
2A81 : C2 97 06                 jp      nz,FCERR        ;[GWB] NOT THERE - ERROR
2A84 : 32 CB 38                 ld      (SUBFLG),a      ;[GWB] CLEAR THIS
2A87 : E5                       push    hl              ;[GWB] SAVE TXTPTR
2A88 : 60                       ld      h,b             ;[GWB] HL = PTR TO ARRAY
2A89 : 69                       ld      l,c             
2A8A : EB                       ex      de,hl           ;[GWB] HL = LENGTH
2A8B : 19                       add     hl,de           ;[GWB] HL = LAST BYTE OF ARRAY
2A8C : E5                       push    hl              ;[GWB] SAVE
2A8D : 0A                       ld      a,(bc)          ;[GWB] GET NO. OF DIMS 
2A8E : 87                       add     a,a             ;[GWB] DOUBLE SINCE 2 BYTE ENTRIES
2A8F : 6F                       ld      l,a             
2A90 : 26 00                    ld      h,0             
2A92 : 03                       inc     bc              ;[GWB] SKIP NO. OF DIMS
2A93 : 09                       add     hl,bc           
2A94 : EB                       ex      de,hl           ;[GWB] DE = PTR TO FIRST BYTE OF DATA
2A95 : C1                       pop     bc              ;[GWB] BC = PTR TO LAST BYTE OF DATA
2A96 : E1                       pop     hl              ;[GWB] GET TXTPTR
2A97 : C9                       ret                     
2A98
2A98 : AE AD            GFUNTB: byte ORTK, ANDTK        ;;PUT Action Tokens Table
2A9A : 9D 9C                    byte PRESTK, PSETTK
2A9C : CF                       byte XORTK
2A9D
2A9D                    ;[GWB] GRAPHICS MACRO LANGUAGE SUPPORT
2A9D : 11 A7 2A   [GWB] DRAW:   ld      de,DRWTAB       ;[GWB] DISPATCH TABLE FOR GML
2AA0 : AF                       xor     a               ;[GWB] CLEAR OUT DRAW FLAGS
2AA1 : 32 34 39                 ld      (DRWFLG),a
2AA4 : C3 24 2C                 jp      MACLNG
2AA7
2AA7 : D5         [GWB] DRWTAB: byte    'U'+128         ;[GWB] UP
2AA8 : D5 2A                    word    DRUP		        
2AAA : C4                       byte    'D'+128         ;[GWB] DOWN
2AAB : D8 2A                    word    DRDOWN    
2AAC : CC                       byte    'L'+128         ;[GWB] LEFT
2AAE : DE 2A                    word    DRLEFT    
2AB0 : D2                       byte    'R'+128         ;[GWB] RIGHT
2AB1 : E1 2A                    word    DRIGHT
2AB3 : 4D                       byte    'M"             ;[GWB] MOVE
2AB4 : 01 2B                    word    DMOVE   
2AB6 : C5                       byte    'E'+128         ;[GWB] -,-
2AB7 : F1 2A                    word    DRWEEE     
2AB9 : C6                       byte    'F'+128         ;[GWB] +,-
2ABA : EC 2A                    word    DRWFFF     
2ABC : C7                       byte    'G'+128         ;[GWB] +,+
2ABD : F9 2A                    word    DRWGGG     
2ABF : C8                       byte    'H'+128         ;[GWB] -,+
2AC0 : E9 2A                    word    DRWHHH     
2AC2 : C1                       byte    'A'+128         ;[GWB] ANGLE COMMAND
2AC3 : BA 2B                    word    DANGLE
2AC5 : 42                       byte    'B"             ;[GWB] MOVE WITHOUT PLOTTING
2AC6 : B2 2B                    word    DNOPLT          
2AC8 : 4E                       byte    'N"             ;[GWB] DON'T CHANGE CURRENT COORDS
2AC9 : AD 2B                    word    DNOMOV          
2ACB : 58                       byte    'X"             ;[GWB] EXECUTE STRING
2ACC : 33 2D                    word    MCLXEQ   
2ACE : C3                       byte    'C'+128         ;[GWB] COLOR
2ACF : 07 2C                    word    DCOLR
2AD1 : D3                       byte    'S'+128         ;[GWB] SCALE
2AD2 : C7 2B                    word    DSCALE
2AD4 : 00                       byte    0               ;[GWB] END OF TABLE
2AD5                                    
2AD5 : CD FA 26   [GWB] DRUP:   call    NEGDE           ;[GWB] MOVE +0,-Y
2AD8 : 01 00 00   [GWB] DRDOWN: ld      bc,0            ;[GWB] MOVE +0,+Y, DX=0
2ADB : C3 2B 2B                 jp      DOMOVR          ;[GWB] TREAT AS RELATIVE MOVE
2ADE                                                    
2ADE : CD FA 26   [GWB] DRLEFT: call    NEGDE           ;[GWB] MOVE -X,+0
2AE1 : 42         [GWB] DRIGHT: ld      b,d             ;[GWB] MOVE +X,+0
2AE2 : 4B                       ld      c,e             ;[GWB] [BC]=VALUE
2AE3 : 11 00 00                 ld      de,0            ;[GWB] DY=0
2AE6 : C3 2B 2B                 jp      DOMOVR          ;[GWB] TREAT AS RELATIVE MOVE
2AE9                                                    
2AE9 : CD FA 26   [GWB] DRWHHH: call    NEGDE           ;[GWB] MOVE -X,-Y
2AEC : 42         [GWB] DRWFFF: ld      b,d             ;[GWB] MOVE +X,+Y
2AED : 4B                       ld      c,e             
2AEE : C3 2B 2B                 jp      DOMOVR          
2AF1                                                    
2AF1 : 42         [GWB] DRWEEE: ld      b,d             ;[GWB] MOVE +X,-Y
2AF2 : 4B                       ld      c,e             
2AF3 : CD FA 26   [GWB] DRWHHC: call    NEGDE           
2AF6 : C3 2B 2B                 jp      DOMOVR          
2AF9                                                    
2AF9 : CD FA 26   [GWB] DRWGGG: call    NEGDE           ;[GWB] MOVE -X,+Y
2AFC : 42                       ld      b,d             
2AFD : 4B                       ld      c,e             
2AFE : C3 F3 2A                 jp      DRWHHC          ;[GWB] MAKE DY POSITIVE & GO
2B01                                                    
2B01 : CD 92 2C   [GWB] DMOVE:  call    FETCHZ          ;[GWB] GET NEXT CHAR AFTER COMMA
2B04 : 06 00                    ld      b,0             ;[GWB] ASSUME RELATIVE
2B06 : FE 2B                    cp      '+'             ;[GWB] IF "+" OR "-" THEN RELATIVE
2B08 : CA 11 2B                 jp      z,MOVREL        
2B0B : FE 2D                    cp      '-'           
2B0D : CA 11 2B                 jp      z,MOVREL        
2B10 : 04                       inc     b               ;[GWB] NON-Z TO FLAG ABSOLUTE
2B11 : 78         [GWB] MOVREL: ld      a,b
2B12 : F5                       push    af              ;[GWB] SAVE ABS/REL FLAG ON STACK
2B13 : CD B5 2C                 call    DECFET          ;[GWB] BACK UP SO VALSCN WILL SEE "-"
2B16 : CD C3 2C                 call    VALSCN          ;[GWB] GET X VALUE
2B19 : D5                       push    de              ;[GWB] SAVE IT
2B1A : CD 92 2C                 call    FETCHZ          ;[GWB] NOW CHECK FOR COMMA
2B1D : FE 2C                    cp      ','             ;[GWB] COMMA?
2B1F : C2 97 06                 jp      nz,FCERR        
2B22 : CD C3 2C                 call    VALSCN          ;[GWB] GET Y VALUE IN D
2B25 : C1                       pop     bc              ;[GWB] GET BACK X VALUE
2B26 : F1                       pop     af              ;[GWB] GET ABS/REL FLAG
2B27 : B7                       or      a               
2B28 : C2 87 2B                 jp      nz,DRWABS       ;[GWB] NZ - ABSOLUTE
2B2B    
2B2B : CD D4 2B   [GWB] DOMOVR: call    DSCLDE          ;[GWB] ADJUST Y OFFSET BY SCALE
2B2E : D5                       push    de              ;[GWB] SAVE Y OFFSET
2B2F : 50                       ld      d,b             ;[GWB] GET X INTO [DE]
2B30 : 59                       ld      e,c             
2B31 : CD D4 2B                 call    DSCLDE          ;[GWB] GO SCALE IT.
2B34 : EB                       ex      de,hl           ;[GWB] GET ADJUSTED X INTO [HL]
2B35 : D1                       pop     de              ;[GWB] GET ADJUSTED Y INTO [DE]
2B36 : AF                       xor     a               
2B37 : 32 25 39                 ld      (CSCLXY),a      
2B3A : 3A 35 39                 ld      a,(DRWANG)      ;[GWB] GET ANGLE BYTE
2B3D : 1F                       rra                     ;[GWB] LOW BIT TO CARRY
2B3E : 30 3A                    jr      nc,ANGEVN       ;[GWB] ANGLE IS EVEN - DON'T SWAP X AND Y
2B40 : F5                       push    af              ;[GWB] SAVE THIS BYTE
2B41 : D5                       push    de              ;[GWB] SAVE DY
2B42 : E5                       push    hl              ;[GWB] SAVE DX
2B43 : CD 6F 2D                 call    GTASPC          ;[GWB] GO GET SCREEN ASPECT RATIO
2B46 : 7C                       ld      a,h             
2B47 : B7                       or      a               ;[GWB] IS ASPECT RATIO GREATER THAN ONE?
2B48 : 28 05                    jr      z,ASPLS0        ;[GWB] BRIF GOOD ASPECT RATIO
2B4A : 3E 01                    ld      a,1             
2B4C : 32 25 39                 ld      (CSCLXY),a      
2B4F : EB         [GWB] ASPLS0: ex      de,hl           ;[GWB] GET ASPECT RATIO INTO [C] FOR GOSCAL
2B50 : 4D                       ld      c,l             
2B51 : E1                       pop     hl              ;[GWB] GET BACK DX
2B52 : 3A 25 39                 ld      a,(CSCLXY)      
2B55 : B7                       or      a               
2B56 : 28 01                    jr      z,ASPLS1        ;branch if aspect ratio less 1.0
2B58 : E3                       ex      (sp),hl         ;[GWB] XTHL
2B59 : EB         [GWB] ASPLS1: ex      de,hl           ;[GWB] [HL]=DY, save DX
2B5A : E5                       push    hl              ;[GWB] SAVE 1/ASPECT
2B5B : CD F7 2B                 call    GOSCAL          ;[GWB] SCALE DELTA X BY ASPECT RATIO
2B5E : C1                       pop     bc              ;[GWB] GET BACK 1/ASPECT RATIO
2B5F : E1                       pop     hl              ;[GWB] GET DY
2B60 : D5                       push    de              ;[GWB] SAVE SCALED DX
2B61 : EB                       ex      de,hl           ;[GWB] DY TO [DE] FOR GOSCAL
2B62 : 21 00 00                 ld      hl,0            
2B65 : 19         [GWB] DMULP:  add     hl,de           ;[GWB] MULTIPLY [DE] BY HI BYTE OF 1/ASPECT
2B66 : 10 FD                    djnz    DMULP           
2B68 : E5                       push    hl              ;[GWB] SAVE PARTIAL RESULT
2B69 : CD F7 2B                 call    GOSCAL          ;[GWB] MULTIPLY [DE] BY LOW BYTE
2B6C : E1                       pop     hl              ;[GWB] GET BACK PARTIAL RESULT
2B6D : 19                       add     hl,de           ;[GWB] [HL]=Y * 1/ASPECT
2B6E : D1                       pop     de              ;[GWB] GET BACK SCALED Y
2B6F : 3A 25 39                 ld      a,(CSCLXY)      
2B72 : B7                       or      a               
2B73 : 28 01                    jr      z,ASLSS1        ;[GWB] branch if aspect ratio less than 1
2B75 : EB                       ex      de,hl           
2B76 : CD FA 26   [GWB] ASLSS1: call    NEGDE           ;[GWB] ALWAYS NEGATE NEW DY
2B79 : F1                       pop     af              ;[GWB] GET BACK SHIFTED ANGLE
2B7A : 1F         [GWB] ANGEVN: rra                     ;[GWB] TEST SECOND BIT
2B7B : D2 84 2B                 jp      nc,ANGPOS       ;[GWB] DON'T NEGATE COORDS IF NOT SET
2B7E : CD BB 25                 call    NEGHL           
2B81 : CD FA 26                 call    NEGDE           ;[GWB] NEGATE BOTH DELTAS
2B84 : CD E7 28   [GWB] ANGPOS: call    GTABSC          ;[GWB] GO CALC TRUE COORDINATES
2B87                                                    
2B87 : 3A 34 39   [GWB] DRWABS: ld      a,(DRWFLG)      ;[GWB] SEE WHETHER WE PLOT OR NOT
2B8A : 87                       add     a,a             ;[GWB] CHECK HI BIT
2B8B : DA 9A 2B                 jp      c,DSTPOS        ;[GWB] JUST SET POSITION.
2B8E : F5                       push    af              ;[GWB] SAVE THIS FLAG
2B8F : C5                       push    bc              ;[GWB] SAVE X,Y COORDS
2B90 : D5                       push    de              ;[GWB] BEFORE SCALE SO REFLECT DISTANCE OFF
2B91 : CD 2B 2E                 call    SCLXYX          ;[GWB] SCALE IN CASE COORDS OFF SCREEN
2B94 : CD D8 28                 call    GLINE2          
2B97 : D1                       pop     de              
2B98 : C1                       pop     bc              ;[GWB] GET THEM BACK
2B99 : F1                       pop     af              ;[GWB] GET BACK FLAG
2B9A : 87         [GWB] DSTPOS: add     a,a             ;[GWB] SEE WHETHER TO STORE COORDS
2B9B : DA A8 2B                 jp      c,DNSTOR        ;[GWB] DON'T UPDATE IF B6=1
2B9E : EB                       ex      de,hl           
2B9F : 22 07 39                 ld      (GRPACY),hl     ;[GWB] UPDATE GRAPHICS AC
2BA2 : EB                       ex      de,hl           
2BA3 : 60                       ld      h,b             
2BA4 : 69                       ld      l,c             
2BA5 : 22 09 39                 ld      (GRPACX),hl     
2BA8 : AF         [GWB] DNSTOR: xor     a               ;[GWB] CLEAR SPECIAL FUNCTION FLAGS
2BA9 : 32 34 39                 ld      (DRWFLG),a      
2BAC : C9                       ret                     
2BAD                                                    
2BAD : 3E 40      [GWB] DNOMOV: ld      a,64            ;[GWB] SET BIT SIX IN FLAG BYTE
2BAF : C3 B4 2B                 jp      DSTFLG          
2BB2                                                    
2BB2 : 3E 80      [GWB] DNOPLT: ld      a,128           ;[GWB] SET BIT 7
2BB4 : 21 34 39   [GWB] DSTFLG: ld      hl,DRWFLG       
2BB7 : B6                       or      (hl)            
2BB8 : 77                       ld      (hl),a          ;[GWB] STORE UPDATED BYTE
2BB9 : C9                       ret
2BBA
2BBA : D2 C7 2B   [GWB] DANGLE: jp      nc,NCFCER       ;[GWB] ERROR IF NO ARG
2BBD : 7B                       ld      a,e             ;[GWB] MAKE SURE LESS THAN 4
2BBE : FE 04                    cp      4               
2BC0 : D2 C7 2B                 jp      nc,NCFCER       ;[GWB] ERROR IF NOT
2BC3 : 32 35 39                 ld      (DRWANG),a      
2BC6 : C9                       ret                     
2BC7             [GWB] NCFCER:                                         
2BC7 : D2 97 06  [GWB] DSCALE:  jp      nc,FCERR        ;[GWB] FC ERROR IF NO ARG
2BCA : 7A                       ld      a,d             ;[GWB] MAKE SURE LESS THAN 256
2BCB : B7                       or      a               
2BCC : C2 97 06                 jp      nz,FCERR        
2BCF : 7B                       ld      a,e             
2BD0 : 32 33 39                 ld      (DRWSCL),a      ;[GWB] STORE SCALE FACTOR
2BD3 : C9                       ret                     
2BD4                                                    
2BD4 : 3A 33 39   [GWB] DSCLDE: ld      a,(DRWSCL)      ;[GWB] GET SCALE FACTOR
2BD7 : B7                       or      a               ;[GWB] ZERO MEANS NO SCALING
2BD8 : C8                       ret     z               
2BD9 : 21 00 00                 ld      hl,0            
2BDC                                                    
2BDC : 19        [GWB] DSCLP:   add     hl,de           ;[GWB] ADD IN [DE] SCALE TIMES
2BDD : 3D                       dec     a               
2BDE : C2 DC 2B                 jp      nz,DSCLP        
2BE1 : EB                       ex      de,hl           ;[GWB] PUT IT BACK IN [DE]
2BE2 : 7A                       ld      a,d             ;[GWB] SEE IF VALUE IS NEGATIVE
2BE3 : 87                       add     a,a             
2BE4 : F5                       push    af              ;[GWB] SAVE RESULTS OF TEST
2BE5 : D2 E9 2B                 jp      nc,DSCPOS       
2BE8 : 1B                       dec     de              ;[GWB] MAKE IT TRUNCATE DOWN
2BE9 : CD F0 26   [GWB] DSCPOS: call    HLFDE           ;[GWB] DIVIDE BY FOUR
2BEC : CD F0 26                 call    HLFDE           
2BEF : F1                       pop     af              ;[GWB] SEE IF WAS NEGATIVE
2BF0 : D0                       ret     nc              
2BF1 : 7A                       ld      a,d             
2BF2 : F6 C0                    or      0C0H            
2BF4 : 57                       ld      d,a             
2BF5 : 13                       inc     de              
2BF6 : C9                       ret                     ;[GWB] ALL DONE IF WAS POSITIVE
2BF7    
2BF7 : 7A         [GWB] GOSCAL: ld      a,d             ;[GWB] SEE IF NEGATIVE
2BF8 : 87                       add     a,a             
2BF9 : D2 03 2C                 jp      nc,GOSC2        ;[GWB] NO, MULTIPLY AS-IS
2BFC : 21 46 2D                 ld      hl,HEGD         ;[GWB] NEGATE BEFORE RETURNING
2BFF : E5                       push    hl              
2C00 : CD FA 26                 call    NEGDE           ;[GWB] MAKE POSITIVE FOR MULTIPLY
2C03 : 79         [GWB] GOSC2:  ld      a,c             ;[GWB] GET SCALE FACTOR
2C04 : C3 FB 28                 jp      SCALE           ;[GWB] GET SCALE FACTOR
2C07          
2C07 : D2 C7 2B   [GWB] DCOLR:  jp      nc,NCFCER       ;[GWB] FC ERROR IF NO ARG
2C0A : 7B                       ld      a,e             ;[GWB] GO SET ATTRIBUTE
2C0B : CD 84 2D                 call    SETATR          
2C0E : DA 97 06                 jp      c,FCERR         ;[GWB] ERROR IF ILLEGAL ATTRIBUTE
2C11 : C9                       ret                      
2C12    
2C12 :                  ;;Issue FC Error if Point is Not on Screen
2C12 : E5         [GWB] CHKRNG: push    hl              ;[GWB] SAVE TXTPTR
2C13 : CD 1F 2E                 call    CHKRXY           
2C16 : D2 97 06                 jp      nc,FCERR        ;[GWB] OUT OF BOUNDS - ERROR
2C19 : E1         {GWB} CHKPHR: pop     hl              
2C1A : C9                       ret                     
2C1B
2C1B :                  ;;Deprecated: Issue FC Error if Point is Not on Screen
2C1B :                  ;;This is the same code as CHKRNG in GW-BASIC
2C1B :                  ;;The above code is uses instead, and this is never called
2C1B :                  ;;
2C1B : E5                       push    hl              ;;Save [HL]
2C1C : CD 2B 2E                 call    SCLXYX          ;;Check if Point is Off Screen
2C1F : D2 97 06                 jp      nc,FCERR        ;;If it is, generate FC Error
2C22 : E1                       pop     hl              ;;Otherwise, Restorw [HL]
2C23 : C9                       ret                     ;;and Return
2C24    
2C24 : EB         [GWB] MACLNG: ex      de,hl           
2C25 : 22 39 39                 ld      (MCLTAB),hl     ;[GWB] SAVE POINTER TO COMMAND TABLE
2C28 : EB                       ex      de,hl           
2C29 : CD 85 09                 call    FRMEVL          ;[GWB] EVALUATE STRING ARGUMENT
2C2C : E5                       push    hl              ;[GWB] SAVE TXTPTR TILL DONE
2C2D : 11 00 00                 ld      de,0            ;[GWB] PUSH DUMMY ENTRY TO MARK END OF STK
2C30 : D5                       push    de              ;[GWB] DUMMY ADDR
2C31 : F5                       push    af              ;[GWB] DUMMY LENGTH
2C32    
2C32 : CD C6 0F   [GWB] MCLNEW: call    FRESTR          
2C35 : CD 31 15                 call    MOVRM           ;[GWB] GET LENGTH & POINTER
2C38 : 78                       ld      a,b             
2C39 : B1                       or      c               
2C3A : 28 06                    jr      z,MCLOOP        ;[GWB] Don't Push if addr is 0
2C3C : 7B                       ld      a,e             
2C3D : B7                       or      a               
2C3E : 28 02                    jr      z,MCLOOP        ;[GWB]  or if Len is 0...
2C40 : C5                       push    bc              ;[GWB] PUSH ADDR OF STRING
2C41 : F5                       push    af              
2C42    
2C42 : F1         [GWB] MCLOOP: pop     af              ;GWB] GET LENGTH OFF STACK
2C43 : 32 38 39                 ld      (MCLLEN),a       
2C46 : E1                       pop     hl              ;GWB] GET ADDR
2C47 : 7C                       ld      a,h             
2C48 : B5                       or      l               ;[GWB] SEE IF LAST ENTRY
2C49 : 28 68                    jr      z,POPHRT        ;[GWB] ALL FINISHED IF ZERO
2C4B : 22 36 39                 ld      (MCLPTR),hl     ;[GWB] SET UP POINTER
2C4E : CD 98 2C   {GWB} MCLSCN: call    FETCHR          ;[GWB] GET A CHAR FROM STRING
2C51 : 28 EF                    jr      z,MCLOOP        ;[GWB] END OF STRING - SEE IF MORE ON STK
2C53 : 87                       add     a,a             ;[GWB] PUT CHAR * 2 INTO [C]
2C54 : 4F                       ld      c,a             
2C55 : 2A 39 39                 ld      hl,(MCLTAB)     ;GWB] POINT TO COMMAND TABLE
2C58    
2C58 : 7E  `      [GWB] MSCNLP: ld      a,(hl)          ;[GWB] GET CHAR FROM COMMAND TABLE
2C59 : 87                       add     a,a             ;[GWB] CHAR = CHAR * 2 (CLR HI BIT FOR CMP)
2C5A    
2C5A : CC 97 06   [GWB] GOFCER: call    z,FCERR         ;[GWB] END OF TABLE.
2C5D : B9                       cp      c               ;[GWB] HAVE WE GOT IT?
2C5E : 28 05                    jr      z,MISCMD        ;[GWB] YES.
2C60 : 23                       inc     hl              ;[GWB] MOVE TO NEXT ENTRY
2C61 : 23                       inc     hl              
2C62 : 23                       inc     hl              
2C63 : 18 F3                    jr      MSCNLP          
2C65    
2C65 : 01 4E 2C   [gwb] MISCMD: ld      bc,MCLSCN       ;[GWB] RETURN TO TOP OF LOOP WHEN DONE
2C68 : C5                       push    bc              
2C69 : 7E                       ld      a,(hl)          ;[GWB] SEE IF A VALUE NEEDED
2C6A : 4F                       ld      c,a             ;[GWB] PASS GOTTEN CHAR IN [C]
2C6B : 87                       add     a,a             
2C6C : 30 1E                    jr      nc,MNOARG       ;[GWB] COMMAND DOESN'T REQUIRE ARGUMENT
2C6E : B7                       or      a               ;[GWB] CLEAR CARRY
2C6F : 1F                       rra                     ;[GWB] MAKE IT A CHAR AGAIN
2C70 : 4F                       ld      c,a             ;[GWB] PUT IN [C]
2C71 : C5                       push    bc              
2C72 : E5                       push    hl              ;[GWB] SAVE PTR INTO CMD TABLE
2C73 : CD 98 2C                 call    FETCHR          ;[GWB] GET A CHAR
2C76 : 11 01 00                 ld      de,1            ;[GWB] DEFAULT ARG=1
2C79 : 28 0E                    jr      z,VSNAR0        
2C7B : CD C6 0C                 call    ISLETC          
2C7E : 30 06                    jr      nc,VSNARG       ;[GWB] NO ARG IF END OF STRING
2C80 : CD C6 2C                 call    ISLET2          ;[GWB] SEE IF POSSIBLE LETTER
2C83 : 37                       scf                     
2C84 : 18 04                    jr      VSNAR0          
2C86    
2C86 : CD B5 2C   [GWB] VSNARG: call DECFET             ;[GWB] PUT CHAR BACK INTO STRING
2C89 : B7         [GWB] VSNAR0: or a                    ;[GWB] CLEAR CARRY
2C8A : E1         {GWB} ISCMD3: pop hl                  
2C8B : C1                       pop bc                  ;[GWB] GET BACK COMMAND CHAR
2C8C : 23         [GWB] MNOARG: inc hl                  ;[GWB] POINT TO DISPATCH ADDR
2C8D : 7E                       ld a,(hl)               ;[GWB] GET Address INTO HL
2C8E : 23                       inc hl                  
2C8F : 66                       ld h,(hl)               
2C90 : 6F                       ld l,a                  
2C91 : E9                       jp (hl)                 ;[GWB] DISPATCH
2C92    
2C92 : CD 98 2C   [GWB] FETCHZ: call    FETCHR          ;[GWB] GET A CHAR FROM STRING
2C95 : 28 C3                    jr      z,GOFCER        ;[GWB] GIVE ERROR IF END OF LINE
2C97 : C9                       ret
2C98    
2C98 : E5         [GWB] FETCHR: push    hl              
2C99 : 21 38 39   [GWB] FETCH2: ld      hl,MCLLEN       ;[GWB] POINT TO STRING LENGTH
2C9C : 7E                       ld      a,(hl)          
2C9D : B7                       or      a               
2C9E : 28 13                    jr      z,POPHRT        ;[GWB] RETURN Z=0 IF END OF STRING
2CA0 : 35                       dec     (hl)            ;[GWB] UPDATE COUNT FOR NEXT TIME
2CA1 : 2A 36 39                 ld      hl,(MCLPTR)     ;[GWB] GET PTR TO STRING
2CA4 : 7E                       ld      a,(hl)          ;[GWB] GET CHARACTER FROM STRING
2CA5 : 23                       inc     hl              ;UPDATE PTR FOR NEXT TIME
2CA6 : 22 36 39                 ld      (MCLPTR),hl     
2CA9 : FE 20                    cp      ' '             ;[GWB] [GWB] SKIP SPACES
2CAB : 28 EC                    jr      z,FETCH2        
2CAD : FE 60                    cp      96              ;[GWB] CONVERT LOWER CASE TO UPPER
2CAF : 38 02                    jr      c,POPHRT        
2CB1 : D6 20                    sub     32              ;[GWB] DO CONVERSION
2CB3 : E1               POPHRT: pop     hl              
2CB4 : C9                       ret
2CB5    
2CB5 : E5         [GWB] DECFET: push    hl              
2CB6 : 21 38 39                 ld      hl,MCLLEN       ;[GWB] INCREMENT LENGTH
2CB9 : 34                       inc     (hl)            
2CBA : 2A 36 39                 ld      hl,(MCLPTR)     ;[GWB] BACK UP POINTER
2CBD : 2B                       dec     hl              
2CBE : 22 36 39                 ld      (MCLPTR),hl     
2CC1 : E1                       pop     hl              
2CC2 : C9                       ret                     
    ;
2CC3    
2CC3 : CD 92 2C   [GWB] VALSCN: call    FETCHZ          ;[GWB] GET FIRST CHAR OF ARGUMENT
2CC6 : FE 3D      [GWB] ISLET2: cp      '='             ;[GWB] NUMERIC?
2CC8 : 28 61                    jr      z,VARGET        ;;No, Evaluate Variable
2CCA : FE 2B                    cp      '+'             ;[GWB] PLUS SIGN?
2CCC : 28 F5                    jr      z,VALSCN        ;[GWB] THEN SKIP IT
2CCE : FE 2D                    cp      '-'             ;[GWB] NEGATIVE VALUE?
2CD0 : 20 06                    jr      nz,VALSC2       
2CD2 : 11 46 2D  "              ld      de,NEGD         ;[GWB] IF SO, NEGATE BEFORE RETURNING
2CD5 : D5                       push    de              
2CD6 : 18 EB                    jr      VALSCN          ;[GWB] EAT THE "-"
2CD8 : 11 00 00   [GWB] VALSC2: ld de,0
2CDB : 06 04                    ld b,4
2CDD    
2CDD : FE 2C      [GWB] NUMLOP: cp      ','             ;[GWB] COMMA
2CDF : 28 D4                    jr      z,DECFET        ;[GWB] YES, BACK UP AND RETURN
2CE1 : FE 3B                    cp      ';'             ;[GWB] SEMICOLON?
2CE3 : C8                       ret     z               ;[GWB] YES, JUST RETURN
2CE4 : FE 3A                    cp      '9'+1           ;[GWB] NOW SEE IF ITS A DIGIT 
2CE6 : 30 CD                    jr      nc,DECFET       ;[GWB] IF NOT, BACK UP AND RETURN
2CE8 : FE 30                    cp      '0'                  
2CEA : 38 C9                    jr      c,DECFET             
2CEC : 6B                       ld      l,e                  
2CED : 62                       ld      h,d                  
2CEE : 29                       add     hl,hl               
2CEF : 29                       add     hl,hl               
2CF0 : 19                       add     hl,de               
2CF1 : 29                       add     hl,hl               
2CF2 : D6 30                    sub     '0'             ;[GWB] ADD IN THE DIGIT
2CF4 : 5F                       ld      e,a                  
2CF5 : 16 00                    ld      d,0               
2CF7 : 19                       add     hl,de           ;[GWB] VALUE SHOULD BE IN [DE]
2CF8 : EB                       ex      de,hl           ;[GWB] GET NEXT CHAR     
2CF9 : CD 98 2C                 call    FETCHR             
2CFC : C8                       ret     z                   
2CFD : 05                       dec     b                   
2CFE : 20 DD                    jr      nz,NUMLOP            
2D00 : FE 30                    cp      '0'                 
2D02 : 38 D9                    jr      c,NUMLOP             
2D04 : FE 3A                    cp      '9'+1                 
2D06 : 30 D5                    jr      nc,NUMLOP            
2D08 : 18 1A                    jr      SCNFC                
    ;
2D0A    
2D0A : CD 92 2C   [GWB] SCNVAR: call    FETCHZ          ;[GWB] MAKE SURE FIRST CHAR IS LETTER
2D0D : 11 60 38                 ld      de,BUF          ;[GWB] PLACE TO COPY NAME FOR PTRGET
2D10 : D5                       push    de              ;[GWB] SAVE ADDR OF BUF FOR "ISVAR"
2D11 : 06 20                    ld      b,32            ;[GWB] COPY MAX OF 32 CHARACTERS           
2D13 : CD C6 0C                 call    ISLETC          ;[GWB] MAKE SURE IT'S A LETTER
2D16 : 38 0C                    jr      c,SCNFC         ;[GWB] FC ERROR IF NOT LETTER
2D18 : 12         [GWB] SCNVLP: ld      (de),a          ;[GWB] STORE CHAR IN BUF
2D19 : 13                       inc     de              
2D1A : FE 3B                    cp      ';'             ;[GWB] A SEMICOLON?
2D1C : 28 09                    jr      z,SCNV2         ;[GWB] YES - END OF VARIABLE NAME
2D1E : CD 92 2C                 call    FETCHZ          ;[GWB] GET NEXT CHAR
2D21 : 05                       dec     b               
2D22 : 20 F4                    jr      nz,SCNVLP       
2D24 : CD 97 06   [GWB] SCNFC:  call    FCERR           ;[GWB]ERROR - VARIABLE TOO LONG
2D27 : E1         [GWB] SCNV2:  pop     hl              ;[GWB]GET PTR TO BUF
2D28 : C3 4E 0A                 jp      ISVAR           ;[GWB]GO GET ITS VALUE
2D2B    
2D2B : CD 0A 2D   [GWB] VARGET: call    SCNVAR          ;[GWB]SCAN & EVALUATE VARIABLE
2D2E : CD 04 23                 call    FRCINX          ;[GWB]MAKE IT AN INTEGER
2D31 : EB                       ex      de,hl           ;[GWB]IN [DE]
2D32 : C9                       ret                     
2D33                                                    
2D33 : CD 0A 2D   [GWB] MCLXEQ: call    SCNVAR          ;[GWB] SCAN VARIABLE NAME 
2D36 : 3A 38 39                 ld      a,(MCLLEN)      ;[GWB] SAVE CURRENT STRING POS & LENGTH
2D39 : 2A 36 39                 ld      hl,(MCLPTR)     
2D3C : E3                       ex      (sp),hl         ;[GWB]PUSH MCLPTR
2D3D : F5                       push    af               ]
2D3E : 0E 02                    ld      c,2             ;[GWB]MAKE SURE OF ROOM ON STACK
2D40 : CD A0 0B                 call    GETSTK          
2D43 : C3 32 2C                 jp      MCLNEW          
2D46
2D46 : AF         [GWB] NEGD:   xor     a               ;;[DE] = -[DE]
2D47 : 93                       sub     e               
2D48 : 5F                       ld      e,a             
2D49 : 9A                       sbc     a,d             
2D4A : 93                       sub     e               
2D4B : 57                       ld      d,a             
2D4C : C9                       ret                     
2D4D
2D4D                    ;;Move Cursor to Column [H], Row [L]    
2D4D : F5               MOVEIT: push    af              
2D4D : F5                       push    af              
2D4E : E5                       push    hl              ;;Save Location
2D4F : D9                       exx                     
2D50 : 2A 01 38                 ld      hl,(CURRAM)     ;;Get Current Cursor Address
2D53 : 3A 0D 38                 ld      a,(CURCHR)      ;;Get Character Under Cursor
2D56 : 77                       ld      (hl),a          ;;and Put Back into Screen Location
2D57 : E1                       pop     hl              ;;Restore Location
2D58 : 7D                       ld      a,l             ;;Address Offset = Row * 5 
2D59 : 87                       add     a,a             
2D5A : 87                       add     a,a             
2D5B : 85                       add     a,l             
2D5C : EB                       ex      de,hl           
2D5D : 5A                       ld      e,d             ;;[DE] = Column
2D5E : 16 00                    ld      d,0             
2D60 : 62                       ld      h,d             ;;[HL] = Offset
2D61 : 6F                       ld      l,a             
2D62 : 7B                       ld      a,e             ;;[A] = Column - 1
2D63 : 3D                       dec     a               
2D64 : 29                       add     hl,hl           ;;Offset = Offset * 8 (Row * 40)
2D65 : 29                       add     hl,hl           
2D66 : 29                       add     hl,hl           
2D67 : 19                       add     hl,de           ;;Offset = Offset + Column
2D68 : 11 00 30                 ld      de,SCREEN       ;;Get Screen Address
2D6B : 19                       add     hl,de           ;;and Add Offset
2D6C : C3 E7 1D                 jp      TTYFIS          ;;Save Position and Finish
2D6F    
2D6F : 11 CC 00   [GWB] GTASPC: ld      de,$00CC        ;;Aspect Ration = 318:204 (6.25:4)
2D72 : 21 3E 01                 ld      hl,$013E        
2D75 : C9                       ret                     
2D76                                                    
2D76 : 32 28 39   [GWB] STOREC: ld      (PINDEX),a      ;;Store Point Position
2D79 : 22 26 39                 ld      (CURLOC),hl     ;;and Semigraphics Character Address
2D7C : C9                       ret                     
2D7D                                                    
2D7D : 3A 28 39   [GWB] FETCHC: ld      a,(PINDEX)      ;;Load Bit Index 
2D80 : 2A 26 39                 ld      hl,(CURLOC)     ;;Load Current Point Address
2D83 : C9                       ret                     
2D84                                                    
2D84 :                  ;;Set Graphics Attribute (Foreground Color)                                                   
2D84 : FE 10      [GWB] SETATR: cp      16              ;;Is Color > 16
2D86 : 3F                       ccf                     ;;If Yes
2D87 : D8                       ret     c               ;;  Return Error
2D88 : 32 02 39                 ld      (ATRBYT),a      ;;Store Color
2D8B : C9                       ret                     
2D8C    
2D8C :                 ;;Get Bit Mask for Bit Position PINDEX
2D8C : 11 CA 1A        GETMSK:  ld      de,BITTAB       
2D8F : 3A 28 39                 ld      a,(PINDEX)
2D92 : 83                       add     a,e
2D93 : 5F                       ld      e,a
2D94 : 30 01                    jr      nc,GETMSS
2D96 : 14                       inc     d
2D97 : 1A              GETMSS:  ld      a,(de)
2D98 : C9                       ret
2D99
2D99 :                + ;{GWB} SET CURRENT POINT
2D99 :                | ;;Sets Current Point to Foreground Color ATRBYT
2D99 :                | ;;Background Color is not changed
2D99 :                | ;;Current point is at Current Point Index PINDEX in 
2D99 :                | ;;Semigraphics Character at Current Address CURLOC
2D99 :                
2D99 : E5         [GWB] SETC:   push    hl              ;;Save [HL]
2D9A : D5                       push    de              ;;and [DE]
2D9B : 2A 26 39                 ld      hl,(CURLOC)     ;;Get Current Screen Address
2D9E : 7E                       ld      a,(hl)          ;;Get Character at Address
2D9F : F6 A0                    or      SGBASE          ;;Verify it's in the range of              
2DA1 : AE                       xor     (hl)            ;;Semigraphics Characters
2DA2 : 28 02                    jr      z,SETC2         ;;If Not
2DA4 : 36 A0                    ld      (hl),SGBASE     ;;  Store Base Semigraphic Character
2DA6 : CD 8C 2D         SETC2:  call    GETMSK          ;;Get Bit Mask for Pixel to set
2DA9 : B6                       or      (hl)            ;;Set it
2DAA : 77                       ld      (hl),a          ;;Write Character back to Screen Matrix
2DAB : 11 00 04                 ld      de,COLOR-SCREEN ;;Add Offset into Color Matrix to
2DAE : 19                       add     hl,de           ;;Screen Address to Get Color Address
2DAF : 3A 02 39                 ld      a,(ATRBYT)      ;;Get Color Byte
2DB2 : 87                       add     a,a             ;;Now multiply by 16,
2DB3 : 87                       add     a,a             ;;moving it to the high nybble (Foreground Color)
2DB4 : 87                       add     a,a             ;;leaving 0 (Black) in thr low nybblr (Background Color)
2DB5 : 87                       add     a,a             
2DB6 : 57                       ld      d,a             ;;Save New Color Byte
2DB7 : 5E                       ld      e,(hl)          ;;Get Old Color Byte
2DB8 : 3E 0F                    ld      a,0             ;;Override Old Background Color ($0F would keep it)
2DBA : A3                       and     e               ;;Clear Old Foreground Color
2DBB : B2                       or      d               ;;Put in the New Foreground Color
2DBC : 77                       ld      (hl),a          ;;Writeback Attribute back to Color Matrix
2DBD : D1                       pop     de              
2DBE : E1                       pop     hl              
2DBF : C9                       ret                     
2DC0 
2DC0 :                  ;;Draw Horizontal Line [HL] Pixels Long 
2DC0 : 7D               NSETCX: ld      a,l             ;;Looping HL Times
2DC1 : B4                       or      h               ;;If HL is 0
2DC2 : C8                       ret     z               ;;  Return
2DC3 : CD 99 2D                 call    SETC            ;;Set Pixel at Current Location
2DC6 : CD DB 2E                 call    RIGHTC          ;;Move 1 Pixel Right
2DC9 : 2B                       dec     hl              ;;Count Down
2DCA : 18 F4                    jr      NSETCX          ;;and Loop
2DCC 
2DCC :                + ;;Get Foreground Color at Current Location
2DCC :                | ;;This routine was intended to return both the Pixel State and Color
2DCC :                | ;;It first sets [A] to the pixel value, which is always 0 due to a bug,
2DCC :                | ;;  then sets [A] to the Foreground Color, so it
2DCC :                | ;;Returns Only the Foreground Color.
2DCC : E5         {~~~} GETC:   push    hl              ;;Save [HL]
2DCD : D5                       push    de              ;;and [DE]
2DCE : 2A 26 39                 ld      hl,(CURLOC)     ;;Get Current Screen Address
2DD1 : 7E                       ld      a,(hl)          ;;Get Character at Address
2DD2 : F6 A0                    or      SGBASE          ;;Verify it's in the range of  
2DD4 : AE                       xor     (hl)            ;;Semigraphics Characters
2DD5 : 28 10                    jr      z,GETC2         ;;If it is, Check Pixel BUG: Should be JR NZ
2DD7 : 11 00 04         GETC3:  ld      de,COLOR-SCREEN ;;Add Offset into Color Matrix to
2DDA : 19                       add     hl,de           ;;Screen Address to Get Color Address
2DDB : 7E                       ld      a,(hl)          ;;Get Color Byte
2DDC : 28 04                    jr      z,GETC4         ;;If Not Zero
2DDE : 0F                       rrca                    ;;  Rotate 4 Bits Right
2DDF : 0F                       rrca                    ;;  Moving High Nybble (Foreground Color)
2DE0 : 0F                       rrca                    ;;  to Low Nybbme
2DE1 : 0F                       rrca
2DE2 : E6 0F            GETC4:  and     $0F             ;;Set High Nybble to 0, leaving only Foreground color
2DE4 : D1                       pop     de              ;;Restore [DE]
2DE5 : E1                       pop     hl              ;;and [HL]
2DE6 : C9                       ret
2DE7 : CD 8C 2D         GETC2:  call    GETMSK          ;;Get Bit Mask for Pixel to set
2DEA : A6                       and     (hl)            ;;and Remove all other Bits of Character
2DEB : 18 EA                    jr      GETC3           ;;Then continue on to Get the Foreground Color
2DED
2DED                    ;{GWB} MACHINE DEPENDENT GRAPHICS ROUTINES: 
2DED                    ;
2DED                  + ;;Get Screen Address and and Pixel Index from Character X, Character Y
2DED                  | ;{GWB} GET POSITION INTO BITMSK AND [H,L]
2DED                  | ;;Uses: [B,C] = Character X Position 
2DED                  | ;;      [D,E] = Character Y Position 
2DED                  | ;;Sets: PINDEX = [A] = 0
2DED                  | ;;      CURLOC = [H,L] = Screen Address
2DED                  | ;;
2DED : E5         [GWB] MAPXYC: push    hl              ;;Save [H,L] 
2DEE : D5                       push    de              ;;Save [D,E] (YPOS)
2DEF : 21 28 30                 ld      hl,SCREEN+40    ;;Address = Column 0, Line 1
2DF2 : 7B                       ld      a,e             ;;
2DF3 : 11 28 00                 ld      de,40           ;;Screen Width
2DF6 : 3C                       inc     a               ;;Mask = YPOS +1 
2DF7 : 3D         (~~~) MAPCLP: dec     a               ;;Mask = Mask - 1
2DF8 : 28 1B                    jr      z,MAPXYA        ;;iF Zero, Add XPOS and FInish Up 
2DFA : 19                       add     hl,de           ;;Else Add Screen Width to Address
2DFB : 18 FA                    jr      MAPCLP          ;;and Loop
2DFD 
2DED :                + ;;Get Screen Address and and Pixel Index from Character X, Character Y
2DED :                | ;;Uses: [B,C] = Character X Position 
2DED :                | ;;      [D,E] = Pixel Y Position 
2DFD :                | ;;Sets: PINDEX = [A] = 0, 1, or 2
2DFD :                | ;;      CURLOC = [H,L] = Screen Address
2DFD : E5         [GWB] MAPXYP: push    hl              ;;Save [H,L] 
2DFE : D5                       push    de              ;;Save [D,E] (YPOS)
2DFF : 21 28 30                 ld      hl,SCREEN+40    ;;Address = Column 0, Line 1
2E02 : 7B                       ld      a,e             ;;Mask = YPOS
2E03 : 11 28 00                 ld      de,40           ;;Screen Width
2E06 : D6 03      (~~~) MAPPLP: sub     3               ;;Mask = Mask - 3
2E08 : 38 03                    jr      c,MAPPAD        ;;If Positive
2E0A : 19                       add     hl,de           ;;  Add Screen Width to Screen Address
2E0B : 18 F9                    jr      MAPPLP          ;;  and Loop
2E0D : C6 03      (~~~) MAPPAD: add     a,3             ;;Mask = Mask + 3
2E0F : 87                       add     a,a             ;;
2E10 : CB 29                    sra     c               ;;
2E12 : 30 01                    jr      nc,MAPXYA       ;;If Mask is Even
2E14 : 3C                       inc     a               ;;  Mask = Mask + 1
2E15 : 09         (~~~) MAPXYA: add     hl,bc           ;;Add XPOS to Screen Address
2E16 : 32 28 39                 ld      (PINDEX),a      ;;Store Mask
2E19 : 22 26 39                 ld      (CURLOC),hl     ;;Store Address
2E1C : D1                       pop     de              ;;Get YPOS back into DE
2E1D : E1                       pop     hl              ;;Restore HL
2E1E : C9                       ret                     
2E1F
2E1F                    ;{GWB} SEE IF LOCATION OFF SCREEN
2E1F : 3E 17      [~~~] CHKRXY: ld       a,23            
2E21 : 32 41 39                 ld       (GYMAX),a       ;;Mex Y = 23 Rows
2E24 : 3E 27                    ld       a,39            
2E26 : 32 42 39  "              ld       (GXMAX),a       ;;Mac X = 39 Coumns
2E29 : 18 0A                    jr       CMPGMY           
2E2B    
2E2B :                  ;{GWB} SEE IF POINT OFF SCREEN
2E2B :                  ;;; Labeled SCALXY in GW-BASIC, but Standard BASIC also has a SCALXY Routine
2E2B : 3E 47      [GWB] SCLXYX: ld      a,71            
2E2D : 32 41 39                 ld      (GYMAX),a       ;;Max Y = 71 Pixels
2E30 : 3E 4F                    ld      a,79            
2E32 : 32 42 39                 ld      (GXMAX),a       ;;Max X = 79 Pixels
2E35 : E5         (~~~) CMPGMY: push    hl              ;Save Registers
2E36 : C5                       push    bc              
2E37 : D5                       push    de              
2E38 : 3A 41 39                 ld      a,(GYMAX)       
2E3B : 26 00                    ld      h,0             ;;[H,L] = GYMAX
2E3D : 6F                       ld      l,a             
2E3E : CB 7A                    bit     7,d             ;;If [D,E] is Negative
2E40 : 20 1F                    jr      nz,SETGYZ       ;;  [H,L] = 0 and Set Carry
2E42 : E7                       rst     COMPAR          ;;Else Compare [D,E] and [H,L]
2E43 : 50         (~~~) SCLXY2: ld      d,b             ;;[D,E] = [B,C]
2E44 : 59                       ld      e,c             
2E45 : 06 00                    ld      b,0             
2E47 : 30 02                    jr      nc,CMPGMX       
2E49 : E3                       ex      (sp),hl         
2E4A : 04                       inc     b               
2E4B : 3A 42 39   (~~~) CMPGMX: ld      a,(GXMAX)       
2E4E : 26 00                    ld      h,0             ;;[H,L] = GXMAX
2E50 : 6F  "                    ld      l,a             
2E51 : CB 7A                    bit     7,d             ;;If [D,E] is Negative
2E53 : 20 11                    jr      nz,SETGXZ       ;;  [H,L] = 0 and Set Carry
2E55 : E7                       rst     COMPAR          ;;Else Compare [D,E] and [H,L]
2E56 : D1         (~~~) SCLXY3: pop     de              
2E57 : 38 03                    jr      c,SCLXY4         
2E59 : CB 18                    rr      b               
2E5B : 06                       byte    $06             ;;LD B, over EX
2E5C : E3         (~~~) SCLXY4: ex      (sp),hl            
2E5D : C1                       pop     bc              
2E5E : 3F                       ccf                     
2E5F : E1                       pop     hl              
2E60 : C9                       ret                     
2E61    
2E61 : 2E 00            SETGYZ: ld      l,0             ;;[L] = 0
2E63 : 37                       scf                     ;;Set Carry Flag
2E64 : 18 DD                    jr      SCLXY2          ;;and Continue
2E66    
2E66 : 2E 00            SETGXZ: ld l,0                  ;;[L] = 0
2E68 : 37                       scf                     ;;Set Carry Flag
2E69 : 18 EB                    jr SCLXY3               ;;and Continue
2E6B :
2E6B :                  ;;; Orphan Code???
2E6B : FE 02      {~~~} CHKMSK: cp      2               
2E6D : 30 07                    jr      nc,CHKMS2        
2E6F : D5                       push    de              
2E70 : 11 29 30                 ld      de,SCREEN+41    
2E73 : E7                       rst     COMPAR          
2E74 : D1                       pop     de              
2E75 : D8                       ret     c               
2E76 : 3D         {~~~} CHKMS2: dec     a               
2E77 : 3D                       dec     a               
2E78 : D0                       ret     nc              
2E79 : C6 06                    add     a,6             
2E7B : D5                       push    de              
2E7C : 11 D8 FF                 ld      de,$FFD8        ;;-40
2E7F : 19                       add     hl,de           
2E80 : D1                       pop     de              
2E81 : B7                       or      a               
2E82 : C9                       ret                     
2E83 : 
2E83 :                  ;;; Orphan Code???
2E83 :                  ;;Call with [A] = Pixel Index, [HL] = Screen Address
2E83 : FE 04      {~~~} DOWN4:  cp      4                
2E85 : 38 08                    jr      c,DOWNP         ;;If Pixel Index > 3, Move Down 1 Pixel
2E87 : D5                       push    de              
2E88 : 11 C0 33                 ld      de,SCREEN+960   
2E8B : E7                       rst     COMPAR          
2E8C : D1                       pop     de              
2E8D : 3F                       ccf                     
2E8E : D8                       ret     c               
2E8F    
2E8F :                  ;Down 1 Pixel: Calculate New Screen Address and Bit Index
2E8F : 3C               DOWNP:  inc     a               
2E90 : 3C                       inc     a               ;;[A] = Bit Index * 2
2E91 : FE 06                    cp      6               
2E93 : 3F                       ccf                     
2E94 : D0                       ret     nc              
2E95 : D6 06                    sub     6               ;;[A] = [A] - 6 
2E97 : D5                       push    de              
2E98 : 11 28 00                 ld      de,40        
2E9B : 19                       add     hl,de           ;;[HL] = curloc + 40
2E9C : D1                       pop     de              
2E9D : B7                       or      a               ;;Set Flags
2E9E : C9                       ret                     
2E9F :   
2E9F :                  ;;Left 1 Pixel: Calculate New Screen Address and Bit Index
2E9F : 3D               LEFTP:  dec     a               ;;Decrement Bit Index
2EA0 : CB 47                    bit     0,a             
2EA2 : C8                       ret     z               ;;If Bit Index is Even
2EA3 : 3C                       inc     a               ;;  Add 2
2EA4 : 3C                       inc     a               
2EA5 : 2B                       dec     hl              ;;  Decremement Address
2EA6 : B7                       or      a               ;;  Set Flags from Bit Index
2EA7 : C9                       ret                     
2EA8 :
2EA8 :                  ;;Right 1 Pixel: Calculate New Screen Address and Bit Index
2EA8 : 3C         [GWB] RIGHT:  inc     a               ;;Increment Bit Index
2EA9 : CB 47                    bit     0,a             
2EAB : C0                       ret     nz              ;;If Bit Index is Odd
2EAC : 3D                       dec     a               ;;  Add 2
2EAD : 3D                       dec     a               
2EAE : 23                       inc     hl              ;;  Incremement Address
2EAF : B7                       or      a               ;;  Set Flags from Bit Index
2EB0 : C9                       ret                     
2EB1    
2EB1 :                  ;;Move Text Cursor Down One Line   
2EB1 : F5         [~~~] DOWNL:  push    af              ;[GWB] SAVE BIT MASK OF CURRENT "C" Address
2EB2 : E5                       push    hl              ;[GWB] SAVE Address    
2EB3 : CD 7D 2D                 call    FETCHC          ;[GWB] GET CURRENT LOCATION
2EB6 : 11 28 00                 ld      de,40           ;;Line Width = 40 characters
2EB9 : 19                       add     hl,de           ;;Move Down One Line
2EBA : C3 F7 2E                 jp      POPSTC          ;;Store Current, Restore Saved and Return
2EBD                                                    
2EB1 :                  ;;Move Pixel Cursor Down One Line   
2EBD : F5         [GWB] DOWNC:  push    af              ;[GWB] SAVE BIT MASK OF CURRENT "C" Address
2EBE : E5                       push    hl              ;[GWB] SAVE Address    
2EBF : CD 7D 2D  "              call    FETCHC          ;[GWB] ;GET CURRENT LOCATION
2EC2 : CD 8F 2E  "              call    DOWNP           ;;Calculate New Screen Address, Bit Index
2EC5 : 18 30                    jr      POPSTC          ;;Store Current, Restore Saved and Return
2EC7
2EC7                    ;;Orphan Code???
2EC7 : F5                       push    af              ;[GWB] SAVE BIT MASK OF CURRENT "C" Address
2EC8 : E5                       push    hl              ;[GWB] SAVE Address    
2EC9 : CD 7D 2D                 call    FETCHC          ;[GWB] ;GET CURRENT LOCATION
2ECC : CD 76 2E                 call    CHKMS2           
2ECF : 18 26  " &"              jr      POPSTC          ;;Store Current, Restore Saved and Return
    ;                                                   
2ED1 : F5         [GWB] LEFTC:  push    af              ;[GWB] SAVE BIT MASK OF CURRENT "C" Address
2ED2 : E5                       push    hl              ;[GWB] SAVE Address    
2ED3 : CD 7D 2D                 call    FETCHC          ;[GWB] GET CURRENT LOCATION
2ED6 : CD 9F 2E                 call    LEFTP           ;;Calculate New Screen Address, Bit Index
2ED9 : 18 1C                    jr      POPSTC          ;;Store Current, Restore Saved and Return
2EDB                                                    
2EDB : F5         [GWB] RIGHTC: push    af              ;[GWB] SAVE BIT MASK OF CURRENT "C" Address
2EDC : E5                       push    hl              ;[GWB] SAVE Address    
2EDD : CD 7D 2D                 call    FETCHC          ;[GWB] GET CURRENT LOCATION
2EE0 : CD A8 2E                 call    RIGHT           
2EE3 : 18 12                    jr      POPSTC          ;;Store Current, Restore Saved and Return
2EE5
2EE5                    ;;Orphan Code???
2EE5 : F5                       push    af
2EE6 : E5                       push    hl
2EE7 : CD 7D 2D                 call    FETCHC
2EEA : CD 83 2E                 call    DOWN4
2EED : 18 08                    jr      POPSTC
2EEF
2EEF                    ;;Orphan Code???
2EEF : F5                       push   af
2EF0 : E5                       push   hl
2EF1 : CD 7D 2D                 call   FETCHC
2EF4 : CD 83 2E                 call   DOWN4
2EF7    
2EF7 : 32 28 39         POPSTC: ld      (PINDEX),a      ;;Store Bit Position 
2EFA : 22 26 39                 ld      (CURLOC),hl     ;;Store Current Point Address
2EFD : E1                       pop     hl              ;;Restore Saved Address
2EFE : F1                       pop     af              ;;Restore Saved Bit Index
2EFF : C9                       ret                     ;;Return from Subroutine
    ;
2F00    
2F00 : 22 3C 39   [GWB] PGINIT: ld      (ARYPNT),hl     ;;Save Pointer into Array
2F03 : 60                       ld      h,b             
2F04 : 69                       ld      l,c             
2F05 : 22 11 39                 ld      (MAXDEL),hl     ;;Save Bit Counr?
2F08 : 87                       add     a,a             ;;Index = Operation ID * 2
2F09 : 4F                       ld      c,a             ;;Copy to BC
2F0A : 06 00                    ld      b,0          
2F0C : 21 18 2F                 ld      hl,OPCTAB       ;;Get Operation Table Address
2F0F : 09                       add     hl,bc           ;;Add Index
2F10 : 7E                       ld      a,(hl)          ;;Get Address from Table
2F11 : 23                       inc     hl              
2F12 : 66                       ld      h,(hl)          
2F13 : 6F                       ld      l,a             
2F14 : 22 3F 39                 ld      (OPCADR),hl      ;;Store It
2F17 : C9                       ret                     
2F18
2F18 : 6C 2F            OPCTAB: word    ORC             ;;A = A | C     OR
2F1A : 6E 2F                    word    ANDC            ;;A = A & C     AND
2F1C : 72 2F                    word    CPLA            ;;A = !A        PRESET
2F1E : 73 2F                    word    NOOP            ;;No Operation  PSET
2F20 : 70 2F                    word    XORC            ;;A = A ^ C     XOR (Default)
2F22 :
2F22 :                  ;;Read One Line of Characters from Colors to Screen
2F22 : CD 5F 2F   [GWB] NREAD:  call    NSETUP          ;;[H,L] = Screen Address, [A] = Counter
2F25 : 46               NREADL: ld      b,(hl)          ;;[B] = Character at Address
2F26 : 11 00 04                 ld      de,COLOR-SCREEN ;;[D,E] = Offset into Color Matrix
2F29 : EB                       ex      de,hl           ;;[D,E] = Screen Address, [H,L] = Offset
2F2A : 19                       add     hl,de           ;;[H,L] = Color Address
2F2B : 4E                       ld      c,(hl)          ;;[C] = Color Attribute
2F2C : E1                       pop     hl              ;;Pop Array Pointer into [H,L]
2F2D : 70                       ld      (hl),b          ;;Copy Character into Array
2F2E : 23                       inc     hl              ;;Bump Array Pointer
2F2F : 71                       ld      (hl),c          ;;Copy Colors into Array
2F30 : 23                       inc     hl              ;;Bump Array Pointer
2F31 : E5                       push    hl              ;;Push Array Pointer back onto Stack
2F32 : EB                       ex      de,hl           ;;[H,L} = Screen Address, Discard Offset
2F33 : 23                       inc     hl              ;;Bump Screen Address 
2F34 : 3D                       dec     a               ;;Decrement Counter
2F35 : 20 EE                    jr      nz,NREADL       ;;If Not Done, Do Next Position
2F37 : 18 21                    jr      NDONE           ;;Else Save Array Pointer and Return
2F39 :
2F39 :                  ;;Write One Line of Characters and Colors to Screen
2F39 : CD 5F 2F   [GWB] NWRITE: call    NSETUP          ;;[H,L] = Screen Address, [A] = Counter
2F3C : EB               NWRITL: ex      de,hl           ;;[D,E] = Screen Address
2F3D : 21 00 04                 ld      hl,COLOR-SCREEN ;;[H,L] = Offset into Color Matrix
2F40 : 19                       add     hl,de           ;;[H,L] = Color Address
2F41 : 4E                       ld      c,(hl)          ;;[C] = Color Attribute
2F42 : E1                       pop     hl              ;;Pop Array Pointer into [H,L]
2F43 : 46                       ld      b,(hl)          ;;Read Character from Array into [B]
2F44 : 23                       inc     hl              ;;Bump Array Pointer
2F45 : 08                       ex      af,af'          ;;Save Counter
2F46 : 7E                       ld      a,(hl)          ;;Read Color Attribute from into [A]
2F47 : 23                       inc     hl              ;;Bump Array Pointer
2F48 : CD 3E 39                 call    OPCJMP          ;;Do Operation on Color Attribute
2F4B : E5                       push    hl              ;;Push Array Pointer onto Stack
2F4C : EB                       ex      de,hl           ;;[H,L} = Screen Address, Discard Offset
2F4D : 70                       ld      (hl),b          ;;Write Character to Character
2F4E : 11 00 04                 ld      de,COLOR-SCREEN ;;[H,L] = Offset into Color Matrix
2F51 : EB                       ex      de,hl           ;;[D,E] = Screen Address, [H,L] = Offse
2F52 : 19                       add     hl,de           ;;[H,L] = Color Address
2F53 : 77                       ld      (hl),a          ;;Write Attribute to Color Matrix
2F54 : EB                       ex      de,hl           ;;[H,L] = Screen Address
2F55 : 23                       inc     hl              ;;Next Screen Address
2F56 : 08                       ex      af,af'          ;;Restore Counter
2F57 : 3D                       dec     a               ;;Decremement it
2F58 : 20 E2                    jr      nz,NWRITL       ;;If Not Done, Do Next Position
2F5A : E1               NDONE:  pop     hl              ;;Pop Array Pointer off Stack
2F5B : 22 3C 39                 ld      (ARYPNT),hl     ;;and Store in ARYPNT
2F5E : C9                       ret                     
2F5F :   
2F5F :                  ;;Get CURLOC and MAXDEL for NREAD and NWRITE
2F5F : 2A 11 39         NSETUP: ld      hl,(MAXDEL)     
2F62 : 7D                       ld      a,l             ;;[A] = Byte Count 
2F63 : 2A 3C 39                 ld      hl,(ARYPNT)     
2F66 : E3                       ex      (sp),hl         ;;Push Array Pointer under Return Address
2F67 : E5                       push    hl              
2F68 : 2A 26 39                 ld      hl,(CURLOC)     ;;[H,L] = Screen Address
2F6B : C9                       ret                     
2F6C :
2F6C :                  ;;PUT Action Subroutines
2F6C : B1               ORC:    or      c               ;;OR
2F6D : C9                       ret                     ;;
2F6E : A1               ANDC:   and     c               ;;AND
2F6F : C9                       ret                     ;;
2F70 : A9               XORC:   xor     c               ;;XOR (Default)
2F71 : C9                       ret                     ;;
2F72 : 2F               CPLA:   cpl                     ;;PRSET
2F73 : C9               NOOP:   ret                     ;;PSET (Use Color from Array)
    ;
2F74 : FF FF                    word    $FFFF           ;;Filler to End of 4K ROM
2F76 : 00 00                    word    $0000
2F78 : FF FF                    word    $FFFF  
2F7A : 00 00                    word    $0000  
2F7C : FF FF                    word    $FFFF  
2F7E : 00 00                    word    $0000  
2F80 : FF FF                    word    $FFFF  
2F82 : 00 00                    word    $0000  
2F84 : FF FF                    word    $FFFF  
2F86 : 00 00                    word    $0000  
2F88 : FF FF                    word    $FFFF  
2F8A : 00 00                    word    $0000  
2F8C : FF FF                    word    $FFFF   
2F8E : 00 00                    word    $0000   
2F90 : FF FF                    word    $FFFF   
2F92 : 00 00                    word    $0000   
2F94 : FF FF                    word    $FFFF   
2F96 : 00 00                    word    $0000   
2F98 : FF FF                    word    $FFFF   
2F9A : 00 00                    word    $0000   
2F9C : FF FF                    word    $FFFF  
2F9E : 00 00                    word    $0000  
2FA0 : FF FF                    word    $FFFF   
2FA2 : 00 00                    word    $0000   
2FA4 : FF FF                    word    $FFFF   
2FA6 : 00 00                    word    $0000   
2FA8 : FF FF                    word    $FFFF   
2FAA : 00 00                    word    $0000   
2FAC : FF FF                    word    $FFFF   
2FAE : 00 00                    word    $0000  
2FB0 : FF FF                    word    $FFFF  
2FB2 : 00 00                    word    $0000  
2FB4 : FF FF                    word    $FFFF   
2FB6 : 00 00                    word    $0000   
2FB8 : FF FF                    word    $FFFF   
2FBA : 00 00                    word    $0000   
2FBC : FF FF                    word    $FFFF   
2FBE : 00 00                    word    $0000   
2FC0 : FF FF                    word    $FFFF   
2FC2 : 00 00                    word    $0000   
2FC4 : FF FF                    word    $FFFF  
2FC6 : 00 00                    word    $0000  
2FC8 : FF FF                    word    $FFFF   
2FCA : 00 00                    word    $0000   
2FCC : FF FF                    word    $FFFF   
2FCE : 00 00                    word    $0000   
2FD0 : FF FF                    word    $FFFF  
2FD2 : 00 00                    word    $0000  
2FD4 : FF FF                    word    $FFFF
2FD6 : 00 00                    word    $0000 
2FD8 : FF FF                    word    $FFFF  
2FDA : 00 00                    word    $0000  
2FDC : FF FF                    word    $FFFF  
2FDE : 00 00                    word    $0000  
2FE0 : FF FF                    word    $FFFF  
2FE2 : 00 00                    word    $0000  
2FE4 : FF FF                    word    $FFFF  
2FE6 : 00 00                    word    $0000  
2FE8 : FF FF                    word    $FFFF 
2FEA : 00 00                    word    $0000 
2FEC : FF FF                    word    $FFFF  
2FEE : 00 00                    word    $0000  
2FF0 : FF FF                    word    $FFFF  
2FF2 : 00 00                    word    $0000  
2FF4 : FF FF                    word    $FFFF  
2FF6 : 00 00                    word    $0000  
2FF8 : FF FF                    word    $FFFF  
2FFA : 00 00                    word    $0000  
2FFC : FF FF                    word    $FFFF 
2FFE : 00 00                    word    $0000 

;--------------------------------------------------------------
Symbol table
============

Value  Type Name
-----  ---- ----
207A  Code L207A
20A7  Code L20A7
20AD  Code L20AD
20B1  Code L20B1
20B4  Code L20B4
2155  Code L2155
2170  Code L2170
2352  Code L2352
235F  Code L235F
2917  Code L2917
291C  Code L291C
2922  Code L2922
29B6  Code L29B6
29FB  Code L29FB
2D8C  Code GETMSK
2D97  Code GETMSS
2E43  Code SCLXY2
2E56  Code SCLXY3
2E5C  Code L2E5C
38E0  Data VARPNT
38E2  Data X38E2


4152  Code L4152
434F  Code L434F
4CBB  Code L4CBB
4E45  Code L4E45
4E49  Code L4E49
5249  Code L5249
534C  Code L534C
BAC1  Data XBAC1
D8C4  Data XD8C4
DECC  Data XDECC
E1D2  Data XE1D2
E9C8  Data XE9C8
ECC6  Data XECC6
F9C7  Data XF9C7
FE78  Data XFE78

Number of symbols:   374

;--------------------------------------------------------------
